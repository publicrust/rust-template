Permission)));

            if (category == null)
            {
                category =  _config.ShopCategories.Select(x => x.Value).FirstOrDefault(i => i.EnableNPC && i.NpcIds.Contains(npc.UserIDString) && !string.IsNullOrEmpty(i.Permission) && !permission.UserHasPermission(player.UserIDString, i.PrefixPermission));
                if (category == null)
                    return;
                SendReply(player, Lang("NoPerm", player.UserIDString, category.DisplayName));
                return;
            }

            GetPlayerData(player).ShopKey = category.DisplayName;
            ShowGUIShops(player, category.DisplayName);
        }

        private void OnEnterNPC(BasePlayer npc, BasePlayer player) //added 2.0.0
        {
            //Puts($"npc id is {npc.UserIDString}, {player.UserIDString}");
            if (player == null || !player.userID.IsSteamId() || _config.NPCAutoOpen == false) return;

            if (!permission.UserHasPermission(player.UserIDString, Use))
            {
                SendReply(player, Lang("NoPermUse", player.UserIDString, Use));
                return;
            }

            if (_imageLibraryCheck >= _config.ImageLibraryCounter)
            {
                SendReply(player, Lang("ImageLibraryFailure", player.UserIDString, _config.ImageLibraryCounter));
                return;
            }

            if (!_isShopReady || LangAPI != null && !_isLangAPIReady)
            {
                SendReply(player, Lang("GUIShopResponse", player.UserIDString));
                return;
            }

            if (_wipeReady == false)
            {
                float timeresult = _config.Time.CanShopIn / 60;
                SendReply(player,Lang("WipeReady", player.UserIDString, player.displayName, Math.Round(timeresult)));
                return;
            }

            float distance = Vector3.Distance(npc.ServerPosition, player.ServerPosition);
            if (distance > _config.NPCDistanceCheck) return;
            ShopCategory category = _config.ShopCategories.Select(x => x.Value).FirstOrDefault(i => i.EnableNPC && i.NpcIds.Contains(npc.UserIDString) && (!string.IsNullOrEmpty(i.Permission) && permission.UserHasPermission(player.UserIDString, i.PrefixPermission) || string.IsNullOrEmpty(i.Permission)));

            if (category == null)
            {
                category =  _config.ShopCategories.Select(x => x.Value).FirstOrDefault(i => i.EnableNPC && i.NpcIds.Contains(npc.UserIDString) && !string.IsNullOrEmpty(i.Permission) && !permission.UserHasPermission(player.UserIDString, i.PrefixPermission));
                if (category == null)
                    return;
                SendReply(player, Lang("NoPerm", player.UserIDString, category.DisplayName));
                return;
            }

            //Puts($"on enter npc cat is {category.DisplayName}, ");
            if (_config.NPCLeaveResponse) //added 2.0.0
            {
                SendReply(player, Lang("NPCResponseOpen", player.UserIDString), category.DisplayName);
            }

            GetPlayerData(player).ShopKey = category.DisplayName;
            ShowGUIShops(player, category.DisplayName);
        }

        private void OnLeaveNPC(BasePlayer npc, BasePlayer player) //added 1.8.7
        {
            if (player == null || !player.userID.IsSteamId() || !permission.UserHasPermission(player.UserIDString, Use)) return;

            float distance = Vector3.Distance(npc.ServerPosition, player.ServerPosition);
            if (distance <= _config.NPCDistanceCheck) return;

            ShopCategory category = _config.ShopCategories.Select(x => x.Value).FirstOrDefault(i => i.EnableNPC && i.NpcIds.Contains(npc.UserIDString) && (!string.IsNullOrEmpty(i.Permission) && permission.UserHasPermission(player.UserIDString, i.PrefixPermission) || string.IsNullOrEmpty(i.Permission)));
            if (category == null) return;

            CloseShop(player);
            GetPlayerData(player).ShopKey = String.Empty;

            if (_config.NPCLeaveResponse) //added 1.8.8
            {
                SendReply(player, Lang("NPCResponseClose", player.UserIDString), category.DisplayName);
            }
        }

        #endregion

        #region Helpers

        private Vector3 GetLookPoint(BasePlayer player)
        {
            RaycastHit raycastHit;
            if (!Physics.Raycast(new Ray(player.eyes.position, Quaternion.Euler(player.serverInput.current.aimAngles) * Vector3.forward), out raycastHit, _config.SpawnDistance))
            {
                return player.ServerPosition;
            }

            return raycastHit.point;
        }

        private bool IsNearMonument(BasePlayer player)
        {
            if (SteamServer.MapName == "Procedural Map")
            {
                return TerrainMeta.TopologyMap.GetTopology(player.transform.position, TerrainTopology.MONUMENT);
            }

            foreach (var monumentInfo in _monuments)
            {
                float distance = Vector3Ex.Distance2D(monumentInfo.transform.position, player.ServerPosition);

                if (monumentInfo.name.Contains("sphere") && distance < 30f)
                {
                    return true;
                }

                if (monumentInfo.name.Contains("launch") && distance < 30f)
                {
                    return true;
                }

                if (!monumentInfo.IsInBounds(player.ServerPosition)) continue;

                return true;
            }

            return false;
        }

        #endregion

        #region API Hooks

        private double GetCurrency(BasePlayer player, string shopKey)
        {
            ShopCategory shop;
            if (!_config.ShopCategories.TryGetValue(shopKey, out shop))
            {
                return 0;
            }

            return GetCurrency(shop, player);
        }

        private void OpenShop(BasePlayer player, string shopKey, string npcID)
        {
            ShopCategory shop;
            if (!_config.ShopCategories.TryGetValue(shopKey, out shop) || !shop.EnableNPC || !shop.NpcIds.Contains(npcID))
            {
                return;
            }

            GetPlayerData(player).ShopKey = shopKey;
            ShowGUIShops(player, shopKey);
        }

        private void CloseShop(BasePlayer player)
        {
            if (player == null)
            {
                return;
            }

            GetPlayerData(player).ShopKey = String.Empty;
            CuiHelper.DestroyUi(player, GUIShopOverlayName);
        }

        #endregion

    }
}

// --- End of file: GUIShop.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/group-messages ---
// --- Original File Path: G/GroupMessages/GroupMessages.cs ---

using System;
using System.Linq;
using System.Collections.Generic;

namespace Oxide.Plugins 
{
    [Info("Group Messages", "Sasuke", "1.0.1")]
    [Description("Send randomly configured chat messages for each player based in your groups")]

    class GroupMessages : RustPlugin 
    {
        #region constants

        private string tag;
        private string color;
        private float interval;

        private Dictionary<string, object> messages = DefaultMessages();
        private static Dictionary<string, object> DefaultMessages()
        {
            return new Dictionary<string, object>()
            {
                ["default"] = new List<string>()
                {
                    "Did you know that new plug-ins are always launched in <color=#008cba>uMod</color> to make your server even better!?",
                    "Go to <color=#008cba>umod.org</color> to download new plugins to the server!"
                },
                ["admin"] = new List<string>()
                {
                    "Remember that you are an <color=#af5>administrator</color> and make this server a cool and fun environment!"
                }
            };
        }
        
        #endregion

        #region hooks

        protected override void LoadDefaultConfig()
        {
            Config["Chat tag"] = tag = GetConfig("Chat tag", "uMod");
            Config["Chat color"] = color = GetConfig("Chat color", "#008cba");
            Config["Interval"] = interval = GetConfig("Interval", 60f);
            Config["Messages"] = messages = GetConfig("Messages", messages);

            SaveConfig();
        }

        void OnServerInitialized()
        {
            LoadDefaultConfig();
            StartAutoMessages();
        }

        #endregion

        #region functions

        private void StartAutoMessages()
        {
            timer.Every(interval, () => {
                var activeList = BasePlayer.activePlayerList;
                foreach (var player in activeList)
                {
                    var playerMessages = PlayerMessages(player);
                    if (playerMessages.Count < 1)
                        continue;

                    var randomMessage = playerMessages.GetRandom();
                    if (string.IsNullOrEmpty(randomMessage)) 
                        continue;

                    player.ChatMessage($"<color={color}>{tag}</color>: {randomMessage}");
                }
            });
        }

        #endregion

        #region tools

        private List<string> PlayerMessages(BasePlayer player)
        {
            var msgs = new List<string>();
            var parsedMessages = ParseDictionary(messages);

            foreach(var pair in parsedMessages)
            {
                if (!permission.GroupExists(pair.Key))
                {
                    permission.CreateGroup(pair.Key, string.Empty, 0);
                }

                if (permission.UserHasGroup(player.UserIDString, pair.Key))
                {
                    msgs.AddRange(pair.Value);
                }
            }

            return msgs;
        }

        private Dictionary<string, List<string>> ParseDictionary(Dictionary<string, object> dict)
        {
            var parsed = dict.ToDictionary(
                x => x.Key, 
                x => x.Value != null
                    ? (List<string>)(x.Value as List<object>)
                        .Select(val => val.ToString())
                        .ToList()
                    : new List<string>()
            );

            return parsed;
        }

        private T GetConfig<T>(string name, T value) 
            => Config[name] == null 
                ? value 
                : (T)Convert.ChangeType(Config[name], typeof(T));

        #endregion
    }
}

// --- End of file: GroupMessages.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/game-server-tools ---
// --- Original File Path: G/GameServerTools/GameServerTools.cs ---

#region

using ConVar;
using Facepunch.Extend;
using Facepunch.Math;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

#endregion

namespace Oxide.Plugins
{
    [Info("Game Server Tools", "mrcameron999", "1.0.7")]
    [Description("Adds several adamin tools for use with gameservertools.com")]
    public class GameServerTools : CovalencePlugin
    {
        private Dictionary<string, ApprovedCachedPlayer> _approvedCachedJoins = new Dictionary<string, ApprovedCachedPlayer>(); //stored data on player approve
        private readonly Dictionary<IPlayer, CachedPlayer> _cachedJoins = new Dictionary<IPlayer, CachedPlayer>(); //Stored data on playerConnected

        private readonly Dictionary<string, string> _headers = new Dictionary<string, string>();
        //private readonly string _connection = "https://localhost:44361/";
        private readonly string _connection = "https://api.gameservertools.com/";
        
        private readonly float timeout = 1000f;

        private string _linkedGroupName = "DiscordLinked";
        private string _nitroGroupName = "Nitro";
        private int _port = 28015;
        private bool _showClaimMessage;
        private bool _loggingEnabled = false;
        private bool _disableBanCtrl = false;

        private Dictionary<ulong, List<string>> messages = new Dictionary<ulong, List<string>>();

        private void Init() // Called when server starts. Created any missing groups
        {
            LoadConfigData();
            permission.CreateGroup(_linkedGroupName, "linked", 0);
            permission.CreateGroup(_nitroGroupName, "nitro", 0);
            permission.RegisterPermission("GameServerTools.linked", this);
            permission.GrantGroupPermission(_linkedGroupName, "GameServerTools.linked", this);

            _headers.Add("Content-Type", "application/json");

            if (_disableBanCtrl)
            {
                Unsubscribe("OnPlayerBanned");
                Unsubscribe("OnUserApprove");
            }
            else
            {
                AddUniversalCommand("ban", "OverrideBanCommand");
            }

            if(_loggingEnabled)
                Puts($"GST Debug Info\n Your server port is {_port} your api key is {_headers["ApiKey"]}");
        }

        private void LoadConfigData() //Loads config data
        {
            if (Config["DisableBanCtrl"] == null)
            {
                Config["DisableBanCtrl"] = false;
                SaveConfig();
            }
            if (Config["Port"] == null)
            {
                Config["Port"] = 28015;
                SaveConfig();
            }


            string apiKey = Config["APIKEY"].ToString();

            if (apiKey == "")
                LogError("NO API KEY PROVIDED! Please ensure you have added your api key in the config file");
            else
                _headers.Add("ApiKey", apiKey);

            _linkedGroupName = Config["OxideGroupNameForLinked"].ToString();
            _nitroGroupName = Config["OxideGroupNameForNitro"].ToString();
            _showClaimMessage = (bool)Config["DisplayMessageOnClaimRewards"];
            _loggingEnabled = bool.Parse(Config["DebugLoggingEnabled"].ToString());
            _disableBanCtrl = bool.Parse(Config["DisableBanCtrl"].ToString());

            _port = int.Parse(Config["Port"].ToString());
        }

        #region Hooks

        private void OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel) //Stores all player chats and uses them later for reports
        {
            List<string> messageList;
            if (!messages.TryGetValue(player.userID, out messageList))
            {
                messageList = new List<string>();
                messages.Add(player.userID, messageList);
            }

            messageList.Insert(0, $"{DateTime.UtcNow} UTC | {channel} | {message}");
        }

        private void OnPlayerReported(BasePlayer reporter, string targetName, string targetId, string subject, string message, string type)
        {
            ReportType typeOfReport = GetTypeIdFromType(type);

            Dictionary<string, object> parameters = new Dictionary<string, object>
            {
                { "ReporterId", reporter.userID.ToString() },
                { "ReportedPlayerId", targetId },
                { "Subject", subject },
                { "Reason", message },
                { "ServerPort", _port },
                { "Type", typeOfReport }
            };

            List<KeyValuePair<int, List<string>>> files = new List<KeyValuePair<int, List<string>>>();

            if (typeOfReport == ReportType.Abusive || typeOfReport == ReportType.Spam) // Get the chat log
            {
                ulong playerIdLong = ulong.Parse(targetId);
                if (messages.ContainsKey(playerIdLong))
                {
                    List<string> userMessages = messages[playerIdLong];
                    if (userMessages.Count > 100)
                    {
                        userMessages.RemoveRange(100, userMessages.Count);
                    }

                    files.Add(new KeyValuePair<int, List<string>>(0, messages[playerIdLong]));
                }
            }

            if (typeOfReport == ReportType.Cheat)
            {
                BasePlayer target = BasePlayer.Find(targetId);
                if (target != null)
                {
                    int oldDelay = ConVar.Server.combatlogdelay;
                    ConVar.Server.combatlogdelay = 0;
                    string combatLogString = target.stats.combat.Get(ConVar.Server.combatlogsize);
                    ConVar.Server.combatlogdelay = oldDelay;

                    files.Add(new KeyValuePair<int, List<string>>(1, combatLogString.Split(new string[] { "\r\n", "\r", "\n" }, StringSplitOptions.None).ToList()));
                }
            }

            parameters.Add("TextFiles", files);

            SendReport(parameters);
        }

        private void OnServerInitialized(bool initial)
        {
            if (initial)
            {
                ClearAllPlayerConnections();
            }
        }

        //This may fail but it doesnt matter it gets called on start up.(server crash, above method)
        private void OnServerShutdown() => ClearAllPlayerConnections();

        private void OnPlayerDisconnected(BasePlayer player)
        {
            Dictionary<string, object> parameters = new Dictionary<string, object>();

            parameters.Add("SteamId", player.UserIDString);
            parameters.Add("ServerPort", _port);

            UserLeftServer(parameters);
        }

        private void OnPlayerBanned(string name, ulong id, string address, string reason)
        {
            AddBanClass ban = new AddBanClass();

            ban.SteamId = id.ToString();
            ban.Reason = reason;
            ban.ExpireTime = null;
            ban.BannedBy = null;

            SubmitNewBan(ban, null, (newBan) =>
            {
                ServerUsers.User user = ServerUsers.Get(id);
                if (user == null || user.group != ServerUsers.UserGroup.Banned)
                {
                    Puts("no user found that is banned");
                }
                else
                {
                    ServerUsers.Remove(id);
                    ServerUsers.Save();
                }
            });
        }

        private void OnUserApprove(Network.Connection connection)
        {
            ulong ownerId = connection.userid;

            string id = connection.userid.ToString();
            if (_approvedCachedJoins.ContainsKey(id))
            {
                ApprovedCachedPlayer data = _approvedCachedJoins[id];
                TimeSpan timeSinceAdd = DateTime.Now - data.timeOfAdd;

                if (timeSinceAdd.TotalMinutes < 1)
                {
                    timer.Once(5.0f, () => // Prevents spam joinning
                    {
                        if (connection != null)
                            Network.Net.sv.Kick(connection, data.reason, false);
                    });

                    return;
                }

                _approvedCachedJoins.Remove(id);
            }

            CheckForBans(connection, ownerId);
        }

        private void OnUserConnected(IPlayer player)
        {
            FetchDiscordLinkData(player);

            UserConnectedToServer(player);
        }

        #endregion Hooks

        #region Web Requests
        private void CheckForBans(Network.Connection connection, ulong ownerId)
        {
            webrequest.Enqueue($"{_connection}api/Ban/GetActiveBans?steamId={ownerId}&serverPort={_port}", null, (code, response) =>
            //webrequest.Enqueue($"{apiUrl}/api/Ban/ReturnSelf?thing='hello'", null, (code, response) =>
            {
                if (code == 200)
                {
                    List<AddBanClass> bans = JsonConvert.DeserializeObject<List<AddBanClass>>(response);
                    if (bans.Count > 0)
                    {
                        AddBanClass banSuccess = bans.FirstOrDefault();

                        string kickReason = lang.GetMessage("YouAreBannedMessage", this, connection.userid.ToString());
                        kickReason = kickReason.Replace("@reason", banSuccess.Reason);
                        Network.Net.sv.Kick(connection, kickReason, false);

                        _approvedCachedJoins.Add(connection.userid.ToString(), new ApprovedCachedPlayer() { reason = kickReason, timeOfAdd = DateTime.Now });
                    }
                }
                else if (code == 204)
                {
                    //Puts($"You are not banned!");
                }
                else if (code == 0)
                {
                    Puts($"-=-=-=-gameservertools.com is unreachable!-=-=-=-=-");
                }
                else
                {
                    Puts($"Something went wrong code {code} {response}");
                }
            }, this, Core.Libraries.RequestMethod.GET, _headers);
        }
        private void SendReport(Dictionary<string, object> parameters)
        {
            string body = JsonConvert.SerializeObject(parameters);

            if (_loggingEnabled)
                Puts($"Sending report...");

            webrequest.Enqueue($"{_connection}api/Report/AddReport", body, (code, response) =>
            {
                if (_loggingEnabled)
                    Puts($"Got result back!\nCode: {code}\n Response: {response}");
            }, this, RequestMethod.POST, _headers, timeout);
        }

        private void ClearAllPlayerConnections()
        {
            webrequest.Enqueue($"{_connection}api/Stat/ServerStarted?serverPort={_port}", null, (code, response) =>
            {
            }, this, Core.Libraries.RequestMethod.POST, _headers, timeout);
        }

        private void SubmitNewBan(AddBanClass newBan, IPlayer admin, Action<AddBanClass> successCallBack)
        {
            newBan.ServerPort = _port;
            string body = JsonConvert.SerializeObject(newBan);
            webrequest.Enqueue($"{_connection}/api/Ban/AddBan", body, (code, response) =>
            {
                if (code == 200)// Success
                {
                    AddBanClass banSuccess = JsonConvert.DeserializeObject<AddBanClass>(response);

                    BasePlayer playerToKick = BasePlayer.Find(banSuccess.SteamId.ToString());
                    if (playerToKick != null && playerToKick.IsConnected)
                    {
                        string messageReplaced = lang.GetMessage("YouAreBannedMessage", this, playerToKick.UserIDString);
                        messageReplaced = messageReplaced.Replace("@reason", banSuccess.Reason);
                        playerToKick.Kick(messageReplaced);
                    }

                    string broadCastMessage = lang.GetMessage("PlayerBannedBroadcastMsg", this, playerToKick.UserIDString);
                    broadCastMessage = broadCastMessage.Replace("@user", banSuccess.Reason);
                    Chat.Broadcast(broadCastMessage);

                    successCallBack.Invoke(banSuccess);
                }
                else if (code == 400)
                {
                    if (admin != null && admin.IsConnected)
                    {
                        string messageReplaced = lang.GetMessage("FailedToBan", this, admin.Id);
                        messageReplaced = messageReplaced.Replace("@response", response);
                        admin.Reply(messageReplaced);
                    }
                    Puts($"Failed to ban user! {response}");
                }
                else if (code == 401)
                {
                    if (admin != null && admin.IsConnected)
                    {
                        string messageReplaced = lang.GetMessage("FailedToBanNoPermission", this, admin.Id);
                        admin.Reply(messageReplaced);
                    }
                    Puts($"Failed to ban user! {response}");
                }
                else
                {
                    if (admin != null && admin.IsConnected)
                    {
                        string messageReplaced = lang.GetMessage("FailedToBan", this, admin.Id);
                        messageReplaced = messageReplaced.Replace("@response", response);
                        admin.Reply(messageReplaced);
                    }

                    Puts($"Ban failed: {response} Code: {code}");
                }
            }, this, Core.Libraries.RequestMethod.PUT, _headers);
        }

        private void UserLeftServer(Dictionary<string, object> parameters)
        {
            string body = JsonConvert.SerializeObject(parameters);

            webrequest.Enqueue($"{_connection}api/Stat/UserLeftServer", body, (code, response) =>
            {
            }, this, Core.Libraries.RequestMethod.PUT, _headers, timeout);
        }

        private void UserConnectedToServer(IPlayer player)
        {
            Dictionary<string, object> parameters = new Dictionary<string, object>();

            parameters.Add("SteamId", player.Id);
            parameters.Add("ServerPort", _port);

            string body = JsonConvert.SerializeObject(parameters);
            webrequest.Enqueue($"{_connection}api/Stat/UserJoinnedServer", body, (code, response) =>
            {
            }, this, Core.Libraries.RequestMethod.POST, _headers, timeout);
        }

        private void FetchDiscordLinkData(IPlayer player)
        {
            webrequest.Enqueue($"{_connection}api/Link/GetLinkData?steamId={player.Id}", null, (code, response) =>
            {
                if (code == 200)
                {
                    LinkModel linkData = JsonConvert.DeserializeObject<LinkModel>(response);
                    //check if they have left the discord here
                    HandleDiscordLinkerConnect(linkData, player);
                }
                else
                {
                    player.Reply("Something went wrong with this command. Please contact the admin of the server");
                    Debug.LogError($"Error checking link: {response} {code}");
                }
            }, this, RequestMethod.GET, _headers, timeout);
        }

        #endregion WebRequests

        #region DiscordLinker

        private void HandleDiscordLinkerConnect(LinkModel linkData, IPlayer player)
        {
            if (linkData.LinkId == 0) // not linked
            {
                string joinMessageNotLinked = lang.GetMessage("JoinMessageNotLinked", this, player.Id);
                player.Reply($"{joinMessageNotLinked}");

                bool userHasGroup = player.BelongsToGroup(_linkedGroupName);
                if (userHasGroup)
                {
                    player.RemoveFromGroup(_linkedGroupName);
                    player.RemoveFromGroup(_nitroGroupName);
                    Interface.CallHook("OnDiscordUserUnLinked", player);
                }
            }
            else if (linkData.LinkId != 0 && !linkData.InDiscord) // left discord
            {
                string joinMessageLeft = lang.GetMessage("JoinMessageLeft", this, player.Id);
                player.Reply($"{joinMessageLeft}");
                //removes the from the group encase they unlinked their account

                bool userHasGroup = player.BelongsToGroup(_linkedGroupName);
                if (userHasGroup)
                {
                    player.RemoveFromGroup(_linkedGroupName);
                    player.RemoveFromGroup(_nitroGroupName);
                    Interface.CallHook("OnDiscordUserUnLinked", player);
                }
            }
            else // Linked
            {
                string joinMessageLinked = lang.GetMessage("JoinMessageLinked", this, player.Id);
                player.Reply($"{joinMessageLinked}");
                bool userHasGroup = player.BelongsToGroup(_linkedGroupName);
                if (!userHasGroup)
                {
                    player.AddToGroup(_linkedGroupName);
                    Interface.CallHook("OnDiscordUserAddedToGroup", player);
                }

                // Check for nitro rewards
                bool userHasNitro = player.BelongsToGroup(_nitroGroupName);
                if (userHasNitro && !linkData.NitroBoosted)
                {
                    string noLongerBoostingMessage = lang.GetMessage("NitroLostMessage", this, player.Id);

                    player.Reply(noLongerBoostingMessage);

                    player.RemoveFromGroup(_nitroGroupName);
                    Interface.CallHook("OnNitroBoostRemove", player);
                    // Do discord nitro stuff here
                }
                else if (!userHasNitro && linkData.NitroBoosted)
                {
                    string nowBoostingMessage = lang.GetMessage("NitroGainMessage", this, player.Id);
                    player.Reply(nowBoostingMessage);

                    player.AddToGroup(_nitroGroupName);
                    Interface.CallHook("OnNitroBoost", player);
                }
            }
        }

        #endregion

        #region Helpers

        private ReportType GetTypeIdFromType(string type)
        {
            switch (type)
            {
                case "abusive":
                    return ReportType.Abusive;

                case "cheat":
                    return ReportType.Cheat;

                case "spam":
                    return ReportType.Spam;

                case "name":
                    return ReportType.Name;
            }
            return ReportType.Abusive;
        }

        private void MessageAllPlayers(string message)
        {
            foreach (IPlayer player in players.Connected)
            {
                player.Message(message);
            }
        }

        private bool TryGetBanExpiry(
          string arg,
          int n,
          IPlayer iplayer,
          out long expiry,
          out string durationSuffix)
        {
            expiry = GetTimestamp(arg, n, -1L);
            durationSuffix = (string)null;
            int current = Epoch.Current;
            if (expiry > 0L && expiry <= (long)current)
            {
                string messageReplaced = lang.GetMessage("PastExireDate", this, iplayer.Id);
                iplayer.Reply(messageReplaced);
                return false;
            }
            durationSuffix = expiry > 0L ? " for " + (expiry - (long)current).FormatSecondsLong() : "";
            return true;
        }

        private long GetTimestamp(string arg, int iArg, long def = 0)
        {
            string s = arg == string.Empty ? null : arg;
            if (s == null)
                return def;
            int num = 3600;
            if (s.Length > 1 && char.IsLetter(s[s.Length - 1]))
            {
                switch (s[s.Length - 1])
                {
                    case 'M':
                        num = 2592000;
                        break;

                    case 'Y':
                        num = 31536000;
                        break;

                    case 'd':
                        num = 86400;
                        break;

                    case 'h':
                        num = 3600;
                        break;

                    case 'm':
                        num = 60;
                        break;

                    case 's':
                        num = 1;
                        break;

                    case 'w':
                        num = 604800;
                        break;
                }

                s = s.Substring(0, s.Length - 1);
            }
            long result;
            if (!long.TryParse(s, out result))
                return def;
            if (result > 0L && result <= 315360000L)
                result = DateTimeOffset.UtcNow.ToUnixTimeSeconds() + result * (long)num;
            return result;
        }

        #endregion helpers

        #region Commands

        [Command("Near")]
        private void FindNear(IPlayer iplayer, string command, string[] args)
        {
            if (iplayer.IsServer)
            {
                BasePlayer target = BasePlayer.Find(args[0]);
                if (target != null)
                {
                    IOrderedEnumerable<BasePlayer> orderList = BasePlayer.activePlayerList.OrderBy(p => Vector3.Distance(p.transform.position, target.transform.position));

                    int i = 0;
                    List<ulong> discordId = new List<ulong>();
                    foreach (BasePlayer player in orderList)
                    {
                        if (player.userID == target.userID)
                        {
                            continue;
                        }

                        if (i >= 15)
                        {
                            break;
                        }
                        discordId.Add(player.userID);
                        i++;
                    }
                    iplayer.Reply(String.Join(",", discordId.ToArray()));
                }
            }
            else
            {
                iplayer.Reply("Not server");
            }
        }

        [Command("checklink")] //Used by gst to automatically check a users account. This is not called by users
        private void CheckLinkCommand(IPlayer iplayer, string command, string[] args)
        {
            if (!iplayer.IsServer) return;

            BasePlayer player = BasePlayer.Find(args[0]);
            if (player == null || !player.IsConnected)
            {
                return;
            }

            if (args.Length > 1)
            {
                if (_showClaimMessage)
                {
                    string messageReplaced = lang.GetMessage("BroadcastMessage", this, iplayer.Id);
                    string newMessage = messageReplaced.Replace("@userName", player.displayName);
                    MessageAllPlayers(newMessage);
                }
            }

            FetchDiscordLinkData(player.IPlayer);
        }

        [Command("nitro", "linked")]
        private void NitroCheck(IPlayer iplayer, string command, string[] args)
        {
            CachedPlayer data;
            if (_cachedJoins.TryGetValue(iplayer, out data))
            {
                TimeSpan timeSinceAdd = DateTime.Now - data.TimeOfAdd;
                if (timeSinceAdd.TotalMinutes < 1)
                {
                    string message = lang.GetMessage("RecentlyUsedThisCommand", this, iplayer.Id);
                    iplayer.Reply(message);
                    return;
                }

                _cachedJoins.Remove(iplayer);
            }

            _cachedJoins.Add(iplayer, new CachedPlayer());

            string messageCheckingAccount = lang.GetMessage("CheckingAccount", this, iplayer.Id);
            iplayer.Reply(messageCheckingAccount);

            FetchDiscordLinkData(iplayer);
        }

        private void OverrideBanCommand(IPlayer iplayer, string command, string[] args)
        {
            if (!iplayer.IsAdmin && !iplayer.IsServer) // Replicate normal server permissions
            {
                return;
            }
            if (args.Length < 1) // Replicate normal server permissions
            {
                string messageReplaced = lang.GetMessage("InvalidArguments", this, iplayer.Id);
                iplayer.Reply(messageReplaced);
                return;
            }

            BasePlayer player = args[0] == null ? null : BasePlayer.Find(args[0]);
            if (player == null || player.net == null || player.net.connection == null)
            {
                string messageReplaced = lang.GetMessage("NoPlayerFound", this, iplayer.Id);
                iplayer.Reply(messageReplaced);
            }
            else
            {
                string noReasonString = lang.GetMessage("NoReason", this, iplayer.Id);

                string notes = args.Length < 2 ? noReasonString : args[1];

                long expiry;
                string durationSuffix;
               
                if (!TryGetBanExpiry(args.Length < 3 ? string.Empty : args[2], 2, iplayer, out expiry, out durationSuffix))
                    return;
                
                AddBanClass ban = new AddBanClass();
                
                ban.SteamId = player.UserIDString;
                ban.Reason = notes;
                ban.BannedBy = iplayer.IsServer ? null : iplayer.Id;
                
                if (expiry > 0L)
                {
                    
                    ban.ExpireTime = DateTimeOffset.FromUnixTimeSeconds(expiry).DateTime;
                }
                else
                    ban.ExpireTime = null;
                
                SubmitNewBan(ban, iplayer, (sumbitedBan) =>
                {
                   
                    if (iplayer != null && iplayer.IsConnected)
                    {
                        string messageReplaced = lang.GetMessage("BanSentSuccess", this, iplayer.Id);
                        messageReplaced = messageReplaced.Replace("@niceBanId", sumbitedBan.NiceBanId);
                        iplayer.Reply(messageReplaced);
                    }
                    if (player.IsConnected && player.net.connection.ownerid != 0UL && (long)player.net.connection.ownerid != (long)player.net.connection.userid)
                    {
                        string banReason = string.Empty;
                        if (iplayer != null && iplayer.IsConnected)
                        {
                            string messageReplaced = lang.GetMessage("FamilyShareAccount", this, iplayer.Id);
                            iplayer.Reply(messageReplaced);
                            banReason = lang.GetMessage("FamilyShareReason", this, iplayer.Id);
                        }
                        else
                        {
                            banReason = lang.GetMessage("FamilyShareReason", this);
                        }
                        banReason = banReason.Replace("@player", player.net.connection.userid.ToString());
                        banReason = banReason.Replace("@niceBanId", sumbitedBan.NiceBanId);

                        AddBanClass shareBan = new AddBanClass();
                        shareBan.SteamId = player.net.connection.ownerid.ToString();
                        shareBan.Reason = banReason;
                        shareBan.BannedBy = iplayer.Id;
                        if (expiry > 0L)
                        {
                            shareBan.ExpireTime = DateTimeOffset.FromUnixTimeSeconds(expiry).DateTime;
                        }
                        else
                        {
                            shareBan.ExpireTime = null;
                        }
                        SubmitNewBan(ban, iplayer, (sumbitedBanFamilyShare) =>
                        {
                            if (iplayer != null && iplayer.IsConnected)
                            {
                                string messageReplaced = lang.GetMessage("BanSentSuccess", this, iplayer.Id);
                                messageReplaced = messageReplaced.Replace("@niceBanId", sumbitedBan.NiceBanId);
                                iplayer.Reply(messageReplaced);
                            }
                        });
                    }
                });
            }
        }

        [Command("AddAllBans")]
        private void AddAllBans(IPlayer iplayer, string command, string[] args)
        {
            if (iplayer != null && iplayer.IsAdmin)
            {
                List<ServerUsers.User> list = ServerUsers.GetAll(ServerUsers.UserGroup.Banned).ToList<ServerUsers.User>();
                float time = 0.0f;
                int i = 1;
                foreach (ServerUsers.User user in list)
                {
                    timer.Once(time, () =>
                    {
                        if (iplayer != null && iplayer.IsConnected)
                        {
                            string messageReplaced = lang.GetMessage("MassBanMessage", this, iplayer.Id);
                            messageReplaced = messageReplaced.Replace("@user", user.steamid.ToString());
                            messageReplaced = messageReplaced.Replace("@listCount", list.Count.ToString());
                            messageReplaced = messageReplaced.Replace("@index", i.ToString());
                            iplayer.Reply(messageReplaced);
                        }

                        i++;
                        AddBanClass ban = new AddBanClass();
                        ban.SteamId = user.steamid.ToString();
                        ban.Reason = user.notes;
                        ban.BannedBy = null;
                        ban.DontSendRconKick = true;
                        if (user.expiry > 0L)
                        {
                            long minsToAdd = (user.expiry - (long)Facepunch.Math.Epoch.Current);// / 60.0f);
                            minsToAdd = minsToAdd / 60;
                            ban.ExpireTime = DateTime.UtcNow.AddMinutes(minsToAdd);
                        }
                        else
                            ban.ExpireTime = null;

                        SubmitNewBan(ban, iplayer, (newban) => { });
                    });
                    time = time + 0.5f;
                }
            }
        }

        #endregion Commands

        #region Classes and Enums

        private enum ReportType
        {
            Abusive = 1,
            Cheat = 2,
            Spam = 3,
            Name = 4
        }

        public class LinkModel
        {
            public int LinkId { get; set; }
            public long SteamId { get; set; }
            public long DiscordId { get; set; }
            public int OrgId { get; set; }
            public DateTime LinkDate { get; set; }
            public bool InDiscord { get; set; }
            public bool ClaimedRewards { get; set; }
            public int? NitroBoostId { get; set; }
            public bool NitroBoosted { get; set; }
        }

        private class CachedPlayer
        {
            public CachedPlayer()
            {
                TimeOfAdd = DateTime.UtcNow;
            }

            public DateTime TimeOfAdd { get; }
        }

        private class AddBanClass
        {
            public string SteamId { get; set; }
            public string Reason { get; set; }
            public DateTime? ExpireTime { get; set; }
            public int OrgId { get; set; }
            public int? ServerId { get; set; }
            public string BannedBy { get; set; }
            public string NiceBanId { get; set; }
            public int ServerPort { get; set; }
            public bool DontSendRconKick { get; set; }
        }

        private class ApprovedCachedPlayer
        {
            public string reason { get; set; }
            public DateTime timeOfAdd { get; set; }
        }

        #endregion classes

        #region Config and Lang

        protected override void LoadDefaultConfig()
        {
            Config["APIKEY"] = "";
            Config["OxideGroupNameForLinked"] = "DiscordLinked";
            Config["OxideGroupNameForNitro"] = "NitroBoosted";
            Config["DisplayMessageOnClaimRewards"] = true;
            Config["DebugLoggingEnabled"] = false;
            Config["DisableBanCtrl"] = false;
            Config["Port"] = 28015;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["BroadcastMessage"] = "@userName has just claimed some really cool  reward for linkking his account head to discordlinker.com to claim yours",
                ["JoinMessageLinked"] = "Your account is linked!",
                ["JoinMessageNotLinked"] = "Your account is NOT linked!",
                ["JoinMessageLeft"] = "Your left our discord :( You will no longer get rewards",
                ["RecentlyUsedThisCommand"] = "You recently used this command",
                ["CheckingAccount"] = "Checking your account...",
                ["AccountLinkSuccess"] = "Account Link successfull!",
                ["AlreadyLinked"] = "Your account has not been linked! Link your account at discordlinker.com/",
                ["UnkownError"] = "Unkown error",
                ["NitroLostMessage"] = "You are no longer nitro boosting this amazing server!",
                ["NitroGainMessage"] = "You are now nitro boosting this amazing server you will now get this awsome thing!",
                ["YouAreBannedMessage"] = "You are banned! Reason: @reason Head to discord.com/yourserver to appeal this ban",
                ["FailedToBan"] = "Failed to ban user! @response",
                ["FailedToBanNoPermission"] = "Failed to ban user! You do not have permission on gameservertools.com to ban users! Please contact your server owner to get this resolved",
                ["PastExireDate"] = "Expiry time is in the past",
                ["NoPlayerFound"] = "Player not found",
                ["NoReason"] = "No Reason Given",
                ["BanSentSuccess"] = "Ban Succesfully sent to Game Server Tools. BanId: @niceBanId",
                ["FamilyShareAccount"] = "Found family share account. Sending ban!",
                ["FamilyShareReason"] = "Family share owner of @player, Share Ban Id: @niceBanId",
                ["MassBanMessage"] = "@index/@listCount Sending ban for @user",
                ["PlayerBannedBroadcastMsg"] = "Player @user has been banned.",
                ["InvalidArguments"] = "Please provide a user to ban"
            }, this);
        }

        #endregion config
    }
}

// --- End of file: GameServerTools.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/godmode ---
// --- Original File Path: G/Godmode/Godmode.cs ---

ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust;
using Rust;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Godmode", "Wulf/lukespragg/Arainrr/dFxPhoeniX", "4.2.14")]
    [Description("Allows players with permission to be invulnerable and god-like")]
    internal class Godmode : RustPlugin
    {
        #region Fields

        private const string PermAdmin = "godmode.admin";
        private const string PermInvulnerable = "godmode.invulnerable";
        private const string PermLootPlayers = "godmode.lootplayers";
        private const string PermLootProtection = "godmode.lootprotection";
        private const string PermNoAttacking = "godmode.noattacking";
        private const string PermToggle = "godmode.toggle";
        private const string PermUntiring = "godmode.untiring";
        private const string PermAutoEnable = "godmode.autoenable";

        private readonly object _false = false, _true = true;
        private Dictionary<ulong, float> _informHistory;
        private readonly StoredMetabolism _storedMetabolism = new StoredMetabolism();

        #endregion Fields

        #region Oxide Hook

        private void Init()
        {
            LoadData();
            permission.RegisterPermission(PermAdmin, this);
            permission.RegisterPermission(PermInvulnerable, this);
            permission.RegisterPermission(PermLootPlayers, this);
            permission.RegisterPermission(PermLootProtection, this);
            permission.RegisterPermission(PermNoAttacking, this);
            permission.RegisterPermission(PermToggle, this);
            permission.RegisterPermission(PermUntiring, this);
            permission.RegisterPermission(PermAutoEnable, this);

            AddCovalenceCommand(configData.godCommand, nameof(GodCommand));
            AddCovalenceCommand(configData.godsCommand, nameof(GodsCommand));
            if (configData.informOnAttack)
            {
                _informHistory = new Dictionary<ulong, float>();
            }
            if (!configData.disconnectDisable)
            {
                Unsubscribe(nameof(OnPlayerDisconnected));
            }
        }

        private void OnServerInitialized()
        {
            if (!_storedMetabolism.FetchDefaultMetabolism())
            {
                PrintError("Failed to fetch default metabolism data");
            }
            foreach (var god in storedData.godPlayers.ToArray())
            {
                if (!permission.UserHasPermission(god, PermToggle))
                {
                    storedData.godPlayers.Remove(god);
                    continue;
                }
                EnableGodmode(god, true);
            }
            CheckHooks();
        }

        private void OnServerSave()
        {
            timer.Once(Random.Range(0f, 60f), SaveData);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (IsGod(player))
            {
                PlayerRename(player, true);
                ModifyMetabolism(player, true);
            }
            else if (permission.UserHasPermission(player.UserIDString, PermAutoEnable))
            {
                EnableGodmode(player.UserIDString);
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (IsGod(player))
            {
                DisableGodmode(player.UserIDString);
            }
        }

        private void Unload()
        {
            foreach (var god in storedData.godPlayers.ToArray())
            {
                DisableGodmode(god, true);
            }
            SaveData();
        }

        private object CanBeWounded(BasePlayer player)
        {
            return IsGod(player) ? _false : null;
        }

        private object CanLootPlayer(BasePlayer target, BasePlayer looter)
        {
            if (target == null || looter == null || target == looter)
            {
                return null;
            }
            if (IsGod(target) && permission.UserHasPermission(target.UserIDString, PermLootProtection) && !permission.UserHasPermission(looter.UserIDString, PermLootPlayers))
            {
                Print(looter, Lang("NoLooting", looter.UserIDString));
                return _false;
            }
            return null;
        }

        private object OnEntityTakeDamage(BasePlayer player, HitInfo info)
        {
            if (player == null || !player.userID.IsSteamId())
            {
                return null;
            }
            var attacker = info?.InitiatorPlayer;
            if (IsGod(player) && permission.UserHasPermission(player.UserIDString, PermInvulnerable))
            {
                InformPlayers(player, attacker);
                NullifyDamage(ref info);
                return _true;
            }
            if (IsGod(attacker) && permission.UserHasPermission(attacker.UserIDString, PermNoAttacking))
            {
                InformPlayers(player, attacker);
                NullifyDamage(ref info);
                return _true;
            }
            return null;
        }

        private object OnRunPlayerMetabolism(PlayerMetabolism metabolism, BasePlayer player, float delta)
        {
            if (!IsGod(player))
            {
                return null;
            }
            metabolism.hydration.value = _storedMetabolism.GetMaxHydration();
            if (!permission.UserHasPermission(player.UserIDString, PermUntiring))
            {
                return null;
            }
            var currentCraftLevel = player.currentCraftLevel;
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench1, currentCraftLevel == 1f);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench2, currentCraftLevel == 2f);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench3, currentCraftLevel == 3f);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.SafeZone, player.InSafeZone());
            return _false;
        }

        #endregion Oxide Hook

        #region Methods

        private void CheckHooks()
        {
            if (storedData.godPlayers.Count > 0)
            {
                Subscribe(nameof(CanBeWounded));
                Subscribe(nameof(CanLootPlayer));
                Subscribe(nameof(OnEntityTakeDamage));
                Subscribe(nameof(OnRunPlayerMetabolism));
            }
            else
            {
                Unsubscribe(nameof(CanBeWounded));
                Unsubscribe(nameof(CanLootPlayer));
                Unsubscribe(nameof(OnEntityTakeDamage));
                Unsubscribe(nameof(OnRunPlayerMetabolism));
            }
        }

        private void InformPlayers(BasePlayer victim, BasePlayer attacker)
        {
            if (!configData.informOnAttack || victim == null || attacker == null || victim == attacker)
            {
                return;
            }
            if (!victim.userID.IsSteamId() || !attacker.userID.IsSteamId())
            {
                return;
            }
            float victimTime;
            if (!_informHistory.TryGetValue(victim.userID, out victimTime))
            {
                _informHistory.Add(victim.userID, 0);
            }
            float attackerTime;
            if (!_informHistory.TryGetValue(attacker.userID, out attackerTime))
            {
                _informHistory.Add(attacker.userID, 0);
            }
            var currentTime = Time.realtimeSinceStartup;
            if (IsGod(victim))
            {
                if (currentTime - victimTime > configData.informInterval)
                {
                    _informHistory[victim.userID] = currentTime;
                    Print(attacker, Lang("InformAttacker", attacker.UserIDString, victim.displayName));
                }
                if (currentTime - attackerTime > configData.informInterval)
                {
                    _informHistory[attacker.userID] = currentTime;
                    Print(victim, Lang("InformVictim", victim.UserIDString, attacker.displayName));
                }
            }
            else if (IsGod(attacker))
            {
                if (currentTime - victimTime > configData.informInterval)
                {
                    _informHistory[victim.userID] = currentTime;
                    Print(attacker, Lang("CantAttack", attacker.UserIDString, victim.displayName));
                }
                if (currentTime - attackerTime > configData.informInterval)
                {
                    _informHistory[attacker.userID] = currentTime;
                    Print(victim, Lang("InformVictim", victim.UserIDString, attacker.displayName));
                }
            }
        }

        #region Godmode Toggle

        private bool? ToggleGodmode(BasePlayer target, BasePlayer player)
        {
            var isGod = IsGod(target);
            if (Interface.CallHook("OnGodmodeToggle", target.UserIDString, !isGod) != null)
            {
                return null;
            }
            if (isGod)
            {
                DisableGodmode(target.UserIDString);
                if (player != null)
                {
                    if (target == player)
                    {
                        Print(player, Lang("GodmodeDisabled", player.UserIDString));
                    }
                    else
                    {
                        Print(player, Lang("GodmodeDisabledFor", player.UserIDString, target.displayName));
                        Print(target, Lang("GodmodeDisabledBy", target.UserIDString, player.displayName));
                    }
                }
                else
                {
                    Print(target, Lang("GodmodeDisabledBy", target.UserIDString, "server console"));
                }
                return false;
            }

            EnableGodmode(target.UserIDString);
            if (player != null)
            {
                if (target == player)
                {
                    Print(player, Lang("GodmodeEnabled", player.UserIDString));
                }
                else
                {
                    Print(player, Lang("GodmodeEnabledFor", player.UserIDString, target.displayName));
                    Print(target, Lang("GodmodeEnabledBy", target.UserIDString, player.displayName));
                }
            }
            else
            {
                Print(target, Lang("GodmodeEnabledBy", target.UserIDString, "server console"));
            }
            var targetId = target.UserIDString;
            if (configData.timeLimit > 0)
            {
                timer.Once(configData.timeLimit, () => DisableGodmode(targetId));
            }
            return true;
        }

        private bool EnableGodmode(string playerId, bool isInit = false)
        {
            if (string.IsNullOrEmpty(playerId) || !isInit && IsGod(playerId))
            {
                return false;
            }
            var player = RustCore.FindPlayerByIdString(playerId);
            if (player == null)
            {
                return false;
            }
            PlayerRename(player, true);
            ModifyMetabolism(player, true);
            if (!isInit)
            {
                storedData.godPlayers.Add(player.UserIDString);
                CheckHooks();
            }
            Interface.CallHook("OnGodmodeToggled", playerId, true);
            return true;
        }

        private bool DisableGodmode(string playerId, bool isUnload = false)
        {
            if (string.IsNullOrEmpty(playerId) || !IsGod(playerId))
            {
                return false;
            }
            var player = RustCore.FindPlayerByIdString(playerId);
            if (player == null)
            {
                return false;
            }
            PlayerRename(player, false);
            ModifyMetabolism(player, false);
            if (!isUnload)
            {
                storedData.godPlayers.Remove(player.UserIDString);
                CheckHooks();
            }
            Interface.CallHook("OnGodmodeToggled", playerId, false);
            return true;
        }

        private void PlayerRename(BasePlayer player, bool isGod)
        {
            if (player == null || !configData.showNamePrefix || string.IsNullOrEmpty(configData.namePrefix))
            {
                return;
            }
            var originalName = GetPayerOriginalName(player.userID);
            if (isGod)
            {
                Rename(player, configData.namePrefix + originalName);
            }
            else
            {
                Rename(player, originalName);
            }
        }

        private void Rename(BasePlayer player, string newName)
        {
            if (player == null || string.IsNullOrEmpty(newName.Trim()))
            {
                return;
            }
            player._name = player.displayName = newName;
            if (player.IPlayer != null)
            {
                player.IPlayer.Name = newName;
            }
            if (player.net?.connection != null)
            {
                player.net.connection.username = newName;
            }
            permission.UpdateNickname(player.UserIDString, newName);
            Player.Teleport(player, player.transform.position);
            player.SendNetworkUpdateImmediate();
            //SingletonComponent<ServerMgr>.Instance.persistance.SetPlayerName(player.userID, newName);
        }

        private void ModifyMetabolism(BasePlayer player, bool isGod)
        {
            if (player == null || player.metabolism == null)
            {
                return;
            }
            if (isGod)
            {
                player.health = player.MaxHealth();
                _storedMetabolism.Unlimited(player.metabolism);
            }
            else
            {
                player.health = player.MaxHealth();
                _storedMetabolism.Restore(player.metabolism);
            }
        }

        #endregion Godmode Toggle

        #region Stored Metabolism

        private class StoredMetabolism
        {
            private struct Attribute
            {
                public float Min { get; private set; }
                public float Max { get; private set; }

                public Attribute(MetabolismAttribute attribute)
                {
                    Min = attribute.min;
                    Max = attribute.max;
                }

                public void Reset(MetabolismAttribute attribute)
                {
                    attribute.min = Min;
                    attribute.max = Max;
                }
            }

            public bool FetchDefaultMetabolism()
            {
                var playerPrefab = "assets/prefabs/player/player.prefab";
                var playerMetabolism = GameManager.server.FindPrefab(playerPrefab)?.GetComponent<PlayerMetabolism>();
                if (playerMetabolism != null)
                {
                    Store(playerMetabolism);
                    return true;
                }
                return false;
            }

            private Attribute calories;
            private Attribute hydration;
            private Attribute heartrate;
            private Attribute temperature;
            private Attribute poison;
            private Attribute radiation_level;
            private Attribute radiation_poison;
            private Attribute wetness;
            private Attribute dirtyness;
            private Attribute oxygen;
            private Attribute bleeding;

            // private Attribute comfort;
            // private Attribute pending_health;
            public float GetMaxHydration()
            {
                return hydration.Max;
            }
            public void Store(PlayerMetabolism playerMetabolism)
            {
                calories = new Attribute(playerMetabolism.calories);
                hydration = new Attribute(playerMetabolism.hydration);
                heartrate = new Attribute(playerMetabolism.heartrate);
                temperature = new Attribute(playerMetabolism.temperature);
                poison = new Attribute(playerMetabolism.poison);
                radiation_level = new Attribute(playerMetabolism.radiation_level);
                radiation_poison = new Attribute(playerMetabolism.radiation_poison);
                wetness = new Attribute(playerMetabolism.wetness);
                dirtyness = new Attribute(playerMetabolism.dirtyness);
                oxygen = new Attribute(playerMetabolism.oxygen);
                bleeding = new Attribute(playerMetabolism.bleeding);
                // comfort = new Attribute(playerMetabolism.comfort);
                // pending_health = new Attribute(playerMetabolism.pending_health);
            }

            public void Unlimited(PlayerMetabolism playerMetabolism)
            {
                playerMetabolism.calories.min = calories.Max;
                playerMetabolism.calories.value = calories.Max;
                // playerMetabolism.hydration.min = hydration.Max; // It causes the character to walk slowly
                playerMetabolism.hydration.value = hydration.Max;
                playerMetabolism.heartrate.min = heartrate.Max;
                playerMetabolism.heartrate.value = heartrate.Max;
                playerMetabolism.temperature.min = 37;
                playerMetabolism.temperature.max = 37;
                playerMetabolism.temperature.value = 37;
                playerMetabolism.poison.max = poison.Min;
                playerMetabolism.poison.value = poison.Min;
                playerMetabolism.radiation_level.max = radiation_level.Min;
                playerMetabolism.radiation_level.value = radiation_level.Min;
                playerMetabolism.radiation_poison.max = radiation_poison.Min;
                playerMetabolism.radiation_poison.value = radiation_poison.Min;
                playerMetabolism.wetness.max = wetness.Min;
                playerMetabolism.wetness.value = wetness.Min;
                playerMetabolism.dirtyness.max = dirtyness.Min;
                playerMetabolism.dirtyness.value = dirtyness.Min;
                playerMetabolism.oxygen.min = oxygen.Max;
                playerMetabolism.oxygen.value = oxygen.Max;
                playerMetabolism.bleeding.max = bleeding.Min;
                playerMetabolism.bleeding.value = bleeding.Min;

                playerMetabolism.SendChangesToClient();
            }

            public void Restore(PlayerMetabolism playerMetabolism)
            {
                calories.Reset(playerMetabolism.calories);
                hydration.Reset(playerMetabolism.hydration);
                heartrate.Reset(playerMetabolism.heartrate);
                temperature.Reset(playerMetabolism.temperature);
                poison.Reset(playerMetabolism.poison);
                radiation_level.Reset(playerMetabolism.radiation_level);
                radiation_poison.Reset(playerMetabolism.radiation_poison);
                wetness.Reset(playerMetabolism.wetness);
                dirtyness.Reset(playerMetabolism.dirtyness);
                oxygen.Reset(playerMetabolism.oxygen);
                bleeding.Reset(playerMetabolism.bleeding);
                // comfort.Reset(playerMetabolism.comfort);
                // pending_health.Reset(playerMetabolism.pending_health);

                playerMetabolism.Reset();

                playerMetabolism.calories.value = calories.Max;
                playerMetabolism.hydration.value = hydration.Max;

                playerMetabolism.SendChangesToClient();
            }
        }

        #endregion Stored Metabolism

        #endregion Methods

        #region Helpers

        private static void NullifyDamage(ref HitInfo info)
        {
            info.damageTypes = new DamageTypeList();
            info.HitMaterial = 0;
            info.PointStart = Vector3.zero;
        }

        private static string GetPayerOriginalName(ulong playerId)
        {
            return SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(playerId);
        }

        #endregion Helpers

        #region API

        private bool EnableGodmode(IPlayer iPlayer)
        {
            return EnableGodmode(iPlayer.Id);
        }

        private bool EnableGodmode(ulong playerId)
        {
            return EnableGodmode(playerId.ToString());
        }

        private bool DisableGodmode(IPlayer iPlayer)
        {
            return DisableGodmode(iPlayer.Id);
        }

        private bool DisableGodmode(ulong playerId)
        {
            return DisableGodmode(playerId.ToString());
        }

        private bool IsGod(ulong playerId)
        {
            return IsGod(playerId.ToString());
        }

        private bool IsGod(BasePlayer player)
        {
            return player != null && IsGod(player.UserIDString);
        }

        private bool IsGod(string playerId)
        {
            return storedData.godPlayers.Contains(playerId);
        }

        private string[] AllGods(string playerId) => AllGods();
        private string[] AllGods()
        {
            return storedData.godPlayers.ToArray();
        }

        #endregion API

        #region Commands

        private void GodCommand(IPlayer iPlayer, string command, string[] args)
        {
            if (args.Length > 0 && !iPlayer.HasPermission(PermAdmin) || !iPlayer.HasPermission(PermToggle))
            {
                Print(iPlayer, Lang("NotAllowed", iPlayer.Id, command));
                return;
            }
            if (args.Length == 0 && iPlayer.Id == "server_console")
            {
                Print(iPlayer, $"The server console cannot use {command}");
                return;
            }
            var target = args.Length > 0 ? RustCore.FindPlayer(args[0]) : iPlayer.Object as BasePlayer;
            if (args.Length > 0 && target == null)
            {
                Print(iPlayer, Lang("PlayerNotFound", iPlayer.Id, args[0]));
                return;
            }
            var obj = ToggleGodmode(target, iPlayer.Object as BasePlayer);
            if (obj.HasValue && iPlayer.Id == "server_console" && args.Length > 0)
            {
                if (obj.Value)
                {
                    Print(iPlayer, $"'{target?.displayName}' have enabled godmode");
                }
                else
                {
                    Print(iPlayer, $"'{target?.displayName}' have disabled godmode");
                }
            }
        }

        private void GodsCommand(IPlayer iPlayer, string command, string[] args)
        {
            if (!iPlayer.HasPermission(PermAdmin))
            {
                Print(iPlayer, Lang("NotAllowed", iPlayer.Id, command));
                return;
            }
            if (storedData.godPlayers.Count == 0)
            {
                Print(iPlayer, Lang("NoGods", iPlayer.Id));
                return;
            }
            var stringBuilder = new StringBuilder();
            stringBuilder.AppendLine();
            foreach (var god in storedData.godPlayers)
            {
                var player = RustCore.FindPlayerByIdString(god);
                stringBuilder.AppendLine(player == null ? god : player.ToString());
            }
            Print(iPlayer, stringBuilder.ToString());
        }

        #endregion Commands

        #region ConfigurationFile

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Inform On Attack (true/false)")]
            public bool informOnAttack = true;

            [JsonProperty(PropertyName = "Inform Interval (Seconds)")]
            public float informInterval = 15;

            [JsonProperty(PropertyName = "Show Name Prefix (true/false)")]
            public bool showNamePrefix = true;

            [JsonProperty(PropertyName = "Name Prefix (Default [God])")]
            public string namePrefix = "[God] ";

            [JsonProperty(PropertyName = "Time Limit (Seconds, 0 to Disable)")]
            public float timeLimit = 0f;

            [JsonProperty(PropertyName = "Disable godmode after disconnect (true/false)")]
            public bool disconnectDisable = false;

            [JsonProperty(PropertyName = "Chat Prefix")]
            public string prefix = "[Godmode]:";

            [JsonProperty(PropertyName = "Chat Prefix color")]
            public string prefixColor = "#00FFFF";

            [JsonProperty(PropertyName = "Chat steamID icon")]
            public ulong steamIDIcon = 0;

            [JsonProperty(PropertyName = "God commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public string[] godCommand = { "god", "godmode" };

            [JsonProperty(PropertyName = "Gods commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public string[] godsCommand = { "gods", "godlist" };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(configData);
        }

        #endregion ConfigurationFile

        #region DataFile

        private StoredData storedData;

        private class StoredData
        {
            public readonly HashSet<string> godPlayers = new HashSet<string>();
        }

        private void LoadData()
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch
            {
                storedData = null;
            }
            if (storedData == null)
            {
                ClearData();
            }
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
        }

        private void ClearData()
        {
            storedData = new StoredData();
            SaveData();
        }

        #endregion DataFile

        #region LanguageFile

        private void Print(IPlayer iPlayer, string message)
        {
            iPlayer?.Reply(message,
                           iPlayer.Id == "server_console"
                                   ? $"{configData.prefix}"
                                   : $"<color={configData.prefixColor}>{configData.prefix}</color>");
        }

        private void Print(BasePlayer player, string message)
        {
            Player.Message(player, message, string.IsNullOrEmpty(configData.prefix) ? string.Empty : $"<color={configData.prefixColor}>{configData.prefix}</color>", configData.steamIDIcon);
        }

        private string Lang(string key, string id = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, id), args);
            }
            catch (Exception)
            {
                PrintError($"Error in the language formatting of '{key}'. (userid: {id}. lang: {lang.GetLanguage(id)}. args: {string.Join(" ,", args)})");
                throw;
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["GodmodeDisabled"] = "You have <color=#FF4500>Disabled</color> godmode",
                ["GodmodeDisabledBy"] = "Your godmode has been <color=#FF4500>Disabled</color> by {0}",
                ["GodmodeDisabledFor"] = "You have <color=#FF4500>Disabled</color> godmode for {0}",
                ["GodmodeEnabled"] = "You have <color=#FF4500>Enabled</color> godmode",
                ["GodmodeEnabledBy"] = "Your godmode has been <color=#FF4500>Enabled</color> by {0}",
                ["GodmodeEnabledFor"] = "You have <color=#FF4500>Enabled</color> godmode for {0}",
                ["InformAttacker"] = "{0} is in godmode and can't take any damage",
                ["InformVictim"] = "{0} just tried to deal damage to you",
                ["CantAttack"] = "You are in godmode and can't attack {0}",
                ["NoGods"] = "No players currently have godmode enabled",
                ["NoLooting"] = "You are not allowed to loot a player with godmode",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["PlayerNotFound"] = "Player '{0}' was not found"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["GodmodeDisabled"] = "Ai <color=#FF4500>dezactivat</color> godmode",
                ["GodmodeDisabledBy"] = "Godmode-ul tÄu a fost <color=#FF4500>dezactivat</color> de cÄtre {0}",
                ["GodmodeDisabledFor"] = "Ai <color=#FF4500>dezactivat</color> godmode pentru {0}",
                ["GodmodeEnabled"] = "Ai <color=#FF4500>activat</color> godmode",
                ["GodmodeEnabledBy"] = "Godmode-ul tÄu a fost <color=#FF4500>activat</color> de cÄtre {0}",
                ["GodmodeEnabledFor"] = "Ai <color=#FF4500>activat</color> godmode pentru {0}",
                ["InformAttacker"] = "{0} este Ã®n godmode Èi nu poate primi daune",
                ["InformVictim"] = "{0} a Ã®ncercat sÄ-Èi provoace daune",
                ["CantAttack"] = "EÈti Ã®n godmode Èi nu-l poÈi ataca pe {0}",
                ["NoGods"] = "Momentan nu existÄ jucÄtori cu godmode activat",
                ["NoLooting"] = "Nu ai permisiunea de a fura de la un jucÄtor cu godmode",
                ["NotAllowed"] = "Nu ai permisiunea de a utiliza comanda '{0}'",
                ["PlayerNotFound"] = "JucÄtorul '{0}' nu a fost gÄsit"
            }, this, "ro");
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["GodmodeDisabled"] = "æ¨çä¸å¸æ¨¡å¼ <color=#FF4500>å·²ç¦ç¨</color>",
                ["GodmodeDisabledBy"] = "{0} <color=#FF4500>ç¦ç¨äº</color> æ¨çä¸å¸æ¨¡å¼",
                ["GodmodeDisabledFor"] = "æ¨ <color=#FF4500>ç¦ç¨äº</color> {0} çä¸å¸æ¨¡å¼",
                ["GodmodeEnabled"] = "æ¨çä¸å¸æ¨¡å¼ <color=#FF4500>å·²å¯ç¨</color>",
                ["GodmodeEnabledBy"] = "{0} <color=#FF4500>å¯ç¨äº</color> æ¨çä¸å¸æ¨¡å¼",
                ["GodmodeEnabledFor"] = "æ¨ <color=#FF4500>å¯ç¨äº</color> {0} çä¸å¸æ¨¡å¼",
                ["InformAttacker"] = "{0} å¤äºä¸å¸æ¨¡å¼ï¼æ¨ä¸è½ä¼¤å®³ä»",
                ["InformVictim"] = "{0} æ³ä¼¤å®³æ¨",
                ["CantAttack"] = "æ¨å¤äºä¸å¸æ¨¡å¼ï¼ä¸è½ä¼¤å®³ {0}",
                ["NoGods"] = "å½åæ²¡æç©å®¶å¯ç¨ä¸å¸æ¨¡å¼",
                ["NoLooting"] = "æ¨ä¸è½æ å¤ºå¤äºä¸å¸æ¨¡å¼çç©å®¶",
                ["NotAllowed"] = "æ¨æ²¡ææéä½¿ç¨ '{0}' å½ä»¤",
                ["PlayerNotFound"] = "ç©å®¶ '{0}' æªæ¾å°"
            }, this, "zh-CN");
        }

        #endregion LanguageFile
    }
}

// --- End of file: Godmode.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/gather-control ---
// --- Original File Path: G/GatherControl/GatherControl.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("GatherControl", "CaseMan", "1.8.2", ResourceId = 2477)]
    [Description("Control gather rates by day and night with permissions")]

    class GatherControl : RustPlugin
    {	
		#region Variables
	    [PluginReference]
        Plugin GUIAnnouncements;		

		bool IsDay;	
		bool UseZeroIndexForDefaultGroup;
		bool UseMessageBroadcast;
		bool UseGUIAnnouncements;
		bool AdminMode;
		string BannerColor;
		string TextColor;
		public Dictionary<ulong, int> Temp = new Dictionary<ulong, int>();
		float Sunrise;
		float Sunset;
		float DayRateMultStaticQuarry;
		float NightRateMultStaticQuarry;
		float DayRateMultExcavator;	
		float NightRateMultExcavator;
		string PLPerm = "gathercontrol.AllowChatCommand";
		string AdmPerm = "gathercontrol.AllowConsoleCommand";
		string BypassPerm = "gathercontrol.bypass";

		class PermData
        {
            public Dictionary<int, PermGroups> PermissionsGroups = new Dictionary<int, PermGroups>();
            public PermData(){}
        }

        class PermGroups
        {
			public float DayRateMultQuarry;			
			public float DayRateMultPickup;			
            public float DayRateMultResource;			
			public float DayRateMultResourceBonus;			
			public float DayRateMultResourceHQM;
			public float DayRateMultCropGather;		
			public float NightRateMultQuarry;			
			public float NightRateMultPickup;			           
            public float NightRateMultResource;			
			public float NightRateMultResourceBonus;			
			public float NightRateMultResourceHQM;
			public float NightRateMultCropGather;
			public Dictionary<string, string> CustomRateMultQuarry = new Dictionary<string, string>();
			public Dictionary<string, string> CustomRateMultPickup = new Dictionary<string, string>();
			public Dictionary<string, string> CustomRateMultResource = new Dictionary<string, string>();
			public Dictionary<string, string> CustomRateMultResourceBonus = new Dictionary<string, string>();
			public Dictionary<string, string> CustomRateMultCropGather = new Dictionary<string, string>();
			public Dictionary<string, string> ToolMultiplier = new Dictionary<string, string>();
			public string PermGroup;
			public PermGroups(){}
        }

		PermData permData;
		#endregion
		#region Initialization
		void Init()
        {
            LoadDefaultConfig();
			permData = Interface.Oxide.DataFileSystem.ReadObject<PermData>("GatherControl");
			LoadDefaultData();
			permission.RegisterPermission(PLPerm, this);
			permission.RegisterPermission(AdmPerm, this);
			permission.RegisterPermission(BypassPerm, this);
            foreach(var perm in permData.PermissionsGroups)
			{
                permission.RegisterPermission(perm.Value.PermGroup, this);
			}
			CheckPlayers();
        }
		void LoadDefaultData()
		{
			if(!permData.PermissionsGroups.ContainsKey(0))
			{
				var def = new PermGroups();
                def.DayRateMultQuarry = 2;
                def.DayRateMultPickup = 2;
                def.DayRateMultResource = 2;
				def.DayRateMultResourceBonus = 2;
				def.DayRateMultResourceHQM = 2;
				def.DayRateMultCropGather = 2;
                def.NightRateMultQuarry = 3;
                def.NightRateMultPickup = 3;
                def.NightRateMultResource = 3;
				def.NightRateMultResourceBonus = 3;
				def.NightRateMultResourceHQM = 3;
				def.NightRateMultCropGather =3;
				def.PermGroup = "gathercontrol.default";
				permData.PermissionsGroups.Add(0, def);
				Interface.Oxide.DataFileSystem.WriteObject("GatherControl", permData);
			}			
		}
        void OnPlayerConnected(BasePlayer player)
		{
			CheckPlayer(player);
		}
		void OnPlayerDisconnected(BasePlayer player, string reason)
		{
			if(Temp.ContainsKey(player.userID)) Temp.Remove(player.userID);
		}

		#endregion
		#region Configuration
        protected override void LoadDefaultConfig()
        {
			Config["UseZeroIndexForDefaultGroup"] = UseZeroIndexForDefaultGroup = GetConfig("UseZeroIndexForDefaultGroup", true);
			Config["UseMessageBroadcast"] = UseMessageBroadcast = GetConfig("UseMessageBroadcast", true);
			Config["UseGUIAnnouncements"] = UseGUIAnnouncements = GetConfig("UseGUIAnnouncements", false);
			Config["BannerColor"] = BannerColor = GetConfig("BannerColor", "Blue");
			Config["TextColor"] = TextColor = GetConfig("TextColor", "Yellow");
			Config["Sunrise"] = Sunrise = GetConfig("Sunrise", 7);
			Config["Sunset"] = Sunset = GetConfig("Sunset", 19);
			Config["DayRateMultStaticQuarry"] = DayRateMultStaticQuarry = GetConfig("DayRateMultStaticQuarry", 1);
			Config["NightRateMultStaticQuarry"] = NightRateMultStaticQuarry = GetConfig("NightRateMultStaticQuarry", 1);
			Config["DayRateMultExcavator"] = DayRateMultExcavator = GetConfig("DayRateMultExcavator", 1);
			Config["NightRateMultExcavator"] = NightRateMultExcavator = GetConfig("NightRateMultExcavator", 1);
			Config["AdminMode"] = AdminMode = GetConfig("AdminMode", false);
			SaveConfig();
		}
		#endregion		
		#region Localization
		void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
				["SunriseMessage"] = "Morning comes. Production rating is lowered.",
				["SunsetMessage"] = "Night is coming. Production rating is increased.",
				["GatherRateInfo"] = "Your gather multipliers:",
				["NoGatherRate"] = "You do not have gather multipliers!",
				["GatherRateInfoPlayer"] = "Player {0} have gather multipliers:",
				["NoGatherRatePlayer"] = "Player {0} do not have gather multipliers!",
				["RateResource"] = "Resource gather multiplier (day/night)",
				["RateResourceBonus"] = "Resource gather multiplier for bonus from ore (day/night)",
				["RateResourceHQM"] = "Resource gather multiplier for HQM from ore (day/night)",
				["RatePickup"] = "Pickup multiplier (day/night)",
				["RateQuarry"] = "Multiplier of quarrying (day/night)",
				["RateCropGather"] = "Multiplier for your crop gather (day/night)",
				["InvalidSyntax"] = "Invalid syntax! Use: showrate <name/ID>",
				["NoPlayer"] = "Player not found!",
				["NoPermission"] = "You don't have the permission to use this command",
				["AdminMode"] = "This is <color=#CCFF00>{0}</color> gather type.\nName: <color=#CCFF00>{1}</color>.\nItem short name: <color=#CCFF00>{2}</color>",
            }, this);
			lang.RegisterMessages(new Dictionary<string, string>
            {
                ["SunriseMessage"] = "ÐÐ°ÑÑÑÐ¿Ð°ÐµÑ ÑÑÑÐ¾. Ð ÐµÐ¹ÑÐ¸Ð½Ð³ Ð´Ð¾Ð±ÑÑÐ¸ ÑÐ¼ÐµÐ½ÑÑÐµÐ½.",
                ["SunsetMessage"] = "ÐÐ°ÑÑÑÐ¿Ð°ÐµÑ Ð½Ð¾ÑÑ. Ð ÐµÐ¹ÑÐ¸Ð½Ð³ Ð´Ð¾Ð±ÑÑÐ¸ ÑÐ²ÐµÐ»Ð¸ÑÐµÐ½.",
				["GatherRateInfo"] = "ÐÐ°ÑÐ¸ Ð¼Ð½Ð¾Ð¶Ð¸ÑÐµÐ»Ð¸ Ð´Ð¾Ð±ÑÑÐ¸ ÑÐµÑÑÑÑÐ¾Ð²:",
				["NoGatherRate"] = "Ð£ Ð²Ð°Ñ Ð½ÐµÑ Ð¼Ð½Ð¾Ð¶Ð¸ÑÐµÐ»ÐµÐ¹ Ð´Ð¾Ð±ÑÑÐ¸!",
				["GatherRateInfoPlayer"] = "Ð£ Ð¸Ð³ÑÐ¾ÐºÐ° {0} ÐµÑÑÑ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ðµ Ð¼Ð½Ð¾Ð¶Ð¸ÑÐµÐ»Ð¸:",
				["NoGatherRatePlayer"] = "Ð£ Ð¸Ð³ÑÐ¾ÐºÐ° {0} Ð½ÐµÑ Ð¼Ð½Ð¾Ð¶Ð¸ÑÐµÐ»ÐµÐ¹ Ð´Ð¾Ð±ÑÑÐ¸!",
				["RateResource"] = "ÐÐ½Ð¾Ð¶Ð¸ÑÐµÐ»Ñ Ð´Ð¾Ð±ÑÑÐ¸ ÑÐµÑÑÑÑÐ¾Ð² (Ð´ÐµÐ½Ñ/Ð½Ð¾ÑÑ)",
				["RateResourceBonus"] = "ÐÐ½Ð¾Ð¶Ð¸ÑÐµÐ»Ñ Ð´Ð¾Ð±ÑÑÐ¸ Ð±Ð¾Ð½ÑÑÐ° Ð¸Ð· ÑÑÐ´Ñ (Ð´ÐµÐ½Ñ/Ð½Ð¾ÑÑ)",
				["RateResourceHQM"] = "ÐÐ½Ð¾Ð¶Ð¸ÑÐµÐ»Ñ Ð´Ð¾Ð±ÑÑÐ¸ ÐÐÐ Ð¸Ð· ÑÑÐ´Ñ (Ð´ÐµÐ½Ñ/Ð½Ð¾ÑÑ)",
				["RatePickup"] = "ÐÐ½Ð¾Ð¶Ð¸ÑÐµÐ»Ñ Ð¿Ð¾Ð´Ð½ÑÑÐ¸Ñ Ð¿ÑÐµÐ´Ð¼ÐµÑÐ¾Ð² (Ð´ÐµÐ½Ñ/Ð½Ð¾ÑÑ)",
				["RateQuarry"] = "ÐÐ½Ð¾Ð¶Ð¸ÑÐµÐ»Ñ Ð´Ð¾Ð±ÑÑÐ¸ ÐºÐ°ÑÑÐµÑÐ¾Ð² (Ð´ÐµÐ½Ñ/Ð½Ð¾ÑÑ)",
				["RateCropGather"] = "ÐÐ½Ð¾Ð¶Ð¸ÑÐµÐ»Ñ ÑÐ±Ð¾ÑÐ° ÑÐ²Ð¾ÐµÐ³Ð¾ ÑÑÐ¾Ð¶Ð°Ñ (Ð´ÐµÐ½Ñ/Ð½Ð¾ÑÑ)",
				["InvalidSyntax"] = "ÐÐµÐ¿ÑÐ°Ð²Ð¸Ð»ÑÐ½ÑÐ¹ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸Ñ. ÐÑÐ¿Ð¾Ð»ÑÐ·ÑÐ¹ÑÐµ: showrate <Ð¸Ð¼Ñ/ID>",
				["NoPlayer"] = "ÐÐ³ÑÐ¾Ðº Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½!",
				["NoPermission"] = "Ð£ Ð²Ð°Ñ Ð½ÐµÐ´Ð¾ÑÑÐ°ÑÐ¾ÑÐ½Ð¾ Ð¿ÑÐ°Ð² Ð´Ð»Ñ Ð²ÑÐ¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ ÑÑÐ¾Ð¹ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ",
				["AdminMode"] = "This is <color=#CCFF00>{0}</color> gather type.\nName: <color=#CCFF00>{1}</color>.\nItem short name: <color=#CCFF00>{2}</color>",
            }, this, "ru");
        }
        #endregion
		#region Hooks
		private void CheckDay()
		{
			var time = TOD_Sky.Instance.Cycle.Hour;
			if(time >= Sunrise && time <= Sunset)
			{
				if(!IsDay && time>=Sunrise && time<=Sunrise + 0.1) MessageToAll("SunriseMessage");
				IsDay = true;	
			}
			else
			{
				if(IsDay && time>=Sunset && time<=Sunset + 0.1) MessageToAll("SunsetMessage");
				IsDay = false;
			}	
		}
		private void CheckPlayers()
		{
			foreach (var player in BasePlayer.activePlayerList) CheckPlayer(player);  
		}
		private void CheckPlayer(BasePlayer player)
		{
			if(player == null) return;
			int index=-1;
			if(Temp.ContainsKey(player.userID)) Temp.Remove(player.userID);
			if(permission.UserHasPermission(player.UserIDString, BypassPerm)) return;
			index = CheckPlayerPerm(player, index);
			if(index >= 0)Temp.Add(player.userID, index);
		}
		private int CheckPlayerPerm(BasePlayer player, int index)
		{
			foreach (var perm in permData.PermissionsGroups)
            {
                if (permission.UserHasPermission(player.UserIDString, perm.Value.PermGroup) && perm.Key>=index) index = perm.Key;          				  
            }
			if(index==-1 && UseZeroIndexForDefaultGroup) index = 0;
			return index;			
		}	
		private void CustomList(Item item, string str)
		{
			float day, night;
			ParseFromString(str, out day, out night);
			GatherMultiplier(item, day, night);
		}
		private void CustomList(ItemAmount item, string str)
		{
			float day, night;
			ParseFromString(str, out day, out night);
			GatherMultiplier(item, day, night);
		}
		private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {			
            BasePlayer player = entity.ToPlayer();
			if(player == null) return;
			if(AdminMode)
				if(player.IsAdmin) SendReply(player, (string.Format(lang.GetMessage("AdminMode", this), "RESOURCE", item.info.displayName.english, item.info.shortname)));	
			int gr = CheckPlayerPerms(player);
			if(gr >= 0)
			{		
				if(permData.PermissionsGroups[gr].ToolMultiplier.ContainsKey(player.GetActiveItem().info.shortname) && player.GetActiveItem() != null) CustomList(item, permData.PermissionsGroups[gr].ToolMultiplier[player.GetActiveItem().info.shortname]);
				else if(permData.PermissionsGroups[gr].CustomRateMultResource.ContainsKey(item.info.shortname)) CustomList(item, permData.PermissionsGroups[gr].CustomRateMultResource[item.info.shortname]);
				else GatherMultiplier(item, permData.PermissionsGroups[gr].DayRateMultResource, permData.PermissionsGroups[gr].NightRateMultResource);					
			}		
        }
		private void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item) 
		{
			int gr = CheckPlayerPerms(player);
			if(gr >= 0)
			{
				if(permData.PermissionsGroups[gr].ToolMultiplier.ContainsKey(player.GetActiveItem().info.shortname) && player.GetActiveItem() != null) CustomList(item, permData.PermissionsGroups[gr].ToolMultiplier[player.GetActiveItem().info.shortname]);			
				else if(item.info.shortname=="hq.metal.ore") GatherMultiplier(item, permData.PermissionsGroups[gr].DayRateMultResourceHQM, permData.PermissionsGroups[gr].NightRateMultResourceHQM);
				else if(item.info.shortname!="hq.metal.ore" && permData.PermissionsGroups[gr].CustomRateMultResourceBonus.ContainsKey(item.info.shortname)) CustomList(item, permData.PermissionsGroups[gr].CustomRateMultResourceBonus[item.info.shortname]);
				else GatherMultiplier(item, permData.PermissionsGroups[gr].DayRateMultResourceBonus, permData.PermissionsGroups[gr].NightRateMultResourceBonus);	
			}		
		}		
		void OnCollectiblePickup(CollectibleEntity collectible, BasePlayer player)
		{
			if(player == null) return;
			int gr = CheckPlayerPerms(player);
			if(gr >= 0) 
			{
				foreach(ItemAmount item in collectible.itemList)
				{			
					if(AdminMode)
						if(player.IsAdmin) SendReply(player, (string.Format(lang.GetMessage("AdminMode", this), "PICKUP", item.itemDef.displayName.english, item.itemDef.shortname)));						
					if(permData.PermissionsGroups[gr].CustomRateMultPickup.ContainsKey(item.itemDef.shortname)) CustomList(item, permData.PermissionsGroups[gr].CustomRateMultPickup[item.itemDef.shortname]);
					else GatherMultiplier(item, permData.PermissionsGroups[gr].DayRateMultPickup, permData.PermissionsGroups[gr].NightRateMultPickup);
				}
			}			
		}
		void OnQuarryGather(MiningQuarry quarry, Item item)
		{
			if(quarry.OwnerID == 0)
			{
				GatherMultiplier(item, DayRateMultStaticQuarry, NightRateMultStaticQuarry);
				return;				
			}
			int gr=-1;
			BasePlayer player = BasePlayer.FindByID(quarry.OwnerID);
            if(player == null)
			{
				BasePlayer player1 = BasePlayer.FindSleeping(quarry.OwnerID);
				if(player1 == null) return;
				gr = CheckPlayerPerm(player1, -1);
			}
			else
			{	
				gr = CheckPlayerPerms(player);
			}
			if(gr >= 0) 
			{
				if(permData.PermissionsGroups[gr].CustomRateMultQuarry.ContainsKey(item.info.shortname)) CustomList(item, permData.PermissionsGroups[gr].CustomRateMultQuarry[item.info.shortname]);
				else GatherMultiplier(item, permData.PermissionsGroups[gr].DayRateMultQuarry, permData.PermissionsGroups[gr].NightRateMultQuarry);				
			}	
		}
		private void OnExcavatorGather(ExcavatorArm excavator, Item item)
		{
			GatherMultiplier(item, DayRateMultExcavator, NightRateMultExcavator);
		}
		void OnGrowableGathered(GrowableEntity plant, Item item, BasePlayer player)
		{
			if(player == null) return;
			if(AdminMode)
				if(player.IsAdmin) SendReply(player, (string.Format(lang.GetMessage("AdminMode", this), "CROP GATHER", item.info.displayName.english, item.info.shortname)));
			int gr = CheckPlayerPerms(player);
			if(gr >= 0) 
			{	
				if(permData.PermissionsGroups[gr].CustomRateMultCropGather.ContainsKey(item.info.shortname)) CustomList(item, permData.PermissionsGroups[gr].CustomRateMultCropGather[item.info.shortname]);
				else GatherMultiplier(item, permData.PermissionsGroups[gr].DayRateMultCropGather, permData.PermissionsGroups[gr].NightRateMultCropGather);
			}	
		}
		private int CheckPlayerPerms(BasePlayer player)
        {			
           	if(Temp.ContainsKey(player.userID))
			{ 
				return Temp[player.userID];
			}        
			return -1;	
        }
		private void GatherMultiplier(Item item, float daymult, float nightmult) 
        {			
			if(IsDay) item.amount = (int)(item.amount * daymult); 
			else item.amount = (int)(item.amount * nightmult); 
        }
		private void GatherMultiplier(ItemAmount item, float daymult, float nightmult) 
        {			
			if(IsDay) item.amount = (int)(item.amount * daymult); 
			else item.amount = (int)(item.amount * nightmult); 
        }
		void OnTick()
		{
			CheckDay();	
		}
		void OnUserPermissionGranted(string id, string permis)
		{
			OnChangePermsUser(id, permis);
		}
		void OnUserPermissionRevoked(string id, string permis)
		{
			OnChangePermsUser(id, permis);
		}
		void OnUserGroupAdded(string id, string name)
		{
			OnChangeUserGroup(id);
		}
		void OnUserGroupRemoved(string id, string name)
		{			
			OnChangeUserGroup(id);
		}
		void OnGroupPermissionGranted(string name, string permis)
		{
			OnChangePermsGroup(permis);
		}
		void OnGroupPermissionRevoked(string name, string permis)
		{
			OnChangePermsGroup(permis);
		}
		private void OnChangePermsGroup(string permis)
		{
			if(permis == BypassPerm)
			{
				CheckPlayers();
				return;	
			}	
			foreach(var perm in permData.PermissionsGroups)
			{
                if(perm.Value.PermGroup==permis) CheckPlayers();					
			}
		}	
		private void OnChangePermsUser(string id, string permis)
		{
			var player = BasePlayer.Find(id);
			if(player == null) return;
			if(permis == BypassPerm)
			{
				CheckPlayer(player);
				return;	
			}	
			foreach(var perm in permData.PermissionsGroups)
			{
                if(perm.Value.PermGroup==permis) CheckPlayer(player);					
			}
		}
		private void OnChangeUserGroup(string id)
		{
			var player = BasePlayer.Find(id);
			if(player == null) return;
			CheckPlayer(player);
		}
		#endregion
		#region Commands
        [ChatCommand("showrate")]
        void ShowRate(BasePlayer player, string command, string[] args)
        {
			if (!player.IsAdmin && !permission.UserHasPermission(player.userID.ToString(), PLPerm)) 
			{
				SendReply(player, lang.GetMessage("NoPermission", this, player.UserIDString));
                return;
			}
			int gr = CheckPlayerPerms(player);
			if(gr >= 0)	SendReply(player, lang.GetMessage("GatherRateInfo", this, player.UserIDString) + GatherInfo(player, gr));	
			else SendReply(player, lang.GetMessage("NoGatherRate", this, player.UserIDString)); 
		}
		[ConsoleCommand("showrate")]
        private void conShowRate(ConsoleSystem.Arg arg)
		{
			BasePlayer player0 = arg.Player();
			if (player0 is BasePlayer && arg.Connection != null && (arg.Connection.authLevel < 2 && !permission.UserHasPermission(player0.userID.ToString(), AdmPerm))) 
			{
				SendReply(arg, lang.GetMessage("NoPermission", this));
                return;
			}
			if (arg.Args == null || arg.Args.Length <= 0)
			{
                SendReply(arg, lang.GetMessage("InvalidSyntax", this));
                return;
            }
			BasePlayer player = BasePlayer.Find(arg.Args[0]) ?? BasePlayer.FindSleeping(arg.Args[0]);
			if(player == null)
			{
				SendReply(arg, (string.Format(lang.GetMessage("NoPlayer", this))));
				return;
			}	
			int gr = CheckPlayerPerm(player, -1);
			if(gr >= 0)	SendReply(arg, string.Format(lang.GetMessage("GatherRateInfoPlayer", this), player.displayName) + GatherInfo(player, gr));
			else SendReply(arg, string.Format(lang.GetMessage("NoGatherRatePlayer", this), player.displayName));               				          			
		}
		#endregion
		#region Helpers
		T GetConfig<T>(string name, T defaultValue) => Config[name] == null ? defaultValue : (T) Convert.ChangeType(Config[name], typeof(T)); 
		void MessageToAll(string key)
        {		
			foreach (var player in BasePlayer.activePlayerList)
			{
				if(permission.UserHasPermission(player.UserIDString, BypassPerm)) return;
				if(UseMessageBroadcast) SendReply(player, lang.GetMessage(key, this, player.UserIDString));
				if(GUIAnnouncements && UseGUIAnnouncements) GUIAnnouncements?.Call("CreateAnnouncement", lang.GetMessage(key, this, player.UserIDString), BannerColor, TextColor, player);
			}
        }
		private string GatherInfo(BasePlayer player, int gr)
		{
			string message = "";
			{
				message= string.Format("\n{0}: {6}/{12}\n{1}: {7}/{13}\n{2}: {8}/{14}\n{3}: {9}/{15}\n{4}: {10}/{16}\n{5}: {11}/{17}\n", 
					lang.GetMessage("RateResource", this, player.UserIDString),
					lang.GetMessage("RateResourceBonus", this, player.UserIDString),
					lang.GetMessage("RateResourceHQM", this, player.UserIDString),
					lang.GetMessage("RatePickup", this, player.UserIDString),
					lang.GetMessage("RateQuarry", this, player.UserIDString),
					lang.GetMessage("RateCropGather", this, player.UserIDString),	
					permData.PermissionsGroups[gr].DayRateMultResource,
					permData.PermissionsGroups[gr].DayRateMultResourceBonus,
					permData.PermissionsGroups[gr].DayRateMultResourceHQM,
					permData.PermissionsGroups[gr].DayRateMultPickup,
					permData.PermissionsGroups[gr].DayRateMultQuarry,
					permData.PermissionsGroups[gr].DayRateMultCropGather,				
					permData.PermissionsGroups[gr].NightRateMultResource,
					permData.PermissionsGroups[gr].NightRateMultResourceBonus,
					permData.PermissionsGroups[gr].NightRateMultResourceHQM,
					permData.PermissionsGroups[gr].NightRateMultPickup,
					permData.PermissionsGroups[gr].NightRateMultQuarry,
					permData.PermissionsGroups[gr].NightRateMultCropGather
					);
			}
			return message;	
		}	
		private void ParseFromString(string str, out float day, out float night)
		{
			string[] parts = str.Split('/');
			day = float.Parse(parts[0]);
			night = float.Parse(parts[1]);
		}
		#endregion
    }
}


// --- End of file: GatherControl.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/general-item-modifier ---
// --- Original File Path: G/GeneralItemModifier/GeneralItemModifier.cs ---

ï»¿using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("General Item Modifier", "Rick", "1.0.1")]
    [Description("Modifying global item parameters such as display name, icon")]
    public class GeneralItemModifier : RustPlugin
    {
        #region Oxide Hooks

        private void OnServerInitialized()
        {
            foreach (var definition in ItemManager.itemList)
            {
                var entry = config.items.FirstOrDefault(x => x.shortname == definition.shortname);
                if (entry != null)
                {
                    var mods = definition.itemMods.Where(x => !(x is ItemModStatsChanger));
                    var array = mods.Concat(new[] { ItemModStatsChanger.New(entry) }).ToArray();
                    definition.itemMods = array;
                }
            }
        }

        private void Unload()
        {
            foreach (var definition in ItemManager.itemList)
            {
                var entry = config.items.FirstOrDefault(x => x.shortname == definition.shortname);
                if (entry != null)
                {
                    var mods = definition.itemMods.Where(x => !(x is ItemModStatsChanger));
                    var array = mods.ToArray();
                    definition.itemMods = array;
                }
            }
        }

        #endregion

        #region Core

        private class ItemModStatsChanger : ItemMod
        {
            public static ItemModStatsChanger New(ItemEntry _entry)
            {
                var obj = new GameObject().AddComponent<ItemModStatsChanger>();
                obj.entry = _entry;
                return obj;
            }

            private ItemEntry entry;

            public override void OnItemCreated(Item item)
            {
                if (item.name == null && item.skin == 0)
                {
                    item.name = entry.displayName;
                    item.skin = entry.skinId;
                    item.MarkDirty();

                    var e = item.GetHeldEntity();

                    if (e.IsValid()) e.skinID = entry.skinId;
                }
            }
        }

        #endregion

        #region

        private static ConfigData config = new ConfigData();

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Values")]
            public ItemEntry[] items = new[]
            {
                new ItemEntry
                {
                    shortname = "scientistsuit_heavy",
                    skinId = 0,
                    displayName = "!! HEAVY SUIT !!"
                },
                new ItemEntry
                {
                    shortname = "rifle.ak",
                    skinId = 0,
                    displayName = "TOP GU"
                }
            };
        }

        private class ItemEntry
        {
            [JsonProperty(PropertyName = "Shortname")]
            public string shortname;

            [JsonProperty(PropertyName = "Display Name")]
            public string displayName;

            [JsonProperty(PropertyName = "New Icon (Skin)")]
            public ulong skinId;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                for (var i = 0; i < 3; i++)
                {
                    PrintError("Configuration file is corrupted!");
                }

                LoadDefaultConfig();
                return;
            }

            ValidateConfig();
            SaveConfig();
        }

        private void ValidateConfig()
        {
            if (Interface.Oxide.CallHook("OnConfigValidate") != null)
            {
                PrintWarning("Using default configuration...");
                config = new ConfigData();
            }
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: GeneralItemModifier.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/gesture-wheel ---
// --- Original File Path: G/GestureWheel/GestureWheel.cs ---

ï»¿// Requires: ImageLibrary

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System.Globalization;
using Oxide.Core;
using UnityEngine;
using Color = UnityEngine.Color;

namespace Oxide.Plugins
{
    [Info("Gesture Wheel", "Tricky & Mevent", "0.1.3")]
    [Description("Convenient wheel that provides the ability to use gestures")]

    public class GestureWheel : RustPlugin
    {
        #region Plugin References
        [PluginReference]
        private Plugin ImageLibrary;
        #endregion

        #region Config
        Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Command")]
            public string Command = "gestures";

            [JsonProperty(PropertyName = "Use Permission")]
            public bool UsePermission = false;

            [JsonProperty(PropertyName = "Button Radius")]
            public int ButtonRadius = 100;

            [JsonProperty(PropertyName = "Close Button Color")]
            public string CloseButtonColor = "#FFB6B3DE";

            [JsonProperty(PropertyName = "Gesture Button Color")]
            public string GestureButtonColor = "#FF6666DE";

            [JsonProperty(PropertyName = "Gesture Button Size")]
            public int GestureButtonSize = 50;

            [JsonProperty(PropertyName = "Gestures", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<Gesture> Gestures = new List<Gesture>
            {
                new Gesture
                {
                    Name = "wave",
                    Image = "https://i.imgur.com/pB3iZer.png"
                },

                new Gesture
                {
                    Name = "victory",
                    Image = "https://i.imgur.com/PLbSgED.png"
                },

                new Gesture
                {
                    Name = "shrug",
                    Image = "https://i.imgur.com/A3hHcgV.png"
                },

                new Gesture
                {
                    Name = "thumbsup",
                    Image = "https://i.imgur.com/yWuhCMu.png"
                },

                new Gesture
                {
                    Name = "chicken",
                    Image = "https://i.imgur.com/Qxhjf6N.png"
                },

                new Gesture
                {
                    Name = "hurry",
                    Image = "https://i.imgur.com/vVKVeha.png"
                },

                new Gesture
                {
                    Name = "whoa",
                    Image = "https://i.imgur.com/AFeGOrK.png"
                }
            };

            public class Gesture
            {
                [JsonProperty(PropertyName = "Gesture Name")]
                public string Name;

                [JsonProperty(PropertyName = "Image")]
                public string Image;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) throw new Exception();
            }
            catch
            {
                Config.WriteObject(config, false, $"{Interface.Oxide.ConfigDirectory}/{Name}.jsonError");
                PrintError("The configuration file contains an error and has been replaced with a default config.\n" +
                           "The error configuration file was saved in the .jsonError extension");
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Stored Data
        private readonly string Layer = "UI_Emotions";
        private readonly string Perm = "gestures.use";
        List<ulong> Players = new List<ulong>();
        #endregion

        #region Oxide Hooks
        private void Init()
        {
            permission.RegisterPermission(Perm, this);
            cmd.AddChatCommand(config.Command, this, nameof(GesturesCommand));
            cmd.AddConsoleCommand("gestures.close", this, nameof(GesturesCloseCommand));
        }

        private void OnServerInitialized()
        {
            if (ImageLibrary == null)
            {
                PrintError("Image Library is not loaded, get it at https://umod.org/plugins/image-library");
                return;
            }

            ImageLibrary.Call("AddImage", "https://i.imgur.com/D40FoBT.png", "CloseImage");
            ImageLibrary.Call("AddImage", "https://i.imgur.com/2fjUdcJ.png", "EmotionImage");

            for (int i = 0; i < config.Gestures.Count; i++)
                ImageLibrary.Call("AddImage", config.Gestures[i].Image, config.Gestures[i].Name);
        }
        #endregion

        #region Commands
        private void GesturesCommand(BasePlayer player, string command, string[] args)
        {
            if (config.UsePermission && !player.IPlayer.HasPermission(Perm))
                return;

            if (!Players.Contains(player.userID))
            {
                UI_DrawInterface(player);
                Players.Add(player.userID);
            }
            else
            {
                CuiHelper.DestroyUi(player, Layer);
                Players.Remove(player.userID);
            }
        }

        private void GesturesCloseCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null)
                return;

            Players.Remove(player.userID);
        }
        #endregion

        #region User Interface
        private void UI_DrawInterface(BasePlayer player)
        {
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5" }
            }, "Overlay", Layer);

            LoadImage(ref container, Layer, Layer + ".Img", "CloseImage", oMin: "-30 -30", oMax: "30 30", color: HexToRustFormat(config.CloseButtonColor));

            container.Add(new CuiButton
            {
                Button = { Command = "gestures.close", Color = "0 0 0 0", Close = Layer },
                Text = { Text = "" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
            }, Layer + ".Img");

            for (int i = 0; i < config.Gestures.Count; i++)
            {
                var emotion = config.Gestures[i];
                int r = config.Gestures.Count * 10 + config.ButtonRadius;
                var c = (double) config.Gestures.Count / 2;
                var pos = i / c * Math.PI;
                var x = r * Math.Sin(pos);
                var y = r * Math.Cos(pos);

                LoadImage(ref container, Layer, $"EmoButton.{i}", "EmotionImage", aMin: $"{x - config.GestureButtonSize} {y - config.GestureButtonSize}", aMax: $"{x + config.GestureButtonSize} {y + config.GestureButtonSize}", color: HexToRustFormat(config.GestureButtonColor));
                LoadImage(ref container, $"EmoButton.{i}", $"EmoButton.{i}.Img", emotion.Name, aMin: "0.5 0.5", aMax: "0.5 0.5", oMin: "-30 -30", oMax: "30 30");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Color = "0 0 0 0", Command = $"gesture {emotion.Name}" },
                    Text = { Text = "" }
                }, $"EmoButton.{i}");
            }

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
        }

        public void LoadImage(ref CuiElementContainer container, string parent, string name, string image, string aMin = "0 0", string aMax = "1 1", string oMin = "0 0", string oMax = "0 0", string color = "1 1 1 1")
        {
            container.Add(new CuiElement
            {
                Name = name,
                Parent = parent,
                Components =
                {
                    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", image), Color = color },
                    new CuiRectTransformComponent { AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax },
                }
            });
        }
        #endregion

        #region Helpers
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');
            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);

            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
            Color color = new Color32(r, g, b, a);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }
        #endregion
    }
}


// --- End of file: GestureWheel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/gun-game ---
// --- Original File Path: G/GunGame/GunGame.cs ---

ï»¿// Requires: EventManager
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Plugins.EventManagerEx;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("GunGame", "k1lly0u", "0.5.1"), Description("GunGame event mode for EventManager")]
    class GunGame : RustPlugin, IEventPlugin
    {
        private StoredData storedData;
        private DynamicConfigFile data;

        private string[] _validWeapons;

        private static Func<string, StoredData.WeaponSet> GetWeaponSet;

        #region Oxide Hooks
        private void OnServerInitialized()
        {
            data = Interface.Oxide.DataFileSystem.GetFile("EventManager/gungame_weaponsets");
            LoadData();

            FindValidWeapons();

            EventManager.RegisterEvent(Title, this);

            GetMessage = Message;
            GetWeaponSet = storedData.GetWeaponSet;
        }

        protected override void LoadDefaultMessages() => lang.RegisterMessages(Messages, this);

        private void Unload()
        {
            if (!EventManager.IsUnloading)
                EventManager.UnregisterEvent(Title);

            Configuration = null;
        }
        #endregion

        #region Functions
        private void FindValidWeapons()
        {
            List<string> list = Facepunch.Pool.Get<List<string>>();

            foreach (ItemDefinition itemDefinition in ItemManager.itemList)
            {
                if (itemDefinition.category is ItemCategory.Weapon or ItemCategory.Tool)
                {
                    if (!itemDefinition.isHoldable)
                        continue;

                    AttackEntity attackEntity = itemDefinition.GetComponent<ItemModEntity>()?.entityPrefab?.Get()?.GetComponent<AttackEntity>();
                    if (attackEntity != null && attackEntity is BaseMelee or BaseProjectile)
                        list.Add(itemDefinition.shortname);
                }
            }

            list.Sort();

            _validWeapons = list.ToArray();

            Facepunch.Pool.FreeUnmanaged(ref list);
        }

        private string[] GetGunGameWeapons() => _validWeapons;

        private string[] GetGunGameWeaponSets() => storedData._weaponSets.Keys.ToArray();
        #endregion

        #region Event Checks
        public bool InitializeEvent(EventManager.EventConfig config) => EventManager.InitializeEvent<GunGameEvent>(this, config);

        public bool CanUseClassSelector => true;

        public bool RequireTimeLimit => true;

        public bool RequireScoreLimit => false;

        public bool UseScoreLimit => false;

        public bool UseTimeLimit => true;

        public bool IsTeamEvent => false;

        public void FormatScoreEntry(EventManager.ScoreEntry scoreEntry, ulong langUserId, out string score1, out string score2)
        {
            score1 = string.Format(Message("Score.Rank", langUserId), scoreEntry.value1);
            score2 = string.Format(Message("Score.Kills", langUserId), scoreEntry.value2);
        }

        public List<EventManager.EventParameter> AdditionalParameters { get; } = new List<EventManager.EventParameter>
        {
            new EventManager.EventParameter
            {
                DataType = "string",
                Field = "weaponSet",
                Input = EventManager.EventParameter.InputType.Selector,
                SelectMultiple = false,
                SelectorHook = "GetGunGameWeaponSets",
                IsRequired = true,
                Name = "Weapon Set"
            },
            new EventManager.EventParameter
            {
                DataType = "string",
                Field = "downgradeWeapon",
                Input = EventManager.EventParameter.InputType.Selector,
                SelectMultiple = false,
                SelectorHook = "GetGunGameWeapons",
                IsRequired = false,
                Name = "Downgrade Weapon",
                DefaultValue = "machete"
            }
        };

        public string ParameterIsValid(string fieldName, object value)
        {
            switch (fieldName)
            {
                case "weaponSet":
                    {
                        StoredData.WeaponSet weaponSet;
                        if (!storedData.TryFindWeaponSet((string)value, out weaponSet))
                            return "Unable to find a weapon set with the specified name";

                        return null;
                    }
                case "downgradeWeapon":
                    {
                        if (ItemManager.FindItemDefinition((string)value) == null)
                            return "Unable to find a weapon with the specified shortname";

                        return null;
                    }
                default:
                    return null;
            }
        }
        #endregion

        #region Event Classes
        public class GunGameEvent : EventManager.BaseEventGame
        {
            private StoredData.WeaponSet weaponSet;

            private ItemDefinition downgradeWeapon = null;

            public EventManager.BaseEventPlayer winner;

            internal override void InitializeEvent(IEventPlugin plugin, EventManager.EventConfig config)
            {
                string downgradeShortname = config.GetParameter<string>("downgradeWeapon");

                if (!string.IsNullOrEmpty(downgradeShortname))
                    downgradeWeapon = ItemManager.FindItemDefinition(downgradeShortname);

                weaponSet = GetWeaponSet(config.GetParameter<string>("weaponSet"));
                
                base.InitializeEvent(plugin, config);
            }

            internal override void PrestartEvent()
            {
                CloseEvent();
                base.PrestartEvent();
            }

            protected override EventManager.BaseEventPlayer AddPlayerComponent(BasePlayer player) => player.gameObject.AddComponent<GunGamePlayer>();
            
            protected override void OnKitGiven(EventManager.BaseEventPlayer eventPlayer)
            {
                (eventPlayer as GunGamePlayer).GiveRankWeapon(weaponSet.CreateItem((eventPlayer as GunGamePlayer).Rank));
               
                if (downgradeWeapon != null && eventPlayer.Player.inventory.GetAmount(downgradeWeapon.itemid) == 0)                
                    eventPlayer.Player.GiveItem(ItemManager.Create(downgradeWeapon), BaseEntity.GiveItemReason.PickedUp);                                
            }

            internal override void OnEventPlayerDeath(EventManager.BaseEventPlayer victim, EventManager.BaseEventPlayer attacker = null, HitInfo hitInfo = null)
            {
                if (victim == null)
                    return;

                victim.OnPlayerDeath(attacker, Configuration.RespawnTime);

                if (attacker != null && victim != attacker)
                {
                    if (Configuration.ResetHealthOnKill)
                    {
                        attacker.Player.health = attacker.Player.MaxHealth();
                        attacker.Player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    }

                    attacker.OnKilledPlayer(hitInfo);

                    string attackersWeapon = GetWeaponShortname(hitInfo);

                    if (!string.IsNullOrEmpty(attackersWeapon))
                    {
                        if (KilledByRankedWeapon(attacker as GunGamePlayer, attackersWeapon))
                        {
                            (attacker as GunGamePlayer).Rank += 1;

                            if ((attacker as GunGamePlayer).Rank > weaponSet.Count)
                            {
                                winner = attacker;
                                InvokeHandler.Invoke(this, EndEvent, 0.1f);
                                return;
                            }
                            else
                            {
                                (attacker as GunGamePlayer).RemoveRankWeapon();
                                (attacker as GunGamePlayer).GiveRankWeapon(weaponSet.CreateItem((attacker as GunGamePlayer).Rank));
                            }
                        }
                        else if (KilledByDowngradeWeapon(attackersWeapon))
                        {
                            (victim as GunGamePlayer).Rank = Mathf.Clamp((victim as GunGamePlayer).Rank - 1, 1, weaponSet.Count);
                        }
                    }
                }

                UpdateScoreboard();
                base.OnEventPlayerDeath(victim, attacker);
            }

            protected override bool CanDropBackpack() => false;

            private string GetWeaponShortname(HitInfo hitInfo)
            {
                Item item = hitInfo?.Weapon?.GetItem();
                if (item != null)
                    return item.info.shortname;

                BaseEntity weaponPrefab = hitInfo.WeaponPrefab;
                if (weaponPrefab != null)
                {
                    string shortname = weaponPrefab.name.Replace(".prefab", string.Empty)
                                                        .Replace(".deployed", string.Empty)
                                                        .Replace(".entity", string.Empty)
                                                        .Replace("_", ".");

                    if (shortname.StartsWith("rocket."))
                        shortname = "rocket.launcher";
                    else if (shortname.StartsWith("40mm."))
                        shortname = "multiplegrenadelauncher";
                    
                    return shortname;
                }

                return string.Empty;
            }

            private bool KilledByRankedWeapon(GunGamePlayer attacker, string weapon) => attacker.RankWeapon?.info.shortname.Equals(weapon) ?? false;

            private bool KilledByDowngradeWeapon(string weapon) => downgradeWeapon?.shortname.Equals(weapon) ?? false;

            protected override void GetWinningPlayers(ref List<EventManager.BaseEventPlayer> winners)
            {
                if (winner == null)
                {
                    if (eventPlayers.Count > 0)
                    {
                        int rank = 0;
                        int kills = 0;

                        for (int i = 0; i < eventPlayers.Count; i++)
                        {
                            GunGamePlayer eventPlayer = eventPlayers[i] as GunGamePlayer;
                            if (eventPlayer == null)
                                continue;

                            if (eventPlayer.Rank > rank)
                            {
                                winner = eventPlayer;
                                kills = eventPlayer.Kills;
                                rank = eventPlayer.Rank;
                            }
                            else if (eventPlayer.Rank == rank)
                            {
                                if (eventPlayer.Kills > rank)
                                {
                                    winner = eventPlayer;
                                    kills = eventPlayer.Kills;
                                    rank = eventPlayer.Rank;
                                }
                            }
                        }
                    }
                }

                if (winner != null)
                    winners.Add(winner);
            }

            #region Scoreboards
            protected override void BuildScoreboard()
            {
                scoreContainer = EMInterface.CreateScoreboardBase(this);

                int index = -1;

                EMInterface.CreatePanelEntry(scoreContainer, string.Format(GetMessage("Score.Limit", 0UL), weaponSet.Count), index += 1);

                EMInterface.CreateScoreEntry(scoreContainer, string.Empty, string.Empty, "R", index += 1);

                for (int i = 0; i < Mathf.Min(scoreData.Count, 15); i++)
                {
                    EventManager.ScoreEntry score = scoreData[i];
                    EMInterface.CreateScoreEntry(scoreContainer, score.displayName, string.Empty, ((int)score.value1).ToString(), i + index + 1);
                }
            }

            protected override float GetFirstScoreValue(EventManager.BaseEventPlayer eventPlayer) => (eventPlayer as GunGamePlayer).Rank;

            protected override float GetSecondScoreValue(EventManager.BaseEventPlayer eventPlayer) => eventPlayer.Kills;

            protected override void SortScores(ref List<EventManager.ScoreEntry> list)
            {
                list.Sort(delegate (EventManager.ScoreEntry a, EventManager.ScoreEntry b)
                {
                    int primaryScore = a.value1.CompareTo(b.value1);

                    if (primaryScore == 0)
                        return a.value2.CompareTo(b.value2);

                    return primaryScore;
                });
            }
            #endregion

            internal override void GetAdditionalEventDetails(ref List<KeyValuePair<string, object>> list, ulong playerId)
            {
                list.Add(new KeyValuePair<string, object>(GetMessage("UI.RankLimit", playerId), weaponSet.Count));

                if (downgradeWeapon != null)
                    list.Add(new KeyValuePair<string, object>(GetMessage("UI.DowngradeWeapon", playerId), downgradeWeapon.displayName.english));
            }
        }

        private class GunGamePlayer : EventManager.BaseEventPlayer
        {
            public int Rank { get; set; } = 1;

            public Item RankWeapon { get; private set; }

            public void RemoveRankWeapon()
            {
                if (RankWeapon != null)
                {
                    RankWeapon.RemoveFromContainer();
                    RankWeapon.Remove();
                }
            }

            public void GiveRankWeapon(Item item)
            {
                RankWeapon = item;
                Player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);

                BaseProjectile baseProjectile = item.GetHeldEntity() as BaseProjectile;
                if (baseProjectile != null)
                {
                    Item ammo = ItemManager.Create(baseProjectile.primaryMagazine.ammoType, baseProjectile.primaryMagazine.capacity * 5);
                    Player.GiveItem(ammo);
                }

                FlameThrower flameThrower = item.GetHeldEntity() as FlameThrower;
                if (flameThrower != null)
                {
                    Item ammo = ItemManager.CreateByName("lowgradefuel", 1500);
                    Player.GiveItem(ammo);
                }
            }
        }
        #endregion

        #region Weapon Set Creation
        private Hash<ulong, StoredData.WeaponSet> setCreator = new Hash<ulong, StoredData.WeaponSet>();

        [ChatCommand("ggset")]
        private void cmdGunGameSet(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin && !permission.UserHasPermission(player.UserIDString, EventManager.ADMIN_PERMISSION))
            {
                player.ChatMessage("You do not have permission to use this command");
                return;
            }

            setCreator.TryGetValue(player.userID, out StoredData.WeaponSet weaponSet);

            if (args.Length == 0)
            {
                player.ChatMessage("/ggset new - Start creating a new weapon set");
                player.ChatMessage("/ggset edit <name> - Edits the specified weapon set");
                player.ChatMessage("/ggset delete <name> - Deletes the specified weapon set");
                player.ChatMessage("/ggset list - Lists all available weapon sets");

                if (weaponSet != null)
                {
                    player.ChatMessage("/ggset add <opt:rank> - Adds the weapon you are holding to the weapon set. If you specify a rank the weapon will be inserted at that position");
                    player.ChatMessage("/ggset remove <number> - Removes the specified rank from the weapon set");
                    player.ChatMessage("/ggset ranks - List the weapons and ranks in the weapon set");
                    player.ChatMessage("/ggset save <name> - Saves the weapon set you are currently editing");
                }
                return;
            }

            switch (args[0].ToLower())
            {
                case "new":
                    setCreator[player.userID] = new StoredData.WeaponSet();
                    player.ChatMessage("You are now creating a new weapon set");
                    return;

                case "edit":
                    if (args.Length < 2)
                    {
                        player.ChatMessage("You must enter the name of a weapon set to edit");
                        return;
                    }

                    if (!storedData.TryFindWeaponSet(args[1], out weaponSet))
                    {
                        player.ChatMessage("Unable to find a weapon set with the specified name");
                        return;
                    }

                    setCreator[player.userID] = weaponSet;
                    player.ChatMessage($"You are now editing the weapon set {args[1]}");
                    return;

                case "delete":
                    if (args.Length < 2)
                    {
                        player.ChatMessage("You must enter the name of a weapon set to delete");
                        return;
                    }

                    if (!storedData.TryFindWeaponSet(args[1], out weaponSet))
                    {
                        player.ChatMessage("Unable to find a weapon set with the specified name");
                        return;
                    }

                    storedData._weaponSets.Remove(args[1]);
                    SaveData();
                    player.ChatMessage($"You have deleted the weapon set {args[1]}");
                    return;

                case "list":
                    player.ChatMessage($"Available weapon sets;\n{GetGunGameWeaponSets().ToSentence()}");
                    return;

                case "add":
                    if (weaponSet == null)
                    {
                        player.ChatMessage("You are not currently editing a weapon set");
                        return;
                    }

                    Item item = player.GetActiveItem();
                    if (item == null)
                    {
                        player.ChatMessage("You must hold a weapon in your hands to add it to the weapon set");
                        return;
                    }

                    if (!_validWeapons.Contains(item.info.shortname))
                    {
                        player.ChatMessage("This item is not an allowed weapon");
                        return;
                    }

                    int index = -1;
                    if (args.Length == 2 && int.TryParse(args[1], out index))
                        index = Mathf.Clamp(index, 1, weaponSet.Count);

                    int rank = weaponSet.AddItem(item, index);
                    player.ChatMessage($"This weapon has been added at rank {rank}");
                    return;

                case "remove":
                    if (weaponSet == null)
                    {
                        player.ChatMessage("You are not currently editing a weapon set");
                        return;
                    }

                    if (args.Length != 2 || !int.TryParse(args[1], out int delete))
                    {
                        player.ChatMessage("You must enter the rank number to remove a item");
                        return;
                    }

                    if (delete < 1 || delete > weaponSet.Count)
                    {
                        player.ChatMessage("The rank you entered is out of range");
                        return;
                    }

                    weaponSet.weapons.RemoveAt(delete - 1);
                    player.ChatMessage($"You have removed the weapon at rank {delete}");
                    return;
                case "ranks":
                    if (weaponSet == null)
                    {
                        player.ChatMessage("You are not currently editing a weapon set");
                        return;
                    }

                    string str = string.Empty;
                    for (int i = 0; i < weaponSet.Count; i++)
                    {
                        str += $"Rank {i + 1} : {ItemManager.itemDictionary[weaponSet.weapons[i].itemid].displayName.english}\n";
                    }

                    player.ChatMessage(str);
                    return;
                case "save":
                    if (weaponSet == null)
                    {
                        player.ChatMessage("You are not currently editing a weapon set");
                        return;
                    }

                    if (weaponSet.Count < 1)
                    {
                        player.ChatMessage("You have not added any weapons to this weapon set");
                        return;
                    }

                    if (args.Length != 2)
                    {
                        player.ChatMessage("You must enter a name for this weapon set");
                        return;
                    }

                    storedData._weaponSets[args[1]] = weaponSet;
                    SaveData();
                    setCreator.Remove(player.userID);
                    player.ChatMessage($"You have saved this weapon set as {args[1]}");
                    return;

                default:
                    break;
            }
        }
        #endregion

        #region Config        
        private static ConfigData Configuration;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Respawn time (seconds)")]
            public int RespawnTime { get; set; }

            [JsonProperty(PropertyName = "Reset heath when killing an enemy")]
            public bool ResetHealthOnKill { get; set; }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Configuration = Config.ReadObject<ConfigData>();

            if (Configuration.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(Configuration, true);
        }

        protected override void LoadDefaultConfig() => Configuration = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                ResetHealthOnKill = false,
                RespawnTime = 5,
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(Configuration, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            Configuration.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        #region Data Management
        private void SaveData() => data.WriteObject(storedData);

        private void LoadData()
        {
            try
            {
                storedData = data.ReadObject<StoredData>();
            }
            catch
            {
                storedData = new StoredData();
            }
        }

        private class StoredData
        {
            public Hash<string, WeaponSet> _weaponSets = new Hash<string, WeaponSet>();

            public bool TryFindWeaponSet(string name, out WeaponSet weaponSet) => _weaponSets.TryGetValue(name, out weaponSet);

            public WeaponSet GetWeaponSet(string name) => _weaponSets[name];
                       

            public class WeaponSet
            {
                public List<EventManager.ItemData> weapons = new List<EventManager.ItemData>();

                public int Count => weapons.Count;

                public Item CreateItem(int rank) => EventManager.CreateItem(weapons[rank - 1]);

                public int AddItem(Item item, int index)
                {
                    EventManager.ItemData itemData = EventManager.SerializeItem(item);
                    if (index < 0)                    
                        weapons.Add(itemData);                    
                    else weapons.Insert(Mathf.Min(index - 1, weapons.Count), itemData);

                    return weapons.IndexOf(itemData) + 1;
                }
            }
        }
        #endregion

        #region Localization
        public string Message(string key, ulong playerId = 0U) => lang.GetMessage(key, this, playerId != 0U ? playerId.ToString() : null);

        private static Func<string, ulong, string> GetMessage;

        private readonly Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["Score.Rank"] = "Rank: {0}",
            ["Score.Kills"] = "Kills: {0}",            
            ["Score.Name"] = "Rank",
            ["Score.Limit"] = "Rank Limit : {0}",
            ["UI.RankLimit"] = "Rank Limit",
            ["UI.DowngradeWeapon"] = "Downgrade Weapon"
        };
        #endregion
    }
}


// --- End of file: GunGame.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/godmode-indicator ---
// --- Original File Path: G/GodmodeIndicator/GodmodeIndicator.cs ---

ï»¿// Requires: ImageLibrary

// #define UNITY_ASSERTIONS

using System;
using System.Collections.Generic;
using System.ComponentModel;

using Oxide.Game.Rust.Cui;
using Newtonsoft.Json;

using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;

using static Oxide.Game.Rust.Cui.CuiHelper;

namespace Oxide.Plugins
{
    [Info("Godmode Indicator", "2CHEVSKII", "2.1.3")]
    [Description("Displays an indicator on screen if a player is in godmode")]
    class GodmodeIndicator : CovalencePlugin
    {
        #region Configuration and fields

        const string UI_MAIN_PANEL_NAME = "godmodeindicator.ui::main_panel";

        static GodmodeIndicator Instance;

        [PluginReference]
        Plugin ImageLibrary;

        [PluginReference]
        Plugin Godmode;
        string uiCached;

        Dictionary<string, GodmodeUi> idToComponent;

        PluginSettings settings;

        class PluginSettings
        {
            [JsonProperty("UI X position")]
            public float UiX { get; set; }

            [JsonProperty("UI Y position")]
            public float UiY { get; set; }

            [JsonProperty("UI URL")]
            public string UiUrl { get; set; }

            [JsonProperty("UI Color")]
            public string UiColor { get; set; }

            [DefaultValue(1.0f)]
            [JsonProperty("UI Scale", DefaultValueHandling = DefaultValueHandling.Populate)]
            public float UiScale { get; set; }
        }

        PluginSettings GetDefaultSettings() =>
            new PluginSettings
            {
                UiX = 0.05f,
                UiY = 0.85f,
                UiColor = "1 1 1 1",
                UiUrl = "https://i.imgur.com/SF6lN2N.png",
                UiScale = 1.0f
            };

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            settings = GetDefaultSettings();
            SaveConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                settings = Config.ReadObject<PluginSettings>();
                if (settings == null)
                    throw new JsonException("Unable to load configuration file...");
                SaveConfig();
            }
            catch
            {
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(settings, true);

        #endregion

        #region Oxide hooks

        void Init()
        {
            Instance = this;
            idToComponent = new Dictionary<string, GodmodeUi>();
        }

        void OnServerInitialized()
        {
            BuildUi();
            foreach (var player in players.Connected)
            {
                OnUserConnected(player);
            }
        }

        void OnUserConnected(IPlayer user)
        {
            var player = (BasePlayer)user.Object;
            player.gameObject.AddComponent<GodmodeUi>();
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            Debug.Assert(idToComponent.ContainsKey(player.UserIDString));

            if (idToComponent.ContainsKey(player.UserIDString)) // Ok we check it here now to get rid of errors, but I STILL DONT HAVE ANY FUCKING CLUE why they are possible in the first place
            {
                idToComponent[player.UserIDString].OnSleepEnded();
            }
        }

        void OnUserDisconnected(IPlayer user)
        {
            var component = idToComponent[user.Id];
            UnityEngine.Object.Destroy(component);
        }

        void Unload()
        {
            foreach (var player in players.Connected)
            {
                OnUserDisconnected(player);
            }

            uiCached = null;
            Instance = null;
        }

        void OnGodmodeToggled(string playerId, bool enabled)
        {
            Debug.Assert(idToComponent.ContainsKey(playerId));

            GodmodeUi component;
            if(idToComponent.TryGetValue(playerId, out component))
                component.GodmodePluginStatus = enabled;
        }

        #endregion

        void BuildUi()
        {
            string icon = UI_MAIN_PANEL_NAME + "::icon";
            ulong id = (ulong)icon.GetHashCode();
            ImageLibrary.Call(
                "AddImage",
                settings.UiUrl,
                icon,
                id,
                new Action(() =>
                {
                    var container = new CuiElementContainer();

                    container.Add(
                        new CuiElement
                        {
                            Name = UI_MAIN_PANEL_NAME,
                            Parent = "Hud",
                            Components =
                            {
                                new CuiRawImageComponent
                                {
                                    Color = settings.UiColor,
                                    Sprite = "assets/content/textures/generic/fulltransparent.tga",
                                    Png = (string)ImageLibrary?.Call("GetImage", icon, id),
                                    FadeIn = 0.4f
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin =
                                        $"{settings.UiX - .04f * settings.UiScale} {settings.UiY - .056f * settings.UiScale}",
                                    AnchorMax =
                                        $"{settings.UiX + .04f * settings.UiScale} {settings.UiY + .056f * settings.UiScale}"
                                }
                            },
                            FadeOut = 0.4f
                        }
                    );

                    uiCached = ToJson(container);

                    foreach (var component in idToComponent.Values)
                    {
                        component.OnUiBuilt();
                    }
                })
            );
        }

        #region GodmodeUi

        class GodmodeUi : MonoBehaviour
        {
            BasePlayer player;
            bool uiVisible;
            bool isInPluginGod;

            public bool GodmodePluginStatus
            {
                set { isInPluginGod = value; }
            }

            bool IsGod => isInPluginGod || player.IsGod();

            public void OnSleepEnded()
            {
                if (!IsInvoking(nameof(Tick)))
                    InvokeRepeating(nameof(Tick), 1f, 1f);
            }

            public void OnUiBuilt()
            {
                if (!IsInvoking(nameof(Tick)) && !player.IsSleeping())
                    InvokeRepeating(nameof(Tick), 1f, 1f);
            }

            #region MonoBehaviour lifecycle

            void Awake()
            {
                player = GetComponent<BasePlayer>();

                Instance.idToComponent[player.UserIDString] = this;
            }

            void Start()
            {
                isInPluginGod =
                    Instance.Godmode && Instance.Godmode.Call<bool>("IsGod", player.UserIDString);
                if (!player.IsSleeping() && Instance.uiCached != null)
                    InvokeRepeating(nameof(Tick), 1f, 1f);
            }

            void OnDestroy()
            {
                if (uiVisible && player.IsConnected)
                {
                    SetVisible(false);
                }

                Instance?.idToComponent?.Remove(player.UserIDString);
            }

            #endregion

            void SetVisible(bool bVisible)
            {
                Debug.Assert(bVisible != uiVisible, "Double setting visible to " + bVisible);
                Debug.Assert(player && player.IsConnected, "Player is null or disconnected");

                if (bVisible)
                {
                    AddUi(player, Instance.uiCached);
                }
                else
                {
                    DestroyUi(player, UI_MAIN_PANEL_NAME);
                }

                uiVisible = bVisible;
            }

            void Tick()
            {
                if (!IsGod && uiVisible)
                {
                    SetVisible(false);
                }
                else if (IsGod && !uiVisible)
                {
                    SetVisible(true);
                }
            }
        }

        #endregion
    }
}


// --- End of file: GodmodeIndicator.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/gst-ban-ctrl ---
// --- Original File Path: G/GSTBanCtrl/GSTBanCtrl.cs ---

using ConVar;
using Facepunch.Extend;
using Facepunch.Math;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("GST BanCtrl", "Cameron", "1.0.4")]
    [Description("Centralised ban list for multiple servers.")]
    public class GSTBanCtrl : CovalencePlugin
    {
        private Dictionary<string, CachedPlayer> CachedJoins = new Dictionary<string, CachedPlayer>();
        private readonly string apiUrl = "https://api.gameservertools.com";

        //private readonly string apiUrl = "https://localhost:44361";
        private Dictionary<string, string> headers = new Dictionary<string, string>();

        private int port = 28015;

        private void Init()
        {
            LoadConfigData();
        }

        private void LoadConfigData()
        {
            port = int.Parse(Config["Port"].ToString());
            string apiKey = Config["APIKEY"].ToString();
            if (string.IsNullOrEmpty(apiKey))
                LogError("NO API KEY PROVIDED! Please ensure you have added your api key in the config file");
            else
            {
                headers.Add("Content-Type", "application/json");
                headers.Add("ApiKey", apiKey);
            }
        }

        #region WebRequests

        private void SubmitNewBan(AddBanClass newBan, IPlayer admin, Action<AddBanClass> successCallBack)
        {
            newBan.ServerPort = port;
            string body = JsonConvert.SerializeObject(newBan);

            webrequest.Enqueue($"{apiUrl}/api/Ban/AddBan", body, (code, response) =>
            {
                if (code == 200)// Success
                {
                    AddBanClass banSuccess = JsonConvert.DeserializeObject<AddBanClass>(response);

                    BasePlayer playerToKick = BasePlayer.Find(banSuccess.SteamId.ToString());
                    if (playerToKick != null && playerToKick.IsConnected)
                    {
                        string messageReplaced = lang.GetMessage("YouAreBannedMessage", this, playerToKick.UserIDString);
                        messageReplaced = messageReplaced.Replace("@reason", banSuccess.Reason);
                        playerToKick.Kick(messageReplaced);
                    }

                    string broadCastMessage = lang.GetMessage("PlayerBannedBroadcastMsg", this, playerToKick.UserIDString);
                    broadCastMessage = broadCastMessage.Replace("@user", banSuccess.Reason);
                    Chat.Broadcast(broadCastMessage);

                    successCallBack.Invoke(banSuccess);
                }
                else if (code == 400)
                {
                    if (admin != null && admin.IsConnected)
                    {
                        string messageReplaced = lang.GetMessage("FailedToBan", this, admin.Id);
                        messageReplaced = messageReplaced.Replace("@response", response);
                        admin.Reply(messageReplaced);
                    }
                    Puts($"Failed to ban user! {response}");
                }
                else if (code == 401)
                {
                    if (admin != null && admin.IsConnected)
                    {
                        string messageReplaced = lang.GetMessage("FailedToBanNoPermission", this, admin.Id);
                        admin.Reply(messageReplaced);
                    }
                    Puts($"Failed to ban user! {response}");
                }
                else
                {
                    if (admin != null && admin.IsConnected)
                    {
                        string messageReplaced = lang.GetMessage("FailedToBan", this, admin.Id);
                        messageReplaced = messageReplaced.Replace("@response", response);
                        admin.Reply(messageReplaced);
                    }

                    Puts($"Ban failed: {response} Code: {code}");
                }
            }, this, Core.Libraries.RequestMethod.PUT, headers);
        }

        #endregion WebRequests

        #region Altered Facepunch Methods

        private bool TryGetBanExpiry(
          string arg,
          int n,
          IPlayer iplayer,
          out long expiry,
          out string durationSuffix)
        {
            expiry = GetTimestamp(arg, n, -1L);
            durationSuffix = (string)null;
            int current = Epoch.Current;
            if (expiry > 0L && expiry <= (long)current)
            {
                string messageReplaced = lang.GetMessage("PastExireDate", this, iplayer.Id);
                iplayer.Reply(messageReplaced);
                return false;
            }
            durationSuffix = expiry > 0L ? " for " + (expiry - (long)current).FormatSecondsLong() : "";
            return true;
        }

        private long GetTimestamp(string arg, int iArg, long def = 0)
        {
            string s = arg == string.Empty ? null : arg;
            if (s == null)
                return def;
            int num = 3600;
            if (s.Length > 1 && char.IsLetter(s[s.Length - 1]))
            {
                switch (s[s.Length - 1])
                {
                    case 'M':
                        num = 2592000;
                        break;

                    case 'Y':
                        num = 31536000;
                        break;

                    case 'd':
                        num = 86400;
                        break;

                    case 'h':
                        num = 3600;
                        break;

                    case 'm':
                        num = 60;
                        break;

                    case 's':
                        num = 1;
                        break;

                    case 'w':
                        num = 604800;
                        break;
                }

                s = s.Substring(0, s.Length - 1);
            }
            long result;
            if (!long.TryParse(s, out result))
                return def;
            if (result > 0L && result <= 315360000L)
                result = DateTimeOffset.UtcNow.ToUnixTimeSeconds() + result * (long)num;
            return result;
        }

        #endregion Altered Facepunch Methods

        #region Commands

        [Command("Ban")]
        private void OverrideBanCommand(IPlayer iplayer, string command, string[] args)
        {
            if (!iplayer.IsAdmin && !iplayer.IsServer) // Replicate normal server permissions
            {
                return;
            }
            if (args.Length < 1) // Replicate normal server permissions
            {
                string messageReplaced = lang.GetMessage("InvalidArguments", this, iplayer.Id);
                iplayer.Reply(messageReplaced);
                return;
            }

            BasePlayer player = args[0] == null ? null : BasePlayer.Find(args[0]);
            if (player == null || player.net == null || player.net.connection == null)
            {
                string messageReplaced = lang.GetMessage("NoPlayerFound", this, iplayer.Id);
                iplayer.Reply(messageReplaced);
            }
            else
            {
                ServerUsers.User user = ServerUsers.Get(player.userID);

                string noReasonString = lang.GetMessage("NoReason", this, iplayer.Id);

                string notes = args.Length < 2 ? noReasonString : args[1];

                long expiry;
                string durationSuffix;

                if (!TryGetBanExpiry(args.Length < 3 ? string.Empty : args[2], 2, iplayer, out expiry, out durationSuffix))
                    return;

                AddBanClass ban = new AddBanClass();
                ban.SteamId = user.steamid.ToString();
                ban.Reason = notes;
                ban.BannedBy = iplayer.IsServer ? null : iplayer.Id;
                if (expiry > 0L)
                {
                    ban.ExpireTime = DateTimeOffset.FromUnixTimeSeconds(expiry).DateTime;
                }
                else
                    ban.ExpireTime = null;

                SubmitNewBan(ban, iplayer, (sumbitedBan) =>
                {
                    if (iplayer != null && iplayer.IsConnected)
                    {
                        string messageReplaced = lang.GetMessage("BanSentSuccess", this, iplayer.Id);
                        messageReplaced = messageReplaced.Replace("@niceBanId", sumbitedBan.NiceBanId);
                        iplayer.Reply(messageReplaced);
                    }
                    if (player.IsConnected && player.net.connection.ownerid != 0UL && (long)player.net.connection.ownerid != (long)player.net.connection.userid)
                    {
                        string banReason = string.Empty;
                        if (iplayer != null && iplayer.IsConnected)
                        {
                            string messageReplaced = lang.GetMessage("FamilyShareAccount", this, iplayer.Id);
                            iplayer.Reply(messageReplaced);
                            banReason = lang.GetMessage("FamilyShareReason", this, iplayer.Id);
                        }
                        else
                        {
                            banReason = lang.GetMessage("FamilyShareReason", this);
                        }
                        banReason = banReason.Replace("@player", player.net.connection.userid.ToString());
                        banReason = banReason.Replace("@niceBanId", sumbitedBan.NiceBanId);

                        AddBanClass shareBan = new AddBanClass();
                        shareBan.SteamId = user.steamid.ToString();
                        shareBan.Reason = banReason;
                        shareBan.BannedBy = iplayer.Id;
                        if (expiry > 0L)
                        {
                            shareBan.ExpireTime = DateTimeOffset.FromUnixTimeSeconds(expiry).DateTime;
                        }
                        else
                        {
                            shareBan.ExpireTime = null;
                        }
                        SubmitNewBan(ban, iplayer, (sumbitedBanFamilyShare) =>
                        {
                            if (iplayer != null && iplayer.IsConnected)
                            {
                                string messageReplaced = lang.GetMessage("BanSentSuccess", this, iplayer.Id);
                                messageReplaced = messageReplaced.Replace("@niceBanId", sumbitedBan.NiceBanId);
                                iplayer.Reply(messageReplaced);
                            }
                        });
                    }
                });
            }
        }

        [Command("AddAllBans")]
        private void AddAllBans(IPlayer iplayer, string command, string[] args)
        {
            if (iplayer != null && iplayer.IsAdmin)
            {
                List<ServerUsers.User> list = ServerUsers.GetAll(ServerUsers.UserGroup.Banned).ToList<ServerUsers.User>();
                float time = 0.0f;
                int i = 1;
                foreach (ServerUsers.User user in list)
                {
                    timer.Once(time, () =>
                    {
                        if (iplayer != null && iplayer.IsConnected)
                        {
                            string messageReplaced = lang.GetMessage("MassBanMessage", this, iplayer.Id);
                            messageReplaced = messageReplaced.Replace("@user", user.steamid.ToString());
                            messageReplaced = messageReplaced.Replace("@listCount", list.Count.ToString());
                            messageReplaced = messageReplaced.Replace("@index", i.ToString());
                            iplayer.Reply(messageReplaced);
                        }

                        i++;
                        AddBanClass ban = new AddBanClass();
                        ban.SteamId = user.steamid.ToString();
                        ban.Reason = user.notes;
                        ban.BannedBy = null;
                        ban.DontSendRconKick = true;
                        if (user.expiry > 0L)
                        {
                            long minsToAdd = (user.expiry - (long)Facepunch.Math.Epoch.Current);// / 60.0f);
                            minsToAdd = minsToAdd / 60;
                            ban.ExpireTime = DateTime.UtcNow.AddMinutes(minsToAdd);
                        }
                        else
                            ban.ExpireTime = null;

                        SubmitNewBan(ban, iplayer, (newban) => { });
                    });
                    time = time + 0.5f;
                }
            }
        }

        #endregion Commands

        #region Hooks

        private void OnPlayerBanned(string name, ulong id, string address, string reason)
        {
            AddBanClass ban = new AddBanClass();

            ban.SteamId = id.ToString();
            ban.Reason = reason;
            ban.ExpireTime = null;
            ban.BannedBy = null;

            SubmitNewBan(ban, null, (newBan) =>
            {
                ServerUsers.User user = ServerUsers.Get(id);
                if (user == null || user.group != ServerUsers.UserGroup.Banned)
                {
                    Puts("no user found that is banned");
                }
                else
                {
                    ServerUsers.Remove(id);
                    ServerUsers.Save();
                }
            });
        }

        private void OnUserApprove(Network.Connection connection)
        {
            ulong ownerId = connection.userid;

            string id = connection.userid.ToString();
            if (CachedJoins.ContainsKey(id))
            {
                CachedPlayer data = CachedJoins[id];
                TimeSpan timeSinceAdd = DateTime.Now - data.timeOfAdd;

                if (timeSinceAdd.TotalMinutes < 1)
                {
                    timer.Once(5.0f, () => // Prevents spam joinning
                    {
                        if (connection != null)
                            Network.Net.sv.Kick(connection, data.reason, false);
                    });

                    return;
                }

                CachedJoins.Remove(id);
            }

            webrequest.Enqueue($"{apiUrl}/api/Ban/GetActiveBans?steamId={ownerId}&serverPort={port}", null, (code, response) =>
            //webrequest.Enqueue($"{apiUrl}/api/Ban/ReturnSelf?thing='hello'", null, (code, response) =>
            {
                if (code == 200)
                {
                    List<AddBanClass> bans = JsonConvert.DeserializeObject<List<AddBanClass>>(response);
                    if (bans.Count > 0)
                    {
                        AddBanClass banSuccess = bans.FirstOrDefault();

                        string kickReason = lang.GetMessage("YouAreBannedMessage", this, connection.userid.ToString());
                        kickReason = kickReason.Replace("@reason", banSuccess.Reason);
                        Network.Net.sv.Kick(connection, kickReason, false);

                        CachedJoins.Add(connection.userid.ToString(), new CachedPlayer() { reason = kickReason, timeOfAdd = DateTime.Now });
                    }
                }
                else if (code == 204)
                {
                    //Puts($"You are not banned!");
                }
                else if (code == 0)
                {
                    Puts($"-=-=-=-gameservertools.com is unreachable!-=-=-=-=-");
                }
                else
                {
                    Puts($"Something went wrong code {code}");
                }
            }, this, Core.Libraries.RequestMethod.GET, headers);
            return;
        }

        #endregion Hooks

        #region Classes

        private class AddBanClass
        {
            public string SteamId { get; set; }
            public string Reason { get; set; }
            public DateTime? ExpireTime { get; set; }
            public int OrgId { get; set; }
            public int? ServerId { get; set; }
            public string BannedBy { get; set; }
            public string NiceBanId { get; set; }
            public int ServerPort { get; set; }
            public bool DontSendRconKick { get; set; }
        }

        private class CachedPlayer
        {
            public string reason { get; set; }
            public DateTime timeOfAdd { get; set; }
        }

        #endregion Classes

        protected override void LoadDefaultConfig()
        {
            Config["APIKEY"] = "";
            Config["Port"] = 28015;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["YouAreBannedMessage"] = "You are banned! Reason: @reason Head to discord.com/yourserver to appeal this ban",
                ["FailedToBan"] = "Failed to ban user! @response",
                ["FailedToBanNoPermission"] = "Failed to ban user! You do not have permission on gameservertools.com to ban users! Please contact your server owner to get this resolved",
                ["PastExireDate"] = "Expiry time is in the past",
                ["NoPlayerFound"] = "Player not found",
                ["NoReason"] = "No Reason Given",
                ["BanSentSuccess"] = "Ban Succesfully sent to Game Server Tools. BanId: @niceBanId",
                ["FamilyShareAccount"] = "Found family share account. Sending ban!",
                ["FamilyShareReason"] = "Family share owner of @player, Share Ban Id: @niceBanId",
                ["MassBanMessage"] = "@index/@listCount Sending ban for @user",
                ["PlayerBannedBroadcastMsg"] = "Player @user has been banned.",
                ["InvalidArguments"] = "Please provide a user to ban"
            }, this); ;
        }
    }
}

// --- End of file: GSTBanCtrl.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/guess-the-number ---
// --- Original File Path: G/GuessTheNumber/GuessTheNumber.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using System.Text;
using UnityEngine;
using System.Linq;
using Oxide.Game.Rust.Cui;
using Oxide.Core;

namespace Oxide.Plugins
{
    /*==============================================================================================================
    *    
    *    THANKS to Dora the original creator of this plugin
    *    THANKS to redBDGR the previous maintainer of this plugin upto v2.0.2
    *    THANKS to Krungh Crow the previous maintainer of this plugin upto v2.1.3
    *
     ==============================================================================================================*/

    [Info("Guess The Number", "Mabel", "2.2.3")]
    [Description("An event that requires player to guess the correct number")]

    class GuessTheNumber : RustPlugin
    {
        [PluginReference] private readonly Plugin Battlepass, ServerRewards, Economics, SkillTree, XPerience;

        private Data data;
        public Dictionary<ulong, int> playerInfo = new Dictionary<ulong, int>();

        bool useEconomics = true;
        bool useEconomicsloss = true;
        bool useServerRewards = false;
        bool useServerRewardsloss = false;
        bool useBattlepass1 = false;
        bool useBattlepass2 = false;
        bool useBattlepassloss = false;
        bool useSkillTree = false;
        bool useSkillTreeloss = false;
        bool useXPerience = false;
        bool useXPerienceloss = false;
        bool useItem = false;
        bool useCommand = false;
        bool autoEventsEnabled = false;
        bool showAttempts = false;
        bool showAttemptsTips = false;
        bool useChat = false;
        bool useGameTip = true;
        float gameTipDuration = 20f;
        float autoEventTime = 600f;
        float eventLength = 30f;
        int minDefault = 1;
        int maxDefault = 1000;
        int maxTries = 1;
        int MinPlayer = 1;
        int economicsWinReward = 20;
        int economicsLossReward = 10;
        int serverRewardsWinReward = 20;
        int serverRewardsLossReward = 10;
        int battlepassWinReward1 = 20;
        int battlepassWinReward2 = 20;
        int battlepassLossReward1 = 10;
        int battlepassLossReward2 = 10;
        int skillTreeWinReward = 100;
        int skillTreeLossReward = 50;
        int xPerienceWinReward = 100;
        int xPerienceLossReward = 50;
        int itemWinReward = 100;
        string itemName = "scrap";
        ulong itemSkin = 0;
        string itemCustomName = "";
        string commandName = "Display Name For Reward Messages";
        string commandToExecute = "o.grant user {playerId} some.permission";
        string chatCommand = "top";


        string Prefix = "[<color=#abf229>GuessTheNumber</color>] ";
        ulong SteamIDIcon = 0;
        private bool AddSecondCurrency;
        private bool AddFirstCurrency;

        const string permissionNameADMIN = "guessthenumber.admin";
        const string permissionNameENTER = "guessthenumber.enter";

        bool Changed = false;
        bool eventActive = false;
        Timer eventTimer;
        Timer autoRepeatTimer;
        int minNumber = 0;
        int maxNumber = 0;
        bool hasEconomics = false;
        bool hasServerRewards = false;
        bool hasBattlepass = false;
        bool hasSkillTree = false;
        bool hasXPerince = false;
        int number = 0;

        void LoadVariables()
        {
            //UI Chat Command
            chatCommand = Convert.ToString(GetConfig("LeaderBoard UI Settings", "Command", "top"));
            //Announce
            showAttempts = Convert.ToBoolean(GetConfig("Announce Settings", "Show all Guess Attempts to chat", false));
            showAttemptsTips = Convert.ToBoolean(GetConfig("Announce Settings", "Show all Guess Attempts to GameTips", false));
            useChat = Convert.ToBoolean(GetConfig("Announce Settings", "Use Chat Messages", false));
            Prefix = Convert.ToString(GetConfig("Announce Settings", "Prefix", "[<color=#abf229>Guess The Number</color>] "));
            SteamIDIcon = Convert.ToUInt64(GetConfig("Announce Settings", "SteamID", 76561199090290915));
            useGameTip = Convert.ToBoolean(GetConfig("Announce Settings", "Use Game Tip Messages", true));
            gameTipDuration = Convert.ToInt32(GetConfig("Announce Settings", "Game Tip Duration", 20));
            //Online
            MinPlayer = Convert.ToInt32(GetConfig("Online Settings", "Minimum amount of players to be online to start the game", "1"));
            //Events
            autoEventsEnabled = Convert.ToBoolean(GetConfig("Event Settings", "Auto Events Enabled", false));
            autoEventTime = Convert.ToInt32(GetConfig("Event Settings", "Auto Event Repeat Time", 600));
            eventLength = Convert.ToInt32(GetConfig("Event Settings", "Event Length", 30));
            minDefault = Convert.ToInt32(GetConfig("Event Settings", "Default Number Min", 1));
            maxDefault = Convert.ToInt32(GetConfig("Event Settings", "Default Number Max", 100));
            maxTries = Convert.ToInt32(GetConfig("Event Settings", "Max Tries", 1));
            //Economics
            useEconomics = Convert.ToBoolean(GetConfig("Reward Economics Settings", "Use Economics", true));
            useEconomicsloss = Convert.ToBoolean(GetConfig("Reward Economics Settings", "Use Economics on loss", true));
            economicsWinReward = Convert.ToInt32(GetConfig("Reward Economics Settings", "Amount (win)", 20));
            economicsLossReward = Convert.ToInt32(GetConfig("Reward Economics Settings", "Amount (loss)", 10));
            //ServerRewards
            useServerRewards = Convert.ToBoolean(GetConfig("Reward ServerRewards Settings", "Use ServerRewards", false));
            useServerRewardsloss = Convert.ToBoolean(GetConfig("Reward ServerRewards Settings", "Use ServerRewards on loss", false));
            serverRewardsWinReward = Convert.ToInt32(GetConfig("Reward ServerRewards Settings", "Amount (win)", 20));
            serverRewardsLossReward = Convert.ToInt32(GetConfig("Reward ServerRewards Settings", "Amount (loss)", 10));
            //Battlepass
            useBattlepass1 = Convert.ToBoolean(GetConfig("Reward Battlepass Settings", "Use Battlepass 1st currency", false));
            useBattlepass2 = Convert.ToBoolean(GetConfig("Reward Battlepass Settings", "Use Battlepass 2nd currency", false));
            useBattlepassloss = Convert.ToBoolean(GetConfig("Reward Battlepass Settings", "Use Battlepass on loss", false));
            battlepassWinReward1 = Convert.ToInt32(GetConfig("Reward Battlepass Settings", "Amount 1st currency (win)", 20));
            battlepassWinReward2 = Convert.ToInt32(GetConfig("Reward Battlepass Settings", "Amount 2nd currency (win)", 20));
            battlepassLossReward1 = Convert.ToInt32(GetConfig("Reward Battlepass Settings", "Amount 1st currency (loss)", 10));
            battlepassLossReward2 = Convert.ToInt32(GetConfig("Reward Battlepass Settings", "Amount 2nd currency (loss)", 10));
            //SkillTree
            useSkillTree = Convert.ToBoolean(GetConfig("Reward SkillTree Settings", "Use SkillTree", false));
            useSkillTreeloss = Convert.ToBoolean(GetConfig("Reward SkillTree Settings", "Use SkillTree on loss", false));
            skillTreeWinReward = Convert.ToInt32(GetConfig("Reward SkillTree Settings", "Amount (win)", 100));
            skillTreeLossReward = Convert.ToInt32(GetConfig("Reward SkillTree Settings", "Amount (loss)", 50));
            //XPerience
            useXPerience = Convert.ToBoolean(GetConfig("Reward XPerience Settings", "Use XPerience", false));
            useXPerienceloss = Convert.ToBoolean(GetConfig("Reward XPerience Settings", "Use XPerience on loss", false));
            xPerienceWinReward = Convert.ToInt32(GetConfig("Reward XPerience Settings", "Amount (win)", 100));
            xPerienceLossReward = Convert.ToInt32(GetConfig("Reward XPerience Settings", "Amount (loss)", 50));
            //Item
            useItem = Convert.ToBoolean(GetConfig("Reward Item Settings", "Use Item", false));
            itemName = Convert.ToString(GetConfig("Reward Item Settings", "Item Shortname", "scrap"));
            itemSkin = Convert.ToUInt64(GetConfig("Reward Item Settings", "Item Skin ID", 0));
            itemCustomName = Convert.ToString(GetConfig("Reward Item Settings", "Custom Display Name", ""));
            itemWinReward = Convert.ToInt32(GetConfig("Reward Item Settings", "Amount", 100));
            //Command
            useCommand = Convert.ToBoolean(GetConfig("Reward Command Settings", "Use Command", false));
            commandName = Convert.ToString(GetConfig("Reward Command Settings", "Command Name", "Display Name For Reward Messages"));
            commandToExecute = Convert.ToString(GetConfig("Reward Command Settings", "Command To Execute", "o.grant user {playerId} some.permission"));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        void Init()
        {
            LoadData();
            permission.RegisterPermission(permissionNameADMIN, this);
            permission.RegisterPermission(permissionNameENTER, this);
            LoadVariables();
        }

        void Unload()
        {
            killUI();

            if (autoEventsEnabled)
                if (!autoRepeatTimer.Destroyed)
                {
                    autoRepeatTimer.Destroy();
                }
            return;
        }

        private void OnServerInitialized()
        {
            LoadVariables();

            cmd.AddChatCommand(chatCommand, this, nameof(TopCommand));

            if (autoEventsEnabled)
            {
                if (eventActive)
                {
                    return;
                }
                autoRepeatTimer = timer.Repeat(autoEventTime, 0, () =>
                {
                    if (BasePlayer.activePlayerList.Count >= MinPlayer)
                    {
                        minNumber = minDefault;
                        maxNumber = maxDefault;
                        number = Convert.ToInt32(Math.Round(Convert.ToDouble(UnityEngine.Random.Range(Convert.ToSingle(minNumber), Convert.ToSingle(maxNumber)))));
                        StartEvent();
                    }
                    else
                    {
                        return;
                    }
                });
            }

            if (!Economics)
                hasEconomics = false;
            else
                hasEconomics = true;

            if (!ServerRewards)
                hasServerRewards = false;
            else
                hasServerRewards = true;

            if (!Battlepass)
                hasBattlepass = false;
            else
                hasBattlepass = true;

            if (!SkillTree)
                hasSkillTree = false;
            else
                hasSkillTree = true;

            if (!XPerience)
                hasXPerince = false;
            else
                hasXPerince = true;
        }

        void Loaded()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["No Permission"] = "You cannot use this command!",
                ["Event Already Active"] = "There is currently already an event that is active!",
                ["Event Started"] = "A random number event has started, correctly guess the random number to win a prize!\nUse /guess <number> to enter between <color=#abf229>{0}</color> and <color=#abf229>{1}</color>",
                ["Help Message"] = "<color=#abf229>/gtn start</color> (this will use the default min/max set in the config)",
                ["Help Message1"] = "<color=#abf229>/gtn start <min number> <max number></color> (allows you to set custom min/max numbers)",
                ["Help Message2"] = "<color=#abf229>/gtn end</color> (will end the current event)",
                ["No Event"] = "There are no current events active",
                ["Max Tries"] = "You have already guessed the maximum number of times",
                ["Event Win"] = "<color=#abf229>{0}</color> has won the event! (correct number was <color=#abf229>{1}</color>)",
                ["Battlepass Reward1"] = "For winning you are rewarded (BP1) : <color=#abf229>{0}</color>",
                ["Battlepass loss Reward1"] = "Incorrect answer you get (BP1) : <color=#abf229>{0}</color>",
                ["Battlepass Reward2"] = "For winning you are rewarded (BP2) : <color=#abf229>{0}</color>",
                ["Battlepass loss Reward2"] = "Incorrect answer you get (BP2) : <color=#abf229>{0}</color>",
                ["Economics Reward"] = "For winning you are rewarded $ <color=#abf229>{0}</color>",
                ["Economics loss Reward"] = "Incorrect answer you get $ <color=#abf229>{0}</color>",
                ["ServerRewards Reward"] = "For winning you are rewarded <color=#abf229>{0}</color> RP",
                ["ServerRewards loss Reward"] = "Incorrect answer you get <color=#abf229>{0}</color> RP",
                ["Wrong Number"] = "You guessed the wrong number\nGuesses remaining this round : <color=#abf229>{0}</color>",
                ["/guess Invalid Syntax"] = "Invalid syntax! /guess <number>",
                ["Event Timed Out"] = "The event time has run out and no one successfully guessed the number!\nThe Number to guess was : <color=#abf229>{0}</color>",
                ["Invalid Guess Entry"] = "The guess you entered was invalid! numbers only please",
                ["Event Created"] = "The event has been succesfully created, the winning number is <color=#abf229>{0}</color>",
                ["GTN console invalid syntax"] = "Invalid syntax! gtn <start/end> <min number> <max number>",
                ["SkillTree Reward"] = "For winning you are rewarded <color=#abf229>{0}</color> XP",
                ["SkillTree loss Reward"] = "Incorrect answer you get <color=#abf229>{0}</color> XP",
                ["XPerience Reward"] = "For winning you are rewarded <color=#abf229>{0}</color> XP",
                ["XPerience loss Reward"] = "Incorrect answer you get <color=#abf229>{0}</color> XP",
                ["Item Reward"] = "For winning you are rewarded <color=#abf229>{0}</color>",
                ["Command Reward"] = "For winning you are rewarded <color=#abf229>{0}</color>",
                ["UI_TITLE"] = "Guess The Number",
                ["UI_TOP_TEXT"] = "Top 10 Players",
                ["UI_NO_PLAYERS"] = "Nobody Has Played Yet! :(",
                ["UI_PLAYERS"] = "{0}. {1} - Wins: <color=#abf229>{2}</color>"

            }, this);
        }

        [ConsoleCommand("gtn")]
        void GTNCONSOLECMD(ConsoleSystem.Arg args)
        {
            if (args.Connection != null)
                return;
            if (args.Args == null)
            {
                args.ReplyWith(msg("GTN console invalid syntax"));
                return;
            }
            if (args.Args.Length == 0)
            {
                args.ReplyWith(msg("GTN console invalid syntax"));
                return;
            }
            if (args.Args.Length > 3)
            {
                args.ReplyWith(msg("GTN console invalid syntax"));
                return;
            }
            if (args.Args[0] == null)
            {
                args.ReplyWith(msg("GTN console invalid syntax"));
                return;
            }
            if (args.Args[0] == "start")
            {
                if (eventActive)
                {
                    args.ReplyWith(msg("Event Already Active"));
                    return;
                }
                if (args.Args.Length == 3)
                {
                    minNumber = Convert.ToInt32(args.Args[1]);
                    maxNumber = Convert.ToInt32(args.Args[2]);
                    if (minNumber != 0 && maxNumber != 0)
                    {
                        number = Convert.ToInt32(Math.Round(Convert.ToDouble(UnityEngine.Random.Range(Convert.ToSingle(minNumber), Convert.ToSingle(maxNumber)))));
                        StartEvent();
                        args.ReplyWith(string.Format(msg("Event Created"), number.ToString()));
                    }
                    else
                    {
                        args.ReplyWith(msg("Invalid Params"));
                        return;
                    }
                }
                else
                {
                    minNumber = minDefault;
                    maxNumber = maxDefault;
                    number = Convert.ToInt32(Math.Round(Convert.ToDouble(UnityEngine.Random.Range(Convert.ToSingle(minNumber), Convert.ToSingle(maxNumber)))));
                    StartEvent();
                    args.ReplyWith(string.Format(msg("Event Created"), number.ToString()));
                }
                if (autoEventsEnabled)
                    if (!autoRepeatTimer.Destroyed)
                    {
                        autoRepeatTimer.Destroy();
                        autoRepeatTimer = timer.Repeat(autoEventTime, 0, () => StartEvent());
                    }
                return;
            }
            else if (args.Args[0] == "end")
            {
                if (eventActive == false)
                {
                    args.ReplyWith(msg("No Event"));
                    return;
                }
                if (!eventTimer.Destroyed || eventTimer != null)
                    eventTimer.Destroy();
                if (autoEventsEnabled)
                    if (!autoRepeatTimer.Destroyed)
                    {
                        autoRepeatTimer.Destroy();
                        autoRepeatTimer = timer.Repeat(autoEventTime, 0, () => StartEvent());
                    }
                eventActive = false;
                args.ReplyWith("The current event has been cancelled");

                if (useChat)
                {
                    SendMessageToActivePlayers(msg("Event Timed Out"));
                }
                if (useGameTip)
                {
                    SendToastToActivePlayers(msg("Event Timed Out"));
                }
            }
            else
                args.ReplyWith(msg("GTN console invalid syntax"));
            return;
        }

        [ChatCommand("gtn")]
        private void startGuessNumberEvent(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionNameADMIN))
            {
                if (useChat)
                {
                    Player.Message(player, $"{lang.GetMessage("No Permission", this, player.UserIDString)}", Prefix, SteamIDIcon);
                }
                if (useGameTip)
                {
                    player.ShowToast(GameTip.Styles.Red_Normal, $"{lang.GetMessage("No Permission", this, player.UserIDString)}");
                }
                return;
            }
            if (args.Length == 0)
            {
                player.ChatMessage(DoHelpMenu());
                return;
            }
            if (args.Length > 3)
            {
                player.ChatMessage(DoHelpMenu());
                return;
            }
            if (args[0] == null)
            {
                player.ChatMessage(DoHelpMenu());
                return;
            }
            if (args[0] == "start")
            {
                if (eventActive)
                {
                    if (useChat)
                    {
                        Player.Message(player, $"{lang.GetMessage("Event Already Active", this, player.UserIDString)}", Prefix, SteamIDIcon);
                    }
                    if (useGameTip)
                    {
                        player.ShowToast(GameTip.Styles.Red_Normal, $"{lang.GetMessage("Event Already Active", this, player.UserIDString)}");
                    }
                    return;
                }
                if (args.Length == 3)
                {
                    minNumber = Convert.ToInt32(args[1]);
                    maxNumber = Convert.ToInt32(args[2]);
                    if (minNumber != 0 && maxNumber != 0)
                    {
                        number = Convert.ToInt32(Math.Round(Convert.ToDouble(UnityEngine.Random.Range(Convert.ToSingle(minNumber), Convert.ToSingle(maxNumber)))));
                        StartEvent();

                        if (useChat)
                        {
                            Player.Message(player, $"{string.Format(lang.GetMessage("Event Created", this, player.UserIDString), number)}", Prefix, SteamIDIcon);
                        }
                        if (useGameTip)
                        {
                            player.SendConsoleCommand("gametip.showgametip", $"{string.Format(lang.GetMessage("Event Created", this, player.UserIDString), number)}", gameTipDuration);

                            timer.Once(gameTipDuration, () =>
                            {
                                player.SendConsoleCommand("gametip.hidegametip");
                            });
                        }
                    }
                    else
                    {
                        if (useChat)
                        {
                            Player.Message(player, $"{lang.GetMessage("Invalid Params", this, player.UserIDString)}", Prefix, SteamIDIcon);
                        }
                        if (useGameTip)
                        {
                            player.ShowToast(GameTip.Styles.Red_Normal, $"{lang.GetMessage("Invalid Params", this, player.UserIDString)}");
                        }
                        return;
                    }
                }
                else
                {
                    minNumber = minDefault;
                    maxNumber = maxDefault;
                    number = Convert.ToInt32(Math.Round(Convert.ToDouble(UnityEngine.Random.Range(Convert.ToSingle(minNumber), Convert.ToSingle(maxNumber)))));
                    StartEvent();

                    if (useChat)
                    {
                        Player.Message(player, $"{string.Format(lang.GetMessage("Event Created", this, player.UserIDString), number)}", Prefix, SteamIDIcon);
                    }
                    if (useGameTip)
                    {
                        player.SendConsoleCommand("gametip.showgametip", $"{string.Format(lang.GetMessage("Event Created", this, player.UserIDString), number)}", gameTipDuration);

                        timer.Once(gameTipDuration, () =>
                        {
                            player.SendConsoleCommand("gametip.hidegametip");
                        });
                    }
                }
                if (autoEventsEnabled)
                    if (!autoRepeatTimer.Destroyed)
                    {
                        autoRepeatTimer.Destroy();
                        autoRepeatTimer = timer.Repeat(autoEventTime, 0, () => StartEvent());
                    }
                return;
            }
            else if (args[0] == "end")
            {
                if (eventActive == false)
                {
                    if (useChat)
                    {
                        Player.Message(player, $"{lang.GetMessage("No Event", this, player.UserIDString)}", Prefix, SteamIDIcon);
                    }
                    if (useGameTip)
                    {
                        player.ShowToast(GameTip.Styles.Red_Normal, $"{lang.GetMessage("No Event", this, player.UserIDString)}");
                    }
                    return;
                }
                if (!eventTimer.Destroyed || eventTimer != null)
                    eventTimer.Destroy();
                if (autoEventsEnabled)
                    if (!autoRepeatTimer.Destroyed)
                    {
                        autoRepeatTimer.Destroy();
                        autoRepeatTimer = timer.Repeat(autoEventTime, 0, () => StartEvent());
                    }
                eventActive = false;
                if (useChat)
                {
                    SendMessageToActivePlayers(msg("Event Timed Out"));
                }
                if (useGameTip)
                {
                    SendToastToActivePlayers(msg("Event Timed Out"));
                }
            }
            else
            {
                if (useChat)
                {
                    Player.Message(player, $"{lang.GetMessage("Help Message", this, player.UserIDString)}", Prefix, SteamIDIcon);
                }
                if (useGameTip)
                {
                    player.SendConsoleCommand("gametip.showgametip", $"{lang.GetMessage("Help Message", this, player.UserIDString)}", gameTipDuration);

                    timer.Once(gameTipDuration, () =>
                    {
                        player.SendConsoleCommand("gametip.hidegametip");
                    });
                }
            }
            return;
        }

        [ChatCommand("guess")]
        private void numberReply(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionNameENTER))
            {
                if (useChat)
                {
                    Player.Message(player, $"{lang.GetMessage("No Permission", this, player.UserIDString)}", Prefix, SteamIDIcon);
                }
                if (useGameTip)
                {
                    player.ShowToast(GameTip.Styles.Red_Normal, $"{lang.GetMessage("No Permission", this, player.UserIDString)}");
                }
                return;
            }
            if (!eventActive)
            {
                if (useChat)
                {
                    Player.Message(player, $"{lang.GetMessage("No Event", this, player.UserIDString)}", Prefix, SteamIDIcon);
                }
                if (useGameTip)
                {
                    player.ShowToast(GameTip.Styles.Red_Normal, $"{lang.GetMessage("No Event", this, player.UserIDString)}");
                }
                return;
            }

            if (args.Length == 1)
            {
                if (!IsNumber(args[0]))
                {
                    if (useChat)
                    {
                        Player.Message(player, $"{lang.GetMessage("Invalid Guess Entry", this, player.UserIDString)}", Prefix, SteamIDIcon);
                    }
                    if (useGameTip)
                    {
                        player.ShowToast(GameTip.Styles.Red_Normal, $"{lang.GetMessage("Invalid Guess Entry", this, player.UserIDString)}");
                    }
                    return;
                }
                int playerNum = Convert.ToInt32(args[0]);
                if (!playerInfo.ContainsKey(player.userID))
                    playerInfo.Add(player.userID, 0);
                if (playerInfo[player.userID] >= maxTries)
                {
                    if (useChat)
                    {
                        Player.Message(player, $"{lang.GetMessage("Max Tries", this, player.UserIDString)}", Prefix, SteamIDIcon);
                    }
                    if (useGameTip)
                    {
                        player.ShowToast(GameTip.Styles.Red_Normal, $"{lang.GetMessage("Max Tries", this, player.UserIDString)}");
                    }
                    return;
                }
                if (args[0] == "0")
                {
                    if (useChat)
                    {
                        Player.Message(player, $"{lang.GetMessage("You are not allowed to guess this number", this, player.UserIDString)}", Prefix, SteamIDIcon);
                    }
                    if (useGameTip)
                    {
                        player.ShowToast(GameTip.Styles.Red_Normal, $"{lang.GetMessage("You are not allowed to guess this number", this, player.UserIDString)}");
                    }
                    return;
                }

                if (showAttempts == true)
                {
                    SendMessageToActivePlayers($"<color=#abf229>{player.displayName}</color> guessed {args[0].ToString()}");
                }
                if (showAttemptsTips == true)
                {
                    SendToastToActivePlayers($"<color=#abf229>{player.displayName}</color> guessed {args[0].ToString()}");
                }
                if (playerNum == number)
                {
                    if (useChat)
                    {
                        SendMessageToActivePlayers(string.Format(msg("Event Win", player.UserIDString), player.displayName, number.ToString()));
                    }
                    if (useGameTip)
                    {
                        SendToastToActivePlayers(string.Format(msg("Event Win", player.UserIDString), player.displayName, number));
                    }

                    if (hasEconomics)
                    {
                        if (useEconomics)
                        {
                            if ((bool)Economics?.Call("Deposit", (ulong)player.userID, (double)economicsWinReward))
                            {
                                if (useChat)
                                {
                                    Player.Message(player, $"{string.Format(lang.GetMessage("Economics Reward", this, player.UserIDString), economicsWinReward)}", Prefix, SteamIDIcon);
                                }
                                if (useGameTip)
                                {
                                    player.SendConsoleCommand("gametip.showgametip", $"{string.Format(lang.GetMessage("Economics Reward", this, player.UserIDString), economicsWinReward)}", gameTipDuration);

                                    timer.Once(gameTipDuration, () =>
                                    {
                                        player.SendConsoleCommand("gametip.hidegametip");
                                    });
                                }
                            }
                        }
                    }

                    if (hasServerRewards)
                    {
                        if (useServerRewards)
                        {
                            ServerRewards?.Call("AddPoints", (ulong)player.userID, (int)serverRewardsWinReward);
                            {
                                if (useChat)
                                {
                                    Player.Message(player, $"{string.Format(lang.GetMessage("ServerRewards Reward", this, player.UserIDString), serverRewardsWinReward)}", Prefix, SteamIDIcon);
                                }
                                if (useGameTip)
                                {
                                    player.SendConsoleCommand("gametip.showgametip", $"{string.Format(lang.GetMessage("ServerRewards Reward", this, player.UserIDString), serverRewardsWinReward)}", gameTipDuration);

                                    timer.Once(gameTipDuration, () =>
                                    {
                                        player.SendConsoleCommand("gametip.hidegametip");
                                    });
                                }
                            }
                        }
                    }

                    if (hasBattlepass)
                    {
                        if (useBattlepass1)
                        {
                            Battlepass?.Call("AddFirstCurrency", (ulong)player.userID, battlepassWinReward1);
                            {
                                if (useChat)
                                {
                                    Player.Message(player, $"{string.Format(lang.GetMessage("Battlepass Reward1", this, player.UserIDString), battlepassWinReward1)}", Prefix, SteamIDIcon);
                                }
                                if (useGameTip)
                                {
                                    player.SendConsoleCommand("gametip.showgametip", $"{string.Format(lang.GetMessage("Battlepass Reward1", this, player.UserIDString), battlepassWinReward1)}", gameTipDuration);

                                    timer.Once(gameTipDuration, () =>
                                    {
                                        player.SendConsoleCommand("gametip.hidegametip");
                                    });
                                }
                            }
                        }

                        if (useBattlepass2)
                        {
                            Battlepass?.Call("AddSecondCurrency", (ulong)player.userID, battlepassWinReward2);
                            {
                                if (useChat)
                                {
                                    Player.Message(player, $"{string.Format(lang.GetMessage("Battlepass Reward2", this, player.UserIDString), battlepassWinReward2)}", Prefix, SteamIDIcon);
                                }
                                if (useGameTip)
                                {
                                    player.SendConsoleCommand("gametip.showgametip", $"{string.Format(lang.GetMessage("Battlepass Reward2", this, player.UserIDString), battlepassWinReward2)}", gameTipDuration);

                                    timer.Once(gameTipDuration, () =>
                                    {
                                        player.SendConsoleCommand("gametip.hidegametip");
                                    });
                                }
                            }
                        }
                    }

                    if (hasSkillTree)
                    {
                        if (useSkillTree)
                        {
                            SkillTree?.Call("AwardXP", (ulong)player.userID, (double)skillTreeWinReward);
                            {
                                if (useChat)
                                {
                                    Player.Message(player, $"{string.Format(lang.GetMessage("SkillTree Reward", this, player.UserIDString), skillTreeWinReward)}", Prefix, SteamIDIcon);
                                }
                                if (useGameTip)
                                {
                                    player.SendConsoleCommand("gametip.showgametip", $"{string.Format(lang.GetMessage("SkillTree Reward", this, player.UserIDString), skillTreeWinReward)}", gameTipDuration);

                                    timer.Once(gameTipDuration, () =>
                                    {
                                        player.SendConsoleCommand("gametip.hidegametip");
                                    });
                                }
                            }
                        }
                    }

                    if (hasXPerince)
                    {
                        if (useXPerience)
                        {
                            XPerience?.Call("GiveXP", player, (double)xPerienceWinReward);
                            {
                                if (useChat)
                                {
                                    Player.Message(player, $"{string.Format(lang.GetMessage("XPerience Reward", this, player.UserIDString), xPerienceWinReward)}", Prefix, SteamIDIcon);
                                }
                                if (useGameTip)
                                {
                                    player.SendConsoleCommand("gametip.showgametip", $"{string.Format(lang.GetMessage("XPerience Reward", this, player.UserIDString), xPerienceWinReward)}", gameTipDuration);

                                    timer.Once(gameTipDuration, () =>
                                    {
                                        player.SendConsoleCommand("gametip.hidegametip");
                                    });
                                }
                            }
                        }
                    }
                    if (useItem)
                    {
                        int amount = itemWinReward;
                        var item = ItemManager.CreateByName(itemName, amount, itemSkin);
                        var displayName = string.IsNullOrEmpty(itemCustomName) ? item.info.displayName.translated : itemCustomName;
                        item.name = displayName;
                        player.GiveItem(item);

                        if (useChat)
                        {
                            Player.Message(player, $"{string.Format(lang.GetMessage("Item Reward", this, player.UserIDString), displayName)}", Prefix, SteamIDIcon);
                        }
                        if (useGameTip)
                        {
                            player.SendConsoleCommand("gametip.showgametip", $"{string.Format(lang.GetMessage("Item Reward", this, player.UserIDString), displayName)}", gameTipDuration);

                            timer.Once(gameTipDuration, () =>
                            {
                                player.SendConsoleCommand("gametip.hidegametip");
                            });
                        }
                    }
                    if (useCommand)
                    {
                        var formattedCommand = commandToExecute.Replace("{playerId}", player.UserIDString);
                        Server.Command(formattedCommand);

                        if (useChat)
                        {
                            Player.Message(player, $"{string.Format(lang.GetMessage("Command Reward", this, player.UserIDString), commandName)}", Prefix, SteamIDIcon);
                        }
                        if (useGameTip)
                        {
                            player.SendConsoleCommand("gametip.showgametip", $"{string.Format(lang.GetMessage("Command Reward", this, player.UserIDString), commandName)}", gameTipDuration);

                            timer.Once(gameTipDuration, () =>
                            {
                                player.SendConsoleCommand("gametip.hidegametip");
                            });
                        }
                    }
                    LogWinner(player.displayName);

                    number = 0;
                    eventActive = false;
                    playerInfo.Clear();
                    eventTimer.Destroy();
                    autoRepeatTimer = timer.Repeat(autoEventTime, 0, () => StartEvent());
                }
                else
                {
                    playerInfo[player.userID]++;
                    if (useChat)
                    {
                        Player.Message(player, $"{string.Format(lang.GetMessage("Wrong Number", this, player.UserIDString), (playerInfo[player.userID] - maxTries))}", Prefix, SteamIDIcon);
                    }
                    if (useGameTip)
                    {
                        player.SendConsoleCommand("gametip.showgametip", $"{string.Format(lang.GetMessage("Wrong Number", this, player.UserIDString), (playerInfo[player.userID] - maxTries))}", gameTipDuration);

                        timer.Once(gameTipDuration, () =>
                        {
                            player.SendConsoleCommand("gametip.hidegametip");
                        });
                    }
                    if (hasEconomics)
                    {
                        if (useEconomics)
                        {
                            if (useEconomicsloss)
                            {
                                if ((bool)Economics?.Call("Deposit", (ulong)player.userID, (double)economicsLossReward))
                                {
                                    if (useChat)
                                    {
                                        Player.Message(player, $"{string.Format(lang.GetMessage("Economics loss Reward", this, player.UserIDString), economicsLossReward)}", Prefix, SteamIDIcon);
                                    }
                                    if (useGameTip)
                                    {
                                        player.SendConsoleCommand("gametip.showgametip", $"{string.Format(lang.GetMessage("Economics loss Reward", this, player.UserIDString), economicsLossReward)}", gameTipDuration);

                                        timer.Once(gameTipDuration, () =>
                                        {
                                            player?.SendConsoleCommand("gametip.hidegametip");
                                        });
                                    }
                                }
                            }
                        }
                    }

                    if (hasServerRewards)
                    {
                        if (useServerRewards)
                        {
                            if (useServerRewardsloss)
                            {
                                ServerRewards?.Call("AddPoints", (ulong)player.userID, (int)serverRewardsLossReward);
                                {
                                    if (useChat)
                                    {
                                        Player.Message(player, $"{string.Format(lang.GetMessage("ServerRewards loss Reward", this, player.UserIDString), serverRewardsLossReward)}", Prefix, SteamIDIcon);
                                    }
                                    if (useGameTip)
                                    {
                                        player.SendConsoleCommand("gametip.showgametip", $"{string.Format(lang.GetMessage("ServerRewards loss Reward", this, player.UserIDString), serverRewardsLossReward)}", gameTipDuration);

                                        timer.Once(gameTipDuration, () =>
                                        {
                                            player?.SendConsoleCommand("gametip.hidegametip");
                                        });
                                    }
                                }
                            }
                        }
                    }
                    if (hasBattlepass)
                    {
                        if (useBattlepass1)
                        {
                            if (useBattlepassloss)
                            {
                                Battlepass?.Call("AddFirstCurrency", (ulong)player.userID, battlepassLossReward1);
                                {
                                    if (useChat)
                                    {
                                        Player.Message(player, $"{string.Format(lang.GetMessage("Battlepass loss Reward1", this, player.UserIDString), battlepassLossReward1)}", Prefix, SteamIDIcon);
                                    }
                                    if (useGameTip)
                                    {
                                        player.SendConsoleCommand("gametip.showgametip", $"{string.Format(lang.GetMessage("Battlepass loss Reward1", this, player.UserIDString), battlepassLossReward1)}", gameTipDuration);

                                        timer.Once(gameTipDuration, () =>
                                        {
                                            player?.SendConsoleCommand("gametip.hidegametip");
                                        });
                                    }
                                }
                            }
                        }

                        if (useBattlepass2)
                        {
                            if (useBattlepassloss)
                            {
                                Battlepass?.Call("AddSecondCurrency", (ulong)player.userID, battlepassWinReward2);
                                {
                                    if (useChat)
                                    {
                                        Player.Message(player, $"{string.Format(lang.GetMessage("Battlepass loss Reward2", this, player.UserIDString), battlepassLossReward2)}", Prefix, SteamIDIcon);
                                    }
                                    if (useGameTip)
                                    {
                                        player.SendConsoleCommand("gametip.showgametip", $"{string.Format(lang.GetMessage("Battlepass loss Reward2", this, player.UserIDString), battlepassLossReward2)}", gameTipDuration);

                                        timer.Once(gameTipDuration, () =>
                                        {
                                            player?.SendConsoleCommand("gametip.hidegametip");
                                        });
                                    }
                                }
                            }
                        }
                    }
                    if (hasSkillTree)
                    {
                        if (useSkillTreeloss)
                        {
                            SkillTree?.Call("AwardXP", (ulong)player.userID, (double)skillTreeLossReward);
                            {
                                if (useChat)
                                {
                                    Player.Message(player, $"{string.Format(lang.GetMessage("SkillTree loss Reward", this, player.UserIDString), skillTreeLossReward)}", Prefix, SteamIDIcon);
                                }
                                if (useGameTip)
                                {
                                    player.SendConsoleCommand("gametip.showgametip", $"{string.Format(lang.GetMessage("SkillTree loss Reward", this, player.UserIDString), skillTreeLossReward)}", gameTipDuration);

                                    timer.Once(gameTipDuration, () =>
                                    {
                                        player?.SendConsoleCommand("gametip.hidegametip");
                                    });
                                }
                            }
                        }
                    }
                    if (hasXPerince)
                    {
                        if (useXPerienceloss)
                        {
                            XPerience?.Call("GiveXP", player, (double)xPerienceLossReward);
                            {
                                if (useChat)
                                {
                                    Player.Message(player, $"{string.Format(lang.GetMessage("XPerience loss Reward", this, player.UserIDString), xPerienceLossReward)}", Prefix, SteamIDIcon);
                                }
                                if (useGameTip)
                                {
                                    player.SendConsoleCommand("gametip.showgametip", $"{string.Format(lang.GetMessage("XPerience loss Reward", this, player.UserIDString), xPerienceLossReward)}", gameTipDuration);

                                    timer.Once(gameTipDuration, () =>
                                    {
                                        player?.SendConsoleCommand("gametip.hidegametip");
                                    });
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                if (useChat)
                {
                    Player.Message(player, $"{lang.GetMessage("/guess Invalid Syntax", this, player.UserIDString)}", Prefix, SteamIDIcon);
                }
                if (useGameTip)
                {
                    player.ShowToast(GameTip.Styles.Red_Normal, $"{lang.GetMessage("/guess Invalid Syntax", this, player.UserIDString)}");
                }
            }
            return;
        }

        void StartEvent()
        {
            if (eventActive)
            {
                return;
            }
            if (number == 0)
            {
                return;
            }
            else
            {
                if (useChat)
                {
                    SendMessageToActivePlayers($"{string.Format(lang.GetMessage("Event Started", this), minNumber, maxNumber)}");
                }
                if (useGameTip)
                {
                    SendToastToActivePlayers($"{string.Format(lang.GetMessage("Event Started", this), minNumber, maxNumber)}");
                }
                Puts($"Started a random game and the number to guess is {number.ToString()}");
                eventActive = true;
                eventTimer = timer.Once(eventLength, () =>
                {
                    if (useChat)
                    {
                        SendMessageToActivePlayers($"{string.Format(lang.GetMessage("Event Timed Out", this), number)}");
                    }
                    if (useGameTip)
                    {
                        SendToastToActivePlayers($"{string.Format(lang.GetMessage("Event Timed Out", this), number)}");
                    }
                    eventActive = false;
                    playerInfo.Clear();
                });
            }
        }

        string DoHelpMenu()
        {
            StringBuilder x = new StringBuilder();
            x.AppendLine(msg("Help Message"));
            x.AppendLine(msg("Help Message1"));
            x.AppendLine(msg("Help Message2"));
            return x.ToString().TrimEnd();
        }

        bool IsNumber(string str)
        {
            foreach (char c in str)
                if (c < '0' || c > '9')
                    return false;
            return true;
        }

        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        string msg(string key, string id = null) => lang.GetMessage(key, this, id);

        void SendToastToActivePlayers(string messageKey)
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player != null)
                {
                    player.SendConsoleCommand("gametip.showgametip", lang.GetMessage(messageKey, this, player.UserIDString), gameTipDuration);

                    timer.Once(gameTipDuration, () =>
                    {
                        player?.SendConsoleCommand("gametip.hidegametip");
                    });
                }
            }
        }
        void SendMessageToActivePlayers(string messageKey)
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player != null)
                {
                    Player.Message(player, lang.GetMessage(messageKey, this, player.UserIDString), Prefix, SteamIDIcon);
                }
            }
        }

        [ConsoleCommand("gtn_wipe")]
        private void WipeData(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null)
            {
                ResetData();
            }
        }

        public class Data
        {
            public Dictionary<string, int> Winners { get; set; } = new Dictionary<string, int>();
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("GuessTheNumber_Data", data);
        }

        private void LoadData()
        {
            data = Interface.Oxide.DataFileSystem.ReadObject<Data>("GuessTheNumber_Data") ?? new Data();
        }

        private void ResetData()
        {
            data = new Data();
            SaveData();
            Puts("All Guess The Number data has been reset...");
        }

        void OnNewSave()
        {
            ResetData();
        }

        private void LogWinner(string playerName)
        {
            if (data.Winners.ContainsKey(playerName))
            {
                data.Winners[playerName]++;
            }
            else
            {
                data.Winners[playerName] = 1;
            }
            SaveData();
        }

        private Dictionary<string, int> GetWinners()
        {
            return data.Winners;
        }

        private List<KeyValuePair<string, int>> GetTopWinners()
        {
            var winners = GetWinners();
            var sortedWinners = new List<KeyValuePair<string, int>>(winners);
            sortedWinners.Sort((pair1, pair2) => pair2.Value.CompareTo(pair1.Value));
            return sortedWinners.Take(10).ToList();
        }

        private void TopCommand(BasePlayer player, string cmd)
        {
            if (player != null)
            {
                GuessTheNumberUI(player);
            }
        }

        private HashSet<BasePlayer> UiPlayers = new HashSet<BasePlayer>();

        [ConsoleCommand("guessnumber.close")]
        private void CloseGuessTheNumberUI(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null)
            {
                CuiHelper.DestroyUi(player, "GuessTheNumberUI");
                UiPlayers.Remove(player);
            }
        }

        private void killUI()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, "GuessTheNumberUI");
            }
        }

        private void GuessTheNumberUI(BasePlayer player)
        {
            if (!UiPlayers.Contains(player))
            {
                UiPlayers.Add(player);
            }

            CuiHelper.DestroyUi(player, "GuessTheNumberUI");

            var cuiElements = new CuiElementContainer();

            cuiElements.Add(new CuiPanel
            {
                Image = { Color = "0.70 0.67 0.65 0.3", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-250 -208", OffsetMax = "250 208" },
                CursorEnabled = true
            },
            "Overlay", "GuessTheNumberUI");

            cuiElements.Add(new CuiElement
            {
                Parent = "GuessTheNumberUI",
                Name = "BackGround",
                Components = { new CuiImageComponent { Material = "assets/icons/iconmaterial.mat", Sprite = "assets/content/ui/ui.background.transparent.radial.psd", Color = "0 0 0 0" }, new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-250 -208", OffsetMax = "250 208" }, },
            });

            cuiElements.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-840 -445", OffsetMax = "840 445" }
            },
            "GuessTheNumberUI", "GuessTheNumberUIOffset");

            cuiElements.Add(new CuiPanel
            {
                Image = { Color = "0.1529412 0.1411765 0.1137255 1", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                RectTransform = { AnchorMin = "0.35 0.25", AnchorMax = "0.65 0.75" }
            },
            "GuessTheNumberUIOffset", "GuessTheNumberUIMainBk");

            cuiElements.Add(new CuiPanel
            {
                Image = { Color = "0.1686275 0.1607843 0.1411765 0.9", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                RectTransform = { AnchorMin = "0.02 0.05", AnchorMax = "0.979 0.90" }
            },
            "GuessTheNumberUIMainBk", "GuessTheNumberUIMainIS");

            cuiElements.Add(new CuiElement
            {
                Parent = "GuessTheNumberUIMainBk",
                Name = "TEXT",
                Components = { new CuiTextComponent { Text = lang.GetMessage("UI_TITLE", this, player.UserIDString), FontSize = 30, Align = TextAnchor.MiddleCenter, Color = "0.9686275 0.9215686 0.8823529 0.7", Font = "robotocondensed-bold.ttf" }, new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "1 1.4", OffsetMin = "0 0", OffsetMax = "0 0" } },
            });

            cuiElements.Add(new CuiButton
            {
                Button = { Command = "guessnumber.close", Color = "0.8 0.28 0.2 1", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                RectTransform = { AnchorMin = "0.92 0.92", AnchorMax = "0.98 0.98" },
            }, "GuessTheNumberUIMainBk", "GuessTheNumberUIClose");

            cuiElements.Add(new CuiElement
            {
                Parent = "GuessTheNumberUIClose",
                Name = "GuessTheNumberUICloseIcon",
                Components = { new CuiImageComponent { Material = "assets/icons/iconmaterial.mat", Sprite = "assets/icons/close.png", Color = "0.729 0.694 0.658 1" }, new CuiRectTransformComponent { AnchorMin = "0.3 0.3", AnchorMax = "0.7 0.7" } },
            });

            cuiElements.Add(new CuiLabel
            {
                Text = { Text = lang.GetMessage("UI_TOP_TEXT", this, player.UserIDString), FontSize = 20, Align = TextAnchor.MiddleCenter, Color = "0.9686275 0.9215686 0.8823529 0.7", Font = "robotocondensed-bold.ttf" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 320" }
            }, "GuessTheNumberUIMainIS");

            var topWinners = GetTopWinners();
            if (topWinners.Count == 0)
            {
                cuiElements.Add(new CuiLabel
                {
                    Text = { Text = lang.GetMessage("UI_NO_PLAYERS", this, player.UserIDString), FontSize = 18, Align = TextAnchor.MiddleCenter, Color = "0.9686275 0.9215686 0.8823529 0.7", Font = "robotocondensed-bold.ttf" },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" }
                }, "GuessTheNumberUIMainIS");
            }
            else
            {
                float topPosition = 0.85f;
                float heightStep = 0.08f;

                for (int i = 0; i < topWinners.Count; i++)
                {
                    var winner = topWinners[i];
                    cuiElements.Add(new CuiLabel
                    {
                        Text = { Text = string.Format(lang.GetMessage("UI_PLAYERS", this, player.UserIDString), i + 1, winner.Key, winner.Value), FontSize = 17, Align = TextAnchor.MiddleCenter, Color = "0.9686275 0.9215686 0.8823529 0.7", },
                        RectTransform = { AnchorMin = $"0 {(topPosition - (i + 1) * heightStep)}", AnchorMax = $"1 {(topPosition - i * heightStep)}" }
                    }, "GuessTheNumberUIMainIS");
                }
            }
            CuiHelper.AddUi(player, cuiElements);
        }
    }
}

// --- End of file: GuessTheNumber.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/gr-teleport ---
// --- Original File Path: G/GrTeleport/GrTeleport.cs ---

using Facepunch;
using Oxide.Core;
using Oxide.Core.Libraries;
using Newtonsoft.Json;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Reflection;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Gr Teleport", "carny666", "1.0.3")]
    [Description("Allows teleportation using the map grid reference and death reference")]
    class GrTeleport : RustPlugin
    {
        #region constants
        const float calgon = 0.0066666666666667f;

        #endregion

        #region permissions
        private const string adminPermission = "GrTeleport.admin";
        private const string grtPermission = "GrTeleport.use";
        #endregion

        #region local variabls / supporting classes
        GrTeleportData grTeleportData;

        int lastGridTested = 0;
        List<SpawnPosition> spawnGrid = new List<SpawnPosition>();
        List<Cooldown> coolDowns = new List<Cooldown>();
        List<RustUser> rustUsers = new List<RustUser>();
        List<DeathNotice> pendingDeathNotice = new List<DeathNotice>();

        private bool debug = false;

        class GrTeleportData
        {
            public int CooldownInSeconds { get; set; }
            public bool AvoidWater { get; set; }
            public bool AllowBuildingBlocked { get; set; }
            public bool AllowOffCargoship { get; set; }
            public int LimitPerDay { get; set; }
            public string RestrictedZones { get; set; }
            public int DistanceToWarnConstructions { get; set; }
            public float AllowableWaterDepth { get; set; }
            public bool DisplayDeathLocation { get; set; }
            public int SecondsBeforeTeleport { get; set; }
            public float MinHealthForTeleport { get; set; }
            public float MinThirstForTeleport { get; set; }
            public float MinHungerForTeleport { get; set; }
            public float MinTemperatureForTeleport { get; set; }
            public float MaxTemperatureForTeleport { get; set; }
            public Dictionary<string, GroupData> groupData = new Dictionary<string, GroupData>();
        }

        class SpawnPosition
        {
            const float aboveGoundPosition = 2.5f;

            public Vector3 Position;
            public Vector3 GroundPosition;
            public string GridReference;

            public SpawnPosition(Vector3 position)
            {
                Position = position;
                GroundPosition = GetGroundPosition(new Vector3(position.x, 25, position.z));
            }

            public bool isPositionAboveWater()
            {
                if ((TerrainMeta.HeightMap.GetHeight(Position) - TerrainMeta.WaterMap.GetHeight(Position)) >= 0)
                    return false;
                return true;
            }

            public float WaterDepthAtPosition()
            {
                return (TerrainMeta.WaterMap.GetHeight(Position) - TerrainMeta.HeightMap.GetHeight(Position));
            }

            Vector3 GetGroundPosition(Vector3 sourcePos)
            {
                RaycastHit hitInfo;
                if (Physics.Raycast(sourcePos, Vector3.down, out hitInfo))
                    sourcePos.y = hitInfo.point.y;

                if (TerrainMeta.HeightMap != null)
                    sourcePos.y = Mathf.Max(sourcePos.y, TerrainMeta.HeightMap.GetHeight(sourcePos)) + aboveGoundPosition;

                return sourcePos;
            }

        }

        class Cooldown
        {
            public string name;
            public int cooldownPeriodSeconds;
            public DateTime lastUse;
            public DateTime expirtyDateTime;

            public Cooldown(string PlayerName, int CoolDownInSeconds)
            {
                name = PlayerName;
                cooldownPeriodSeconds = CoolDownInSeconds;
                lastUse = DateTime.Now;
                expirtyDateTime = lastUse.AddSeconds(cooldownPeriodSeconds);
            }

        }

        class RustUser
        {
            public BasePlayer Player { get; set; }
            public int TeleportsRemaining { get; set; }
            public DateTime ResetDateTime { get; set; }
            public int CoolDownInSeconds { get; set; }
            public bool isWaitingForTeleport { get; set; }
        }

        class GroupData
        {
            public int coolDownPeriodSeconds { get; set; }
            public int dailyTeleports { get; set; }
            public string groupName { get; set; }
            public int SecondsBeforeTeleport { get; set; }
            public float MinHealthForTeleport { get; set; }
            public float MinThirstForTeleport { get; set; }
            public float MinHungerForTeleport { get; set; }
            public float MinTemperatureForTeleport { get; set; }
            public float MaxTemperatureForTeleport { get; set; }
        }

        class DeathNotice
        {
            public BasePlayer Player { get; set; }
            public Vector3 DeathLocation { get; set; }
            public string DeathGridReference { get; set; }
        }

        #endregion

        #region events

        void Init()
        {
            grTeleportData = Config.ReadObject<GrTeleportData>();
            if (Config["Messages"] != null)
                Config.WriteObject(grTeleportData, true);
                
            permission.RegisterPermission(adminPermission, this);
            permission.RegisterPermission(grtPermission, this);

            try
            {
                spawnGrid = CreateSpawnGrid();
            }
            catch (Exception ex)
            {
                throw new Exception($"Error: Loaded {ex.Message}");
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "buildingblocked", "You cannot grTeleport into or out from a building blocked area." },
                { "cargoship", "You cannot grTeleport off the Cargoship." },
                { "CannotGridTeleport", "You cannot grTeleport to this position." },
                { "noinit", "spawnGrid was not initialized. 0 spawn points available." },
                { "teleported", "You have GrTeleported to {gridreference}, {position}. You're {groupname}, so you have a {cooldown} second cooldown between uses and {limit} grTeleports." }, // {gridreference}
                { "teleportlimit", "You have {teleportsremaining} remaining." }, // {teleportsremaining}
                { "teleportminutesexhauseted", "You have exhausted your remaining grTeleports for today. You can use grTeleport in {minutesleft} minutes." },  // minutesleft hoursleft
                { "teleporthoursexhauseted", "You have exhausted your remaining grTeleports for today. You can use grTeleport in {hoursleft} hours." },  // minutesleft hoursleft
                { "overwater", "That refernce point is above water." },
                { "cmdusage", "usage ex: /grt n10  (where n = a-zz and 10=0-60" },
                { "noaccess", "You do not have sufficient access to execute this command." },
                { "sgerror", "Error creating spawnpoints, too much water? contact dev." },
                { "cooldown", "Sorry, your are currently in a {cooldownperiod} second cooldown, you have another {secondsleft} seconds remaining." }, // {cooldownperiod} {secondsleft}
                { "cooldownreply", "Cooldown has been set to {cooldownperiod} seconds" },
                { "gridwidthreply", "Gridwidth has been set to {gridwidth}x{gridwidth}" },
                { "cuboardreply", "Buidling block teleportation is {togglebuildingblocked}" },
                { "cargoreply", "Cargoship teleportation is {togglecargoship}" },
                { "avoidwaterreply", "Avoid water has been set tp {avoidwater}" },
                { "dailylimitreply", "Daily limit has been set to {dailylimit}." },
                { "cupboard", "Sorry, you cannot teleport within {distance} of a cupboard." },
                { "zoneadded", "Restricted Zone ({zone}) has been added, you now have {zones}." },
                { "zonenotadded", "You need to enter a zone (or a comma seperated list of zones) as well." },
                { "restrictedzone", "You cannot teleport here, {zone} is restricted." },
                { "zonecomma", "You need to supply a commaseperated list of zones." },
                { "zonesadded", "Restricted Zones ({zone}) have been added, you now have {zones}." },
                { "zonenotremoved", "Restricted Zone ({zone}) has not been removed, you now have {zones}." },
                { "zoneremoved", "Restricted Zone ({zone}) have been removed, you now have {zones}." },
                { "zonesremoved", "Restricted Zones ({zone}) have been removed, you now have {zones}." },
                { "nozones", "There are no zones to remove." },
                { "buildonref", "Your construction is within the vicinty of a grTransport reference. You may want to reconsider building here within {amount}m. your are now {distance}." },
                { "constructionreply", "Construction/Grid Reference distance has been set to {DistanceToWarnConstructions}m." },
                { "setgroupusage", "type /setgroup groupName 30 10 - where 30 is cooldown and 10 is daily teleport limit." },
                { "setgroupusageerror", "Must have 3 arguments. /setgroup groupName 30 10" },
                { "setwaterdepthreply", "Allowable water depth has been set to {waterdepth}" },
                { "setwaterdeptherror", "usage: /setwaterdepth 1.0" },
                { "togglecargoshipreply", "Cargoship has been toggled to {displayCargoship}" },
                { "toggleDeathMessagereply", "Death message has been toggled to {displayDeath}" },
                { "clearingallzones", "Clearing all zones from restricted." },
                { "addingallzones", "Adding all zones as restricted." },
                { "delaymessage", "You will be teleported in {seconds} seconds." },
                { "thirstymessage", "You are too thirsty to be teleported, get some water." },
                { "hungrymessage", "You are too hungry to be teleported, get some food." },
                { "woundedmessage", "You wounded, you cannot be teleported, get some medical attention." },
                { "coldmessage", "You are too cold ({temperature}) to be teleported, get warmer." },
                { "hotmessage", "You are too hot ({temperature}>{toohot}) to be teleported, cool off." },
                { "radiatedmessage", "You are radiated, you cannot to be teleported, find some meds or water." },
                { "alreadywaitingmessage", "You are already waiting to teleport." },
                { "nogroups", "There are not groups to list." }
            }, this);
        }

        void OnEntityBuilt(Planner plan, GameObject go)
        {
            try
            {
                var amount = grTeleportData.DistanceToWarnConstructions;
                foreach (SpawnPosition sp in spawnGrid)
                {
                    var distance = Vector3.Distance(sp.GroundPosition, GetActualGroundPosition(plan.GetOwnerPlayer().transform.position));

                    if (distance <= amount)
                    {
                        PrintToChat(plan.GetOwnerPlayer(), lang.GetMessage("buildonref", this, plan.GetOwnerPlayer().UserIDString).Replace("{amount}", amount.ToString()).Replace("{distance}", distance.ToString("0.0")));
                        return;
                    }
                }
            }
            catch (Exception ex)
            {
                PrintError($"{ex.Message}");
            }

        }

        protected override void LoadDefaultConfig()
        {
            var data = new GrTeleportData
            {
                CooldownInSeconds = 15,
                AvoidWater = true,
                AllowBuildingBlocked = false,
                AllowOffCargoship = false,
                LimitPerDay = -1, // -1 = unlim
                RestrictedZones = "ZZZ123,YYY666",
                DistanceToWarnConstructions = 15,
                AllowableWaterDepth = 1.0f,
                DisplayDeathLocation = true,
                SecondsBeforeTeleport = 10,
                MinHealthForTeleport = 40,
                MinThirstForTeleport = 40,
                MinTemperatureForTeleport = 0,
                MaxTemperatureForTeleport = 40,
                MinHungerForTeleport = 40,
                groupData = new Dictionary<string, GroupData>()
            };
            Config.WriteObject(data, true);
        }

        void OnEntityDeath(BaseEntity entity, HitInfo info)
        {
            try
            {
                if (!grTeleportData.DisplayDeathLocation) return;

                if (entity is BasePlayer)
                    pendingDeathNotice.Add(new DeathNotice { Player = entity.ToPlayer(), DeathLocation = entity.transform.position, DeathGridReference = GetGridReference(entity.transform.position) });

            }
            catch (Exception ex)
            {
                PrintError("Error OnEntityDeath " + ex.StackTrace);
            }
        }

        void OnPlayerRespawned(BasePlayer player)
        {
            if (!grTeleportData.DisplayDeathLocation) return;

            var deathNotice = pendingDeathNotice.Find(x => x.Player == player);
            if (deathNotice != null)
            {
                pendingDeathNotice.Remove(deathNotice);
                PrintToChat(player, "You died " + deathNotice.DeathGridReference);
            }

        }

        #endregion

        #region commands
        [ChatCommand("grt")]
        void chatCommandGrt(BasePlayer player, string command, string[] args)
        {
            try
            {
                if (args.Length > 0)
                {
                    var gridReference = args[0];
                    var userGroupData = GetUsersGroupDataOrDefault(player);

                    if (userGroupData == null && !player.IsAdmin)
                    {
                        CheckAccess(player, "grt", "userGroupDataNull", true);
                        return;
                    }

                    var user = GetOrCreateUser(player, userGroupData);

                    if (user.isWaitingForTeleport && !player.IsAdmin)
                    {
                        PrintToChat(player, lang.GetMessage("alreadywaitingmessage", this, player.UserIDString));
                        return;
                    }

                    if (user.TeleportsRemaining == 0 && !player.IsAdmin)
                    {
                        if ((user.ResetDateTime - DateTime.Now).TotalHours < 1)
                            PrintToChat(player, lang.GetMessage("teleportminutesexhauseted", this, player.UserIDString).Replace("{minutesleft}", (user.ResetDateTime - DateTime.Now).TotalMinutes.ToString("0")).Replace("{hoursleft}", (user.ResetDateTime - DateTime.Now).TotalHours.ToString("0")));
                        else
                            PrintToChat(player, lang.GetMessage("teleporthoursexhauseted", this, player.UserIDString).Replace("{minutesleft}", (user.ResetDateTime - DateTime.Now).TotalMinutes.ToString("0")).Replace("{hoursleft}", (user.ResetDateTime - DateTime.Now).TotalHours.ToString("0")));
                        return;
                    }

                    var tmp = GetCooldown(player.displayName);
                    if (tmp != null && !player.IsAdmin)
                    {
                        PrintToChat(player, lang.GetMessage("cooldown", this, player.UserIDString).Replace("{cooldownperiod}", tmp.cooldownPeriodSeconds.ToString()).Replace("{secondsleft}", tmp.expirtyDateTime.Subtract(DateTime.Now).TotalSeconds.ToString("0")));
                        return;
                    }

                    if (TestRestrictedZone(gridReference) && !player.IsAdmin)
                    {
                        PrintToChat(player, lang.GetMessage("restrictedzone", this, player.UserIDString).Replace("{zone}", gridReference.ToUpper()));
                        return;
                    }

                    if (spawnGrid == null || spawnGrid.Count <= 0)
                        spawnGrid = CreateSpawnGrid();

                    if (!TestCanGrtTeleport(player, gridReference)) return;

                    var delay = (player.IsAdmin) ? 0 : grTeleportData.SecondsBeforeTeleport;

                    if (delay > 1)
                        PrintToChat(player, lang.GetMessage("delaymessage", this, player.UserIDString).Replace("{seconds}", delay.ToString()));

                    user.isWaitingForTeleport = true;

                    timer.Once(delay, () =>
                    {
                        user.isWaitingForTeleport = false;
                        if (!TestCanGrtTeleport(player, gridReference)) return;

                        if (TeleportToGridReference(player, gridReference, false))
                        {
                            if (user.TeleportsRemaining != -1)
                                user.TeleportsRemaining--;

                            PrintToChat(player, lang.GetMessage("teleported", this, player.UserIDString)
                                .Replace("{position}", player.transform.position.ToString())
                                .Replace("{gridreference}", gridReference.ToUpper())
                                .Replace("{groupname}", userGroupData.groupName)
                                .Replace("{cooldown}", userGroupData.coolDownPeriodSeconds.ToString())
                                .Replace("{limit}", ((userGroupData.dailyTeleports == -1) ? "unlimited" : userGroupData.dailyTeleports.ToString())));

                            if (user.TeleportsRemaining != -1)
                                PrintToChat(player, lang.GetMessage("teleportlimit", this, player.UserIDString)
                                    .Replace("{teleportsremaining}", user.TeleportsRemaining.ToString()));

                            AddToCoolDown(player.displayName, userGroupData.coolDownPeriodSeconds);
                        }
                    });
                    return;
                }
            }
            catch (Exception ex)
            {
                PrintError($"Error chatCommandGrt:{ex.Message}");
                return;
            }

            PrintToChat(player, lang.GetMessage("cmdusage", this, player.UserIDString));
        }

        [ConsoleCommand("grt.testpos")]
        void ccGrtTestPos(ConsoleSystem.Arg arg)
        {
            try
            {
                if (arg.Player() == null) return;

                BasePlayer player = arg.Player();
                if (!CheckAccess(player, "grt.testpos", adminPermission)) return;
                PrintToChat(player, GetGridReference(player.transform.position));
            }
            catch (Exception ex)
            {
                throw new Exception($"ccGrtTestPos {ex.Message}");

            }
        }

        [ConsoleCommand("grt.nextspawn")]
        void ccGrtNextspawn(ConsoleSystem.Arg arg)
        {
            try
            {
                if (arg.Player() == null) return;

                BasePlayer player = arg.Player();

                if (spawnGrid.Count <= 0)
                    throw new Exception(lang.GetMessage("noinit", this, player.UserIDString));

                if (!CheckAccess(player, "grt.nextspawn", adminPermission)) return;

                do
                {
                    if (++lastGridTested >= spawnGrid.Count) lastGridTested = 0;
                } while (spawnGrid[lastGridTested].isPositionAboveWater());

                Teleport(player, spawnGrid[lastGridTested].GroundPosition, false);

                PrintToChat(player, lang.GetMessage("teleported", this, player.UserIDString)
                    .Replace("{gridreference}", spawnGrid[lastGridTested].GridReference)
                    .Replace("{position}", player.transform.position.ToString()));
            }
            catch (Exception ex)
            {
                throw new Exception($"ccGrtNextspawn {ex.Message}");
            }
        }

        [ConsoleCommand("grt.prevspawn")]
        void ccGrtPrevspawn(ConsoleSystem.Arg arg)
        {
            try
            {
                if (arg.Player() == null) return;

                BasePlayer player = arg.Player();

                if (spawnGrid.Count <= 0)
                    throw new Exception(lang.GetMessage("noinit", this, player.UserIDString));

                if (!CheckAccess(player, "grt.prevspawn", adminPermission)) return;

                do
                {
                    if (--lastGridTested < 0) lastGridTested = spawnGrid.Count - 1;
                } while (spawnGrid[lastGridTested].isPositionAboveWater());

                Teleport(player, spawnGrid[lastGridTested].GroundPosition, false);

                PrintToChat(player, lang.GetMessage("teleported", this, player.UserIDString)
                    .Replace("{gridreference}", spawnGrid[lastGridTested].GridReference)
                    .Replace("{position}", player.transform.position.ToString()));
            }
            catch (Exception ex)
            {
                throw new Exception($"ccGrtPrevspawn {ex.Message}");
            }
        }

        [ChatCommand("setcooldown")]
        void chmSetCooldown(BasePlayer player, string command, string[] args)
        {
            try
            {
                if (!CheckAccess(player, "setcooldown", adminPermission)) return;
                if (args.Length > 0)
                    grTeleportData.CooldownInSeconds = int.Parse(args[0]);

                coolDowns.Clear();

                Config.WriteObject(grTeleportData, true);
                PrintToChat(player, lang.GetMessage("cooldownreply", this, player.UserIDString).Replace("{cooldownperiod}", grTeleportData.CooldownInSeconds.ToString()));
            }
            catch (Exception ex)
            {
                throw new Exception($"chmSetCooldown {ex.Message}");
            }

        }

        [ChatCommand("setwaterdepth")]
        void chmsetwaterdepth(BasePlayer player, string command, string[] args)
        {
            try
            {
                if (!CheckAccess(player, "setwaterdepth", adminPermission)) return;
                try
                {
                    if (args.Length > 0)
                        grTeleportData.AllowableWaterDepth = float.Parse(args[0]);
                }
                catch (Exception ex)
                {
                    PrintToChat(player, lang.GetMessage("setwaterdeptherror", this, player.UserIDString)
                        .Replace("{waterdepth}", grTeleportData.AllowableWaterDepth.ToString("0.00")));
                }

                Config.WriteObject(grTeleportData, true);
                PrintToChat(player, lang.GetMessage("setwaterdepthreply", this, player.UserIDString)
                    .Replace("{waterdepth}", grTeleportData.AllowableWaterDepth.ToString("0.00")));
            }
            catch (Exception ex)
            {
                throw new Exception($"chmSetwaterdepth {ex.Message}");
            }

        }

        //DisplayDeathLocation
        [ChatCommand("toggledeathmessage")]
        void chmToggletoggledeathmessage(BasePlayer player, string command, string[] args)
        {
            try
            {
                if (!CheckAccess(player, "toggleavoidwater", adminPermission)) return;
                grTeleportData.DisplayDeathLocation = !grTeleportData.DisplayDeathLocation;
                Config.WriteObject(grTeleportData, true);
                PrintToChat(player, lang.GetMessage("toggleDeathMessagereply", this, player.UserIDString).Replace("{displayDeath}", grTeleportData.DisplayDeathLocation.ToString()));
            }
            catch (Exception ex)
            {
                throw new Exception($"chmToggletoggledeathmessage {ex.Message}");
            }

        }

        [ChatCommand("setconstruction")]
        void chmSetconstruction(BasePlayer player, string command, string[] args)
        {
            try
            {
                if (!CheckAccess(player, "setconstruction", adminPermission)) return;
                if (args.Length > 0)
                    grTeleportData.DistanceToWarnConstructions = int.Parse(args[0]);

                coolDowns.Clear();

                Config.WriteObject(grTeleportData, true);
                PrintToChat(player, lang.GetMessage("constructionreply", this, player.UserIDString).Replace("{DistanceToWarnConstructions}", grTeleportData.DistanceToWarnConstructions.ToString()));
            }
            catch (Exception ex)
            {
                throw new Exception($"chmSetconstruction {ex.Message}");
            }
        }

        [ChatCommand("setdailylimit")]
        void chmSetDailyLimit(BasePlayer player, string command, string[] args)
        {
            try
            {
                if (!CheckAccess(player, "setdailylimit", adminPermission)) return;
                if (args.Length > 0)
                    grTeleportData.LimitPerDay = int.Parse(args[0]);

                rustUsers.Clear(); // This is suspect.. ??

                Config.WriteObject(grTeleportData, true);
                PrintToChat(player, lang.GetMessage("dailylimitreply", this, player.UserIDString).Replace("{dailylimit}", grTeleportData.LimitPerDay.ToString()));
            }
            catch (Exception ex)
            {
                throw new Exception($"chmSetDailyLimit {ex.Message}");
            }
        }

        [ChatCommand("addzone")]
        void chmAddzone(BasePlayer player, string command, string[] args)
        {
            try
            {
                if (!CheckAccess(player, "chmAddzone", adminPermission)) return;
                if (args.Length > 0)
                {
                    if (string.IsNullOrEmpty(grTeleportData.RestrictedZones))
                        grTeleportData.RestrictedZones = "";

                    if (args[0].Contains(","))
                    {
                        foreach (var z in args[0].ToUpper().Split(','))
                        {
                            if (grTeleportData.RestrictedZones.Length > 0)
                                grTeleportData.RestrictedZones += $",{z}";
                            else
                                grTeleportData.RestrictedZones += $"{z}";
                        }
                        Config.WriteObject(grTeleportData, true);
                        PrintToChat(player, lang.GetMessage("zoneadded", this, player.UserIDString).Replace("{zone}", args[0].ToUpper()).Replace("{zones}", grTeleportData.RestrictedZones.Replace("ZZZ123,YYY666,", "")));
                    }
                    else
                    {
                        if (grTeleportData.RestrictedZones.Length > 0)
                            grTeleportData.RestrictedZones += $",{args[0].ToUpper()}";
                        else
                            grTeleportData.RestrictedZones += $"{args[0].ToUpper()}";

                        Config.WriteObject(grTeleportData, true);
                        PrintToChat(player, lang.GetMessage("zonesadded", this, player.UserIDString).Replace("{zone}", args[0].ToUpper()).Replace("{zones}", grTeleportData.RestrictedZones.Replace("ZZZ123,YYY666,", "")));
                    }
                }
                else
                {
                    PrintToChat(player, lang.GetMessage("zonenotadded", this, player.UserIDString).Replace("{zones}", grTeleportData.RestrictedZones.Replace("ZZZ123,YYY666,", "")));
                }



            }
            catch (Exception ex)
            {
                throw new Exception($"chmSetCooldown {ex.Message}");
            }
        }

        [ChatCommand("removezone")]
        void chmRemoveZone(BasePlayer player, string command, string[] args)
        {
            try
            {
                if (!CheckAccess(player, "chmRemovezone", adminPermission)) return;
                if (args.Length > 0)
                {
                    if (string.IsNullOrEmpty(grTeleportData.RestrictedZones))
                    {
                        PrintToChat(player, lang.GetMessage("nozones", this, player.UserIDString));
                        return;
                    }
                    List<string> tmpZoneList = new List<string>(grTeleportData.RestrictedZones.Split(','));

                    if (args[0].Contains(","))
                    {
                        foreach (var z in args[0].ToUpper().Split(','))
                        {
                            if (tmpZoneList.Contains(z))
                                tmpZoneList.Remove(z);
                        }

                        grTeleportData.RestrictedZones = string.Join(",", tmpZoneList.ToArray());
                        Config.WriteObject(grTeleportData, true);
                        PrintToChat(player, lang.GetMessage("zonesremoved", this, player.UserIDString).Replace("{zone}", args[0].ToUpper()).Replace("{zones}", grTeleportData.RestrictedZones));
                    }
                    else
                    {
                        if (tmpZoneList.Contains(args[0].ToUpper()))
                            tmpZoneList.Remove(args[0].ToUpper());

                        grTeleportData.RestrictedZones = string.Join(",", tmpZoneList.ToArray());
                        Config.WriteObject(grTeleportData, true);
                        PrintToChat(player, lang.GetMessage("zoneremoved", this, player.UserIDString).Replace("{zone}", args[0].ToUpper()).Replace("{zones}", grTeleportData.RestrictedZones));
                    }
                }
                else
                {
                    PrintToChat(player, lang.GetMessage("zonenotremoved", this, player.UserIDString).Replace("{zones}", grTeleportData.RestrictedZones));
                }



            }
            catch (Exception ex)
            {
                throw new Exception($"chmSetCooldown {ex.Message}");
            }
        }

        [ChatCommand("clearzones")]
        void chmClearZones(BasePlayer player, string command, string[] args)
        {
            try
            {
                if (!CheckAccess(player, "chmClearZones", adminPermission)) return;

                List<string> tmpZoneList = new List<string>(grTeleportData.RestrictedZones.Split(','));

                if (string.IsNullOrEmpty(grTeleportData.RestrictedZones) || grTeleportData.RestrictedZones == "ZZZ123,YYY666")
                {
                    PrintToChat(player, lang.GetMessage("addingallzones", this, player.UserIDString));

                    foreach (SpawnPosition sp in spawnGrid)
                        tmpZoneList.Add(sp.GridReference);

                    grTeleportData.RestrictedZones = string.Join(",", tmpZoneList.ToArray());
                    Config.WriteObject(grTeleportData, true);

                    return;
                }
                else
                {
                    PrintToChat(player, $"{grTeleportData.RestrictedZones}");
                    PrintToChat(player, lang.GetMessage("clearingallzones", this, player.UserIDString));
                    grTeleportData.RestrictedZones = "ZZZ123,YYY666";

                }

            }
            catch (Exception ex)
            {
                throw new Exception($"chmClearZones {ex.Message}");
            }
        }

        [ChatCommand("togglebuildingblocked")]
        void chmtogglebuildingblocked(BasePlayer player, string command, string[] args)
        {
            try
            {
                if (!CheckAccess(player, "togglebuildingblocked", adminPermission)) return;
                grTeleportData.AllowBuildingBlocked = !grTeleportData.AllowBuildingBlocked;
                Config.WriteObject(grTeleportData, true);
                PrintToChat(player, lang.GetMessage("cuboardreply", this, player.UserIDString).Replace("{togglebuildingblocked}", grTeleportData.AllowBuildingBlocked.ToString()));
            }
            catch (Exception ex)
            {
                throw new Exception($"setcupboard {ex.Message}");
            }

        }

        [ChatCommand("togglecargoship")]
        void chmtogglecargoship(BasePlayer player, string command, string[] args)
        {
            try
            {
                if (!CheckAccess(player, "togglecargoship", adminPermission)) return;
                grTeleportData.AllowOffCargoship = !grTeleportData.AllowOffCargoship;
                Config.WriteObject(grTeleportData, true);
                PrintToChat(player, lang.GetMessage("cargoshipreply", this, player.UserIDString).Replace("{togglecargoship}", grTeleportData.AllowOffCargoship.ToString()));
            }
            catch (Exception ex)
            {
                throw new Exception($"setcargoship {ex.Message}");
            }

        }

        [ChatCommand("toggleavoidwater")]
        void chmSetAvoidWater(BasePlayer player, string command, string[] args)
        {
            try
            {
                if (!CheckAccess(player, "toggleavoidwater", adminPermission)) return;
                grTeleportData.AvoidWater = !grTeleportData.AvoidWater;
                Config.WriteObject(grTeleportData, true);
                PrintToChat(player, lang.GetMessage("avoidwaterreply", this, player.UserIDString).Replace("{avoidwater}", grTeleportData.AvoidWater.ToString()));
            }
            catch (Exception ex)
            {
                throw new Exception($"chmSetAvoidWater {ex.Message}");
            }

        }

        [ChatCommand("setgroup")]
        void chmSetGroup(BasePlayer player, string command, string[] args)
        {
            try
            {
                //if (!CheckAccess(player, "setgroup", adminPermission)) return;

                if (args.Length == 0) // help
                {
                    PrintToChat(player, lang.GetMessage("setgroupusage", this, player.UserIDString));
                    return;
                }

                string GroupName = "";
                int cooldownInSeconds = grTeleportData.CooldownInSeconds;
                int dailyLimit = grTeleportData.LimitPerDay;

                if (args.Length == 3) // set..
                {
                    try
                    {
                        GroupName = args[0];
                        cooldownInSeconds = int.Parse(args[1]);
                        dailyLimit = int.Parse(args[2]);
                    }
                    catch (Exception)
                    {
                        PrintToChat(player, lang.GetMessage("setgroupusageerror", this, player.UserIDString));
                        return;
                    }
                }
                else // bad comd, help
                {
                    PrintToChat(player, lang.GetMessage("setgroupusageerror", this, player.UserIDString));
                    return;
                }

                if (!grTeleportData.groupData.ContainsKey(GroupName))
                    grTeleportData.groupData.Add(GroupName, new GroupData
                    {
                        coolDownPeriodSeconds = cooldownInSeconds,
                        dailyTeleports = dailyLimit,
                        groupName = GroupName,
                        SecondsBeforeTeleport = grTeleportData.SecondsBeforeTeleport,
                        MinHealthForTeleport = grTeleportData.MinHealthForTeleport,
                        MinThirstForTeleport = grTeleportData.MinThirstForTeleport,
                        MinTemperatureForTeleport = grTeleportData.MinTemperatureForTeleport,
                        MaxTemperatureForTeleport = grTeleportData.MaxTemperatureForTeleport,
                        MinHungerForTeleport = grTeleportData.MinHungerForTeleport

                    });
                else
                {
                    grTeleportData.groupData[GroupName].coolDownPeriodSeconds = cooldownInSeconds;
                    grTeleportData.groupData[GroupName].dailyTeleports = dailyLimit;
                }
                Config.WriteObject(grTeleportData, true);
                PrintToChat(player, $"Saved {GroupName} cooldown:{grTeleportData.groupData[GroupName].coolDownPeriodSeconds} Limit:{grTeleportData.groupData[GroupName].dailyTeleports}.");
                //PrintToChat(player, lang.GetMessage("cooldownreply", this, player.UserIDString).Replace("{cooldownperiod}", grTeleportData.CooldownInSeconds.ToString()));
            }
            catch (Exception ex)
            {
                throw new Exception($"chmSetCooldown {ex.Message}");
            }

        }

        [ChatCommand("getgroups")]
        void chmGetGroups(BasePlayer player, string command, string[] args)
        {
            try
            {
                if (!CheckAccess(player, "getgroups", adminPermission)) return;

                if (grTeleportData.groupData.Count() < 1)
                {
                    PrintToChat(player, lang.GetMessage("nogroups", this, player.UserIDString));
                    return;
                }

                foreach (var g in grTeleportData.groupData)
                    PrintToChat(player, $"{g.Key} cooldown:{g.Value.coolDownPeriodSeconds} Limit:{g.Value.dailyTeleports}.");
                return;
            }
            catch (Exception ex)
            {
                throw new Exception($"chmGetGroup {ex.Message}");
            }

        }

        [ChatCommand("clearcooldown")]
        void chmClearCooldown(BasePlayer player, string command, string[] args)
        {
            try
            {
                if (!CheckAccess(player, "clearcooldown", adminPermission)) return;

                if (args.Length == 1)
                {
                    var cd = coolDowns.Find(x => x.name.ToLower().Contains(args[0].ToLower()));
                    if (cd != null)
                    {
                        coolDowns.Remove(cd);
                        PrintToChat($"Cleared cooldown for {cd.name}..");
                    }
                    else
                    {
                        PrintToChat($"{cd.name} not found.");
                    }
                    return;
                }
                coolDowns.Clear();
                PrintToChat($"Cleared Cooldowns");
                return;
            }
            catch (Exception ex)
            {
                throw new Exception($"chmClearCooldown {ex.Message}");
            }

        }

        [ChatCommand("clearlimit")]
        void chmClearLimit(BasePlayer player, string command, string[] args)
        {
            try
            {
                if (!CheckAccess(player, "clearlimit", adminPermission)) return;

                if (args.Length == 1)
                {
                    var cd = rustUsers.Find(x => x.Player.displayName.ToLower().Contains(args[0].ToLower()));
                    if (cd != null)
                    {
                        var userGroupData = GetUsersGroupDataOrDefault(cd.Player);
                        var user = GetOrCreateUser(cd.Player, userGroupData);
                        cd.TeleportsRemaining = userGroupData.dailyTeleports;
                        PrintToChat($"Cleared limit for {cd.Player.displayName}..");
                    }
                    else
                    {
                        PrintToChat($"{args[0]} not found.");
                    }
                    return;
                }
                coolDowns.Clear();
                PrintToChat($"Cleared Limits");
                return;
            }
            catch (Exception ex)
            {
                throw new Exception($"chmClearLimit {ex.Message}");
            }

        }

        #endregion

        #region API
        //[HookMethod("TeleportToGridReference")]
        private bool TeleportToGridReference(BasePlayer player, string gridReference, bool avoidWater = true)
        {
            try
            {
                var index = GridIndexFromReference(gridReference);
                if (avoidWater && spawnGrid[index].isPositionAboveWater()) return false;
                player.SetParent(null, 0);  // allows teleport off moving objects
                Teleport(player, spawnGrid[index].GroundPosition);
                return true;
            }
            catch (Exception ex)
            {
                throw new Exception($"TeleportToGridReference {ex.Message}");
            }

        }

        //[HookMethod("IsGridReferenceAboveWater")]
        private bool IsGridReferenceAboveWater(string gridReference)
        {
            try
            {
                var index = GridIndexFromReference(gridReference);
                return spawnGrid[index].isPositionAboveWater();
            }
            catch (Exception ex)
            {
                throw new Exception($"IsGridReferenceAboveWater {ex.Message}");
            }

        }
        #endregion

        #region supporting fuctions

        string GetGridReference(Vector3 position)
        {
            try
            {
                var distance = float.MaxValue;
                int index = -1;

                foreach (var s in spawnGrid)
                {
                    if (Vector3.Distance(s.GroundPosition, position) < distance)
                    {
                        distance = Vector3.Distance(s.GroundPosition, position);
                        index = spawnGrid.IndexOf(s);
                    }
                }

                var direction = "";
                if (index > -1)
                {
                    if (position.z > spawnGrid[index].GroundPosition.z)
                        direction += "N";
                    else if (position.z < spawnGrid[index].GroundPosition.z)
                        direction += "S";

                    if (position.x > spawnGrid[index].GroundPosition.x)
                        direction += "E";
                    else if (position.x < spawnGrid[index].GroundPosition.x)
                        direction += "W";

                    var mesg = $"{distance.ToString("0.00")} meters {direction} of the {spawnGrid[index].GridReference} map marker.";
                    return mesg.Replace("{distance}", distance.ToString("0.00")).Replace("{direction}", direction).Replace("{gridreference}", spawnGrid[index].GridReference);
                }
                else
                {
                    return "I don't know.";
                }
            }
            catch (Exception ex)
            {
                throw new Exception($"GetGridReference {ex.Message}");
            }
        }

        List<SpawnPosition> CreateSpawnGrid()
        {
            try
            {
                List<SpawnPosition> retval = new List<SpawnPosition>();

                var worldSize = (ConVar.Server.worldsize);
                float offset = worldSize / 2;
                var gridWidth = (calgon * worldSize);
                float step = worldSize / gridWidth;
                string start = "";

                char letter = 'A';
                int number = 0;

                for (float zz = offset; zz > -offset; zz -= step)
                {
                    for (float xx = -offset; xx < offset; xx += step)
                    {
                        var sp = new SpawnPosition(new Vector3(xx, 0, zz));
                        sp.GridReference = $"{start}{letter}{number}";
                        retval.Add(sp);
                        if (letter.ToString().ToUpper() == "Z")
                        {
                            start = "A";
                            letter = 'A';
                        }
                        else
                        {
                            letter = (char)(((int)letter) + 1);
                        }


                    }
                    number++;
                    start = "";
                    letter = 'A';
                }
                return retval;
            }
            catch (Exception ex)
            {
                throw new Exception($"CreateSpawnGrid {ex.Message}");
            }
        }

        private string CanPlayerTeleport(BasePlayer player)
        {
            return Interface.Oxide.CallHook("CanTeleport", player) as string;
        }

        bool TestCanGrtTeleport(BasePlayer player, string gr)
        {
            var err = CanPlayerTeleport(player);
            if (err != null)
            {
                PrintToChat(player, err);
                return false;
            }

            //Puts("Parent: " + player.GetParentEntity().ToString());

            if (player.IsAdmin) return true;

            var userGroupData = GetUsersGroupDataOrDefault(player);
            var index = GridIndexFromReference(gr);
            string parent = string.Empty;
            try
            {
                parent = player.GetParentEntity().ToString();
            }
            catch
            {
                parent = string.Empty;
            }

            if (index == -1)
            {
                PrintToChat(player, lang.GetMessage("CannotGridTeleport", this, player.UserIDString));
                return false;
            }

            if (player.IsBuildingBlocked(spawnGrid[index].GroundPosition, new Quaternion(0, 0, 0, 0), new Bounds(Vector3.zero, Vector3.zero)) && !grTeleportData.AllowBuildingBlocked)
            {
                PrintToChat(player, lang.GetMessage("buildingblocked", this, player.UserIDString));
                return false;
            }

            if (parent.Contains("cargoship") && !grTeleportData.AllowOffCargoship)
            {
                PrintToChat(player, lang.GetMessage("cargoship", this, player.UserIDString));
                return false;
            }

            if (spawnGrid[index].isPositionAboveWater() && grTeleportData.AvoidWater && (spawnGrid[index].WaterDepthAtPosition() > grTeleportData.AllowableWaterDepth))
            {
                PrintToChat(player, lang.GetMessage("overwater", this, player.UserIDString).Replace("{depth}", spawnGrid[index].WaterDepthAtPosition().ToString("0.00")));
                return false;
            }

            if (player.metabolism.calories.value <= userGroupData.MinHungerForTeleport)
            {
                PrintToChat(player, lang.GetMessage("hungrymessage", this, player.UserIDString));
                return false;
            }

            if (player.metabolism.hydration.value <= userGroupData.MinThirstForTeleport)
            {
                PrintToChat(player, lang.GetMessage("thirstymessage", this, player.UserIDString));
                return false;
            }

            if (player.metabolism.temperature.value <= userGroupData.MinTemperatureForTeleport)
            {
                PrintToChat(player, lang.GetMessage("coldmessage", this, player.UserIDString)
                    .Replace("{temperature}", player.metabolism.temperature.value.ToString()));
                return false;
            }

            if (player.metabolism.temperature.value >= userGroupData.MaxTemperatureForTeleport)
            {
                //{ "hotmessage", "You are too hot ({temperature}>={toohot}) to be teleported, cool off." },
                PrintToChat(player, lang.GetMessage("hotmessage", this, player.UserIDString)
                    .Replace("{toohot}", userGroupData.MaxTemperatureForTeleport.ToString())
                    .Replace("{temperature}", player.metabolism.temperature.value.ToString()));
                return false;
            }

            if (player.metabolism.radiation_poison.value > 0)
            {
                PrintToChat(player, lang.GetMessage("radiatedmessage", this, player.UserIDString));
                return false;
            }

            if (player.IsWounded())
            {
                PrintToChat(player, lang.GetMessage("woundedmessage", this, player.UserIDString));
                return false;
            }

            // todo: test if aggressive...

            return true;
        }

        int GridIndexFromReference(string gridReference)
        {
            try
            {
                foreach (SpawnPosition s in spawnGrid)
                {
                    if (gridReference.ToUpper().Trim() == s.GridReference.ToUpper().Trim())
                        return spawnGrid.IndexOf(s);
                }
                //throw new Exception($"GridIndexFromReference {gridReference.ToUpper()} was not found in spawnGrid {spawnGrid.Count}");
                return -1;
            }
            catch (Exception ex)
            {
                throw new Exception($"GridIndexFromReference {ex.Message}");
            }

        }

        bool TestRestrictedZone(string gridReference)
        {
            if (string.IsNullOrEmpty(grTeleportData.RestrictedZones)) return false;

            if (grTeleportData.RestrictedZones.Length > 0)
            {
                if (grTeleportData.RestrictedZones.Contains(","))
                {
                    var zones = grTeleportData.RestrictedZones.Split(',');
                    foreach (var z in zones)
                    {
                        if (z.ToUpper() == gridReference.ToUpper())
                            return true;
                    }
                }
                else // only one
                {
                    if (grTeleportData.RestrictedZones.ToUpper() == gridReference.ToUpper())
                        return true;
                }
            }
            return false;
        }

        Cooldown GetCooldown(string playerName)
        {
            try
            {
                var cnt = coolDowns.RemoveAll(x => x.expirtyDateTime <= DateTime.Now);
                var index = coolDowns.FindIndex(x => x.name.ToLower() == playerName.ToLower());
                if (index == -1) return null;

                return coolDowns[index];
            }
            catch (Exception ex)
            {
                throw new Exception($"GetCooldown {ex.Message}", ex);
            }
        }

        List<SpawnPosition> OrigCreateSpawnGrid()
        {
            try
            {
                List<SpawnPosition> retval = new List<SpawnPosition>();

                var worldSize = (ConVar.Server.worldsize);
                float offset = worldSize / 2;
                var gridWidth = (calgon * worldSize);
                float step = worldSize / gridWidth;
                string start = "";

                char letter = 'A';
                int number = 0;

                for (float zz = offset; zz > -offset; zz -= step)
                {
                    for (float xx = -offset; xx < offset; xx += step)
                    {
                        var sp = new SpawnPosition(new Vector3(xx, 0, zz));
                        sp.GridReference = $"{start}{letter}{number}";
                        retval.Add(sp);


                        number++;
                    }

                    number = 0;
                    if (letter.ToString().ToUpper() == "Z")
                    {
                        start = "A";
                        letter = 'A';
                    }
                    else
                    {
                        letter = (char)(((int)letter) + 1);
                    }
                }
                return retval;
            }
            catch (Exception ex)
            {
                throw new Exception($"OrigCreateSpawnGrid {ex.Message}");
            }
        }

        void StartSleeping(BasePlayer player)
        {
            if (player.IsSleeping())
                return;

            player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);

            if (!BasePlayer.sleepingPlayerList.Contains(player))
                BasePlayer.sleepingPlayerList.Add(player);

            player.CancelInvoke("InventoryUpdate");
            //player.inventory.crafting.CancelAll(true);
            //player.UpdatePlayerCollider(true, false);
        }

        void Teleport(BasePlayer player, Vector3 position, bool startSleeping = true)
        {
            if (player.net?.connection != null)
                player.ClientRPCPlayer(null, player, "StartLoading");

            if (startSleeping)
                StartSleeping(player);

            player.MovePosition(position);

            if (player.net?.connection != null)
                player.ClientRPCPlayer(null, player, "ForcePositionTo", position);

            player.SendNetworkUpdate();

            if (player.net?.connection != null)
                player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);

            player.UpdateNetworkGroup();

            player.SendNetworkUpdateImmediate(false);
            if (player.net?.connection == null) return;

            try { player.ClearEntityQueue(null); } catch { }
            player.SendFullSnapshot();
        }

        bool CheckAccess(BasePlayer player, string command, string sPermission, bool onErrorDisplayMessageToUser = true)
        {
            try
            {
                if (!permission.UserHasPermission(player.UserIDString, sPermission))
                {
                    if (onErrorDisplayMessageToUser)
                        PrintToChat(player, lang.GetMessage("noaccess", this, player.UserIDString));

                    return false;
                }
                return true;
            }
            catch (Exception ex)
            {
                throw new Exception($"CheckAccess {ex.Message}");
            }
        }

        void AddToCoolDown(string userName, int seconds)
        {
            coolDowns.Add(new Cooldown(userName.ToLower(), seconds));
        }

        bool AreThereCupboardsWithinDistance(Vector3 position, int distance)
        {
            try
            {
                var spawns = Resources.FindObjectsOfTypeAll<GameObject>();
                foreach (GameObject s in spawns)
                {
                    if (Vector3.Distance(s.transform.position, position) < distance)
                    {
                        if (s.name.Contains("tool_cupboard"))
                            return true;
                    }
                }
                return false;
            }
            catch (Exception ex)
            {
                throw new Exception($"AreThereCupboardsWithinDistance {ex.Message}");
            }
        }

        RustUser GetOrCreateUser(BasePlayer player, GroupData groupData)
        {
            var index = rustUsers.FindIndex(x => x.Player == player);

            if (index == -1)
            {
                var user = new RustUser
                {
                    Player = player,
                    TeleportsRemaining = groupData.dailyTeleports,
                    ResetDateTime = DateTime.Now.AddHours(24),
                    CoolDownInSeconds = groupData.coolDownPeriodSeconds,
                    isWaitingForTeleport = false
                }
                ;
                rustUsers.Add(user);
                return rustUsers[rustUsers.IndexOf(user)];
            }

            if (rustUsers[index].ResetDateTime <= DateTime.Now) // reset daily limit
            {
                rustUsers[index].ResetDateTime = DateTime.Now.AddHours(24);
                rustUsers[index].TeleportsRemaining = groupData.dailyTeleports; //grTeleportData.LimitPerDay;
                rustUsers[index].CoolDownInSeconds = groupData.coolDownPeriodSeconds;
            }

            return rustUsers[index];
        }

        Vector3 GetActualGroundPosition(Vector3 sourcePos)
        {
            RaycastHit hitInfo;
            if (Physics.Raycast(sourcePos, Vector3.down, out hitInfo))
                sourcePos.y = hitInfo.point.y;

            sourcePos.y = Mathf.Max(sourcePos.y, TerrainMeta.HeightMap.GetHeight(sourcePos));

            return sourcePos;
        }

        GroupData GetUsersGroupDataOrDefault(BasePlayer user)
        {

            // test admin
            if (permission.UserHasPermission(user.UserIDString, adminPermission))
            {
                GroupData groupData = new GroupData
                {
                    coolDownPeriodSeconds = 0,
                    dailyTeleports = 9999,
                    groupName = "admin",
                    SecondsBeforeTeleport = grTeleportData.SecondsBeforeTeleport,
                    MinHealthForTeleport = grTeleportData.MinHealthForTeleport,
                    MinThirstForTeleport = grTeleportData.MinThirstForTeleport,
                    MinTemperatureForTeleport = grTeleportData.MinTemperatureForTeleport,
                    MaxTemperatureForTeleport = grTeleportData.MaxTemperatureForTeleport,
                    MinHungerForTeleport = grTeleportData.MinHungerForTeleport

                };
                return groupData;
            }

            // test for each groups defined..
            foreach (var p in grTeleportData.groupData)
            {
                string groupName = p.Key;
                GroupData groupData = p.Value;
                // on match return group data
                if (permission.UserHasGroup(user.UserIDString, groupName))
                {
                    return groupData;
                }
            }

            // if has def permission
            if (permission.UserHasPermission(user.UserIDString, grtPermission))
            {
                GroupData groupData = new GroupData
                {
                    coolDownPeriodSeconds = grTeleportData.CooldownInSeconds,
                    dailyTeleports = grTeleportData.LimitPerDay,
                    groupName = "default",
                    SecondsBeforeTeleport = grTeleportData.SecondsBeforeTeleport,
                    MinHealthForTeleport = grTeleportData.MinHealthForTeleport,
                    MinThirstForTeleport = grTeleportData.MinThirstForTeleport,
                    MinTemperatureForTeleport = grTeleportData.MinTemperatureForTeleport,
                    MaxTemperatureForTeleport = grTeleportData.MaxTemperatureForTeleport,
                    MinHungerForTeleport = grTeleportData.MinHungerForTeleport
                };

                return groupData;
            }

            return null; // no permission!!
        }

        #endregion

    }
}


// --- End of file: GrTeleport.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/group-bans ---
// --- Original File Path: G/GroupBans/GroupBans.cs ---

ï»¿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System.Data.SQLite;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using UnityEngine;
using Facepunch.Models;
using ConVar;
using System.Collections.Specialized;


namespace Oxide.Plugins
{


    [Info("Group Bans", "Zeeuss", "0.1.4")]
    [Description("Plugin that allows you to temporarily or permamently ban/unban players from certain oxide groups.")]
    public class GroupBans : CovalencePlugin
    {

        #region Initialization
        const string groupBanUse = "groupbans.use";
        const string groupBanProtect = "groupbans.protect";
        static double GrabCurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;

        void Init()
        {
            // Register permissions
            permission.RegisterPermission(groupBanUse, this);
            permission.RegisterPermission(groupBanProtect, this);

        }
        #endregion

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPerms"] = "You don't have permission to use this command!",
                ["BanSyntax"] = "Syntax: /gban oxide_group time",
                ["UnbanSyntax"] = "Syntax: /gunban oxide_group",
                ["GroupNotExist"] = "Group with this name does not exist!",
                ["BanReason"] = "Your group has been banned!",
                ["ReplyPerma"] = "You have permabanned: {0}!",
                ["ReplyTempBan"] = "You have banned {0} for {1} seconds!",
                ["ReplyUnban"] = "You have unbanned: {0}!"

            }, this);
        }
        #endregion

        #region Commands
        [Command("gban")]
        void chatBanComm(IPlayer player, string command, string[] args)
        {

            if (!permission.UserHasPermission(player.Id, groupBanUse))
            {
                Message(player, Lang("NoPerms", player.Id));
                return;
            }


            // arg 0 = group
            // arg 1 = time - in secs
            if (args.Length == 0)
            {
                Message(player, Lang("BanSyntax", player.Id));
                return;
            }
            else if (args[0] == null)
            {
                Message(player, Lang("BanSyntax", player.Id));
                return;
            }

            if (!permission.GroupExists(args[0]))
            {
                Message(player, Lang("GroupNotExist", player.Id));
                return;
            }



            List<string> idsToBan = new List<string>();
            foreach (var plInGroup in permission.GetUsersInGroup(args[0]))
            {
                string idOfPly = plInGroup.Remove(17);
                idsToBan.Add(idOfPly.ToString());
            }

            foreach(var playerInList in idsToBan)
            {
                if (permission.UserHasPermission(playerInList, groupBanProtect))
                    continue;

                BasePlayer tokick = BasePlayer.FindByID(Convert.ToUInt64(playerInList));

                if (args.Count() <= 1)
                {
                    timer.Once(0.2f, () =>
                    {
                        server.Ban(playerInList, Lang("BanReason", playerInList));
                        if (tokick != null)
                        {
                            tokick.Kick(Lang("BanReason", tokick.UserIDString));
                        }
                    });
                    
                }
                else if (args[1].Length >= 1)
                {
                    timer.Once(0.2f, () =>
                    {
                        ServerUsers.Set(Convert.ToUInt64(playerInList), ServerUsers.UserGroup.Banned, "Group Bans", Lang("BanReason", playerInList), (long)GrabCurrentTime() + Convert.ToUInt32(args[1]));
                        ServerUsers.Save();

                        if (tokick != null)
                        {
                            tokick.Kick(Lang("BanReason", tokick.UserIDString));
                        }
                    });
                    
                }

            }

            if (player != null)
            {

                if (args.Count() <= 1)
                {

                    Message(player, String.Format(lang.GetMessage("ReplyPerma", this, player.Id), args[0]));

                }
                else
                {
                    Message(player, String.Format(lang.GetMessage("ReplyTempBan", this, player.Id), args[0], args[1]));
                }

            }


        }


        [Command("gunban")]
        void chatUnbanComm(IPlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.Id, groupBanUse))
            {
                Message(player, Lang("NoPerms", player.Id));
                return;
            }


            // arg 0 = group

            if (args.Length == 0)
            {
                Message(player, Lang("UnbanSyntax", player.Id));
                return;
            }
            else if (args == null)
            {
                Message(player, Lang("UnbanSyntax", player.Id));
                return;
            }
            else if (args.Length > 1)
            {
                Message(player, Lang("UnbanSyntax", player.Id));
                return;
            }

            if (!permission.GroupExists(args[0]))
            {
                Message(player, Lang("GroupNotExist", player.Id));
                return;
            }

                foreach (var pltounban in permission.GetUsersInGroup(args[0]))
                {

                    timer.Once(0.2f, () =>
                    {
                        string pltounbanID = pltounban.Remove(17); // Removes everything after 17characters == steamID    FORMAT: STEAMID (name)      <----- it's for the ban input string

                        server.Unban(pltounbanID);
                    });
                    

                }

            Message(player, String.Format(lang.GetMessage("ReplyUnban", this, player.Id), args[0]));

        }

        #endregion

        #region Helpers
        private void Message(IPlayer player, string message)
        {
            player.Message(message);
        }

        private string Lang(string key, string id = null)
        {
            return string.Format(lang.GetMessage(key, this, id));
        }

        string GetMsg(string key, params object[] args)
        {

            if (args.Length != 0)
            {
                return string.Format(lang.GetMessage(key, this));
            }
            else
            {
                return string.Format(lang.GetMessage(key, this));
            }
        }

        #endregion





    }
}

// --- End of file: GroupBans.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/global-storage ---
// --- Original File Path: G/GlobalStorage/GlobalStorage.cs ---

ï»¿using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

/* Ideas
    Add tabbed/page storage to the containers so users can access multiple boxes as tabs.
    Add config option to make it so chests are only deployable in TC range.
 */

/* Changes 1.0.5
 * Fixed a lang issue with black listed items being dropped.
 * Fixed a bug with ammo not being handled when destroying/rebuilding an item.
 * Added whitelist option.
 * Added RustEdit method to assign boxes. Requires 2 anchor entities.
 * Updated to support item flags.
 * Patched for May Update.
 */

namespace Oxide.Plugins
{
    [Info("Global Storage", "imthenewguy", "1.0.5")]
    [Description("Create global storage chests in safezone monuments and by placing the item.")]
    class GlobalStorage : RustPlugin
    {
        #region Config

        private Configuration config;
        public class Configuration
        {
            [JsonProperty("Storage prefab profile to use")]
            public string storage_prefab = "assets/prefabs/deployable/large wood storage/box.wooden.large.prefab";

            [JsonProperty("Amount of slots that the players can access? Max value is the maximum number of slots for the container type.")]
            public int slot_count = 30;

            [JsonProperty("Box skin")]
            public ulong box_skin = 1499104921;

            [JsonProperty("Display floating text above the containers indicating that it is a storage unit?")]
            public bool draw_text = true;

            [JsonProperty("If floating text is enabled, how often should it update?")]
            public float draw_update = 5f;

            [JsonProperty("Maximum distance away from the box that the player can see the text?")]
            public float draw_distance = 30f;

            [JsonProperty("Floating text color [white, black, red, blue, green, cyan, grey, magenta, yellow]")]
            public string text_col = "cyan";

            [JsonProperty("Display floating text above manually deployed containers?")]
            public bool draw_text_non_monument = true;

            [JsonProperty("Make player deployed global storage chests invulnerable?")]
            public bool deployed_chests_invulnerable = true;

            [JsonProperty("Auto wipe monument and player data on new server wipe")]
            public bool auto_wipe = true;

            [JsonProperty("A list of item shortnames that cannot be placed into the chest")]
            public List<string> black_list = new List<string>();

            [JsonProperty("If populated with anything, these items will be the only items allowed in the container")]
            public List<string> white_list = new List<string>();

            [JsonProperty("Monument modifiers")]
            public List<Configuration.monumentInfo> monuments = new List<Configuration.monumentInfo>();

            [JsonProperty("Physical storage box prefab to spawn in the world")]
            public string spawn_prefab = "assets/prefabs/deployable/large wood storage/box.wooden.large.prefab";

            [JsonProperty("Item that is given when using the giveglobalbox commands. Be sure to use the shortname that matches the prefab that will be spawning.")]
            public string item_shortname = "box.wooden.large";

            [JsonProperty("Static box spawns on a map that can access global storage")]
            public List<CustomPosInfo> customPosBoxes = new List<CustomPosInfo>();

            [JsonProperty("Anchored boxes placed in rust edit. Requires 2 anchor entities to find it.")]
            public List<AnchorInfo> RustEdit_Boxes = new List<AnchorInfo>();

            [JsonProperty("Custom item whitelist filter settings")]
            public FilterInfo filterSettings = new FilterInfo();            

            public class monumentInfo
            {
                public string name;
                public bool enabled;
                public Vector3 pos;
                public Vector3 rot;
                public monumentInfo(string monument, bool enabled, Vector3 pos, Vector3 rot)
                {
                    this.enabled = enabled;
                    this.pos = pos;
                    this.rot = rot;
                    this.name = monument;
                }
            }

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        public class FilterInfo
        {
            [JsonProperty("Prevent other items from being added to the box besides the items whose names/shortnames are included in the list below??")]
            public bool exclude_everything_else = false;

            [JsonProperty("List of items that you would like to allow (item names/shortnames)?")]
            public List<string> filters = new List<string>();
        }

        public class AnchorInfo
        {
            [JsonProperty("Enabled?")]
            public bool enabled = false;

            [JsonProperty("Primary anchor entity shortname")]
            public string primary_entity = "pookie_deployed";

            [JsonProperty("Secondary anchor entity shortname")]
            public string secondary_entity = "mailbox.deployed";            

            [JsonProperty("How far away from the chest are the anchor entities")]
            public float distance = 2f;
        }

        protected override void LoadDefaultConfig()
        {
            config = new Configuration();
            config.monuments = DefaultMonuments;
            config.black_list = new List<string>() { "cassette", "cassette.medium", "cassette.short", "boombox", "fun.boomboxportable", "fun.casetterecorder" };
            config.RustEdit_Boxes.Add(new AnchorInfo());
            config.filterSettings.filters.Add("Transporters");
        }

        private List<Configuration.monumentInfo> DefaultMonuments
        {
            get
            {
                return new List<Configuration.monumentInfo>
                {
                    new Configuration.monumentInfo("assets/bundled/prefabs/autospawn/monument/fishing_village/fishing_village_b.prefab", true, new Vector3(-10.1f, 2f, 20.4f), new Vector3(0, 270f, 0)),
                    new Configuration.monumentInfo("assets/bundled/prefabs/autospawn/monument/medium/bandit_town.prefab", true, new Vector3(9.0f, 2.8f, 0.7f), new Vector3(0, -90f, 0)),
                    new Configuration.monumentInfo("assets/bundled/prefabs/autospawn/monument/medium/compound.prefab", true, new Vector3(-24.1f, 0.2f, 13.1f), new Vector3(0, 90f, 0)),
                    new Configuration.monumentInfo("assets/bundled/prefabs/autospawn/monument/fishing_village/fishing_village_a.prefab", true, new Vector3(19.0f, 2.0f, -3.8f), new Vector3(0, 0, 0)),
                    new Configuration.monumentInfo("assets/bundled/prefabs/autospawn/monument/fishing_village/fishing_village_c.prefab", true, new Vector3(-5.3f, 2.0f, -2.0f), new Vector3(0, 180, 0))
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    PrintToConsole("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                PrintToConsole($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            PrintToConsole($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion

        #region Data

        PlayerEntity pcdData;
        private DynamicConfigFile PCDDATA;

        const string perms_admin = "globalstorage.admin";
        const string perms_chat = "globalstorage.chat";
        const string perms_access = "globalstorage.access";

        void Init()
        {
            PCDDATA = Interface.Oxide.DataFileSystem.GetFile(this.Name);
            permission.RegisterPermission(perms_admin, this);
            permission.RegisterPermission(perms_chat, this);
            permission.RegisterPermission(perms_access, this);
            LoadData();

            usingWhiteList = config.white_list.Count > 0 ? true : false;

            if (config.RustEdit_Boxes.Count == 0)
            {
                config.RustEdit_Boxes.Add(new AnchorInfo());
                SaveConfig();
            }
        }

        public bool usingWhiteList;

        void Unload()
        {
            UnityEngine.Object.Destroy(NoDamageProtection);
            foreach (var player in BasePlayer.activePlayerList)
            {
                player.EndLooting();
            }

            foreach (var container in boxes.ToList())
            {
                if ((pcdData.monuments.ContainsKey(container.Key) && pcdData.monuments[container.Key].monument == "deployed") || (map_boxes.Contains(container.Value))) continue;
                pcdData.monuments.Remove(container.Key);
                container.Value.KillMessage();
            }
            
            foreach (var storage in pcdData.storage)
            {
                List<StorageInfo> _storage = Pool.GetList<StorageInfo>();
                _storage.AddRange(storage.Value._storage);
                foreach (var item in _storage)
                {
                    if ((usingWhiteList && !config.white_list.Contains(item.shortname)) || (!usingWhiteList && config.black_list.Contains(item.shortname))) storage.Value._storage.Remove(item);
                }
                Pool.FreeList(ref _storage);
            }
            SaveData();
        }

        void OnServerSave()
        {
            SaveData();
        }


        void SaveData()
        {
            PCDDATA.WriteObject(pcdData);
        }

        void LoadData()
        {
            try
            {
                pcdData = Interface.Oxide.DataFileSystem.ReadObject<PlayerEntity>(this.Name);
            }
            catch
            {
                Puts("Couldn't load player data, creating new Playerfile");
                pcdData = new PlayerEntity();
            }
        }

        class StorageBox
        {
            public List<StorageInfo> _storage = new List<StorageInfo>();            
        }

        public class StorageInfo
        {
            public string shortname;
            public string displayName;
            public ulong skin;
            public int amount;
            public int slot;
            public float condition;
            public float maxCondition;
            public int ammo;
            public string ammotype;
            public StorageInfo[] contents;
            public InstancedInfo instanceData;
            public Item.Flag flags;
            public class InstancedInfo
            {
                public bool ShouldPool;
                public int dataInt;
                public int blueprintTarget;
                public int blueprintAmount;
                public ulong subEntity;
            }
            public string text;
        }

        class PlayerEntity
        {
            public Dictionary<ulong, StorageBox> storage = new Dictionary<ulong, StorageBox>();
            public Dictionary<ulong, monumentInfo> monuments = new Dictionary<ulong, monumentInfo>();
            public bool purgeActive = false;
            public Dictionary<ulong, AnchorInfo> RustEdit_storage_data = new Dictionary<ulong, AnchorInfo>();
        }

        public class monumentInfo
        {
            public string monument;
            public bool enabled;
            public Vector3 pos;
            public Vector3 rot;
            public monumentInfo(string monument, bool enabled, Vector3 pos, Vector3 rot)
            {
                this.monument = monument;
                this.enabled = enabled;
                this.pos = pos;
                this.rot = rot;
            }
        }

        public class CustomPosInfo
        {
            public Vector3 pos;
            public Vector3 rot;
            public bool enabled;
            public CustomPosInfo(bool enabled, Vector3 pos, Vector3 rot)
            {
                this.enabled = enabled;
                this.pos = pos;
                this.rot = rot;
            }
        }

        #endregion;

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["WarnDelayTime"] = "Please wait a moment before attempting to open the box again.",
                ["FloatingText"] = "<size=26>Global Storage Chest</size>",
                ["MorePlayersFound"] = "More than one player found: {0}",
                ["NoMatch"] = "No player was found that matched: {0}",
                ["GaveBoxes"] = "Gave {0} {1}x Global Storage Boxes",
                ["ReceiveBoxes"] = "You received {0}x Global Storage Boxes",
                ["AlreadySetup"] = "This box is already setup as a Global Storage Chest.",
                ["SetupBox"] = "Set {0} up as a Global Storage container. OwnerID: {1}",
                ["NoAccessPerms"] = "You do not have permissions to access global storage.",
                ["NoLock"] = "You cannot deploy a lock on a global storage chest.",
                ["BlackList"] = "This item has been black listed from global storage.",
                ["Whitelist"] = "This item is not white listed for global storage.",
                ["ValidUsage"] = "Valid usage: /giveglobalbox <name/id> <quantity>",
                ["ConsoleGave"] = "Gave {0} {1}x Global Storage Boxes",
                ["BlacklistedItemsFound"] = "Found items in your container that are black listed. They have been returned/dropped near you.\n",
                ["WhitelistedItemsFound"] = "Found items in your container that are not on the whitelist. They have been returned/dropped near you.\n",
                ["RemovedContainer"] = "Removed container at: {0}",
                ["PurgeActive"] = "You cannot access global storage while purge is active!",
                ["PurgeEnabledAnnouncement"] = "Purge is enabled. Global Storage can no longer be active.",
                ["PurgeDisabledAnnouncement"] = "Purge is no longer enabled. You can now access global storage."
            }, this);
        }

        #endregion

        #region Storage

        List<StorageContainer> containers = new List<StorageContainer>();

        Dictionary<ulong, float> bagCooldownTimer = new Dictionary<ulong, float>();

        StorageBox storageData;

        private void OpenStorage(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, perms_access))
            {
                PrintToChat(player, lang.GetMessage("NoAccessPerms", this, player.UserIDString));
                return;
            }
            if (bagCooldownTimer.ContainsKey(player.userID))
            {
                if (bagCooldownTimer[player.userID] > Time.time)
                {
                    PrintToChat(player, lang.GetMessage("WarnDelayTime", this, player.UserIDString));
                    return;
                }
                bagCooldownTimer.Remove(player.userID);
            }
            if (!bagCooldownTimer.ContainsKey(player.userID))
            {
                bagCooldownTimer.Add(player.userID, Time.time + 2f);                
            }
            player.EndLooting();

            if (pcdData.purgeActive)
            {
                PrintToChat(player, lang.GetMessage("PurgeActive", this, player.UserIDString));
                return;
            }

            object hookResult = Interface.CallHook("CanAccessGlobalStorage", player);
            if (hookResult is string && hookResult != null) return;

            var pos = new Vector3(player.transform.position.x, player.transform.position.y - 1000, player.transform.position.z);
            var storage = GameManager.server.CreateEntity(config.storage_prefab, pos) as StorageContainer;            
            storage.Spawn();
            storage.inventory.capacity = config.slot_count;
            storage.inventorySlots = config.slot_count;
            storage.baseProtection = NoDamageProtection;
            UnityEngine.Object.DestroyImmediate(storage.GetComponent<GroundWatch>());
            UnityEngine.Object.DestroyImmediate(storage.GetComponent<DestroyOnGroundMissing>());
            storage.OwnerID = player.userID;            

            if (pcdData.storage.TryGetValue(player.userID, out storageData) && storageData._storage.Count > 0)
            {
                foreach (var itemDef in storageData._storage)
                {
                    var item = ItemManager.CreateByName(itemDef.shortname, itemDef.amount, itemDef.skin);
                    if (itemDef.displayName != null) item.name = itemDef.displayName;
                    item.condition = itemDef.condition;
                    item.maxCondition = itemDef.maxCondition;
                    BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
                    if (weapon != null)
                    {
                        if (!string.IsNullOrEmpty(itemDef.ammotype))
                            weapon.primaryMagazine.ammoType = ItemManager.FindItemDefinition(itemDef.ammotype);
                        weapon.primaryMagazine.contents = itemDef.ammo;
                    }
                    FlameThrower flameThrower = item.GetHeldEntity() as FlameThrower;
                    if (flameThrower != null)
                        flameThrower.ammo = itemDef.ammo;
                    if (itemDef.contents != null)
                    {
                        foreach (StorageInfo contentData in itemDef.contents)
                        {
                            Item newContent = ItemManager.CreateByName(contentData.shortname, contentData.amount);
                            if (newContent != null)
                            {
                                newContent.condition = contentData.condition;
                                newContent.MoveToContainer(item.contents);
                            }
                        }
                    }
                    item.flags = itemDef.flags;
                    if (itemDef.instanceData != null)
                    {
                        item.instanceData = new ProtoBuf.Item.InstanceData();
                        item.instanceData.ShouldPool = itemDef.instanceData.ShouldPool;
                        item.instanceData.dataInt = itemDef.instanceData.dataInt;
                        item.instanceData.blueprintTarget = itemDef.instanceData.blueprintTarget;
                        item.instanceData.blueprintAmount = itemDef.instanceData.blueprintAmount;
                    }

                    if (itemDef.text != null) item.text = itemDef.text;

                    item.MoveToContainer(storage.inventory, itemDef.slot, true, true);
                }
            }

            containers.Add(storage);

            timer.Once(0.1f, () =>
            {
                if (storage != null) storage.PlayerOpenLoot(player, "", false);
                Interface.CallHook("OnGlobalStorageOpened", player, storage);
            });
        }

        void StoreContainerLoot(BasePlayer player, StorageContainer container)
        {
            if (!pcdData.storage.TryGetValue(player.userID, out storageData))
            {
                pcdData.storage.Add(player.userID, new StorageBox());
                storageData = pcdData.storage[player.userID];
            }
            if (storageData._storage.Count != 0) storageData._storage.Clear();
            List<StorageInfo> items = new List<StorageInfo>();
            var droppedItemsStr = "";
            List<Item> temp_items_list = Pool.GetList<Item>();
            temp_items_list.AddRange(container.inventory.itemList);
            
            foreach (var item in temp_items_list)
            {
                if ((usingWhiteList && !config.white_list.Contains(item.info.shortname)) || (!usingWhiteList && config.black_list.Contains(item.info.shortname)))
                {
                    player.GiveItem(item);
                    //item.DropAndTossUpwards(player.transform.position, 2);
                    droppedItemsStr += $"{item.name ?? item.info.displayName.english}\n";
                    continue;
                }
                if (config.filterSettings.exclude_everything_else)
                {
                    bool allowed = false;
                    foreach (var entry in config.filterSettings.filters)
                    {
                        if (item.name != null && item.name.Contains(entry))
                        {
                            allowed = true;
                            break;
                        }
                        if (item.info.shortname.Contains(entry))
                        {
                            allowed = true;
                            break;
                        }
                    }
                    if (!allowed)
                    {
                        player.GiveItem(item);
                        droppedItemsStr += $"{item.name ?? item.info.displayName.english}\n";
                        continue;
                    }                    
                }
                var displayName = item.name ?? null;
                StorageInfo itemData;

                storageData._storage.Add(itemData = new StorageInfo()
                {
                    shortname = item.info.shortname,
                    skin = item.skin,
                    slot = item.position,
                    displayName = displayName,
                    amount = item.amount,
                    condition = item.condition,
                    maxCondition = item.maxCondition,
                    ammo = item.GetHeldEntity() is BaseProjectile ? (item.GetHeldEntity() as BaseProjectile).primaryMagazine.contents : item.GetHeldEntity() is FlameThrower ? (item.GetHeldEntity() as FlameThrower).ammo : 0,
                    ammotype = (item.GetHeldEntity() as BaseProjectile)?.primaryMagazine.ammoType.shortname ?? null,
                    contents = item.contents?.itemList.Select(item1 => new StorageInfo
                    {
                        shortname = item1.info.shortname,
                        amount = item1.amount,
                        condition = item1.condition
                    }).ToArray()
                });
                itemData.flags = item.flags;
                if (item.instanceData != null)
                {
                    itemData.instanceData = new StorageInfo.InstancedInfo()
                    {
                        ShouldPool = item.instanceData.ShouldPool,
                        dataInt = item.instanceData.dataInt,
                        blueprintTarget = item.instanceData.blueprintTarget,
                        blueprintAmount = item.instanceData.blueprintAmount,
                        subEntity = item.instanceData.subEntity.Value
                    };
                }

                if (item.text != null) itemData.text = item.text;

                items.Add(itemData);
            }
            if (!string.IsNullOrEmpty(droppedItemsStr))
            {
                if (usingWhiteList) PrintToChat(player, lang.GetMessage("WhitelistedItemsFound", this, player.UserIDString) + droppedItemsStr);
                else PrintToChat(player, lang.GetMessage("BlacklistedItemsFound", this, player.UserIDString) + droppedItemsStr);
            }
            containers.Remove(container);
            container.Invoke(container.KillMessage, 0.01f);

            Pool.FreeList(ref temp_items_list);
        }

        void OnLootEntityEnd(BasePlayer player, StorageContainer entity)
        {            
            if (containers.Contains(entity))
            {
                StoreContainerLoot(player, entity);
            }
        }

        #endregion

        #region Monument handling

        StorageContainer CreateCustomBox(Vector3 pos, Vector3 rot)
        {
            var entity = GameManager.server.CreateEntity(config.spawn_prefab, pos, Quaternion.Euler(rot.x, rot.y, rot.z)) as StorageContainer;
            if (entity == null) return null;
            entity.skinID = config.box_skin;
            entity.Spawn();
            UnityEngine.Object.DestroyImmediate(entity.GetComponent<GroundWatch>());
            UnityEngine.Object.DestroyImmediate(entity.GetComponent<DestroyOnGroundMissing>());
            entity.baseProtection = NoDamageProtection;
            return entity;
        }

        StorageContainer CreateCustomBox(Vector3 pos, Quaternion rot)
        {
            var entity = GameManager.server.CreateEntity(config.spawn_prefab, pos, rot) as StorageContainer;
            if (entity == null) return null;
            entity.skinID = config.box_skin;
            entity.Spawn();
            UnityEngine.Object.DestroyImmediate(entity.GetComponent<GroundWatch>());
            UnityEngine.Object.DestroyImmediate(entity.GetComponent<DestroyOnGroundMissing>());
            entity.baseProtection = NoDamageProtection;
            return entity;
        }

        StorageContainer CreateBox(MonumentInfo monument, Vector3 pos_settings, Vector3 rot_settings, ulong ownerID = 0)
        {
            Vector3 pos = monument.transform.localToWorldMatrix.MultiplyPoint3x4(pos_settings);
            Quaternion rot = monument.transform.localToWorldMatrix.rotation * Quaternion.Euler(rot_settings);
            BaseEntity box = GameManager.server.CreateEntity(config.spawn_prefab, pos, rot);
            if (box == null)
            {
                Puts("Asset path is invalid. Please update the config with the correct path.");
                return null;
            }
            box.skinID = config.box_skin;
            box.Spawn();
            var container = box as StorageContainer;
            container.baseProtection = NoDamageProtection;
            UnityEngine.Object.DestroyImmediate(container.GetComponent<GroundWatch>());
            UnityEngine.Object.DestroyImmediate(container.GetComponent<DestroyOnGroundMissing>());
            container.OwnerID = ownerID;
            return container;
        }
        Dictionary<ulong, StorageContainer> boxes = new Dictionary<ulong, StorageContainer>();

        #endregion

        #region Hooks

        void OnNewSave(string filename)
        {
            if (config.auto_wipe)
            {
                pcdData.storage.Clear();
                pcdData.monuments.Clear();

            }            
        }

        private ProtectionProperties NoDamageProtection;

        void OnServerInitialized(bool initial)
        {
            if (config.black_list.Count == 0) Unsubscribe("CanMoveItem");
            var delay = 0.0f;

            NoDamageProtection = ScriptableObject.CreateInstance<ProtectionProperties>();
            NoDamageProtection.name = "InstancedContainerProtection";
            NoDamageProtection.Add(1);

            foreach (var config_monument in config.monuments)
            {
                var found = false;
                var key = 0ul;
                if (pcdData.monuments.Count > 0)
                {
                    foreach (KeyValuePair<ulong, monumentInfo> kvp in pcdData.monuments)
                    {
                        if (config_monument.name == kvp.Value.monument)
                        {
                            found = true;
                            key = kvp.Key;
                            break;
                        }
                    }
                }                
                if (found)
                {
                    BaseNetworkable box = BaseNetworkable.serverEntities.Find(new NetworkableId(key));

                    if (box == null)
                    {
                        if (!config_monument.enabled)
                        {
                            pcdData.monuments.Remove(key);
                            continue;
                        }
                        delay += 0.1f;
                        pcdData.monuments.Remove(key);

                        MonumentInfo Monument = TerrainMeta.Path.Monuments.Where(x => x.name == config_monument.name).FirstOrDefault();
                        if (Monument == null)
                        {
                            Puts($"Could not find {config_monument.name}");
                            continue;
                        }

                        timer.Once(delay, () =>
                        {
                            var newBox = CreateBox(Monument, config_monument.pos, config_monument.rot);
                            pcdData.monuments.Add(newBox.net.ID.Value, new monumentInfo(Monument.name, true, config_monument.pos, config_monument.rot));
                            boxes.Add(newBox.net.ID.Value, newBox);
                        });                        
                    }
                    else
                    {
                        if (!config_monument.enabled)
                        {
                            box.KillMessage();
                            pcdData.monuments.Remove(key);
                            continue;
                        }
                        var container = box as StorageContainer;
                        if (container.skinID != config.box_skin)
                        {
                            container.skinID = config.box_skin;
                            container.SendNetworkUpdateImmediate();
                        }
                        boxes.Add(container.net.ID.Value, container);
                    }
                }
                else
                {
                    if (!config_monument.enabled) continue;
                    MonumentInfo Monument = TerrainMeta.Path.Monuments.Where(x => x.name == config_monument.name).FirstOrDefault();
                    if (Monument == null)
                    {
                        Puts($"Could not find {config_monument.name}");
                        continue;
                    }

                    delay += 0.1f;

                    timer.Once(delay, () =>
                    {
                        var newBox = CreateBox(Monument, config_monument.pos, config_monument.rot);
                        pcdData.monuments.Add(newBox.net.ID.Value, new monumentInfo(Monument.name, true, config_monument.pos, config_monument.rot));
                       
                        boxes.Add(newBox.net.ID.Value, newBox);
                    });                    
                }
            }

            if (pcdData.monuments.Count > 0)
            {
                foreach (KeyValuePair<ulong, monumentInfo> kvp in pcdData.monuments.ToList())
                {
                    if (kvp.Value.monument == "deployed")
                    {
                        var entity = BaseNetworkable.serverEntities.Find(new NetworkableId(kvp.Key));
                        if (entity == null) pcdData.monuments.Remove(kvp.Key);
                        else boxes.Add(kvp.Key, entity as StorageContainer);
                    }
                }
            }

            foreach (var entry in config.customPosBoxes)
            {
                if (!entry.enabled) continue;
                var newBox = CreateCustomBox(entry.pos, entry.rot);
                if (newBox != null) boxes.Add(newBox.net.ID.Value, newBox);
            } 
            
            if (config.draw_text)
            {
                timer.Every(config.draw_update, () =>
                {
                    if (boxes.Count == 0 || BasePlayer.activePlayerList.Count == 0) return;
                    foreach (var box in boxes)
                    {
                        if (box.Value == null) continue;
                        if (!config.draw_text_non_monument && box.Value.OwnerID > 0) continue;
                        var pos = box.Value.transform.position;
                        pos.y += 1f;
                        foreach (var player in BasePlayer.activePlayerList)
                        {
                            if (Vector3.Distance(player.transform.position, box.Value.transform.position) < config.draw_distance)
                            {
                                if (player.Connection.authLevel == 0)
                                {
                                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                                    player.SendNetworkUpdateImmediate();
                                }
                                
                                player.SendConsoleCommand("ddraw.text", config.draw_update, GetColor(config.text_col), pos, lang.GetMessage("FloatingText", this, player.UserIDString));

                                if (player.Connection.authLevel == 0)
                                {
                                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                                    player.SendNetworkUpdateImmediate();
                                }
                            }
                        }
                    }
                });
            }
            foreach (var entry in config.RustEdit_Boxes)
            {
                FindAnchorBoxes(entry);
            }

            if (config.filterSettings.filters.Count == 0)
            {
                config.filterSettings.filters.Add("Transporters");
                SaveConfig();
                
            }
        }

        Color GetColor(string color)
        {
            switch (color)
            {
                case "white": return Color.white;
                case "black": return Color.black;
                case "red": return Color.red;
                case "blue":return Color.blue;
                case "green":return Color.green;
                case "cyan":return Color.cyan;
                case "grey":return Color.grey;
                case "magenta":return Color.magenta;
                case "yellow": return Color.yellow;
            }
            return Color.cyan;
        }

        object OnEntityTakeDamage(StorageContainer entity, HitInfo info)
        {
            if (entity == null || info == null) return null;
            if (boxes.ContainsKey(entity.net.ID.Value))
            {
                monumentInfo mi;
                if (!pcdData.monuments.TryGetValue(entity.net.ID.Value, out mi)) return null;
                if (config.deployed_chests_invulnerable || (!string.IsNullOrEmpty(mi.monument) && mi.monument != "deployed")) info?.damageTypes?.ScaleAll(0f);
            }               
            return null;
        }

        object CanLootEntity(BasePlayer player, StorageContainer container)
        {
            if (container != null && boxes.ContainsKey(container.net.ID.Value))
            {
                OpenStorage(player);
                return true;
            }
            return null;
        }

        void OnEntityKill(StorageContainer entity)
        {
            if (entity == null) return;            
            if (boxes.ContainsKey(entity.net.ID.Value))
            {                
                monumentInfo mi;
                if (pcdData.monuments.TryGetValue(entity.net.ID.Value, out mi))
                {
                    if (mi.monument == "deployed") pcdData.monuments.Remove(entity.net.ID.Value);
                    else
                    {
                        MonumentInfo Monument = TerrainMeta.Path.Monuments.Where(x => x.name == mi.monument).FirstOrDefault();
                        var configData = config.monuments.Where(x => x.name == mi.monument).FirstOrDefault();
                        if (Monument != null && configData != null)
                        {
                            pcdData.monuments.Remove(entity.net.ID.Value);
                            var box = CreateBox(Monument, configData.pos, configData.rot);
                            boxes.Add(box.net.ID.Value, box);
                            pcdData.monuments.Add(box.net.ID.Value, new monumentInfo(Monument.name, true, configData.pos, configData.rot));
                        }                        
                    }
                }
                else
                {
                    var box = CreateCustomBox(entity.transform.position, entity.transform.rotation);
                    boxes.Add(box.net.ID.Value, box);
                }
                boxes.Remove(entity.net.ID.Value);
            }
        }

        object CanPickupEntity(BasePlayer player, StorageContainer entity)
        {
            if (entity != null && boxes.ContainsKey(entity.net.ID.Value))
            {
                if (entity.OwnerID == player.userID)
                {
                    pcdData.monuments.Remove(entity.net.ID.Value);
                    boxes.Remove(entity.net.ID.Value);
                    return null;
                }
                return false;
            }
            return null;
        }

        void OnEntityBuilt(Planner plan, GameObject go)
        {
            var entity = go?.ToBaseEntity();
            if (entity == null || entity.skinID != config.box_skin) return;
            var player = plan?.GetOwnerPlayer();
            if (player == null) return;
            entity.OwnerID = player.userID;
            pcdData.monuments.Add(entity.net.ID.Value, new monumentInfo("deployed", true, entity.transform.position, new Vector3()));
            boxes.Add(entity.net.ID.Value, entity as StorageContainer);
        }

        object CanDeployItem(BasePlayer player, Deployer deployer, ulong entityId)
        {
            if (boxes.ContainsKey(entityId))
            {
                PrintToChat(player, lang.GetMessage("NoLock", this, player.UserIDString));
                return true;
            }
            return null;
        }

        object CanMoveItem(Item item, PlayerInventory playerLoot, ItemContainerId targetContainer, int targetSlot, int amount)
        {
            if (config.white_list.Count > 0)
            {
                foreach (var container in containers)
                {
                    if (container.inventory.uid == targetContainer && !config.white_list.Contains(item.info.shortname))
                    {
                        var player = item.GetOwnerPlayer();
                        PrintToChat(player, lang.GetMessage("Whitelist", this, player.UserIDString));
                        return true;
                    }
                }
                    
            }
            else if (config.black_list.Count > 0 && config.black_list.Contains(item.info.shortname))
            {
                foreach (var container in containers)
                {
                    if (container.inventory.uid == targetContainer)
                    {
                        var player = item.GetOwnerPlayer();
                        PrintToChat(player, lang.GetMessage("BlackList", this, player.UserIDString));
                        return true;
                    }
                }
            }            
            return null;
        }

        #endregion

        #region Helpers

        void GiveBoxItem(BasePlayer player, int quantity = 1)
        {
            var item = ItemManager.CreateByName(config.item_shortname, quantity, config.box_skin);
            item.name = "global storage box";
            player.GiveItem(item);
        }

        private BasePlayer FindPlayerByName(string Playername, BasePlayer SearchingPlayer = null)
        {
            var lowered = Playername.ToLower();
            var targetList = BasePlayer.allPlayerList.Where(x => x.displayName.ToLower().Contains(lowered)).OrderBy(x => x.displayName.Length);
            if (targetList.Count() == 1)
            {
                return targetList.First();
            }
            if (targetList.Count() > 1)
            {
                if (targetList.First().displayName.Equals(Playername, StringComparison.OrdinalIgnoreCase))
                {
                    return targetList.First();
                }
                if (SearchingPlayer != null)
                {
                    PrintToChat(SearchingPlayer, string.Format(lang.GetMessage("MorePlayersFound", this, SearchingPlayer.UserIDString), String.Join(",", targetList.Select(x => x.displayName))));
                }
                else Puts(string.Format(lang.GetMessage("MorePlayersFound", this), String.Join(",", targetList.Select(x => x.displayName))));
                return null;
            }
            if (targetList.Count() == 0)
            {
                if (SearchingPlayer != null)
                {
                    PrintToChat(SearchingPlayer, string.Format(lang.GetMessage("NoMatch", this, SearchingPlayer.UserIDString), Playername));
                }
                else Puts(string.Format(lang.GetMessage("NoMatch", this), Playername));
                return null;
            }
            return null;
        }

        private const int LAYER_TARGET = ~(1 << 2 | 1 << 3 | 1 << 4 | 1 << 10 | 1 << 18 | 1 << 28 | 1 << 29);
        private BaseEntity GetTargetEntity(BasePlayer player)
        {
            RaycastHit raycastHit;
            bool flag = Physics.Raycast(player.eyes.HeadRay(), out raycastHit, 5, LAYER_TARGET);
            var targetEntity = flag ? raycastHit.GetEntity() : null;
            return targetEntity;
        }

        #endregion

        #region Chat commands

        [ConsoleCommand("gspurge")]
        void PurgeCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, "globalstorage.admin")) return;

            if (arg.Args == null || arg.Args.Length == 0 || (!arg.Args[0].Equals("true", StringComparison.OrdinalIgnoreCase) && !arg.Args[0].Equals("false", StringComparison.OrdinalIgnoreCase)))
            {
                arg.ReplyWith(string.Format(lang.GetMessage("PurgeEnabled", this, player != null ? player.UserIDString : null), pcdData.purgeActive));
                return;
            }
            if (arg.Args[0].Equals("true", StringComparison.OrdinalIgnoreCase))
            {
                pcdData.purgeActive = true;
                PrintToChat(lang.GetMessage("PurgeEnabledAnnouncement", this));
            }
            else
            {
                pcdData.purgeActive = false;
                PrintToChat(lang.GetMessage("PurgeDisabledAnnouncement", this));
            }
            SaveData();
        }

        [ChatCommand("addcustomlocation")]
        void AddCustomLocation(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, perms_admin)) return;
            Puts($"Rot: {player.transform.root}");
            var box = CreateCustomBox(player.transform.position, new Vector3(Vector3.zero.x, player.viewAngles.y, player.viewAngles.z));
            if (box != null)
            {
                config.customPosBoxes.Add(new CustomPosInfo(true, player.transform.position, player.viewAngles));
                SaveConfig();
                boxes.Add(box.net.ID.Value, box);
            }
        }

        [ChatCommand("removecustomlocation")]
        void RemoveCustomLocation(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, perms_admin)) return;
            var entity = GetTargetEntity(player);
            if (entity == null || !(entity is StorageContainer) || entity.PrefabName != config.spawn_prefab) return;
            var container = entity as StorageContainer;
            foreach (var entry in config.customPosBoxes)
            {
                if (entry.pos == container.transform.position)
                {
                    config.customPosBoxes.Remove(entry);
                    boxes.Remove(container.net.ID.Value);
                    PrintToChat(player, string.Format(lang.GetMessage("RemovedContainer", this, player.UserIDString), container.transform.position));
                    container.KillMessage();
                    SaveConfig();
                    return;
                }
            }
        }

        [ChatCommand("giveglobalbox")]
        void GiveBox(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, perms_admin)) return;
            var amount = 1;
            if (args.Length == 0)
            {
                GiveBoxItem(player, amount);
                PrintToChat(player, string.Format(lang.GetMessage("GaveBoxes", this, player.UserIDString), player.displayName, amount));
                return;
            }
            if (args.Length > 0)
            {
                var target = FindPlayerByName(args[0], player);
                if (target == null) return;                
                if (args.Length == 2 && args[1].IsNumeric()) amount = Convert.ToInt32(args[1]);
                GiveBoxItem(target, amount);
                PrintToChat(player, string.Format(lang.GetMessage("GaveBoxes", this, player.UserIDString), target.displayName, amount));
                PrintToChat(player, string.Format(lang.GetMessage("ReceiveBoxes", this, target.UserIDString), amount));
            }
        }

        [ConsoleCommand("giveglobalbox")]
        void GiveBoxConsole(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, perms_admin)) return;
            if (arg.Args.Length == 0)
            {
                if (player != null) arg.ReplyWith(lang.GetMessage("ValidUsage", this, player.UserIDString));
                else arg.ReplyWith(lang.GetMessage("ValidUsage", this));
                return;
            }
            var target = FindPlayerByName(arg.Args[0], player ?? null);
            if (target == null) return;
            var amount = 1;
            if (arg.Args.Length == 2 && arg.Args[1].IsNumeric()) amount = Convert.ToInt32(arg.Args[1]);
            arg.ReplyWith(string.Format(lang.GetMessage("ConsoleGave", this), target.displayName, amount));
            GiveBoxItem(target, amount);
            PrintToChat(target, string.Format(lang.GetMessage("ReceiveBoxes", this, target.UserIDString), amount));
        }

        [ChatCommand("gstorage")]
        void GlobalStorageCMD(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, perms_chat)) return;
            OpenStorage(player);
        }

        [ChatCommand("addglobalstorage")]
        void AddGlobalStorageCMD(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, perms_admin)) return;
            var entity = GetTargetEntity(player);
            if (entity == null || !(entity is StorageContainer) || entity.PrefabName != config.spawn_prefab) return;
            var container = entity as StorageContainer;
            if (boxes.ContainsKey(container.net.ID.Value))
            {
                PrintToChat(player, lang.GetMessage("AlreadySetup", this, player.UserIDString));
                return;
            }
            var ownerID = 0ul;
            if (args.Length > 0)
            {
                var target = FindPlayerByName(args[0], player);
                if (target == null) return;
                ownerID = target.userID;
            }
            container.OwnerID = ownerID;
            container.skinID = config.box_skin;
            container.SendNetworkUpdateImmediate();
            if (!pcdData.monuments.ContainsKey(container.net.ID.Value)) pcdData.monuments.Add(container.net.ID.Value, new monumentInfo("deployed", true, container.transform.position, new Vector3()));
            boxes.Add(container.net.ID.Value, container);
            PrintToChat(player, string.Format(lang.GetMessage("SetupBox", this, player.UserIDString), container.net.ID.Value, ownerID));
        }

        #endregion

        #region Custom RustEdit chests

        List<StorageContainer> map_boxes = new List<StorageContainer>();

        bool FindAnchorBoxes(AnchorInfo anchorInfo) 
        {
            if (anchorInfo == null || string.IsNullOrEmpty(anchorInfo.primary_entity) || string.IsNullOrEmpty(anchorInfo.secondary_entity)) return false;
            if (!anchorInfo.enabled) return false;
            // Search through data to see if our chests has already been found this wipe.
            foreach (var anchorSet in pcdData.RustEdit_storage_data)
            {
                
                if (anchorInfo.primary_entity == anchorSet.Value.primary_entity && anchorInfo.secondary_entity == anchorSet.Value.secondary_entity)
                {
                    var chest = BaseNetworkable.serverEntities.Find(new NetworkableId(anchorSet.Key)) as StorageContainer;
                    if (chest != null)
                    {   
                        if (chest.skinID != config.box_skin)
                        {
                            chest.skinID = config.box_skin;
                            chest.SendNetworkUpdateImmediate();
                        }
                        boxes.Add(anchorSet.Key, chest);
                        map_boxes.Add(chest);
                        return true;
                    }                        
                }
            }

            // We obtain the first entity and use it as our main anchor.
            List<BaseNetworkable> PrimaryEntities = Pool.GetList<BaseNetworkable>();
            PrimaryEntities.AddRange(BaseNetworkable.serverEntities.Where(x => x.ShortPrefabName.Equals(anchorInfo.primary_entity, StringComparison.OrdinalIgnoreCase)));

            // We search the second entities and store them.
            List<BaseNetworkable> SecondaryEntities = Pool.GetList<BaseNetworkable>();
            SecondaryEntities.AddRange(BaseNetworkable.serverEntities.Where(x => x.ShortPrefabName.Equals(anchorInfo.secondary_entity, StringComparison.OrdinalIgnoreCase)));

            var chests = BaseNetworkable.serverEntities.Where(x => x.PrefabName.Equals(config.spawn_prefab, StringComparison.OrdinalIgnoreCase));

            // We use the first entity to check the distance between all entities, and if we find all 3 int he same place we move forward.
            foreach (var primary in PrimaryEntities)
            {
                foreach (var secondary in SecondaryEntities)
                {
                    if (primary == secondary) continue;
                    if (Vector3.Distance(primary.transform.position, secondary.transform.position) < 0.5)
                    {
                        // We found our 2 entities. Now we see if the chest is close by.
                        var chest = chests.Where(x => Vector3.Distance(x.transform.position, primary.transform.position) <= anchorInfo.distance).FirstOrDefault() as StorageContainer;
                        if (chest != null)
                        {
                            if (!pcdData.RustEdit_storage_data.ContainsKey(chest.net.ID.Value)) pcdData.RustEdit_storage_data.Add(chest.net.ID.Value, new AnchorInfo());
                            pcdData.RustEdit_storage_data[chest.net.ID.Value] = anchorInfo;
                            if (chest.skinID != config.box_skin)
                            {
                                chest.skinID = config.box_skin;
                                chest.SendNetworkUpdateImmediate();
                            }
                            boxes.Add(chest.net.ID.Value, chest);
                            map_boxes.Add(chest);
                            SaveData();
                            return true;
                        }
                    }
                }
            }
            Puts($"Failed to find anchor points - Primary: {anchorInfo.primary_entity}. Secondary: {anchorInfo.secondary_entity}. Dist: {anchorInfo.distance}");
            return false;
        }

        #endregion
    }
}


// --- End of file: GlobalStorage.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/game-tip-api ---
// --- Original File Path: G/GameTipAPI/GameTipAPI.cs ---

ï»¿/// <summary>
/// Author: S0N_0F_BISCUIT
/// </summary>
using Newtonsoft.Json;
using Oxide.Core;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
	[Info("GameTipAPI", "S0N_0F_BISCUIT", "1.0.0", ResourceId = 2759)]
	[Description("API for displaying queued gametips to players.")]
	class GameTipAPI : RustPlugin
	{
		#region Variables
		/// <summary>
		/// Message to display in a game tip
		/// </summary>
		class Message
		{
			[JsonProperty(PropertyName = "Text")]
			public string text;
			[JsonProperty(PropertyName = "Duration")]
			public float duration;
		}
		/// <summary>
		/// Game tip queue for a given player
		/// </summary>
		class PlayerTips
		{
			public BasePlayer player = new BasePlayer();
			public Queue<Message> queue = new Queue<Message>();
			public bool active = false;
		}
		/// <summary>
		/// Scheduled game tip to broadcast to players
		/// </summary>
		class ScheduledTip
		{
			[JsonProperty(PropertyName = "Message")]
			public Message message = new Message();
			[JsonProperty(PropertyName = "Period")]
			public float period = 0;
			[JsonProperty(PropertyName = "Mandatory")]
			public bool mandatory = false;
			[JsonProperty(PropertyName = "Enabled")]
			public bool enabled = false;
		}
		/// <summary>
		/// Configuration data
		/// </summary>
		class ConfigData
		{
			[JsonProperty(PropertyName = "Scheduled Tips")]
			public List<ScheduledTip> ScheduledTips = new List<ScheduledTip>();
		}
		/// <summary>
		/// Stored plugin data
		/// </summary>
		class StoredData
		{
			public List<ulong> blacklist = new List<ulong>();
		}
		
		private ConfigData config = new ConfigData();
		private StoredData data = new StoredData();
		private List<PlayerTips> gameTips = new List<PlayerTips>();
		#endregion

		#region Localization
		/// <summary>
		/// Load messages relayed to player
		/// </summary>
		private new void LoadDefaultMessages()
		{
			// English
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["HideTips"] = "Game tips are now hidden.",
				["ShowTips"] = "Game tips are now shown.",
				["ScheduledTips"] = "Starting {0} scheduled tips."
			}, this);
		}
		#endregion

		#region Config Handling
		/// <summary>
		/// Load default config file
		/// </summary>
		protected override void LoadDefaultConfig()
		{
			Config.Clear();
			var config = new ConfigData()
			{
				ScheduledTips = new List<ScheduledTip>()
				{
					new ScheduledTip()
					{
						message = new Message()
						{
							text = "Example Message",
							duration = 5f
						},
						period = 300,
						mandatory = false,
						enabled = false
					}
				}
			};
			Config.WriteObject(config, true);
		}
		/// <summary>
		/// Load config data
		/// </summary>
		private void LoadConfigData()
		{
			config = Config.ReadObject<ConfigData>();
			Config.WriteObject(config, true);
		}
		#endregion

		#region Data Handling
		/// <summary>
		/// Load plugin data
		/// </summary>
		private void LoadData()
		{
			try
			{
				data = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Title);
			}
			catch
			{
				data = new StoredData();
				SaveData();
			}
		}
		/// <summary>
		/// Save PlayerData
		/// </summary>
		private void SaveData()
		{
			Interface.Oxide.DataFileSystem.WriteObject(Title, data);
		}
		#endregion

		#region Initialization
		/// <summary>
		/// Plugin initialization
		/// </summary>
		private void Init()
		{
			// Configuration
			try
			{
				LoadConfigData();
			}
			catch
			{
				LoadDefaultConfig();
			}
			// Data
			LoadData();
		}
		/// <summary>
		/// Start all scheduled tips
		/// </summary>
		void OnServerInitialized()
		{
			try
			{
				int count = 0;
				foreach (ScheduledTip tip in config.ScheduledTips.Where(x => x.enabled))
				{
					AddScheduledTip(tip);
					count++;
				}
				Puts(Lang("ScheduledTips", null, count));
			}
			catch { }
		}
		/// <summary>
		/// Unloading Plugin
		/// </summary>
		void Unload()
		{
			SaveData();
		}
		#endregion

		#region Commands
		/// <summary>
		/// Add player to game tip blacklist
		/// </summary>
		/// <param name="player"></param>
		/// <param name="command"></param>
		/// <param name="args"></param>
		[ChatCommand("hidetips")]
		void HideGameTips(BasePlayer player, string command, string[] args)
		{
			if (!data.blacklist.Contains(player.userID))
			{
				data.blacklist.Add(player.userID);
				player.ChatMessage(Lang("HideTips", player.UserIDString));
				SaveData();
			}
		}
		/// <summary>
		/// Remove player from game tip blacklist
		/// </summary>
		/// <param name="player"></param>
		/// <param name="command"></param>
		/// <param name="args"></param>
		[ChatCommand("showtips")]
		void ShowGameTips(BasePlayer player, string command, string[] args)
		{
			if (data.blacklist.Contains(player.userID))
			{
				data.blacklist.Remove(player.userID);
				player.ChatMessage(Lang("ShowTips", player.UserIDString));
				SaveData();
			}
		}
		#endregion

		#region Functionality
		/// <summary>
		/// Create a new game tip
		/// </summary>
		/// <param name="player"></param>
		/// <param name="message"></param>
		/// <param name="duration"></param>
		/// <param name="mandatory"></param>
		void ShowGameTip(BasePlayer player, string message, float duration = 5f, bool mandatory = false)
		{
			if (player == null || string.IsNullOrEmpty(message))
				return;
			if (!mandatory && data.blacklist.Contains(player.userID))
				return;

			PlayerTips tip;
			if ((tip = gameTips.Find(x => x.player == player)) != null)
				tip.queue.Enqueue(new Message() { text = message, duration = duration });
			else
			{
				gameTips.Add(tip = new PlayerTips() { player = player });
				tip.queue.Enqueue(new Message() { text = message, duration = duration });
			}
			
			if (!tip.active)
				Display(tip);
		}
		/// <summary>
		/// Broadcast a game tip to all players online
		/// </summary>
		/// <param name="message"></param>
		/// <param name="duration"></param>
		/// <param name="mandatory"></param>
		void BroadcastGameTip(string message, float duration = 5f, bool mandatory = false)
		{
			if (string.IsNullOrEmpty(message))
				return;

			foreach (BasePlayer player in BasePlayer.activePlayerList)
			{
				if (!mandatory && data.blacklist.Contains(player.userID))
					continue;

				PlayerTips playerTips;
				if ((playerTips = gameTips.Find(x => x.player == player)) != null)
					playerTips.queue.Enqueue(new Message() { text = message, duration = duration });
				else
				{
					gameTips.Add(playerTips = new PlayerTips() { player = player });
					playerTips.queue.Enqueue(new Message() { text = message, duration = duration });
				}

				if (!playerTips.active)
					Display(playerTips);
			}
		}
		/// <summary>
		/// Create a scheduled tip
		/// </summary>
		/// <param name="tip"></param>
		private void AddScheduledTip(ScheduledTip tip)
		{
			BroadcastGameTip(tip.message.text, tip.message.duration, tip.mandatory);
			timer.Once(tip.period, () => { AddScheduledTip(tip); });
		}
		/// <summary>
		/// Display a tip to a given player
		/// </summary>
		/// <param name="tips"></param>
		private void Display(PlayerTips tips)
		{
			tips.active = true;
			Message message = tips.queue.Dequeue();

			if (!tips.player.IsConnected)
			{
				gameTips.Remove(tips);
				return;
			}
			
			tips.player?.SendConsoleCommand("gametip.hidegametip");
			tips.player?.SendConsoleCommand("gametip.showgametip", message.text);
			timer.Once(message.duration, () =>
			{
				tips.player?.SendConsoleCommand("gametip.hidegametip");
				if (tips.queue.Count > 0)
					Display(tips);
				else
					gameTips.Remove(tips);
			});
		}
		#endregion

		#region Helpers
		/// <summary>
		/// Get string and format from lang file
		/// </summary>
		/// <param name="key"></param>
		/// <param name="userId"></param>
		/// <param name="args"></param>
		/// <returns></returns>
		private string Lang(string key, string userId = null, params object[] args) => string.Format(lang.GetMessage(key, this, userId), args);
		#endregion
	}
}

// --- End of file: GameTipAPI.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/game-menu ---
// --- Original File Path: G/GameMenu/GameMenu.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Game Menu", "Iv Misticos", "1.0.10")]
    [Description("Create your own GUI menu with buttons and title.")]
    class GameMenu : RustPlugin
    {
        #region Variables

        private static CuiButton _backgroundButton;
        
        #endregion
        
        #region Configuration

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Distance between buttons")]
            public float BetweenButtons = 0.02f;

            [JsonProperty(PropertyName = "FadeIn and FadeOut time")]
            public float FadeTime = 0.3f;
            
            [JsonProperty(PropertyName = "List of menus", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ConfigMenu> Menus = new List<ConfigMenu> { new ConfigMenu() };
        }

        private class ConfigMenu
        {
            [JsonIgnore] public CuiPanel Menu;
            [JsonIgnore] public CuiLabel MenuText;
            
            [JsonProperty(PropertyName = "Menu title")]
            public string Name = "Panel";

            [JsonProperty(PropertyName = "Menu title color")]
            public string NameColor = "#ffffff";

            [JsonProperty(PropertyName = "Menu title size")]
            public short NameSize = 12;

            [JsonProperty(PropertyName = "Menu title height")]
            public float NameHeight = 0.1f;

            [JsonProperty(PropertyName = "Menu permission")]
            public string Permission = "gamemenu.use";

            [JsonProperty(PropertyName = "Chat command to open the menu")]
            public string CommmandChat = "menu";

            [JsonProperty(PropertyName = "Console command to open the menu")]
            public string CommmandConsole = "menu";

            [JsonProperty(PropertyName = "Background color")]
            public string BackgroundColor = "0.66 0.66 0.66 0.9";
            
            [JsonProperty(PropertyName = "Menu buttons", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ConfigButton> Buttons = new List<ConfigButton> { new ConfigButton() };
        }

        private class ConfigButton
        {
            [JsonIgnore] public CuiButton Button;
            
            [JsonProperty(PropertyName = "Button color")]
            public string ButtonColor = "0.0 0.0 0.0 1.0";

            [JsonProperty(PropertyName = "Text color")]
            public string TextColor = "#ffffff";

            [JsonProperty(PropertyName = "Text size")]
            public short TextSize = 12;

            [JsonProperty(PropertyName = "Button width")]
            public float ButtonWidth = 0.4f;

            [JsonProperty(PropertyName = "Button height")]
            public float ButtonHeight = 0.1f;

            [JsonProperty(PropertyName = "Button text")]
            public string Text = "Accept TP";

            [JsonProperty(PropertyName = "Execute chat (true) or console (false) command")]
            public bool IsChatCommand = true;

            [JsonProperty(PropertyName = "Executing command")]
            public string Command = "/tpa";
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();

        #endregion
        
        #region Hooks

        // ReSharper disable once UnusedMember.Local
        private void Init()
        {
            LoadConfig();
            
            cmd.AddConsoleCommand("gamemenu.exec", this, arg =>
            {
                if (!arg.HasArgs(2))
                    return false;

                var isChat = arg.Args[0] == "chat";
                SendCommand(arg.Connection, arg.Args.Skip(1).ToArray(), isChat);
                
                return false;
            });

            var menusCount = _config.Menus.Count;
            var btwButtons = _config.BetweenButtons;
            var fadeTime = _config.FadeTime;

            _backgroundButton = new CuiButton
            {
                Button =
                {
                    Close = "GameMenuCUI",
                    Color = "0.0 0.0 0.0 0.0",
                    FadeIn = fadeTime
                },
                Text =
                {
                    Text = string.Empty
                },
                RectTransform =
                {
                    AnchorMin = "0.0 0.0",
                    AnchorMax = "1.0 1.0"
                }
            };
            
            for (var i = 0; i < menusCount; i++)
            {
                var menu = _config.Menus[i];
                
                // Registering permissions
                var perm = menu.Permission;
                if (!string.IsNullOrEmpty(perm) && !permission.PermissionExists(perm, this))
                    permission.RegisterPermission(perm, this);
                
                // Loading CUIs
                
                var buttonsCount = menu.Buttons.Count;
                var totalHeight = 0.0f;
                var sum = 0f;
                for (var i2 = 0; i2 < buttonsCount; i2++)
                {
                    sum += menu.Buttons[i2].ButtonHeight;
                }
                
                var maxWidth = 0f;
                for (var i2 = 0; i2 < buttonsCount; i2++)
                {
                    var buttonWidth = menu.Buttons[i2].ButtonWidth;
                    if (buttonWidth > maxWidth)
                        maxWidth = buttonWidth;
                }
                
                var maxHeight = sum + btwButtons * (buttonsCount - 1);
                
                // Loading menu
                var mWidth = maxWidth + 2 * btwButtons;
                var mWidthMin = (1.0f - mWidth) / 2;
                var mWidthMax = mWidthMin + mWidth;

                var nHeight = menu.NameHeight;
                var mHeight = 3 * btwButtons + maxHeight + nHeight;
                var mHeightMin = (1.0f - mHeight) / 2;
                var mHeightMax = mHeightMin + mHeight;
                
                menu.Menu = new CuiPanel
                {
                    Image =
                    {
                        Color = menu.BackgroundColor,
                        FadeIn = fadeTime
                    },
                    CursorEnabled = true,
                    RectTransform =
                    {
                        AnchorMin = $"{mWidthMin} {mHeightMin}",
                        AnchorMax = $"{mWidthMax} {mHeightMax}"
                    }
                };

                var nHeightMax = mHeightMax - btwButtons;
                var nHeightMin = nHeightMax - nHeight;
                
                menu.MenuText = new CuiLabel
                {
                    Text =
                    {
                        Text = menu.Name,
                        Align = TextAnchor.MiddleCenter,
                        Color = menu.NameColor,
                        FadeIn = fadeTime,
                        FontSize = menu.NameSize
                    },
                    RectTransform =
                    {
                        AnchorMin = $"{mWidthMin} {nHeightMin}",
                        AnchorMax = $"{mWidthMax} {nHeightMax}"
                    }
                };
                
                // Loading buttons
                for (var i2 = 0; i2 < buttonsCount; i2++)
                {
                    var button = menu.Buttons[i2];
                    var width = button.ButtonWidth;
                    var height = button.ButtonHeight;

                    var widthMin = (1.0f - width) / 2;
                    var widthMax = widthMin + width;

                    var heightMin = mHeightMin + totalHeight + (i2 + 1) * btwButtons;
                    var heightMax = heightMin + height;

                    totalHeight += height;
                    var type = button.IsChatCommand ? "chat" : "console";

                    button.Button = new CuiButton
                    {
                        Text =
                        {
                            Text = $"<color={button.TextColor}>{button.Text}</color>",
                            FontSize = button.TextSize,
                            Align = TextAnchor.MiddleCenter,
                            FadeIn = fadeTime
                        },
                        Button =
                        {
                            Color = button.ButtonColor,
                            Command = $"gamemenu.exec {type} {button.Command}",
                            FadeIn = fadeTime
                        },
                        RectTransform =
                        {
                            AnchorMin = $"{widthMin} {heightMin}",
                            AnchorMax = $"{widthMax} {heightMax}"
                        }
                    };
                }
                
                // Registering chat commands for menus
                if (!string.IsNullOrEmpty(menu.CommmandChat))
                    cmd.AddChatCommand(menu.CommmandChat, this, (player, command, args) =>
                    {
                        if (!CanUse(player, perm))
                        {
                            player.ChatMessage(GetMsg("No Permission", player.UserIDString));
                            return;
                        }
                        
                        ShowUI(player, menu);
                    });
                
                // Registering console commands for menus
                if (!string.IsNullOrEmpty(menu.CommmandConsole))
                    cmd.AddConsoleCommand(menu.CommmandConsole, this, arg =>
                    {
                        if (arg.Connection == null || arg.IsRcon)
                        {
                            arg.ReplyWith(GetMsg("Only Player"));
                            return true;
                        }

                        var player = BasePlayer.FindByID(arg.Connection.userid);
                        if (!CanUse(player, perm))
                        {
                            arg.ReplyWith(GetMsg("No Permission", player.UserIDString));
                            return true;
                        }
                        
                        ShowUI(player, menu);
                        return false;
                    });
            }
        }

        // ReSharper disable once UnusedMember.Local
        private void Unload()
        {
            var playersCount = BasePlayer.activePlayerList.Count;
            for (var i = 0; i < playersCount; i++)
                CuiHelper.DestroyUi(BasePlayer.activePlayerList[i], "GameMenuCUI");
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"No Permission", "You don't have enough permission to run this command!"},
                {"Only Player", "This command can be used only by players!"}
            }, this);
            
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"No Permission", "Ð£ ÐÐ°Ñ Ð½ÐµÐ´Ð¾ÑÑÐ°ÑÐ¾ÑÐ½Ð¾ Ð¿ÑÐ°Ð² Ð½Ð° Ð²ÑÐ¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ðµ Ð´Ð°Ð½Ð½Ð¾Ð¹ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ!"},
                {"Only Player", "ÐÐ°Ð½Ð½Ð°Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð° Ð´Ð¾ÑÑÑÐ¿Ð½Ð° ÑÐ¾Ð»ÑÐºÐ¾ Ð¸Ð³ÑÐ¾ÐºÐ°Ð¼!"}
            }, this, "ru");
        }

        #endregion
        
        #region Helpers

        private void ShowUI(BasePlayer player, ConfigMenu menu)
        {
            // ReSharper disable once UseObjectOrCollectionInitializer
            var container = new CuiElementContainer();
            container.Add(_backgroundButton, name:"GameMenuCUI");
            container.Add(menu.Menu, "GameMenuCUI", "GameMenuCUIBackground");
            container.Add(menu.MenuText, "GameMenuCUI", "GameMenuCUIBackgroundText");


            var buttonsCount = menu.Buttons.Count;
            for (var i = 0; i < buttonsCount; i++)
                container.Add(menu.Buttons[i].Button, "GameMenuCUI", "GameMenuCUIButton");

            CuiHelper.DestroyUi(player, "GameMenuCUI");
            CuiHelper.AddUi(player, container);
        }

        // ReSharper disable once SuggestBaseTypeForParameter
        private void SendCommand(Connection conn, string[] args, bool isChat)
        {
            if (!Net.sv.IsConnected())
                return;

            var command = string.Empty;
            var argsLength = args.Length;
            for (var i = 0; i < argsLength; i++)
                command += $"{args[i]} ";
            
            if (isChat)
                command = $"chat.say {command.QuoteSafe()}";

            NetWrite netWrite = Net.sv.StartWrite();
            netWrite.PacketID(Message.Type.ConsoleCommand);
            netWrite.String(command);
            netWrite.Send(new SendInfo(conn));
        }

        private bool CanUse(BasePlayer player, string perm) =>
            player.IsAdmin || string.IsNullOrEmpty(perm) || permission.UserHasPermission(player.UserIDString, perm);

        private string GetMsg(string key, string userId = null) => lang.GetMessage(key, this, userId);

        #endregion
    }
}

// --- End of file: GameMenu.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/guarded-crate ---
// --- Original File Path: G/GuardedCrate/GuardedCrate.cs ---

ï»¿/*
 * Copyright (c) 2023 Bazz3l
 * 
 * Guarded Crate cannot be copied, edited and/or (re)distributed without the express permission of Bazz3l.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */

using System.Collections.Generic;
using System.Globalization;
using System.Collections;
using System.Text;
using System.Linq;
using System;
using Oxide.Core.Plugins;
using Oxide.Core;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json;
using GuardedCrateEx;
using UnityEngine;
using Rust;

namespace Oxide.Plugins
{
    [Info("Guarded Crate", "Bazz3l", "2.0.5")]
    [Description("Spawn high value loot guarded by scientists at random or specified locations.")]
    internal class GuardedCrate : RustPlugin
    {
        [PluginReference] private Plugin NpcSpawn, Clans, ZoneManager, HackableLock, GUIAnnouncements;
        
        #region Fields
        
        private const string PERM_USE = "guardedcrate.use";
        
        private const TerrainTopology.Enum BLOCKED_TOPOLOGY 
            = TerrainTopology.Enum.Cliffside | TerrainTopology.Enum.Cliff | TerrainTopology.Enum.Lake | 
              TerrainTopology.Enum.Ocean | TerrainTopology.Enum.Monument | TerrainTopology.Enum.Building | 
              TerrainTopology.Enum.Offshore | TerrainTopology.Enum.River | TerrainTopology.Enum.Swamp;
        
        private const string MARKER_PREFAB = "assets/prefabs/tools/map/genericradiusmarker.prefab";
        private const string CRATE_PREFAB = "assets/prefabs/deployable/chinooklockedcrate/codelockedhackablecrate.prefab";
        private const string PLANE_PREFAB = "assets/prefabs/npc/cargo plane/cargo_plane.prefab";
        
        private ConfigData _configData;
        private StoredData _storedData;
        
        private static GuardedCrate _instance;

        #endregion

        #region Config
        
        protected override void LoadDefaultConfig()
        {
            _configData = ConfigData.DefaultConfig();
            PrintWarning("Loaded default config.");
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _configData = Config.ReadObject<ConfigData>();
                if (_configData == null) throw new JsonException();
                
                bool hasChanged = false;
                
                if (_configData.CommandName == null)
                {
                    PrintWarning("Updated config.");
                    LoadDefaultConfig();
                    
                    hasChanged = true;
                }
                
                if (_configData.MessageSettings == null)
                {
                    _configData.MessageSettings = new MessageSettings
                    {
                        EnableToast = false,
                        EnableChat = true,
                        EnableChatPrefix = true,
                        ChatIcon = 76561199542824781,
                        EnableGuiAnnouncements = false,
                        GuiAnnouncementsBgColor = "Purple",
                        GuiAnnouncementsTextColor = "White"
                    };
                    
                    hasChanged = true;
                }

                if (_configData.ZoneManagerSettings == null)
                {
                    _configData.ZoneManagerSettings = new ZoneMangerSettings
                    {
                        EnabledIgnoredZones = false,
                        IgnoredZones = new List<string>()
                    };
                    
                    hasChanged = true;
                }
                
                if (hasChanged)
                    SaveConfig();
            }
            catch(Exception e)
            {
                PrintWarning(e.Message);
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_configData, true);
        
        private class ConfigData
        {
            [JsonProperty("command name")]
            public string CommandName;
            [JsonProperty("enable auto spawning events")]
            public bool EnableAutoStart;
            [JsonProperty("auto start event after x duration")]
            public float AutoStartDuration;
            [JsonProperty("message notification settings")]
            public MessageSettings MessageSettings;
            [JsonProperty("zone manager settings")]
            public ZoneMangerSettings ZoneManagerSettings;

            public static ConfigData DefaultConfig()
            {
                return new ConfigData
                {
                    CommandName = "gcrate",
                    EnableAutoStart = true,
                    AutoStartDuration = 3600,
                    MessageSettings = new MessageSettings
                    {
                        EnableToast = false,
                        EnableChat = true, 
                        EnableChatPrefix = true,
                        ChatIcon = 76561199542824781,
                        EnableGuiAnnouncements = false,
                        GuiAnnouncementsBgColor = "Purple",
                        GuiAnnouncementsTextColor = "White"
                    },
                    ZoneManagerSettings = new ZoneMangerSettings
                    {
                        EnabledIgnoredZones = false,
                        IgnoredZones = new List<string>()
                    }
                };
            }
        }

        private class MessageSettings
        {
            [JsonProperty("enable toast message")]
            public bool EnableToast;
            [JsonProperty("enable chat message")]
            public bool EnableChat;
            [JsonProperty("enable chat prefix")]
            public bool EnableChatPrefix;
            [JsonProperty("custom chat message icon (steam64)")]
            public ulong ChatIcon;
            [JsonProperty("enable gui announcements plugin from umod.org")]
            public bool EnableGuiAnnouncements;
            [JsonProperty("gui announcements text color")]
            public string GuiAnnouncementsTextColor;
            [JsonProperty("gui announcements background color")]
            public string GuiAnnouncementsBgColor;
        }
        
        private class ZoneMangerSettings
        {
            [JsonProperty("enable ignored zones")]
            public bool EnabledIgnoredZones;
            [JsonProperty("ignore these zone ids, leave empty to exclude all zones")]
            public List<string> IgnoredZones;
        }

        #endregion

        #region Storage

        private void LoadDefaultData()
        {
            _storedData = new StoredData();
            _storedData.CrateEventEntries = new List<EventEntry>
            {
                new()
                {
                    EventName = "Easy",
                    EventDuration = 1800.0f,

                    EnableAutoHack = true,
                    HackSeconds = 60f,

                    EnableLockToPlayer = true,
                    EnableClanTag = true,

                    EnableMarker = true,
                    MapMarkerColor1 = "#32A844",
                    MapMarkerColor2 = "#000000",
                    MapMarkerOpacity = 0.6f,
                    MapMarkerRadius = 0.7f,

                    EnableLootTable = false,
                    LootMinAmount = 6,
                    LootMaxAmount = 10,
                    LootTable = new List<ItemEntry>(),

                    EnableEliminateGuards = true,
                    GuardAmount = 8,
                    GuardConfig = new GuardConfig
                    {
                        Name = "Easy Crate",
                        WearItems = new List<GuardConfig.WearEntry>
                        {
                            new()
                            {
                                ShortName = "hazmatsuit_scientist_peacekeeper",
                                SkinID = 0UL
                            }
                        },
                        BeltItems = new List<GuardConfig.BeltEntry>
                        {
                            new()
                            {
                                ShortName = "smg.mp5",
                                Amount = 1,
                                SkinID = 0UL,
                                Mods = new List<string>()
                            },
                            new()
                            {
                                ShortName = "syringe.medical",
                                Amount = 10,
                                SkinID = 0UL,
                                Mods = new List<string>()
                            },
                        },
                        Kit = "",
                        Health = 200.0f,
                        RoamRange = 5.0f,
                        ChaseRange = 40.0f,
                        SenseRange = 150.0f,
                        AttackRangeMultiplier = 8.0f,
                        CheckVisionCone = false,
                        VisionCone = 180.0f,
                        DamageScale = 1.0f,
                        TurretDamageScale = 0.25f,
                        AimConeScale = 0.25f,
                        DisableRadio = false,
                        CanRunAwayWater = true,
                        CanSleep = false,
                        SleepDistance = 100f,
                        Speed = 8.5f,
                        AboveOrUnderGround = false,
                        Stationary = false,
                        MemoryDuration = 30.0f
                    }
                },
                new()
                {
                    EventName = "Medium",
                    EventDuration = 1800.0f,

                    EnableAutoHack = true,
                    HackSeconds = 120.0f,

                    EnableLockToPlayer = true,
                    EnableClanTag = true,

                    EnableMarker = true,
                    MapMarkerColor1 = "#EDDF45",
                    MapMarkerColor2 = "#000000",
                    MapMarkerOpacity = 0.6f,
                    MapMarkerRadius = 0.7f,

                    EnableLootTable = false,
                    LootMinAmount = 6,
                    LootMaxAmount = 10,
                    LootTable = new List<ItemEntry>(),

                    EnableEliminateGuards = true,
                    GuardAmount = 10,
                    GuardConfig = new GuardConfig
                    {
                        Name = "Medium Guard",
                        WearItems = new List<GuardConfig.WearEntry>
                        {
                            new()
                            {
                                ShortName = "hazmatsuit_scientist_peacekeeper",
                                SkinID = 0UL
                            }
                        },
                        BeltItems = new List<GuardConfig.BeltEntry>
                        {
                            new()
                            {
                                ShortName = "smg.mp5",
                                Amount = 1,
                                SkinID = 0UL,
                                Mods = new List<string>()
                            },
                            new()
                            {
                                ShortName = "syringe.medical",
                                Amount = 10,
                                SkinID = 0UL,
                                Mods = new List<string>()
                            },
                        },
                        Kit = "",
                        Health = 250.0f,
                        RoamRange = 5.0f,
                        ChaseRange = 40.0f,
                        SenseRange = 150.0f,
                        AttackRangeMultiplier = 8.0f,
                        CheckVisionCone = false,
                        VisionCone = 180.0f,
                        DamageScale = 1.0f,
                        TurretDamageScale = 0.25f,
                        AimConeScale = 0.25f,
                        DisableRadio = false,
                        CanRunAwayWater = true,
                        CanSleep = false,
                        SleepDistance = 100f,
                        Speed = 8.5f,
                        AboveOrUnderGround = false,
                        Stationary = false,
                        MemoryDuration = 30.0f
                    }
                },
                new()
                {
                    EventName = "Hard",
                    EventDuration = 1800.0f,

                    EnableAutoHack = true,
                    HackSeconds = 180.0f,

                    EnableLockToPlayer = true,
                    EnableClanTag = true,

                    EnableMarker = true,
                    MapMarkerColor1 = "#3060D9",
                    MapMarkerColor2 = "#000000",
                    MapMarkerOpacity = 0.6f,
                    MapMarkerRadius = 0.7f,

                    EnableLootTable = false,
                    LootMinAmount = 6,
                    LootMaxAmount = 10,
                    LootTable = new List<ItemEntry>(),

                    EnableEliminateGuards = true,
                    GuardAmount = 12,
                    GuardConfig = new GuardConfig
                    {
                        Name = "Hard Guard",
                        WearItems = new List<GuardConfig.WearEntry>
                        {
                            new()
                            {
                                ShortName = "hazmatsuit_scientist_peacekeeper",
                                SkinID = 0UL
                            }
                        },
                        BeltItems = new List<GuardConfig.BeltEntry>
                        {
                            new()
                            {
                                ShortName = "rifle.ak",
                                Amount = 1,
                                SkinID = 0UL,
                                Mods = new List<string>()
                            },
                            new()
                            {
                                ShortName = "syringe.medical",
                                Amount = 10,
                                SkinID = 0UL,
                                Mods = new List<string>()
                            },
                        },
                        Kit = "",
                        Health = 300.0f,
                        RoamRange = 5.0f,
                        ChaseRange = 40.0f,
                        SenseRange = 150.0f,
                        AttackRangeMultiplier = 8.0f,
                        CheckVisionCone = false,
                        VisionCone = 180.0f,
                        DamageScale = 1.0f,
                        TurretDamageScale = 0.25f,
                        AimConeScale = 0.15f,
                        DisableRadio = false,
                        CanRunAwayWater = true,
                        CanSleep = false,
                        SleepDistance = 100f,
                        Speed = 8.5f,
                        AboveOrUnderGround = false,
                        Stationary = false,
                        MemoryDuration = 30.0f
                    }
                }
            };
            
            SaveData();
        }

        private void LoadData()
        {
            try
            {
                _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
                if (_storedData == null || !_storedData.IsValid) throw new Exception();
            }
            catch
            {
                PrintWarning("Loaded default data.");
                LoadDefaultData();
            }
        }

        private void SaveData()
        {
            if (_storedData == null || !_storedData.IsValid) return;
            Interface.Oxide.DataFileSystem.WriteObject(Name, _storedData);
        }

        private class StoredData
        {
            public List<EventEntry> CrateEventEntries = new();

            [JsonIgnore] 
            private string[] _eventNames;

            [JsonIgnore]
            public string[] EventNames
            {
                get
                {
                    return _eventNames ??= CrateEventEntries
                        .Select(x => x.EventName)
                        .ToArray();
                }
            }
            
            [JsonIgnore] 
            public bool IsValid => CrateEventEntries != null && CrateEventEntries.Count > 0;

            public EventEntry FindEventByName(string eventName)
            {
                return CrateEventEntries.Find(x => x.EventName.Equals(eventName, StringComparison.OrdinalIgnoreCase));
            }
        }

        private class EventEntry
        {
            [JsonProperty("event display name)")]
            public string EventName;
            [JsonProperty("event duration")]
            public float EventDuration;

            [JsonProperty("enable lock to player when completing the event")]
            public bool EnableLockToPlayer;

            [JsonProperty("enable clan tag")]
            public bool EnableClanTag;
            
            [JsonProperty("enable auto hacking of crate when an event is finished")]
            public bool EnableAutoHack;
            [JsonProperty("hackable locked crate")]
            public float HackSeconds;

            [JsonProperty("enable marker")]
            public bool EnableMarker;
            [JsonProperty("marker color 1")]
            public string MapMarkerColor1;
            [JsonProperty("marker color 2")]
            public string MapMarkerColor2;
            [JsonProperty("marker radius")]
            public float MapMarkerRadius;
            [JsonProperty("marker opacity")]
            public float MapMarkerOpacity;

            [JsonProperty("enable loot table")]
            public bool EnableLootTable;
            [JsonProperty("min loot items")]
            public int LootMinAmount;
            [JsonProperty("max loot items")]
            public int LootMaxAmount;
            [JsonProperty("enable eliminate all guards before looting")]
            public bool EnableEliminateGuards;
            
            [JsonProperty("guard spawn amount")]
            public int GuardAmount;
            [JsonProperty("guard spawn config")]
            public GuardConfig GuardConfig;

            [JsonProperty("create loot items")]
            public List<ItemEntry> LootTable;
        }

        private class ItemEntry
        {
            public string DisplayName;
            public string Shortname; 
            public ulong SkinID = 0UL;
            public int MinAmount;
            public int MaxAmount;
            
            public static List<ItemEntry> SaveItems(ItemContainer container)
            {
                List<ItemEntry> items = new List<ItemEntry>();

                foreach (Item item in container.itemList)
                {
                    items.Add(new ItemEntry
                    {
                        DisplayName = item.name,
                        Shortname = item.info.shortname,
                        SkinID = item.skin,
                        MinAmount = item.amount,
                        MaxAmount = item.amount,
                    });
                }

                return items;
            }

            public Item CreateItem()
            {
                Item item =  ItemManager.CreateByName(Shortname, UnityEngine.Random.Range(MinAmount, MaxAmount), SkinID);
                item.name = DisplayName;
                item.MarkDirty();
                return item;
            }
        }
        
        private class GuardConfig
        {
            public string Name;
            public List<WearEntry> WearItems;
            public List<BeltEntry> BeltItems;            
            public string Kit;
            public float Health;
            public float RoamRange;
            public float ChaseRange;
            public float SenseRange;
            public float AttackRangeMultiplier;
            public bool CheckVisionCone;
            public float VisionCone;
            public float DamageScale;
            public float TurretDamageScale;
            public float AimConeScale;
            public bool HostileTargetsOnly;
            public bool DisableRadio;
            public bool CanRunAwayWater;
            public bool CanSleep;
            public float SleepDistance;
            public float Speed;
            public bool AboveOrUnderGround;
            public bool Stationary;
            public float MemoryDuration;
            
            [JsonIgnore] 
            public JObject Parsed;

            public class BeltEntry
            {
                public string ShortName;
                public ulong SkinID;
                public int Amount;
                public string Ammo;
                public List<string> Mods;

                public static List<BeltEntry> SaveItems(ItemContainer container)
                {
                    List<BeltEntry> items = new List<BeltEntry>();
                    
                    foreach (Item item in container.itemList)
                    {
                        BeltEntry beltEntry = new BeltEntry
                        {
                            ShortName = item.info.shortname,
                            SkinID = item.skin,
                            Amount = item.amount,
                            Mods = new List<string>()
                        };

                        if (item.GetHeldEntity() is BaseProjectile projectile && projectile?.primaryMagazine != null && projectile.primaryMagazine.ammoType != null)
                            beltEntry.Ammo = projectile.primaryMagazine.ammoType.shortname;
                        
                        if (item?.contents?.itemList != null)
                        {
                            foreach (Item itemContent in item.contents.itemList)
                                beltEntry.Mods.Add(itemContent.info.shortname);
                        }
                        
                        items.Add(beltEntry);
                    }

                    return items;
                }
            }

            public class WearEntry
            {
                public string ShortName; 
                public ulong SkinID;

                public static List<WearEntry> SaveItems(ItemContainer container)
                {
                    List<WearEntry> items = new List<WearEntry>();

                    foreach (Item item in container.itemList)
                    {
                        items.Add(new WearEntry
                        {
                            ShortName = item.info.shortname,
                            SkinID = item.skin
                        });
                    }

                    return items;
                }
            }

            public void CacheConfig()
            {
                Parsed = new JObject
                {
                    ["Name"] = Name,
                    ["WearItems"] = new JArray { WearItems.Select(x => new JObject { ["ShortName"] = x.ShortName, ["SkinID"] = x.SkinID }) },
                    ["BeltItems"] = new JArray { BeltItems.Select(x => new JObject { ["ShortName"] = x.ShortName, ["Amount"] = x.Amount, ["SkinID"] = x.SkinID, ["Mods"] = new JArray { x.Mods }, ["Ammo"] = x.Ammo }) },
                    ["Kit"] = Kit,
                    ["Health"] = Health,
                    ["RoamRange"] = RoamRange,
                    ["ChaseRange"] = ChaseRange,
                    ["SenseRange"] = SenseRange,
                    ["ListenRange"] = SenseRange / 2f,
                    ["AttackRangeMultiplier"] = AttackRangeMultiplier,
                    ["CheckVisionCone"] = CheckVisionCone,
                    ["VisionCone"] = VisionCone,
                    ["HostileTargetsOnly"] = HostileTargetsOnly,
                    ["DamageScale"] = DamageScale,
                    ["TurretDamageScale"] = TurretDamageScale,
                    ["AimConeScale"] = AimConeScale,
                    ["DisableRadio"] = DisableRadio,
                    ["CanRunAwayWater"] = CanRunAwayWater,
                    ["CanSleep"] = CanSleep,
                    ["SleepDistance"] = SleepDistance,
                    ["Speed"] = Speed,
                    ["AreaMask"] = !AboveOrUnderGround ? 1 : 25,
                    ["AgentTypeID"] = !AboveOrUnderGround ? -1372625422 : 0,
                    ["HomePosition"] = string.Empty,
                    ["MemoryDuration"] = MemoryDuration,
                    ["States"] = new JArray
                    {
                        Stationary 
                            ? new HashSet<string> { "IdleState", "CombatStationaryState" }
                            : new HashSet<string> { "RoamState", "CombatState", "ChaseState", "RaidState" }
                    }
                };
            }
        }

        #endregion

        #region Lang

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { LangKeys.NoPermission, "Sorry you don't have permission to do that." },
                { LangKeys.Prefix, "<color=#8a916f>Guarded Crate</color>:\n" },

                { LangKeys.FailedToStartEvent, "Failed to start event." },
                { LangKeys.StartEvent, "Event starting." },
                { LangKeys.ClearEvents, "Cleaning up all running events." },
                
                { LangKeys.EventStart, "Special delivery is on its way to <color=#e7cf85>{0}</color> watch out it is heavily contested by guards, severity level <color=#e7cf85>{1}</color>.\nBe fast before the event ends in <color=#e7cf85>{2}</color>." },
                { LangKeys.EventCompleted, "<color=#e7cf85>{1}</color> has cleared the event at <color=#e7cf85>{0}</color>." },
                { LangKeys.EventEnded, "Event ended at <color=#e7cf85>{0}</color>; You were not fast enough; better luck next time!" },
                { LangKeys.EventNotFound, "Event not found, please make sure you have typed the correct name." },
                { LangKeys.EventIntersecting, "Another event is intersecting this position." },
                { LangKeys.EventPositionInvalid, "Event position invalid." },
                { LangKeys.EliminateGuards, "The crate is still contested eliminate all guards to gain access to high-valued loot." },
                { LangKeys.EventUpdated, "Event updated, please reload the plugin to take effect." },
                { LangKeys.InvalidGuardAmount, "Invalid guard amount must be between {0} - {1}." },
                
                { LangKeys.HelpStartEvent, "<color=#e7cf85>/{0}</color> start \"<color=#e7cf85><{1}></color>\", start an event of a specified type." },
                { LangKeys.HelpStopEvent, "<color=#e7cf85>/{0}</color> stop, stop all currently running events.\n\n" },
                { LangKeys.HelpHereEvent, "<color=#e7cf85>/{0}</color> here \"<color=#e7cf85><event-name></color>\", start an event at your position\n\n" },
                { LangKeys.HelpPositionEvent, "<color=#e7cf85>/{0}</color> position \"<color=#e7cf85><event-name></color>\" \"<color=#e7cf85>x y z</color>\", start an event at a specified position.\n\n" },
                { LangKeys.HelpLootEvent, "<color=#e7cf85>/{0}</color> loot \"<color=#e7cf85><event-name></color>\", create loot items that you wish to spawn in the crate, add the items to your inventory and run the command.\n\n" },
                { LangKeys.HelpGuardAmount, "<color=#e7cf85>/{0}</color> amount \"<color=#e7cf85><event-name></color>\", specify the guard amount to spawn.\n\n" },
                { LangKeys.HelpGuardLoadout, "<color=#e7cf85>/{0}</color> loadout \"<color=#e7cf85><event-name></color>\", set guard loadout using items in your inventory." }
            }, this);
        }

        private struct LangKeys
        {
            public const string Prefix = "Prefix";
            public const string NoPermission = "NoPermission";
            
            public const string FailedToStartEvent = "FailedToStartEvent";
            public const string ClearEvents = "ClearEvents";
            public const string StartEvent = "StartEvent";
            
            public const string EventCompleted = "EventCompleted";
            public const string EventStart = "EventStart";
            public const string EventEnded = "EventClear";
            public const string EventNotFound = "EventNotFound";
            public const string EventPositionInvalid = "EventPosInvalid";
            public const string EventIntersecting = "EventNearby";
            public const string EventUpdated = "EventUpdated";
            public const string EliminateGuards = "EliminateGuards";
            public const string InvalidGuardAmount = "InvalidGuardAmount";
            
            public const string HelpStartEvent = "HelpStartEvent";
            public const string HelpStopEvent = "HelpStopEvent";
            public const string HelpHereEvent = "HelpHereEvent";
            public const string HelpPositionEvent = "HelpPositionEvent";
            public const string HelpLootEvent = "HelpLootEvent";
            public const string HelpGuardAmount = "HelpGuardAmount";
            public const string HelpGuardLoadout = "HelpGuardLoadout";
        }

        #endregion
        
        #region Oxide Hooks

        private void OnServerInitialized()
        {
            SpawnManager.FindSpawnPoints();
            
            if (!string.IsNullOrEmpty(_configData.CommandName))
            {
                cmd.AddConsoleCommand(_configData.CommandName, this, nameof(GuardedCrateConsoleCommand));
                cmd.AddChatCommand(_configData.CommandName, this, nameof(EventCommandCommands));                
            }

            if (_configData.EnableAutoStart && _configData.AutoStartDuration > 0) 
                timer.Every(_configData.AutoStartDuration, () => TryStartEvent(null));
        }
        
        private void Init()
        {
            permission.RegisterPermission(PERM_USE, this);
            
            _instance = this;
            
            LoadData();
            
            SpawnManager.Initialize();
        }
        
        private void Unload()
        {
            GuardedCrateManager.OnUnload();
            EntitiesCache.OnUnload();
            SpawnManager.OnUnload();
            
            _instance = null;
        }

        private void OnEntityDeath(ScientistNPC scientist, HitInfo info)
        {
            EntitiesCache.FindCrateInstance(scientist)?.OnGuardKilled(scientist, info?.InitiatorPlayer);
            EntitiesCache.RemoveEntity(scientist);
        }
        
        private void OnEntityKill(ScientistNPC scientist)
        {
            EntitiesCache.FindCrateInstance(scientist)?.OnGuardKilled(scientist, null);
            EntitiesCache.RemoveEntity(scientist);
        }
        
        private void OnEntityKill(LootContainer container)
        {
            EntitiesCache.FindCrateInstance(container)?.OnCrateKilled(container);
            EntitiesCache.RemoveEntity(container);
        }
        
        private void OnEntityKill(CargoPlane plane)
        {
            EntitiesCache.FindCrateInstance(plane)?.OnPlaneKilled(plane);
            EntitiesCache.RemoveEntity(plane);
        }

        private object CanHackCrate(BasePlayer player, HackableLockedCrate crate)
        {
            return EntitiesCache.FindCrateInstance(crate)
                ?.CanHackCrate(player);
        }

        #endregion
        
        #region Spawn Manager

        private static class SpawnManager
        {
            private static readonly LayerMask InterestedLayers = LayerMask.GetMask("Prevent_Building", "Vehicle_World", "Vehicle_Large", "Vehicle_Detailed");
            private static List<ZoneInfo> _ignoredZones;
            private static List<Collider> _tempColliders;
            private static List<Vector3> _spawnPoints;
            private static Coroutine _spawnRoutine;
            
            public static void Initialize()
            {
                _ignoredZones = new List<ZoneInfo>();
                _tempColliders = new List<Collider>();
                _spawnPoints = new List<Vector3>();
            }

            public static void OnUnload()
            {
                if (_spawnRoutine != null)
                    ServerMgr.Instance.StopCoroutine(_spawnRoutine);
                
                _ignoredZones.Clear();
                _tempColliders.Clear();
                _spawnPoints.Clear();
                _ignoredZones = null;
                _tempColliders = null;
                _spawnPoints = null;
                _spawnRoutine = null;
            }

            public static void FindSpawnPoints()
            {
                if (_spawnRoutine != null)
                    return;
                
                _spawnRoutine = ServerMgr.Instance.StartCoroutine(GenerateSpawnPoints(true));
            }
            
            private static IEnumerator GenerateSpawnPoints(bool exclusionZones, int attempts = 5000)
            {
                yield return null;
                
                if (exclusionZones && _instance._configData.ZoneManagerSettings.EnabledIgnoredZones)
                {
                    GetIgnoredZones();
                    yield return CoroutineEx.waitForEndOfFrame;
                    yield return CoroutineEx.waitForEndOfFrame;
                }
                
                float mapSizeX = TerrainMeta.Size.x / 2;
                float mapSizeZ = TerrainMeta.Size.z / 2;
                Vector3 spawnPoint = Vector3.zero;
                
                List<Vector3> list = Facepunch.Pool.Get<List<Vector3>>();
                
                for (int i = 0; i < attempts; i++)
                {
                    spawnPoint.x = UnityEngine.Random.Range(-mapSizeX, mapSizeX);
                    spawnPoint.z = UnityEngine.Random.Range(-mapSizeZ, mapSizeZ);
                    
                    if (TestSpawnPoint(ref spawnPoint))
                        list.Add(spawnPoint);

                    if (i % 10 == 0)
                        yield return CoroutineEx.waitForEndOfFrame;
                }

                _spawnPoints.AddRange(list);
                _tempColliders.Clear();
                
                Facepunch.Pool.FreeUnmanaged<Vector3>(ref list);
                Interface.Oxide.LogDebug("GuardedCrate: successfully found {0} spawn points.", _spawnPoints.Count);
                
                _spawnRoutine = null;
            }

            public static Vector3 GetSpawnPoint()
            {
                if (!(_spawnPoints?.Count > 0)) 
                    return Vector3.zero;
                
                for (int i = 0; i < 50; i++)
                {
                    Vector3 spawnPoint = _spawnPoints.GetRandom();
                    if (IsSpawnPointValid(spawnPoint)) 
                        return spawnPoint;
                    
                    _spawnPoints.Remove(spawnPoint);
                    
                    if (_spawnRoutine == null && _spawnPoints.Count < 50)
                        _spawnRoutine = ServerMgr.Instance.StartCoroutine(GenerateSpawnPoints(false));
                }

                return Vector3.zero;
            }
            
            private static void GetIgnoredZones()
            {
                if (_instance._configData.ZoneManagerSettings?.IgnoredZones == null ||
                    _instance._configData.ZoneManagerSettings.IgnoredZones.Count == 0)
                    return;

                if (_instance.ZoneManager == null || !_instance.ZoneManager.IsLoaded)
                    return;
                
                string[] zoneIds = _instance?.ZoneManager.Call("GetZoneIDs") as string[];
                if (zoneIds == null)
                    return;
                
                foreach (string zoneId in zoneIds)
                    AddIgnoredZone(zoneId);
            }

            private static void AddIgnoredZone(string zoneId)
            {
                if (!_instance._configData.ZoneManagerSettings.IgnoredZones.Contains(zoneId))
                    return;
                
                if (_instance.ZoneManager.Call("GetZoneLocation", zoneId) is not Vector3 position ||
                    position == Vector3.zero)
                    return;

                if (_instance.ZoneManager.Call("GetZoneRadius", zoneId) is not float radius)
                    return;
                
                _ignoredZones.Add(new ZoneInfo(position, radius));
            }

            private static bool TestSpawnPoint(ref Vector3 spawnPoint)
            {
                if (!Physics.Raycast(spawnPoint + Vector3.up * 300f, Vector3.down, out RaycastHit hit, 400f, Layers.Solid) || hit.GetEntity() != null) 
                    return false;
                
                spawnPoint.y = hit.point.y;
                
                if (!ValidBounds.TestInnerBounds(spawnPoint)) 
                    return false;
                
                if (AntiHack.TestInsideTerrain(spawnPoint)) 
                    return false;
                
                if (AntiHack.IsInsideMesh(spawnPoint)) 
                    return false;

                if (IsIgnoredZone(spawnPoint))
                    return false;

                return !IsBlockedTopology(spawnPoint) && IsSpawnPointValid(spawnPoint);
            }
            
            private static bool IsBlockedTopology(Vector3 spawnPoint)
            {
                return (TerrainMeta.TopologyMap.GetTopology(spawnPoint) & (int)BLOCKED_TOPOLOGY) != 0;
            }
            
            private static bool IsIgnoredZone(Vector3 spawnPoint)
            {
                foreach (ZoneInfo zoneInfo in _ignoredZones)
                {
                    if (zoneInfo.IsInBounds(spawnPoint))
                        return true;
                }
                
                return false;
            }
            
            private static bool IsSpawnPointValid(Vector3 spawnPoint) 
            {
                if (WaterLevel.Test(spawnPoint, true, true))
                    return false;

                try
                {
                    Vis.Colliders(spawnPoint, 15f, _tempColliders);
                    
                    foreach (Collider collider in _tempColliders)
                    {
                        if ((1 << collider.gameObject.layer & InterestedLayers) > 0)
                            return false;
                        
                        if (collider.name.Contains("radiation", CompareOptions.IgnoreCase))
                            return false;
                        
                        if (collider.name.Contains("rock", CompareOptions.IgnoreCase))
                            return false;
                        
                        if (collider.name.Contains("cliff", CompareOptions.IgnoreCase))
                            return false;
                        
                        if (collider.name.Contains("fireball", CompareOptions.IgnoreCase) ||
                            collider.name.Contains("iceberg", CompareOptions.IgnoreCase) ||
                            collider.name.Contains("ice_sheet", CompareOptions.IgnoreCase))
                            return false;
                    }
                }
                finally
                {
                    _tempColliders.Clear();
                }
                
                List<BasePlayer> players = Facepunch.Pool.Get<List<BasePlayer>>();

                try
                {
                    Vis.Entities(spawnPoint, 150, players, Layers.Mask.Player_Server);

                    foreach (BasePlayer player in players)
                    {
                        if (!player.IsSleeping() && !player.IsVisibleAndCanSee(spawnPoint))
                            return false;
                    }
                }
                finally
                {
                    Facepunch.Pool.FreeUnmanaged<BasePlayer>(ref players);
                }
                
                List<BaseEntity> entities = Facepunch.Pool.Get<List<BaseEntity>>();

                try
                {
                    Vis.Entities(spawnPoint, 150f, entities, Layers.PlayerBuildings);
                    
                    if (entities.Count > 0)
                        return false;
                }
                finally
                {
                    Facepunch.Pool.FreeUnmanaged<BaseEntity>(ref entities);
                }
                
                return true;
            }
        }

        private class ZoneInfo
        {
            public Vector3 Position;
            public float Radius;

            public ZoneInfo() { }

            public ZoneInfo(Vector3 position, float radius)
            {
                Position = position;
                Radius = radius;
            }
            
            public bool IsInBounds(Vector3 position)
            {
                return Vector3Ex.Distance2D(Position, position) <= Radius;
            }
        }

        #endregion

        #region Guarded Crate Manager

        private static class GuardedCrateManager
        {
            private static readonly List<GuardedCrateInstance> GuardedCrateInstances = new();

            public static void OnUnload() => CleanupInstances();

            public static bool HasIntersectingEvent(Vector3 position)
            {
                for (int i = 0; i < GuardedCrateInstances.Count; i++)
                {
                    GuardedCrateInstance crateInstance = GuardedCrateInstances[i];
                    if (crateInstance != null && Vector3Ex.Distance2D(crateInstance.transform.position, position) < 80f)
                        return true;
                }

                return false;
            }

            public static void CleanupInstances()
            {
                for (int i = GuardedCrateInstances.Count - 1; i >= 0; i--)
                    GuardedCrateInstances[i]?.EventEnded(true);
                
                GuardedCrateInstances.Clear();
            }
            
            public static void RegisterInstance(GuardedCrateInstance crateInstance)
            {
                GuardedCrateInstances.Add(crateInstance);
                
                _instance?.SubscribeToHooks(GuardedCrateInstances.Count);
            }
            
            public static void UnregisterInstance(GuardedCrateInstance crateInstance)
            {
                GuardedCrateInstances.Remove(crateInstance);
                
                _instance?.SubscribeToHooks(GuardedCrateInstances.Count);
            }
        }

        #endregion

        #region Guarded Crate Event

        private bool TryStartEvent(string eventName = null)
        {
            if (!NpcSpawn.IsPluginReady())
            {
                PrintWarning("NpcSpawn not loaded please download from https://codefling.com");
                Interface.Oxide.UnloadPlugin(Name);
                return false;
            }

            Vector3 position = SpawnManager.GetSpawnPoint();
            if (position == Vector3.zero)
            {
                PrintWarning("Failed to find a valid spawn point.");
                return false;
            }

            EventEntry eventEntry = !string.IsNullOrEmpty(eventName) ? _storedData.FindEventByName(eventName) : _storedData.CrateEventEntries.GetRandom();
            if (eventEntry == null)
            {
                PrintWarning("Failed to find a valid event entry please check your configuration.");
                return false;
            }
            
            GuardedCrateInstance.CreateInstance(eventEntry, position);
            return true;
        }
        
        private class GuardedCrateInstance : MonoBehaviour
        {
            public List<BaseEntity> guardSpawnInstances = new();
            public MapMarkerGenericRadius markerSpawnInstance;
            public HackableLockedCrate crateSpawnInstance;
            public CargoPlane planeSpawnInstance;
            public GuardConfig guardConfig;
            public List<ItemEntry> lootTable;
            private EventState eventState;

            public string eventName;
            public float eventSeconds = 120f;
            
            public bool enableLockToPlayer;
            public bool enableClanTag;

            public bool enableAutoHack;
            public float hackSeconds;
            
            public bool enableMarker;
            public Color markerColor1;
            public Color markerColor2;
            public float markerRadius;
            public float markerOpacity;

            public bool enableEliminateGuards;
            public int guardAmount;

            public bool enableLootTable;
            public int minLootAmount;
            public int maxLootAmount;
            
            public float thinkEvery = 1f;
            public float lastThinkTime;
            public float timePassed;
            public bool timeEnded;
            
            public static void CreateInstance(EventEntry eventEntry, Vector3 position)
            {
                if (eventEntry.GuardConfig.Parsed == null)
                    eventEntry.GuardConfig.CacheConfig();
                
                GuardedCrateInstance crateInstance = CustomUtils.CreateObjectWithComponent<GuardedCrateInstance>(position, Quaternion.identity, "Guarded_Create_Event");
                crateInstance.gameObject.AddComponent<SphereCollider>().radius = 15f;
                
                crateInstance.eventName = eventEntry.EventName;
                crateInstance.eventSeconds = eventEntry.EventDuration;
                
                crateInstance.enableLockToPlayer = eventEntry.EnableLockToPlayer;
                crateInstance.enableClanTag = eventEntry.EnableClanTag;
                
                crateInstance.enableAutoHack = eventEntry.EnableAutoHack;
                crateInstance.hackSeconds = eventEntry.HackSeconds;
                
                crateInstance.enableMarker = eventEntry.EnableMarker;
                crateInstance.markerColor1 = CustomUtils.GetColor(eventEntry.MapMarkerColor1);
                crateInstance.markerColor2 = CustomUtils.GetColor(eventEntry.MapMarkerColor2);
                crateInstance.markerRadius = eventEntry.MapMarkerRadius;
                crateInstance.markerOpacity = eventEntry.MapMarkerOpacity;
                
                crateInstance.enableLootTable = eventEntry.EnableLootTable;
                crateInstance.lootTable = eventEntry.LootTable;
                crateInstance.minLootAmount = eventEntry.LootMinAmount;
                crateInstance.maxLootAmount = eventEntry.LootMaxAmount;
                
                crateInstance.enableEliminateGuards = eventEntry.EnableEliminateGuards;
                crateInstance.guardConfig = eventEntry.GuardConfig;
                crateInstance.guardAmount = eventEntry.GuardAmount;
                crateInstance.EventStartup();
                
                GuardedCrateManager.RegisterInstance(crateInstance);
            }
            
            public static void RemoveInstance(GuardedCrateInstance crateInstance)
            {
                GuardedCrateManager.UnregisterInstance(crateInstance);
                
                if (crateInstance?.gameObject != null)
                    UnityEngine.GameObject.DestroyImmediate(crateInstance.gameObject);
            }

            #region Unity

            private void FixedUpdate()
            {
                if (lastThinkTime < thinkEvery)
                {
                    lastThinkTime += UnityEngine.Time.deltaTime;
                }
                else
                {
                    if (timeEnded)
                        return;

                    timePassed += lastThinkTime;

                    if (timePassed >= eventSeconds)
                    {
                        timeEnded = true;
                        EventFailed();
                        return;
                    }

                    lastThinkTime = 0.0f;
                }
            }

            #endregion
            
            #region Setup / Destroy

            private IEnumerator Initialize()
            {
                yield return CoroutineEx.waitForEndOfFrame;
                eventState = EventState.Active;
                yield return SpawnPlane();
                Notification.MessagePlayers(LangKeys.EventStart, MapHelper.PositionToString(transform.position), eventName, eventSeconds.ToStringTime());
            }
            
            public void Dispose()
            {
                StopAllCoroutines();
                CancelInvoke();
                ClearEntities();
                
                GuardedCrateInstance.RemoveInstance(this);
            }
            
            #endregion
            
            #region Management

            public void EventStartup()
            {
                enabled = true;
                eventState = EventState.Starting;
                StartCoroutine(Initialize());
                Interface.Oxide.CallHook("OnGuardedCrateEventStart", transform.position);
            }
            
            public void EventComplete(BasePlayer player)
            {
                if (eventState != EventState.Active)
                    return;
                
                eventState = EventState.Completed;
                EventWinner(player);
                UnlockCrates();
                EventEnded();
            }

            public void EventFailed()
            {
                eventState = EventState.Failed;
                Interface.Oxide.CallHook("OnGuardedCrateEventFailed", transform.position);
                Notification.MessagePlayers(LangKeys.EventEnded, MapHelper.PositionToString(transform.position));
                EventEnded(true);
            }

            public void EventEnded(bool forced = false) => Dispose();
            
            private void EventWinner(BasePlayer player)
            {
                if (player == null) 
                    return;
                
                string displayName = player.displayName;
                
                if (enableClanTag)
                {
                    if (_instance != null && _instance.Clans.IsPluginReady())
                        displayName = string.Format("[{0}]{1}", _instance.Clans.Call<string>("GetClanOf", player.userID), displayName);
                }

                if (enableLockToPlayer)
                {
                    if (_instance != null && _instance.HackableLock.IsPluginReady())
                        _instance.HackableLock.Call("LockCrateToPlayer", player, crateSpawnInstance);
                }
                
                Interface.CallHook("OnGuardedCrateEventEnded", player, crateSpawnInstance);
                Notification.MessagePlayers(LangKeys.EventCompleted, MapHelper.PositionToString(transform.position), displayName);
            }
            
            private void UnlockCrates()
            {
                if (eventState != EventState.Completed) 
                    return;

                if (enableAutoHack)
                    crateSpawnInstance.StartHacking();
                
                crateSpawnInstance.shouldDecay = true;
                crateSpawnInstance.RefreshDecay();
            }
            
            #endregion
            
            #region Spawning
            
            public IEnumerator SpawnEntities()
            {
                yield return CoroutineEx.waitForEndOfFrame;
                yield return SpawnMarker();
                yield return SpawnCrate();
                yield return SpawnGuards();
            }
            
            private IEnumerator SpawnPlane()
            {
                yield return CoroutineEx.waitForEndOfFrame;
                
                planeSpawnInstance = (CargoPlane)GameManager.server.CreateEntity(PLANE_PREFAB);
                planeSpawnInstance.InitDropPosition(transform.position);
                planeSpawnInstance.Spawn();
                planeSpawnInstance.secondsTaken = 0f;
                planeSpawnInstance.secondsToTake = 30f;
                planeSpawnInstance.gameObject.AddComponent<CargoPlaneComponent>().guardedCrate = this;
                
                EntitiesCache.CreateEntity(planeSpawnInstance, this);
            }
            
            private IEnumerator SpawnGuards()
            {
                yield return CoroutineEx.waitForEndOfFrame;
                
                if (_instance == null || !_instance.NpcSpawn.IsPluginReady())
                {
                    Interface.Oxide.LogDebug("NpcSpawn not loaded, please load the plugin.");
                    yield break;
                }

                for (int i = 0; i < guardAmount; i++)
                {
                    Vector3 position = transform.position.GetPointAround(10551297, 5f, (360f / guardAmount) * i);
                    
                    yield return SpawnGuard(position);
                }
            }

            private IEnumerator SpawnGuard(Vector3 position)
            {
                yield return CoroutineEx.waitForEndOfFrame;
                
                guardConfig.Parsed["HomePosition"] = position.ToString();
                
                ScientistNPC entity = (ScientistNPC)_instance?.NpcSpawn.Call("SpawnNpc", position, guardConfig.Parsed);
                guardSpawnInstances.Add(entity);
                EntitiesCache.CreateEntity(entity, this);
            }
            
            private IEnumerator SpawnMarker()
            {
                yield return CoroutineEx.waitForEndOfFrame;

                if (!enableMarker)
                    yield break;
                
                markerSpawnInstance = CustomUtils.CreateEntity<MapMarkerGenericRadius>(MARKER_PREFAB, transform.position, Quaternion.identity);
                markerSpawnInstance.EnableSaving(false);
                markerSpawnInstance.color1 = markerColor1;
                markerSpawnInstance.color2 = markerColor2;
                markerSpawnInstance.radius = markerRadius;
                markerSpawnInstance.alpha = markerOpacity;
                markerSpawnInstance.Spawn();
                markerSpawnInstance.SendUpdate();
                markerSpawnInstance.InvokeRepeating(nameof(MapMarkerGenericRadius.SendUpdate), 10.0f, 10.0f);
            }
            
            private IEnumerator SpawnCrate()
            {
                yield return CoroutineEx.waitForEndOfFrame;
                
                crateSpawnInstance = CustomUtils.CreateEntity<HackableLockedCrate>(CRATE_PREFAB, transform.position + (Vector3.up * 100f), Quaternion.identity);
                crateSpawnInstance.EnableSaving(false);
                crateSpawnInstance.shouldDecay = false;
                crateSpawnInstance.hackSeconds = HackableLockedCrate.requiredHackSeconds - hackSeconds;
                crateSpawnInstance.Spawn();
                crateSpawnInstance.Invoke(RefillCrate, 2f);
                
                EntitiesCache.CreateEntity(crateSpawnInstance, this);
            }
            
            private void ClearGuards()
            {
                for (int i = guardSpawnInstances.Count - 1; i >= 0; i--)
                    guardSpawnInstances[i].SafeKill();
                
                guardSpawnInstances.Clear();
            }
            
            private void ClearMarker()
            {
                markerSpawnInstance.SafeKill();
                markerSpawnInstance = null;
            }
            
            private void ClearCrate(bool completed)
            {
                if (!completed)
                    crateSpawnInstance.SafeKill();
                
                crateSpawnInstance = null;
            }
            
            private void ClearCargoPlane()
            {
                planeSpawnInstance.SafeKill();
                planeSpawnInstance = null;
            }
            
            private void ClearEntities()
            {
                ClearCrate(eventState == EventState.Completed);
                ClearCargoPlane();
                ClearMarker();
                ClearGuards();
            }
            
            #endregion

            #region Loot
            
            public object CanPopulateCrate()
            {
                return !enableLootTable || lootTable.Count <= 0 ? null : (object)false;
            }

            private List<ItemEntry> GenerateLoot()
            {
                int itemCount = UnityEngine.Random.Range(minLootAmount, maxLootAmount);
                int itemTries = 100;

                List<ItemEntry> items = new List<ItemEntry>();

                do
                {
                    ItemEntry lootItem = lootTable.GetRandom();
                    if (!items.Contains(lootItem))
                        items.Add(lootItem);
                } 
                while (items.Count < itemCount && --itemTries > 0);

                return items;
            }

            private void RefillCrate()
            {
                if (!enableLootTable)
                    return;
                
                if (lootTable == null || lootTable.Count == 0) 
                    return;
                
                List<ItemEntry> items = GenerateLoot();
                if (items == null || items.Count == 0)
                    return;

                crateSpawnInstance.inventory.onItemAddedRemoved = null;
                crateSpawnInstance.inventory.SafeClear();
                crateSpawnInstance.inventory.capacity = items.Count;
                
                foreach (ItemEntry lootItem in items)
                {
                    Item item = lootItem.CreateItem();
                    if (!item.MoveToContainer(crateSpawnInstance.inventory))
                        item.Remove();
                }

                items.Clear();
            }
            
            #endregion

            #region Oxide Hooks
            
            public object CanHackCrate(BasePlayer player)
            {
                if (!enableEliminateGuards)
                    return null;

                if (guardSpawnInstances.Count > 0)
                {
                    Notification.MessagePlayer(player, LangKeys.EliminateGuards);
                    return true;
                }
                
                return null;
            }

            public void OnGuardKilled(ScientistNPC scientist, BasePlayer player)
            {
                guardSpawnInstances.Remove(scientist);
                
                timePassed = 0f;
                
                if (guardSpawnInstances.Count > 0) 
                    return;
                
                EventComplete(player);
            }

            public void OnPlaneKilled(CargoPlane plane)
            {
                planeSpawnInstance = null;
            }

            public void OnCrateKilled(LootContainer container)
            {
                crateSpawnInstance = null;
            }

            #endregion
        }

        private class CargoPlaneComponent : MonoBehaviour
        {
            public GuardedCrateInstance guardedCrate;
            public CargoPlane cargoPlane;
            public bool hasDropped;
            
            private void Awake()
            {
                cargoPlane = GetComponent<CargoPlane>();
                cargoPlane.dropped = true;
            }

            private void Update()
            {
                if (hasDropped) 
                    return;
                
                float time = Mathf.InverseLerp(0.0f, cargoPlane.secondsToTake, cargoPlane.secondsTaken);
                if (!(time >= 0.5)) 
                    return;
                
                hasDropped = true;

                if (!guardedCrate.IsUnityNull())
                    guardedCrate.StartCoroutine(guardedCrate.SpawnEntities());
                
                Destroy(this);
            }
        }
        
        private enum EventState
        { 
            Starting,
            Active,
            Failed,
            Completed,
        }

        #endregion
        
        #region Entities Cache

        private static class EntitiesCache
        {
            private static Dictionary<BaseEntity, GuardedCrateInstance> Entities = new();
            
            public static void OnUnload() => Entities.Clear();

            public static GuardedCrateInstance FindCrateInstance(BaseEntity entity)
            {
                if (entity == null) 
                    return null;
                
                return Entities.TryGetValue(entity, out GuardedCrateInstance component) ? component : null;
            }
            
            public static void CreateEntity(BaseEntity entity, GuardedCrateInstance component) => Entities.Add(entity, component);

            public static void RemoveEntity(BaseEntity entity) => Entities.Remove(entity);
        }

        #endregion

        #region Notification

        private static class Notification
        {
            public static void MessagePlayer(ConsoleSystem.Arg arg, string langKey, params object[] args)
            {
                if (_instance == null || arg == null) 
                    return;
                
                arg.ReplyWith((args.Length > 0 ? string.Format(_instance.lang.GetMessage(langKey, _instance), args) : _instance.lang.GetMessage(langKey, _instance)));
            }
        
            public static void MessagePlayer(BasePlayer player, string langKey, params object[] args)
            {
                if (_instance == null || player == null) 
                    return;
                
                player.ChatMessage((args.Length > 0 ? string.Format(_instance.lang.GetMessage(langKey, _instance, player.UserIDString), args) : _instance.lang.GetMessage(langKey, _instance, player.UserIDString)));
            }

            public static void MessagePlayers(string langKey, params object[] args)
            {
                if (_instance == null) 
                    return;
                
                string message = args?.Length > 0 ? string.Format(_instance.lang.GetMessage(langKey, _instance), args) : _instance.lang.GetMessage(langKey, _instance);
                if (_instance._configData.MessageSettings.EnableChat)
                    ConsoleNetwork.BroadcastToAllClients("chat.add", 2, _instance._configData.MessageSettings.ChatIcon, _instance._configData.MessageSettings.EnableChatPrefix ? (_instance.lang.GetMessage(LangKeys.Prefix, _instance) + message) : message);
                if (_instance._configData.MessageSettings.EnableToast)
                    ConsoleNetwork.BroadcastToAllClients("gametip.showtoast_translated", 2, null, message);
                if (_instance._configData.MessageSettings.EnableGuiAnnouncements && _instance.GUIAnnouncements.IsPluginReady())
                    _instance.GUIAnnouncements?.Call("CreateAnnouncement", message, _instance._configData.MessageSettings.GuiAnnouncementsBgColor, _instance._configData.MessageSettings.GuiAnnouncementsTextColor, null, 0.03f);
            }
        }

        #endregion

        #region Console Command
        
        private void GuardedCrateConsoleCommand(ConsoleSystem.Arg arg)
        {
            if (arg == null || !arg.IsRcon) 
                return;
            
            if (!arg.HasArgs())
            {
                DisplayHelpText(arg.Player());
                return;
            }

            string option = arg.GetString(0);
            if (option.Equals("start", StringComparison.OrdinalIgnoreCase))
            {
                bool started = TryStartEvent(string.Join(" ", arg.Args.Skip(1).ToArray()));
                Notification.MessagePlayer(arg, (started ? LangKeys.StartEvent : LangKeys.FailedToStartEvent));
                return;
            }
            
            if (option.Equals("stop", StringComparison.OrdinalIgnoreCase))
            {
                GuardedCrateManager.CleanupInstances();
                Notification.MessagePlayer(arg, LangKeys.ClearEvents);
                return;
            }
            
            if (option.Equals("position", StringComparison.OrdinalIgnoreCase))
            {
                if (!arg.HasArgs(3))
                {
                    DisplayHelpText(arg.Player());
                    return;
                }
                
                EventEntry eventEntry = _storedData.FindEventByName(arg.GetString(1));
                if (eventEntry == null)
                {
                    Notification.MessagePlayer(arg, LangKeys.EventNotFound);
                    return;
                }

                Vector3 position = arg.GetVector3(2);
                if (position == Vector3.zero)
                {
                    Notification.MessagePlayer(arg, LangKeys.EventPositionInvalid);
                    return;
                }

                if (GuardedCrateManager.HasIntersectingEvent(position))
                {
                    Notification.MessagePlayer(arg, LangKeys.EventIntersecting);
                    return;
                }
                
                GuardedCrateInstance.CreateInstance(eventEntry, position);
                return;
            }
            
            DisplayHelpText(arg.Player());
        }

        #endregion

        #region Chat Command
        
        private void EventCommandCommands(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERM_USE))
            {
                Notification.MessagePlayer(player, LangKeys.NoPermission);
                return;
            }

            if (args.Length < 1)
            {
                DisplayHelpText(player);
                return;
            }

            string option = args[0];
            if (option.Equals("start", StringComparison.OrdinalIgnoreCase))
            {
                bool started = TryStartEvent(string.Join(" ", args.Skip(1).ToArray()));
                Notification.MessagePlayer(player, (started ? LangKeys.StartEvent : LangKeys.FailedToStartEvent));
                return;
            }
            
            if (option.Equals("stop", StringComparison.OrdinalIgnoreCase))
            {
                GuardedCrateManager.CleanupInstances();
                Notification.MessagePlayer(player, LangKeys.ClearEvents);
                return;
            }
            
            if (option.Equals("here", StringComparison.OrdinalIgnoreCase))
            {
                if (args.Length < 2)
                {
                    DisplayHelpText(player);
                    return;
                }
                
                EventEntry eventEntry = _storedData.FindEventByName(args[1]);
                if (eventEntry == null)
                {
                    Notification.MessagePlayer(player, LangKeys.EventNotFound);
                    return;
                }
                
                GuardedCrateInstance.CreateInstance(eventEntry, player.transform.position);
                return;
            }

            if (option.Equals("position", StringComparison.OrdinalIgnoreCase))
            {
                if (args.Length < 3)
                {
                    DisplayHelpText(player);
                    return;
                }
                
                EventEntry eventEntry = _storedData.FindEventByName(args[1]);
                if (eventEntry == null)
                {
                    Notification.MessagePlayer(player, LangKeys.EventNotFound);
                    return;
                }

                Vector3 position = args[2].ToVector3();
                if (position == Vector3.zero)
                {
                    Notification.MessagePlayer(player, LangKeys.EventPositionInvalid);
                    return;
                }

                if (GuardedCrateManager.HasIntersectingEvent(position))
                {
                    Notification.MessagePlayer(player, LangKeys.EventIntersecting);
                    return;
                }

                GuardedCrateInstance.CreateInstance(eventEntry, position);
                return;
            }
            
            if (option.Equals("loot", StringComparison.OrdinalIgnoreCase))
            {
                if (args.Length < 2)
                {
                    DisplayHelpText(player);
                    return;
                }

                EventEntry eventEntry = _storedData.FindEventByName(args[1]);
                if (eventEntry == null)
                {
                    Notification.MessagePlayer(player, LangKeys.EventNotFound);
                    return;
                }
                
                if (player.inventory == null)
                    return;
                
                eventEntry.LootTable.Clear();
                eventEntry.LootTable.AddRange(ItemEntry.SaveItems(player.inventory.containerMain));
                eventEntry.LootTable.AddRange(ItemEntry.SaveItems(player.inventory.containerBelt));
                
                SaveData();
                Notification.MessagePlayer(player, LangKeys.EventUpdated);
                return;
            }
            
            if (option.Equals("amount", StringComparison.OrdinalIgnoreCase))
            {
                if (args.Length < 3)
                {
                    DisplayHelpText(player);
                    return;
                }

                EventEntry eventEntry = _storedData.FindEventByName(args[1]);
                if (eventEntry == null)
                {
                    Notification.MessagePlayer(player, LangKeys.EventNotFound);
                    return;
                }
                
                int amount;
                if (!int.TryParse(args[2], out amount) || amount < 1)
                {
                    Notification.MessagePlayer(player, LangKeys.InvalidGuardAmount);
                    return;
                }
                
                eventEntry.GuardAmount = amount;
                
                SaveData();
                Notification.MessagePlayer(player, LangKeys.EventUpdated);
                return;
            }
            
            if (option.Equals("loadout", StringComparison.OrdinalIgnoreCase))
            {
                if (args.Length < 2)
                {
                    DisplayHelpText(player);
                    return;
                }
                
                EventEntry eventEntry = _storedData.FindEventByName(args[1]);
                if (eventEntry == null)
                {
                    Notification.MessagePlayer(player, LangKeys.EventNotFound);
                    return;
                }
                
                if (player.inventory == null)
                    return;
                
                eventEntry.GuardConfig.BeltItems.Clear();
                eventEntry.GuardConfig.WearItems.Clear();
                
                eventEntry.GuardConfig.BeltItems = GuardConfig.BeltEntry.SaveItems(player.inventory.containerBelt);
                eventEntry.GuardConfig.WearItems = GuardConfig.WearEntry.SaveItems(player.inventory.containerWear);
                
                SaveData();
                Notification.MessagePlayer(player, LangKeys.EventUpdated);
                return;
            }
            
            DisplayHelpText(player);
        }
        
        private void DisplayHelpText(BasePlayer player)
        {
            StringBuilder sb = Facepunch.Pool.Get<StringBuilder>();

            try
            {
                sb.Clear();
                sb.AppendFormat(lang.GetMessage(LangKeys.Prefix, this, player.UserIDString))
                    .AppendFormat(lang.GetMessage(LangKeys.HelpStartEvent, this, player.UserIDString), _configData.CommandName, string.Join("|", _storedData.EventNames))
                    .AppendFormat(lang.GetMessage(LangKeys.HelpStopEvent, this, player.UserIDString), _configData.CommandName)
                    .AppendFormat(lang.GetMessage(LangKeys.HelpHereEvent, this, player.UserIDString), _configData.CommandName)
                    .AppendFormat(lang.GetMessage(LangKeys.HelpPositionEvent, this, player.UserIDString), _configData.CommandName)
                    .AppendFormat(lang.GetMessage(LangKeys.HelpLootEvent, this, player.UserIDString), _configData.CommandName)
                    .AppendFormat(lang.GetMessage(LangKeys.HelpGuardAmount, this, player.UserIDString), _configData.CommandName)
                    .AppendFormat(lang.GetMessage(LangKeys.HelpGuardLoadout, this, player.UserIDString), _configData.CommandName);
                
                Notification.MessagePlayer(player, sb.ToString());
            }
            finally
            {
                sb.Clear();
                Facepunch.Pool.FreeUnmanaged(ref sb);
            }
        }

        #endregion
        
        #region Hook Subscribing

        private readonly HashSet<string> _hooks = new()
        {
            "OnEntityDeath",
            "OnEntityKill",
            "CanHackCrate"
        };

        private void SubscribeToHooks(int count)
        {
            if (count > 0)
            {
                foreach (string hook in _hooks) 
                    Subscribe(hook);
                
                return;
            }

            if (count == 0)
            {
                foreach (string hook in _hooks) 
                    Unsubscribe(hook);
            }
        }

        #endregion
        
        #region Alpha Loot

        private object CanPopulateLoot(HackableLockedCrate crate)
        {
            return EntitiesCache.FindCrateInstance(crate)
                ?.CanPopulateCrate();
        }

        #endregion

        #region Rust Edit

        private object OnNpcRustEdit(ScientistNPC npc)
        {
            return EntitiesCache.FindCrateInstance(npc) != null ? (object)true : null;
        }

        #endregion

        #region API Hooks
        
        private bool API_IsGuardedCrateCargoPlane(CargoPlane entity)
        {
            return EntitiesCache.FindCrateInstance(entity) != null;
        }
        
        private bool API_IsGuardedCrateEntity(BaseEntity entity)
        {
            return EntitiesCache.FindCrateInstance(entity) != null;
        }

        #endregion
    }
}

namespace GuardedCrateEx
{
    internal static class CustomUtils
    {
        public static T CreateObjectWithComponent<T>(Vector3 position, Quaternion rotation, string name) where T : MonoBehaviour
        {
            return new GameObject(name)
            {
                layer = (int)Layer.Prevent_Building,
                transform =
                {
                    position = position,
                    rotation = rotation
                }
            }.AddComponent<T>();
        }
        
        public static T CreateEntity<T>(string prefab, Vector3 position, Quaternion rotation) where T : BaseEntity
        {
            T baseEntity = (T)GameManager.server.CreateEntity(prefab, position, rotation);
            baseEntity.enableSaving = false;
            return baseEntity;
        }
        
        public static Color GetColor(string hex)
        {
            return ColorUtility.TryParseHtmlString(hex, out Color color) ? color : Color.yellow;
        }
    }
    
    internal static class ExtensionMethods
    {
        public static bool IsPluginReady(this Plugin plugin) => plugin != null && plugin.IsLoaded;
        
        public static string ToStringTime(this float seconds) 
        {
            TimeSpan timeSpan = TimeSpan.FromSeconds(seconds);
            if (timeSpan.Days >= 1) return $"{timeSpan.Days} day{(timeSpan.Days != 1 ? "(s)" : "")}";
            if (timeSpan.Hours >= 1) return $"{timeSpan.Hours} hour{(timeSpan.Hours != 1 ? "(s)" : "")}";
            return timeSpan.Minutes >= 1 ? $"{timeSpan.Minutes} minute{(timeSpan.Minutes != 1 ? "(s)" : "")}" : $"{timeSpan.Seconds} second{(timeSpan.Seconds == 1 ? "(s)" : "")}";
        }
        
        public static Vector3 GetPointAround(this Vector3 origin, int layers, float radius, float angle)
        {
            Vector3 pointAround = Vector3.zero;
            pointAround.x = origin.x + radius * Mathf.Sin(angle * Mathf.Deg2Rad);
            pointAround.z = origin.z + radius * Mathf.Cos(angle * Mathf.Deg2Rad);
            pointAround.y = TerrainMeta.HeightMap.GetHeight(origin) + 100f;
            
            if (Physics.Raycast(pointAround, Vector3.down, out RaycastHit hit, 200f, layers, QueryTriggerInteraction.Ignore))
                pointAround.y = hit.point.y;
            
            pointAround.y += 0.25f;
            return pointAround;
        }
        
        public static void SafeKill(this BaseEntity entity)
        {
            if (entity != null && !entity.IsDestroyed)
                entity.Kill();
        }

        public static void SafeClear(this ItemContainer container)
        {
            for (int i = container.itemList.Count - 1; i >= 0; i--)
            {
                Item item = container.itemList[i];
                item.RemoveFromContainer();
                item.Remove();
            }
        }
    }
}

// --- End of file: GuardedCrate.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/gui-announcements ---
// --- Original File Path: G/GUIAnnouncements/GUIAnnouncements.cs ---

ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Globalization;
using System.Collections;

using UnityEngine;

using Oxide.Core;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("GUIAnnouncements", "JoeSheep", "2.0.6", ResourceId = 1222)]
    [Description("Creates announcements with custom messages across the top of player's screens.")]

    class GUIAnnouncements : RustPlugin
    {
        #region Configuration

        #region Permissions
        const string PermAnnounce = "GUIAnnouncements.announce";
        const string PermAnnounceToggle = "GUIAnnouncements.toggle";
        const string PermAnnounceGetNextRestart = "GUIAnnouncements.getnextrestart";
        const string PermAnnounceJoinLeave = "GUIAnnouncements.announcejoinleave";
        #endregion

        #region Global Declerations
        private Dictionary<ulong, string> Exclusions = new Dictionary<ulong, string>();
        private HashSet<ulong> JustJoined = new HashSet<ulong>();
        private HashSet<ulong> GlobalTimerPlayerList = new HashSet<ulong>();
        private Dictionary<BasePlayer, Timer> PrivateTimers = new Dictionary<BasePlayer, Timer>();
        private Dictionary<BasePlayer, Timer> NewPlayerPrivateTimers = new Dictionary<BasePlayer, Timer>();
        private Dictionary<BasePlayer, Timer> PlayerRespawnedTimers = new Dictionary<BasePlayer, Timer>();
        private Timer PlayerTimer;
        private Timer GlobalTimer;
        private Timer NewPlayerTimer;
        private Timer PlayerRespawnedTimer;
        private Timer RealTimeTimer;
        private bool RealTimeTimerStarted = false;
        private Timer SixtySecondsTimer;
        private Timer AutomaticAnnouncementsTimer;
        private Timer GetNextRestartTimer;
        private string HeliLastHitPlayer = String.Empty;
        private string CH47LastHitPlayer = String.Empty;
        private string APCLastHitPlayer = String.Empty;
        private HashSet<ulong> HeliNetIDs = new HashSet<ulong>();
        private HashSet<ulong> CH47NetIDs = new HashSet<ulong>();
        private HashSet<ulong> KilledCH47NetIDs = new HashSet<ulong>();
        private bool ConfigUpdated;
        private static readonly int WorldSize = ConVar.Server.worldsize;
        private List<DateTime> RestartTimes = new List<DateTime>();
        private Dictionary<DateTime, TimeSpan> CalcNextRestartDict = new Dictionary<DateTime, TimeSpan>();
        private DateTime NextRestart;
        List<TimeSpan> RestartAnnouncementsTimeSpans = new List<TimeSpan>();
        private int LastHour;
        private int LastMinute;
        private bool RestartCountdown;
        private bool RestartJustScheduled = false;
        private bool RestartScheduled = false;
        private string RestartReason = String.Empty;
        private List<string> RestartAnnouncementsWhenStrings;
        private DateTime ScheduledRestart;
        private TimeSpan AutomaticTimedAnnouncementsRepeatTimeSpan;
        private bool RestartSuspended = false;
        private bool DontCheckNextRestart = false;
        private bool MutingBans = false;
        private bool AnnouncingGameTime = false;
        private string LastGameTime;
        private int GameTimeCurrentCount = 0;
        private bool AnnouncingRealTime = false;
        private string LastRealTime;
        private int RealTimeCurrentCount = 0;
        private List<string> GameTimes = new List<string>();
        private List<string> RealTimes = new List<string>();
        private IEnumerator<List<string>> ATALEnum;
        private List<List<string>> AutomaticTimedAnnouncementsStringList = new List<List<string>>();

        string BannerTintGrey = "0.1 0.1 0.1 0.7";
        string BannerTintRed = "0.5 0.1 0.1 0.7";
        string BannerTintOrange = "0.95294 0.37255 0.06275 0.7";
        string BannerTintYellow = "1 0.92 0.016 0.7";
        string BannerTintGreen = "0.1 0.4 0.1 0.5";
        string BannerTintCyan = "0 1 1 0.7";
        string BannerTintBlue = "0.09020 0.07843 0.71765 0.7";
        string BannerTintPurple = "0.53333 0.07843 0.77647 0.7";
        string TextRed = "0.5 0.2 0.2";
        string TextOrange = "0.8 0.5 0.1";
        string TextYellow = "1 0.92 0.016";
        string TextGreen = "0 1 0";
        string TextCyan = "0 1 1";
        string TextBlue = "0.09020 0.07843 0.71765";
        string TextPurple = "0.53333 0.07843 0.77647";
        string TextWhite = "1 1 1";
        string BannerAnchorMaxX = "1.026 ";
        string BannerAnchorMaxYDefault = "0.9743";
        string BannerAnchorMaxY = "0.9743";
        string BannerAnchorMinX = "-0.027 ";
        string BannerAnchorMinYDefault = "0.915";
        string BannerAnchorMinY = "0.915";
        string TextAnchorMaxX = "0.868 ";
        string TextAnchorMaxYDefault = "0.9743";
        string TextAnchorMaxY = "0.9743";
        string TextAnchorMinX = "0.131 ";
        string TextAnchorMinYDefault = "0.915";
        string TextAnchorMinY = "0.915";
        string TABannerAnchorMaxY = "0.9743";
        string TABannerAnchorMinY = "0.915";
        string TATextAnchorMaxY = "0.9743";
        string TATextAnchorMinY = "0.915";

        #endregion
        //============================================================================================================
        #region Config Option Declerations

        //Color List
        public string BannerColorList { get; private set; } = "Grey, Red, Orange, Yellow, Green, Cyan, Blue, Purple";
        public string TextColorList { get; private set; } = "White, Red, Orange, Yellow, Green, Cyan, Blue, Purple";

        //Airdrop Announcements
        public bool AirdropAnnouncementsEnabled { get; private set; } = false;
        public bool AirdropAnnouncementsLocation { get; private set; } = false;
        public string AirdropAnnouncementsText { get; private set; } = "Airdrop en route!";
        public string AirdropAnnouncementsTextWithGrid { get; private set; } = "Airdrop en route to {grid}.";
        public string AirdropAnnouncementsBannerColor { get; private set; } = "Green";
        public string AirdropAnnouncementsTextColor { get; private set; } = "Yellow";

        //Automatic Game Time Announcements
        public bool AutomaticGameTimeAnnouncementsEnabled { get; private set; } = false;
        public Dictionary<string, List<object>> AutomaticGameTimeAnnouncementsList { get; private set; } = new Dictionary<string, List<object>>
        {
            {"18:15", new List<object>{ "The in game time is 18:15 announcement 1.", "The in game time is 18:15 announcement 2.", "The in game time is 18:15 announcement 3." } },
            {"00:00", new List<object>{ "The in game time is 00:00 announcement 1.", "The in game time is 00:00 announcement 2.", "The in game time is 00:00 announcement 3." } },
            {"12:00", new List<object>{ "The in game time is 12:00 announcement 1.", "The in game time is 12:00 announcement 2.", "The in game time is 12:00 announcement 3." } },
        };
        public string AutomaticGameTimeAnnouncementsBannerColor { get; private set; } = "Grey";
        public string AutomaticGameTimeAnnouncementsTextColor { get; private set; } = "White";

        //Automatic Timed Announcements
        public bool AutomaticTimedAnnouncementsEnabled { get; private set; } = false;
        public static List<object> AutomaticTimedAnnouncementsList { get; private set; } = new List<object>
        {
            new List<object>{ "1st Automatic Timed Announcement 1", "1st Automatic Timed Announcement 2" },
            new List<object>{ "2nd Automatic Timed Announcement 1", "2nd Automatic Timed Announcement 2" },
            new List<object>{ "3rd Automatic Timed Announcement 1", "3rd Automatic Timed Announcement 2" },
        };
        public string AutomaticTimedAnnouncementsRepeat { get; private set; } = "00:30:00";
        public string AutomaticTimedAnnouncementsBannerColor { get; private set; } = "Grey";
        public string AutomaticTimedAnnouncementsTextColor { get; private set; } = "White";

        //Automatic Realtime Announcements
        public bool AutomaticRealtimeAnnouncementsEnabled { get; private set; } = false;
        public Dictionary<string, List<object>> AutomaticRealTimeAnnouncementsList { get; private set; } = new Dictionary<string, List<object>>
        {
            {"18:15", new List<object>{ "The local time is 18:15 announcement 1.", "The local time is 18:15 announcement 2.", "The local time is 18:15 announcement 3." } },
            {"00:00", new List<object>{ "The local time is 00:00 announcement 1.", "The local time is 00:00 announcement 2.", "The local time is 00:00 announcement 3." } },
            {"12:00", new List<object>{ "The local time is 12:00 announcement 1.", "The local time is 12:00 announcement 2.", "The local time is 12:00 announcement 3." } },
        };
        public string AutomaticRealTimeAnnouncementsBannerColor { get; private set; } = "Grey";
        public string AutomaticRealTimeAnnouncementsTextColor { get; private set; } = "White";

        //Christmas Stocking Refill Announcement
        public bool StockingRefillAnnouncementsEnabled { get; private set; } = false;
        public string StockingRefillAnnouncementText { get; private set; } = "Santa has refilled your stockings. Go check what you've got!";
        public string StockingRefillAnnouncementBannerColor { get; private set; } = "Green";
        public string StockingRefillAnnouncementTextColor { get; private set; } = "Red";

        //General Settings
        public float AnnouncementDuration { get; private set; } = 10f;
        public int FontSize { get; private set; } = 18;
        public float FadeOutTime { get; private set; } = 0.5f;
        public float FadeInTime { get; private set; } = 0.5f;
        public static float AdjustVPosition { get; private set; } = 0.0f;

        //Global Join/Leave Announcements
        public bool GlobalLeaveAnnouncementsEnabled { get; private set; } = false;
        public bool GlobalJoinAnnouncementsEnabled { get; private set; } = false;
        public bool GlobalJoinLeavePermissionOnly { get; private set; } = true;
        public string GlobalLeaveText { get; private set; } = "{rank} {playername} has left.";
        public string GlobalJoinText { get; private set; } = "{rank} {playername} has joined.";
        public string GlobalLeaveAnnouncementBannerColor { get; private set; } = "Grey";
        public string GlobalLeaveAnnouncementTextColor { get; private set; } = "White";
        public string GlobalJoinAnnouncementBannerColor { get; private set; } = "Grey";
        public string GlobalJoinAnnouncementTextColor { get; private set; } = "White";

        //Helicopter Announcements
        public bool HelicopterSpawnAnnouncementEnabled { get; private set; } = false;
        public bool HelicopterDespawnAnnouncementEnabled { get; private set; } = false;
        public bool HelicopterDestroyedAnnouncementEnabled { get; private set; } = false;
        public bool HelicopterDestroyedAnnouncementWithDestroyer { get; private set; } = false;
        public string HelicopterSpawnAnnouncementText { get; private set; } = "Patrol Helicopter Inbound!";
        public string HelicopterDespawnAnnouncementText { get; private set; } = "The patrol helicopter has left.";
        public string HelicopterDestroyedAnnouncementText { get; private set; } = "The patrol helicopter has been taken down!";
        public string HelicopterDestroyedAnnouncementWithDestroyerText { get; private set; } = "{playername} got the last shot on the helicopter taking it down!";
        public string HelicopterSpawnAnnouncementBannerColor { get; private set; } = "Red";
        public string HelicopterSpawnAnnouncementTextColor { get; private set; } = "Orange";
        public string HelicopterDestroyedAnnouncementBannerColor { get; private set; } = "Red";
        public string HelicopterDestroyedAnnouncementTextColor { get; private set; } = "White";
        public string HelicopterDespawnAnnouncementBannerColor { get; private set; } = "Red";
        public string HelicopterDespawnAnnouncementTextColor { get; private set; } = "White";

        //Chinook Announcements
        public bool CH47SpawnAnnouncementsEnabled { get; private set; } = false;
        public bool CH47DespawnAnnouncementsEnabled { get; private set; } = false;
        public bool CH47DestroyedAnnouncementsEnabled { get; private set; } = false;
        public bool CH47DestroyedAnnouncementsWithDestroyer { get; private set; } = false;
        public bool CH47CrateDroppedAnnouncementsEnabled { get; private set; } = false;
        public bool CH47CrateDroppedAnnouncementsWithLocation { get; private set; } = false;
        public string CH47SpawnAnnouncementText { get; private set; } = "Chinook inbound!";
        public string CH47DespawnAnnouncementText { get; private set; } = "The Chinook has left.";
        public string CH47DestroyedAnnouncementText { get; private set; } = "The Chinook has been taken down!";
        public string CH47DestroyedAnnouncementWithDestroyerText { get; private set; } = "{playername} got the last shot on the Chinook taking it down!";
        public string CH47CrateDroppedAnnouncementText { get; private set; } = "The Chinook has dropped a crate!";
        public string CH47CrateDroppedAnnouncementTextWithGrid { get; private set; } = "The Chinook has dropped a crate in {grid}.";
        public string CH47SpawnAnnouncementBannerColor { get; private set; } = "Red";
        public string CH47SpawnAnnouncementTextColor { get; private set; } = "Yellow";
        public string CH47DestroyedAnnouncementBannerColor { get; private set; } = "Red";
        public string CH47DestroyedAnnouncementTextColor { get; private set; } = "White";
        public string CH47DespawnAnnouncementBannerColor { get; private set; } = "Red";
        public string CH47DespawnAnnouncementTextColor { get; private set; } = "White";
        public string CH47CrateDroppedAnnouncementBannerColor { get; private set; } = "Red";
        public string CH47CrateDroppedAnnouncementTextColor { get; private set; } = "Yellow";

        //Bradley APC Announcements
        public bool APCSpawnAnnouncementsEnabled { get; private set; } = false;
        public bool APCDestroyedAnnouncementsEnabled { get; private set; } = false;
        public bool APCDestroyedAnnouncementsWithDestroyer { get; private set; } = false;
        public string APCSpawnAnnouncementText { get; private set; } = "An APC is patrolling the launch site!";
        public string APCDestroyedAnnouncementText { get; private set; } = "The APC has been destroyed.";
        public string APCDestroyedAnnouncementWithDestroyerText { get; private set; } = "{playername} got the last shot on the APC destroying it!";
        public string APCSpawnAnnouncementBannerColor { get; private set; } = "Red";
        public string APCSpawnAnnouncementTextColor { get; private set; } = "Yellow";
        public string APCDestroyedAnnouncementBannerColor { get; private set; } = "Red";
        public string APCDestroyedAnnouncementTextColor { get; private set; } = "White";

        //Cargoship Announcements
        public bool CargoshipSpawnAnnouncementsEnabled { get; private set; } = false;
        public bool CargoshipEgressAnnouncementsEnabled { get; private set; } = false;
        public string CargoshipSpawnAnnouncementText { get; private set; } = "Cargoship ahoy!";
        public string CargoshipEgressAnnouncementText { get; private set; } = "The cargoship is departing.";
        public string CargoshipSpawnAnnouncementBannerColor { get; private set; } = "Blue";
        public string CargoshipSpawnAnnouncementTextColor { get; private set; } = "Yellow";
        public string CargoshipEgressAnnouncementBannerColor { get; private set; } = "Blue";
        public string CargoshipEgressAnnouncementTextColor { get; private set; } = "White";

        //Crate Hack Announcements
        public bool CrateHackAnnouncementsEnabled { get; private set; } = false;
        public bool CrateHackSpecifyOilRig { get; private set; } = false;
        public string CrateHackAnnouncementText { get; private set; } = "An oil rig crate is being hacked!";
        public string CrateHackAnnouncementSmallOilRigText { get; private set; } = "The small oil rig crate is being hacked!";
        public string CrateHackAnnouncementLargeOilRigText { get; private set; } = "The large oil rig crate is being hacked!";
        public string CrateHackAnnouncementBannerColor { get; private set; } = "Orange";
        public string CrateHackAnnouncementTextColor { get; private set; } = "Yellow";

        //New Player Announcements
        public bool NewPlayerAnnouncementsEnabled { get; private set; } = false;
        public string NewPlayerAnnouncementsBannerColor { get; private set; } = "Grey";
        public string NewPlayerAnnouncementsTextColor { get; private set; } = "White";
        public Dictionary<int, List<object>> NewPlayerAnnouncementsList { get; private set; } = new Dictionary<int, List<object>>
        {
            {1, new List<object>{ "1st Join {rank} {playername} New player announcement 1.", "1st Join {rank} {playername} New player announcement 2.", "1st Join {rank} {playername} New player announcement 3." } },
            {2, new List<object>{ "2nd Join {rank} {playername} New player announcement 1.", "2nd Join {rank} {playername} New player announcement 2.", "2nd Join {rank} {playername} New player announcement 3." } },
            {3, new List<object>{ "3rd Join {rank} {playername} New player announcement 1.", "3rd Join {rank} {playername} New player announcement 2.", "3rd Join {rank} {playername} New player announcement 3." } },
        };

        //Player Banned Announcement
        public bool PlayerBannedAnnouncementsEnabled { get; private set; } = false;
        public string PlayerBannedAnnouncmentText { get; private set; } = "{playername} has been banned. {reason}.";
        public string PlayerBannedAnnouncementBannerColor { get; private set; } = "Grey";
        public string PlayerBannedAnnouncementTextColor { get; private set; } = "Red";

        //Respawn Announcements
        public bool RespawnAnnouncementsEnabled { get; private set; } = false;
        public string RespawnAnnouncementsBannerColor { get; private set; } = "Grey";
        public string RespawnAnnouncementsTextColor { get; private set; } = "White";
        public List<object> RespawnAnnouncementsList { get; private set; } = new List<object>
        {
                    "{playername} Respawn announcement 1.",
                    "{playername} Respawn announcement 2.",
                    "{playername} Respawn announcement 3."
        };

        //Restart Announcements
        public bool RestartAnnouncementsEnabled { get; private set; } = false;
        public string RestartAnnouncementsFormat { get; private set; } = "Restarting in {time}";
        public string RestartAnnouncementsBannerColor { get; private set; } = "Grey";
        public string RestartAnnouncementsTextColor { get; private set; } = "White";
        public List<object> RestartTimesList { get; private set; } = new List<object>
        {
            "08:00:00",
            "20:00:00"
        };
        public List<object> RestartAnnouncementsTimes { get; private set; } = new List<object>
        {
            "12:00:00",
            "11:00:00",
            "10:00:00",
            "09:00:00",
            "08:00:00",
            "07:00:00",
            "06:00:00",
            "05:00:00",
            "04:00:00",
            "03:00:00",
            "02:00:00",
            "01:00:00",
            "00:45:00",
            "00:30:00",
            "00:15:00",
            "00:05:00"
        };
        public bool RestartServer { get; private set; } = false;
        public string RestartSuspendedAnnouncement { get; private set; } = "The restart in {time} has been suspended.";
        public string RestartCancelledAnnouncement { get; private set; } = "The restart in {time} has been cancelled.";

        //Test Announcement
        public float TestAnnouncementDuration { get; private set; } = 10f;
        public int TestAnnouncementFontSize { get; private set; } = 18;
        public float TestAnnouncementFadeOutTime { get; private set; } = 0.5f;
        public float TestAnnouncementFadeInTime { get; private set; } = 0.5f;
        public static float TestAnnouncementAdjustVPosition { get; private set; } = 0.0f;
        public string TestAnnouncementBannerColor { get; private set; } = "Grey";
        public string TestAnnouncementsTextColor { get; private set; } = "White";

        //Third Party Plugin Support
        public bool DoNotOverlayLustyMap { get; private set; } = false;
        public string LustyMapPosition { get; private set; } = "Left";

        //Welcome Announcement
        public bool WelcomeAnnouncementsEnabled { get; private set; } = false;
        public string WelcomeAnnouncementText { get; private set; } = "Welcome {playername}! There are {playercount} player(s) online.";
        public string WelcomeBackAnnouncementText { get; private set; } = "Welcome back {playername}! There are {playercount} player(s) online.";
        public string WelcomeAnnouncementBannerColor { get; private set; } = "Grey";
        public string WelcomeAnnouncementTextColor { get; private set; } = "White";
        public float WelcomeAnnouncementDuration { get; private set; } = 20f;
        public float WelcomeAnnouncementDelay { get; private set; } = 0f;
        public bool WelcomeBackAnnouncement { get; private set; } = false;
        #endregion

        //============================================================================================================
        #region LoadConfig
        private void LoadGUIAnnouncementsConfig()
        {
            string BColor; string TColor; string Category; string Setting;

            //Color List
            BannerColorList = GetConfig("A List Of Available Colors To Use (DO NOT CHANGE)", "Banner Colors", BannerColorList);
            if (BannerColorList != "Grey, Red, Orange, Yellow, Green, Cyan, Blue, Purple")
            {
                PrintWarning("Banner color list changed. Reverting changes.");
                Config["A List Of Available Colors To Use(DO NOT CHANGE)", "Banner Colors"] = "Grey, Red, Orange, Yellow, Green, Cyan, Blue, Purple";
                ConfigUpdated = true;
            }
            TextColorList = GetConfig("A List Of Available Colors To Use (DO NOT CHANGE)", "Text Colors", TextColorList);
            if (TextColorList != "White, Red, Orange, Yellow, Green, Cyan, Blue, Purple")
            {
                PrintWarning("Text color list changed. Reverting changes.");
                Config["A List Of Available Colors To Use(DO NOT CHANGE)", "Text Colors"] = "White, Red, Orange, Yellow, Green, Cyan, Blue, Purple";
                ConfigUpdated = true;
            }

            //Airdrop Announcements
            AirdropAnnouncementsEnabled = GetConfig("Public Airdrop Announcements", "Enabled", AirdropAnnouncementsEnabled);
            AirdropAnnouncementsText = GetConfig("Public Airdrop Announcements", "Text", AirdropAnnouncementsText);
            AirdropAnnouncementsTextWithGrid = GetConfig("Public Airdrop Announcements", "Text With Grid", AirdropAnnouncementsTextWithGrid);
            AirdropAnnouncementsLocation = GetConfig("Public Airdrop Announcements", "Show Location", AirdropAnnouncementsLocation);

            BColor = AirdropAnnouncementsBannerColor; Category = "Public Airdrop Announcements"; Setting = "Banner Color";
            AirdropAnnouncementsBannerColor = GetConfig(Category, Setting, AirdropAnnouncementsBannerColor);
            CheckBannerColor(AirdropAnnouncementsBannerColor, Category, Setting, BColor);

            TColor = AirdropAnnouncementsTextColor; Category = "Public Airdrop Announcements"; Setting = "Text Color";
            AirdropAnnouncementsTextColor = GetConfig(Category, Setting, AirdropAnnouncementsTextColor);
            CheckTextColor(AirdropAnnouncementsTextColor, Category, Setting, TColor);

            //Automatic Game Time Announcements
            AutomaticGameTimeAnnouncementsEnabled = GetConfig("Public Automatic Game Time Announcements", "Enabled", AutomaticGameTimeAnnouncementsEnabled);
            AutomaticGameTimeAnnouncementsList = GetConfig("Public Automatic Game Time Announcements", "Announcement List (Show at this in game time : Announcements to show)", AutomaticGameTimeAnnouncementsList);

            BColor = AutomaticGameTimeAnnouncementsBannerColor; Category = "Public Automatic Game Time Announcements"; Setting = "Banner Color";
            AutomaticGameTimeAnnouncementsBannerColor = GetConfig(Category, Setting, AutomaticGameTimeAnnouncementsBannerColor);
            CheckBannerColor(AutomaticGameTimeAnnouncementsBannerColor, Category, Setting, BColor);

            TColor = AutomaticGameTimeAnnouncementsTextColor; Category = "Public Automatic Game Time Announcements"; Setting = "Text Color";
            AutomaticGameTimeAnnouncementsTextColor = GetConfig(Category, Setting, AutomaticGameTimeAnnouncementsTextColor);
            CheckTextColor(AutomaticGameTimeAnnouncementsTextColor, Category, Setting, TColor);

            //Automatic Timed Announcements
            AutomaticTimedAnnouncementsEnabled = GetConfig("Public Automatic Timed Announcements", "Enabled", AutomaticTimedAnnouncementsEnabled);
            AutomaticTimedAnnouncementsList = GetConfig("Public Automatic Timed Announcements", "Announcement List", AutomaticTimedAnnouncementsList);
            AutomaticTimedAnnouncementsRepeat = GetConfig("Public Automatic Timed Announcements", "Show Every (HH:MM:SS)", AutomaticTimedAnnouncementsRepeat);
            if (!TimeSpan.TryParse(AutomaticTimedAnnouncementsRepeat, out AutomaticTimedAnnouncementsRepeatTimeSpan))
            {
                PrintWarning("Config: \"Automatic Timed Announcements - Show Every (HH:MM:SS)\" is not of the correct format HH:MM:SS, or has numbers out of range and should not be higher than 23:59:59. Resetting to default.");
                Config["Public Automatic Timed Announcements", "Show Every (HH:MM:SS)"] = "00:30:00";
                ConfigUpdated = true;
            }

            BColor = AutomaticTimedAnnouncementsBannerColor; Category = "Public Automatic Timed Announcements"; Setting = "Banner Color";
            AutomaticTimedAnnouncementsBannerColor = GetConfig(Category, Setting, AutomaticTimedAnnouncementsBannerColor);
            CheckBannerColor(AutomaticTimedAnnouncementsBannerColor, Category, Setting, BColor);

            TColor = AutomaticTimedAnnouncementsTextColor; Category = "Public Automatic Timed Announcements"; Setting = "Text Color";
            AutomaticTimedAnnouncementsTextColor = GetConfig(Category, Setting, AutomaticTimedAnnouncementsTextColor);
            CheckTextColor(AutomaticTimedAnnouncementsTextColor, Category, Setting, TColor);

            //Automatic Realtime Announcements
            AutomaticRealtimeAnnouncementsEnabled = GetConfig("Public Automatic Real Time Announcements", "Enabled", AutomaticRealtimeAnnouncementsEnabled);
            AutomaticRealTimeAnnouncementsList = GetConfig("Public Automatic Real Time Announcements", "Announcement List (Show at this local time : Announcements to show)", AutomaticRealTimeAnnouncementsList);

            BColor = AutomaticRealTimeAnnouncementsBannerColor; Category = "Public Automatic Real Time Announcements"; Setting = "Banner Color";
            AutomaticRealTimeAnnouncementsBannerColor = GetConfig(Category, Setting, AutomaticRealTimeAnnouncementsBannerColor);
            CheckBannerColor(AutomaticRealTimeAnnouncementsBannerColor, Category, Setting, BColor);

            TColor = AutomaticRealTimeAnnouncementsTextColor; Category = "Public Automatic Real Time Announcements"; Setting = "Text Color";
            AutomaticRealTimeAnnouncementsTextColor = GetConfig(Category, Setting, AutomaticRealTimeAnnouncementsTextColor);
            CheckTextColor(AutomaticRealTimeAnnouncementsTextColor, Category, Setting, TColor);

            //Christmas Stocking Refill Announcement
            StockingRefillAnnouncementsEnabled = GetConfig("Public Christmas Stocking Refill Announcement", "Enabled", StockingRefillAnnouncementsEnabled);
            StockingRefillAnnouncementText = GetConfig("Public Christmas Stocking Refill Announcement", "Text", StockingRefillAnnouncementText);

            BColor = StockingRefillAnnouncementBannerColor; Category = "Public Christmas Stocking Refill Announcement"; Setting = "Banner Color";
            StockingRefillAnnouncementBannerColor = GetConfig(Category, Setting, StockingRefillAnnouncementBannerColor);
            CheckBannerColor(StockingRefillAnnouncementBannerColor, Category, Setting, BColor);

            TColor = StockingRefillAnnouncementTextColor; Category = "Public Christmas Stocking Refill Announcement"; Setting = "Text Color";
            StockingRefillAnnouncementTextColor = GetConfig(Category, Setting, StockingRefillAnnouncementTextColor);
            CheckTextColor(StockingRefillAnnouncementTextColor, Category, Setting, TColor);

            //General Settings
            AnnouncementDuration = GetConfig("General Settings", "Announcement Duration", AnnouncementDuration);
            if (AnnouncementDuration == 0)
            {
                PrintWarning("Config: \"General Settings - Announcement Duration\" set to 0, resetting to 10f.");
                Config["General Settings", "Announcement Duration"] = 10f;
                ConfigUpdated = true;
            }
            FontSize = GetConfig("General Settings", "Font Size", FontSize);
            if (FontSize > 33 | FontSize == 0)
            {
                PrintWarning("Config: \"General Settings - Font Size\" greater than 28 or 0, resetting to 18.");
                Config["General Settings", "Font Size"] = 18;
                ConfigUpdated = true;
            }
            FadeInTime = GetConfig("General Settings", "Fade In Time", FadeInTime);
            if (FadeInTime > AnnouncementDuration / 2)
            {
                PrintWarning("Config: \"General Settings - Fade In Time\" is greater than half of AnnouncementShowDuration, resetting to half of AnnouncementShowDuration.");
                Config["General Settings", "Fade In Time"] = AnnouncementDuration / 2;
                ConfigUpdated = true;
            }
            FadeOutTime = GetConfig("General Settings", "Fade Out Time", FadeOutTime);
            if (FadeOutTime > AnnouncementDuration / 2)
            {
                PrintWarning("Config: \"General Settings - Fade Out Time\" is greater than half of AnnouncementShowDuration, resetting to half of AnnouncementShowDuration.");
                Config["General Settings", "Fade Out Time"] = AnnouncementDuration / 2;
                ConfigUpdated = true;
            }
            AdjustVPosition = GetConfig("General Settings", "Adjust Vertical Position", AdjustVPosition);
            if (AdjustVPosition != 0f)
            {
                BannerAnchorMaxY = (float.Parse(BannerAnchorMaxYDefault) + AdjustVPosition).ToString();
                BannerAnchorMinY = (float.Parse(BannerAnchorMinYDefault) + AdjustVPosition).ToString();
                TextAnchorMaxY = (float.Parse(TextAnchorMaxYDefault) + AdjustVPosition).ToString();
                TextAnchorMinY = (float.Parse(TextAnchorMinYDefault) + AdjustVPosition).ToString();
            }

            //Global Join/Leave Announcements
            GlobalLeaveAnnouncementsEnabled = GetConfig("Public Join/Leave Announcements", "Leave Enabled", GlobalLeaveAnnouncementsEnabled);
            GlobalLeaveText = GetConfig("Public Join/Leave Announcements", "Leave Text", GlobalLeaveText);
            GlobalJoinLeavePermissionOnly = GetConfig("Public Join/Leave Announcements", "Announce Only Players With Permission", GlobalJoinLeavePermissionOnly);

            BColor = GlobalLeaveAnnouncementBannerColor; Category = "Public Join/Leave Announcements"; Setting = "Leave Banner Color";
            GlobalLeaveAnnouncementBannerColor = GetConfig(Category, Setting, GlobalLeaveAnnouncementBannerColor);
            CheckBannerColor(GlobalLeaveAnnouncementBannerColor, Category, Setting, BColor);

            TColor = GlobalLeaveAnnouncementTextColor; Category = "Public Join/Leave Announcements"; Setting = "Leave Text Color";
            GlobalLeaveAnnouncementTextColor = GetConfig(Category, Setting, GlobalLeaveAnnouncementTextColor);
            CheckTextColor(GlobalLeaveAnnouncementTextColor, Category, Setting, TColor);

            GlobalJoinAnnouncementsEnabled = GetConfig("Public Join/Leave Announcements", "Join Enabled", GlobalJoinAnnouncementsEnabled);
            GlobalJoinText = GetConfig("Public Join/Leave Announcements", "Join Text", GlobalJoinText);

            BColor = GlobalJoinAnnouncementBannerColor; Category = "Public Join/Leave Announcements"; Setting = "Join Banner Color";
            GlobalJoinAnnouncementBannerColor = GetConfig(Category, Setting, GlobalJoinAnnouncementBannerColor);
            CheckBannerColor(GlobalJoinAnnouncementBannerColor, Category, Setting, BColor);

            TColor = GlobalJoinAnnouncementTextColor; Category = "Public Join/Leave Announcements"; Setting = "Join Text Color";
            GlobalJoinAnnouncementTextColor = GetConfig(Category, Setting, GlobalJoinAnnouncementTextColor);
            CheckTextColor(GlobalJoinAnnouncementTextColor, Category, Setting, TColor);

            //Helicopter Announcements
            HelicopterSpawnAnnouncementEnabled = GetConfig("Public Helicopter Announcements", "Spawn", HelicopterSpawnAnnouncementEnabled);
            HelicopterSpawnAnnouncementText = GetConfig("Public Helicopter Announcements", "Spawn Text", HelicopterSpawnAnnouncementText);
            HelicopterDespawnAnnouncementEnabled = GetConfig("Public Helicopter Announcements", "Despawn", HelicopterDespawnAnnouncementEnabled);
            HelicopterDespawnAnnouncementText = GetConfig("Public Helicopter Announcements", "Despawn Text", HelicopterDespawnAnnouncementText);
            HelicopterDestroyedAnnouncementEnabled = GetConfig("Public Helicopter Announcements", "Destroyed", HelicopterDestroyedAnnouncementEnabled);
            HelicopterDestroyedAnnouncementWithDestroyer = GetConfig("Public Helicopter Announcements", "Show Destroyer", HelicopterDestroyedAnnouncementWithDestroyer);
            HelicopterDestroyedAnnouncementText = GetConfig("Public Helicopter Announcements", "Destroyed Text", HelicopterDestroyedAnnouncementText);
            HelicopterDestroyedAnnouncementWithDestroyerText = GetConfig("Public Helicopter Announcements", "Destroyed Text With Destroyer", HelicopterDestroyedAnnouncementWithDestroyerText);

            BColor = HelicopterSpawnAnnouncementBannerColor; Category = "Public Helicopter Announcements"; Setting = "Spawn Banner Color";
            HelicopterSpawnAnnouncementBannerColor = GetConfig(Category, Setting, HelicopterSpawnAnnouncementBannerColor);
            CheckBannerColor(HelicopterSpawnAnnouncementBannerColor, Category, Setting, BColor);

            TColor = HelicopterSpawnAnnouncementTextColor; Category = "Public Helicopter Announcements"; Setting = "Spawn Text Color";
            HelicopterSpawnAnnouncementTextColor = GetConfig(Category, Setting, HelicopterSpawnAnnouncementTextColor);
            CheckTextColor(HelicopterSpawnAnnouncementTextColor, Category, Setting, TColor);

            BColor = HelicopterDespawnAnnouncementBannerColor; Category = "Public Helicopter Announcements"; Setting = "Despawn Banner Color";
            HelicopterDespawnAnnouncementBannerColor = GetConfig(Category, Setting, HelicopterDespawnAnnouncementBannerColor);
            CheckBannerColor(HelicopterDespawnAnnouncementBannerColor, Category, Setting, BColor);

            TColor = HelicopterDespawnAnnouncementTextColor; Category = "Public Helicopter Announcements"; Setting = "Despawn Text Color";
            HelicopterDespawnAnnouncementTextColor = GetConfig(Category, Setting, HelicopterDespawnAnnouncementTextColor);
            CheckTextColor(HelicopterDespawnAnnouncementTextColor, Category, Setting, TColor);

            BColor = HelicopterDestroyedAnnouncementBannerColor; Category = "Public Helicopter Announcements"; Setting = "Destroyed Banner Color";
            HelicopterDestroyedAnnouncementBannerColor = GetConfig(Category, Setting, HelicopterDestroyedAnnouncementBannerColor);
            CheckBannerColor(HelicopterDestroyedAnnouncementBannerColor, Category, Setting, BColor);

            TColor = HelicopterDestroyedAnnouncementTextColor; Category = "Public Helicopter Announcements"; Setting = "Destroyed Text Color";
            HelicopterDestroyedAnnouncementTextColor = GetConfig(Category, Setting, HelicopterDestroyedAnnouncementTextColor);
            CheckTextColor(HelicopterDestroyedAnnouncementTextColor, Category, Setting, TColor);

            //Chinook Announcements
            CH47SpawnAnnouncementsEnabled = GetConfig("Public Chinook Announcements", "Spawn", CH47SpawnAnnouncementsEnabled);
            CH47DespawnAnnouncementsEnabled = GetConfig("Public Chinook Announcements", "Despawn", CH47DespawnAnnouncementsEnabled);
            CH47DestroyedAnnouncementsEnabled = GetConfig("Public Chinook Announcements", "Destroyed", CH47DestroyedAnnouncementsEnabled);
            CH47DestroyedAnnouncementsWithDestroyer = GetConfig("Public Chinook Announcements", "Show Destroyer", CH47DestroyedAnnouncementsWithDestroyer);
            CH47CrateDroppedAnnouncementsEnabled = GetConfig("Public Chinook Announcements", "Announce Crate Drops", CH47CrateDroppedAnnouncementsEnabled);
            CH47CrateDroppedAnnouncementsWithLocation = GetConfig("Public Chinook Announcements", "Show Crate Drop Location", CH47CrateDroppedAnnouncementsWithLocation);
            CH47SpawnAnnouncementText = GetConfig("Public Chinook Announcements", "Spawn Text", CH47SpawnAnnouncementText);
            CH47DespawnAnnouncementText = GetConfig("Public Chinook Announcements", "Despawn Text", CH47DespawnAnnouncementText);
            CH47DestroyedAnnouncementText = GetConfig("Public Chinook Announcements", "Destroyed Text", CH47DestroyedAnnouncementText);
            CH47DestroyedAnnouncementWithDestroyerText = GetConfig("Public Chinook Announcements", "Destroyed Text With Destroyer", CH47DestroyedAnnouncementWithDestroyerText);
            CH47CrateDroppedAnnouncementText = GetConfig("Public Chinook Announcements", "Crate Dropped Text", CH47CrateDroppedAnnouncementText);
            CH47CrateDroppedAnnouncementTextWithGrid = GetConfig("Public Chinook Announcements", "Crate Dropped Text With Grid", CH47CrateDroppedAnnouncementTextWithGrid);

            BColor = CH47SpawnAnnouncementBannerColor; Category = "Public Chinook Announcements"; Setting = "Spawn Banner Color";
            CH47SpawnAnnouncementBannerColor = GetConfig(Category, Setting, CH47SpawnAnnouncementBannerColor);
            CheckBannerColor(CH47SpawnAnnouncementBannerColor, Category, Setting, BColor);

            TColor = CH47SpawnAnnouncementTextColor; Category = "Public Chinook Announcements"; Setting = "Spawn Text Color";
            CH47SpawnAnnouncementTextColor = GetConfig(Category, Setting, CH47SpawnAnnouncementTextColor);
            CheckTextColor(CH47SpawnAnnouncementTextColor, Category, Setting, TColor);

            BColor = CH47DespawnAnnouncementBannerColor; Category = "Public Chinook Announcements"; Setting = "Despawn Banner Color";
            CH47DespawnAnnouncementBannerColor = GetConfig(Category, Setting, CH47DespawnAnnouncementBannerColor);
            CheckBannerColor(CH47DespawnAnnouncementBannerColor, Category, Setting, BColor);

            TColor = CH47DespawnAnnouncementTextColor; Category = "Public Chinook Announcements"; Setting = "Despawn Text Color";
            CH47DespawnAnnouncementTextColor = GetConfig(Category, Setting, CH47DespawnAnnouncementTextColor);
            CheckTextColor(CH47DespawnAnnouncementTextColor, Category, Setting, TColor);

            BColor = CH47DestroyedAnnouncementBannerColor; Category = "Public Chinook Announcements"; Setting = "Destroyed Banner Color";
            CH47DestroyedAnnouncementBannerColor = GetConfig(Category, Setting, CH47DestroyedAnnouncementBannerColor);
            CheckBannerColor(CH47DestroyedAnnouncementBannerColor, Category, Setting, BColor);

            TColor = CH47DestroyedAnnouncementTextColor; Category = "Public Chinook Announcements"; Setting = "Destroyed Text Color";
            CH47DestroyedAnnouncementTextColor = GetConfig(Category, Setting, CH47DestroyedAnnouncementTextColor);
            CheckTextColor(CH47DestroyedAnnouncementTextColor, Category, Setting, TColor);

            BColor = CH47CrateDroppedAnnouncementBannerColor; Category = "Public Chinook Announcements"; Setting = "Crate Dropped Banner Color";
            CH47CrateDroppedAnnouncementBannerColor = GetConfig(Category, Setting, CH47CrateDroppedAnnouncementBannerColor);
            CheckBannerColor(CH47CrateDroppedAnnouncementBannerColor, Category, Setting, BColor);

            TColor = CH47CrateDroppedAnnouncementTextColor; Category = "Public Chinook Announcements"; Setting = "Crate Dropped Text Color";
            CH47CrateDroppedAnnouncementTextColor = GetConfig(Category, Setting, CH47CrateDroppedAnnouncementTextColor);
            CheckTextColor(CH47CrateDroppedAnnouncementTextColor, Category, Setting, TColor);

            //Bradley APC Announcements
            APCSpawnAnnouncementsEnabled = GetConfig("Public Bradley APC Announcements", "Spawn", APCSpawnAnnouncementsEnabled);
            APCDestroyedAnnouncementsEnabled = GetConfig("Public Bradley APC Announcements", "Destroyed", APCDestroyedAnnouncementsEnabled);
            APCDestroyedAnnouncementsWithDestroyer = GetConfig("Public Bradley APC Announcements", "Show Destroyer", APCDestroyedAnnouncementsWithDestroyer);
            APCSpawnAnnouncementText = GetConfig("Public Bradley APC Announcements", "Spawn Text", APCSpawnAnnouncementText);
            APCDestroyedAnnouncementText = GetConfig("Public Bradley APC Announcements", "Destroyed Text", APCDestroyedAnnouncementText);
            APCDestroyedAnnouncementWithDestroyerText = GetConfig("Public Bradley APC Announcements", "Destroyed With Destroyer Text", APCDestroyedAnnouncementWithDestroyerText);

            BColor = APCSpawnAnnouncementBannerColor; Category = "Public Bradley APC Announcements"; Setting = "Spawn Banner Color";
            APCSpawnAnnouncementBannerColor = GetConfig(Category, Setting, APCSpawnAnnouncementBannerColor);
            CheckBannerColor(APCSpawnAnnouncementBannerColor, Category, Setting, BColor);

            TColor = APCSpawnAnnouncementTextColor; Category = "Public Bradley APC Announcements"; Setting = "Spawn Text Color";
            APCSpawnAnnouncementTextColor = GetConfig(Category, Setting, APCSpawnAnnouncementTextColor);
            CheckTextColor(APCSpawnAnnouncementTextColor, Category, Setting, TColor);

            BColor = APCDestroyedAnnouncementBannerColor; Category = "Public Bradley APC Announcements"; Setting = "Destroyed Banner Color";
            APCDestroyedAnnouncementBannerColor = GetConfig(Category, Setting, APCDestroyedAnnouncementBannerColor);
            CheckBannerColor(APCDestroyedAnnouncementBannerColor, Category, Setting, BColor);

            TColor = APCDestroyedAnnouncementTextColor; Category = "Public Bradley APC Announcements"; Setting = "Destroyed Text Color";
            APCDestroyedAnnouncementTextColor = GetConfig(Category, Setting, APCDestroyedAnnouncementTextColor);
            CheckTextColor(APCDestroyedAnnouncementTextColor, Category, Setting, TColor);

            //Cargoship Announcements
            CargoshipSpawnAnnouncementsEnabled = GetConfig("Public Cargoship Announcements", "Spawn", CargoshipSpawnAnnouncementsEnabled);
            CargoshipEgressAnnouncementsEnabled = GetConfig("Public Cargoship Announcements", "Leave", CargoshipEgressAnnouncementsEnabled);
            CargoshipSpawnAnnouncementText = GetConfig("Public Cargoship Announcements", "Spawn Text", CargoshipSpawnAnnouncementText);
            CargoshipEgressAnnouncementText = GetConfig("Public Cargoship Announcements", "Leave Text", CargoshipEgressAnnouncementText);

            BColor = CargoshipSpawnAnnouncementBannerColor; Category = "Public Cargoship Announcements"; Setting = "Spawn Banner Color";
            CargoshipSpawnAnnouncementBannerColor = GetConfig(Category, Setting, CargoshipSpawnAnnouncementBannerColor);
            CheckBannerColor(CargoshipSpawnAnnouncementBannerColor, Category, Setting, BColor);

            TColor = CargoshipSpawnAnnouncementTextColor; Category = "Public Cargoship Announcements"; Setting = "Spawn Text Color";
            CargoshipSpawnAnnouncementTextColor = GetConfig(Category, Setting, CargoshipSpawnAnnouncementTextColor);
            CheckTextColor(CargoshipSpawnAnnouncementTextColor, Category, Setting, TColor);

            BColor = CargoshipEgressAnnouncementBannerColor; Category = "Public Cargoship Announcements"; Setting = "Leave Banner Color";
            CargoshipEgressAnnouncementBannerColor = GetConfig(Category, Setting, CargoshipEgressAnnouncementBannerColor);
            CheckBannerColor(CargoshipEgressAnnouncementBannerColor, Category, Setting, BColor);

            TColor = CargoshipEgressAnnouncementTextColor; Category = "Public Cargoship Announcements"; Setting = "Leave Text Color";
            CargoshipEgressAnnouncementTextColor = GetConfig(Category, Setting, CargoshipEgressAnnouncementTextColor);
            CheckTextColor(CargoshipEgressAnnouncementTextColor, Category, Setting, TColor);

            //Crate Hack Announcements
            CrateHackAnnouncementsEnabled = GetConfig("Public Oil Rig Crate Hack Announcements", "Enabled", CrateHackAnnouncementsEnabled);
            CrateHackSpecifyOilRig = GetConfig("Public Oil Rig Crate Hack Announcements", "Specify Which Oil Rig", CrateHackSpecifyOilRig);
            CrateHackAnnouncementText = GetConfig("Public Oil Rig Crate Hack Announcements", "Hack Text", CrateHackAnnouncementText);
            CrateHackAnnouncementSmallOilRigText = GetConfig("Public Oil Rig Crate Hack Announcements", "Hack Text With Small Oil Rig", CrateHackAnnouncementSmallOilRigText);
            CrateHackAnnouncementLargeOilRigText = GetConfig("Public Oil Rig Crate Hack Announcements", "Hack Text With Large Oil Rig", CrateHackAnnouncementLargeOilRigText);

            BColor = CrateHackAnnouncementBannerColor; Category = "Public Oil Rig Crate Hack Announcements"; Setting = "Banner Color";
            CrateHackAnnouncementBannerColor = GetConfig("Public Oil Rig Crate Hack Announcements", "Banner Color", CrateHackAnnouncementBannerColor);
            CheckBannerColor(CrateHackAnnouncementBannerColor, Category, Setting, BColor);

            TColor = CrateHackAnnouncementTextColor; Category = "Public Oil Rig Crate Hack Announcements"; Setting = "Text Color";
            CrateHackAnnouncementTextColor = GetConfig("Public Oil Rig Crate Hack Announcements", "Text Color", CrateHackAnnouncementTextColor);
            CheckTextColor(CrateHackAnnouncementTextColor, Category, Setting, TColor);

            //New Player Announcements
            NewPlayerAnnouncementsEnabled = GetConfig("Private New Player Announcements", "Enabled", NewPlayerAnnouncementsEnabled);
            NewPlayerAnnouncementsList = GetConfig("Private New Player Announcements", "Announcements List (Show On This Many Joins : List To Show)", NewPlayerAnnouncementsList);

            BColor = NewPlayerAnnouncementsBannerColor; Category = "Private New Player Announcements"; Setting = "Banner Color";
            NewPlayerAnnouncementsBannerColor = GetConfig(Category, Setting, NewPlayerAnnouncementsBannerColor);
            CheckBannerColor(NewPlayerAnnouncementsBannerColor, Category, Setting, BColor);

            TColor = NewPlayerAnnouncementsTextColor; Category = "Private New Player Announcements"; Setting = "Text Color";
            NewPlayerAnnouncementsTextColor = GetConfig(Category, Setting, NewPlayerAnnouncementsTextColor);
            CheckTextColor(NewPlayerAnnouncementsTextColor, Category, Setting, TColor);

            //Player Banned Announcement
            PlayerBannedAnnouncementsEnabled = GetConfig("Public Player Banned Announcement", "Enabled", PlayerBannedAnnouncementsEnabled);
            PlayerBannedAnnouncmentText = GetConfig("Public Player Banned Announcement", "Text", PlayerBannedAnnouncmentText);

            BColor = PlayerBannedAnnouncementBannerColor; Category = "Public Player Banned Announcement"; Setting = "Banner Color";
            PlayerBannedAnnouncementBannerColor = GetConfig(Category, Setting, PlayerBannedAnnouncementBannerColor);
            CheckBannerColor(PlayerBannedAnnouncementBannerColor, Category, Setting, BColor);

            TColor = PlayerBannedAnnouncementTextColor; Category = "Public Player Banned Announcement"; Setting = "Text Color";
            PlayerBannedAnnouncementTextColor = GetConfig(Category, Setting, PlayerBannedAnnouncementTextColor);
            CheckTextColor(PlayerBannedAnnouncementTextColor, Category, Setting, TColor);

            //Respawn Announcements
            RespawnAnnouncementsEnabled = GetConfig("Private Respawn Announcements", "Enabled", RespawnAnnouncementsEnabled);
            RespawnAnnouncementsList = GetConfig("Private Respawn Announcements", "Announcements List", RespawnAnnouncementsList);

            BColor = RespawnAnnouncementsBannerColor; Category = "Private Respawn Announcements"; Setting = "Banner Color";
            RespawnAnnouncementsBannerColor = GetConfig(Category, Setting, RespawnAnnouncementsBannerColor);
            CheckBannerColor(RespawnAnnouncementsBannerColor, Category, Setting, BColor);

            TColor = RespawnAnnouncementsTextColor; Category = "Private Respawn Announcements"; Setting = "Text Color";
            RespawnAnnouncementsTextColor = GetConfig(Category, Setting, RespawnAnnouncementsTextColor);
            CheckTextColor(RespawnAnnouncementsTextColor, Category, Setting, TColor);

            //Restart Announcements
            RestartAnnouncementsEnabled = GetConfig("Public Restart Announcements", "Enabled", RestartAnnouncementsEnabled);
            RestartTimesList = GetConfig("Public Restart Announcements", "Restart At (HH:MM:SS)", RestartTimesList);
            if (RestartTimesList.Contains("24:00:00"))
            {
                RestartTimesList[RestartTimesList.IndexOf("24:00:00")] = "00:00:00";
                PrintWarning("\"Public Restart Announcements - Restart At (HH:MM:SS): \"24:00:00\" The 24th hour does not exist, converting to 00:00:00 (the same time)");
                Config["Public Restart Announcements", "Restart Times"] = RestartTimesList;
                ConfigUpdated = true;
            }
            RestartAnnouncementsTimes = GetConfig("Public Restart Announcements", "Announce With Time Left (HH:MM:SS)", RestartAnnouncementsTimes);
            RestartServer = GetConfig("Public Restart Announcements", "Restart My Server", RestartServer);
            RestartAnnouncementsFormat = GetConfig("Public Restart Announcements", "Restart Announcement Text", RestartAnnouncementsFormat);
            RestartSuspendedAnnouncement = GetConfig("Public Restart Announcements", "Suspended Restart Text", RestartSuspendedAnnouncement);
            RestartCancelledAnnouncement = GetConfig("Public Restart Announcements", "Cancelled Scheduled Restart Text", RestartCancelledAnnouncement);

            BColor = RestartAnnouncementsBannerColor; Category = "Public Restart Announcements"; Setting = "Banner Color";
            RestartAnnouncementsBannerColor = GetConfig(Category, Setting, RestartAnnouncementsBannerColor);
            CheckBannerColor(RestartAnnouncementsBannerColor, Category, Setting, BColor);

            TColor = RestartAnnouncementsTextColor; Category = "Public Restart Announcements"; Setting = "Text Color";
            RestartAnnouncementsTextColor = GetConfig(Category, Setting, RestartAnnouncementsTextColor);
            CheckTextColor(RestartAnnouncementsTextColor, Category, Setting, TColor);

            //Test Announcement
            TestAnnouncementFontSize = GetConfig("Private Test Announcement", "Font Size", TestAnnouncementFontSize);
            TestAnnouncementDuration = GetConfig("Private Test Announcement", "Duration", TestAnnouncementDuration);
            TestAnnouncementFadeInTime = GetConfig("Private Test Announcement", "Fade In Time", TestAnnouncementFadeInTime);
            TestAnnouncementFadeOutTime = GetConfig("Private Test Announcement", "Fade Out Time", TestAnnouncementFadeOutTime);
            TestAnnouncementAdjustVPosition = GetConfig("Private Test Announcement", "Adjust Vertical Position", TestAnnouncementAdjustVPosition);
            if (TestAnnouncementAdjustVPosition != 0f)
            {
                TABannerAnchorMaxY = (float.Parse("0.9743") + TestAnnouncementAdjustVPosition).ToString();
                TABannerAnchorMinY = (float.Parse("0.915") + TestAnnouncementAdjustVPosition).ToString();
                TATextAnchorMaxY = (float.Parse("0.9743") + TestAnnouncementAdjustVPosition).ToString();
                TATextAnchorMinY = (float.Parse("0.915") + TestAnnouncementAdjustVPosition).ToString();
            }

            BColor = TestAnnouncementBannerColor; Category = "Private Test Announcement"; Setting = "Banner Color";
            TestAnnouncementBannerColor = GetConfig(Category, Setting, TestAnnouncementBannerColor);
            CheckBannerColor(TestAnnouncementBannerColor, Category, Setting, BColor);

            TColor = TestAnnouncementsTextColor; Category = "Private Test Announcement"; Setting = "Text Color";
            TestAnnouncementsTextColor = GetConfig(Category, Setting, TestAnnouncementsTextColor);
            CheckTextColor(TestAnnouncementsTextColor, Category, Setting, TColor);

            //Third Party Plugin Support
            DoNotOverlayLustyMap = GetConfig("Third Party Plugin Support", "Do Not Overlay LustyMap", DoNotOverlayLustyMap);
            LustyMapPosition = GetConfig("Third Party Plugin Support", "LustyMap Position (Left/Right)", LustyMapPosition);
            if (LustyMapPosition.ToLower() != "left" && LustyMapPosition.ToLower() != "right" || LustyMapPosition == string.Empty || LustyMapPosition == null)
            {
                PrintWarning("Config: \"Third Party Plugin Support - LustyMap Position(Left / Right)\" is not left or right, resetting to left.");
                Config["Third Party Plugin Support", "LustyMap Position (Left/Right)"] = "Left";
                ConfigUpdated = true;
            }
            if (DoNotOverlayLustyMap == true)
            {
                if (LustyMapPosition.ToLower() == "left")
                    BannerAnchorMinX = "0.131 ";
                if (LustyMapPosition.ToLower() == "right")
                    BannerAnchorMaxX = "0.868 ";
            }

            //Welcome Announcements
            WelcomeAnnouncementsEnabled = GetConfig("Private Welcome Announcements", "Enabled", WelcomeAnnouncementsEnabled);
            WelcomeBackAnnouncement = GetConfig("Private Welcome Announcements", "Show Welcome Back If Player Has Been Here Before", WelcomeBackAnnouncement);
            WelcomeAnnouncementText = GetConfig("Private Welcome Announcements", "Welcome Text", WelcomeAnnouncementText);
            WelcomeBackAnnouncementText = GetConfig("Private Welcome Announcements", "Welcome Back Text", WelcomeBackAnnouncementText);
            WelcomeAnnouncementDuration = GetConfig("Private Welcome Announcements", "Duration", WelcomeAnnouncementDuration);
            if (WelcomeAnnouncementDuration == 0)
            {
                PrintWarning("Config: \"Private Welcome Announcement - Duration\" set to 0, resetting to 20f.");
                Config["Private Welcome Announcements", "Duration"] = 20f;
                ConfigUpdated = true;
            }
            WelcomeAnnouncementDelay = GetConfig("Private Welcome Announcements", "Delay", WelcomeAnnouncementDelay);

            BColor = WelcomeAnnouncementBannerColor; Category = "Private Welcome Announcements"; Setting = "Banner Color";
            WelcomeAnnouncementBannerColor = GetConfig(Category, Setting, WelcomeAnnouncementBannerColor);
            CheckBannerColor(WelcomeAnnouncementBannerColor, Category, Setting, BColor);

            TColor = WelcomeAnnouncementTextColor; Category = "Private Welcome Announcements"; Setting = "Text Color";
            WelcomeAnnouncementTextColor = GetConfig(Category, Setting, WelcomeAnnouncementTextColor);
            CheckTextColor(WelcomeAnnouncementTextColor, Category, Setting, TColor);

            if (ConfigUpdated)
            {
                Puts("Configuration file has been updated.");
                SaveConfig();
                ConfigUpdated = false;
                LoadGUIAnnouncementsConfig();
            }
        }

        protected override void LoadDefaultConfig() => PrintWarning("A new configuration file has been created.");

        private T GetConfig<T>(string category, string setting, T defaultValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[category] = data;
                ConfigUpdated = true;
            }
            if (data.TryGetValue(setting, out value))
            {
                if (setting == "Announcements List (Show On This Many Joins : List To Show)" || setting == "Announcement List (Show at this in game time : Announcements to show)" || setting == "Announcement List (Show at this local time : Announcements to show)")
                {
                    var keyType = typeof(T).GetGenericArguments()[0];
                    var valueType = typeof(T).GetGenericArguments()[1];
                    var dict = (IDictionary)Activator.CreateInstance(typeof(T));
                    foreach (var key in ((IDictionary)value).Keys)
                        dict.Add(Convert.ChangeType(key, keyType), Convert.ChangeType(((IDictionary)value)[key], valueType));
                    return (T)dict;
                }
                return (T)Convert.ChangeType(value, typeof(T));
            }
            value = defaultValue;
            data[setting] = value;
            ConfigUpdated = true;
            return (T)Convert.ChangeType(value, typeof(T));
        }

        private List<string> ConvertObjectListToString(object value)
        {
            if (value is List<object>)
            {
                List<object> list = (List<object>)value;
                List<string> strings = list.Select(s => (string)s).ToList();
                return strings;
            }
            else return (List<string>)value;
        }
        #endregion
        #endregion
        //============================================================================================================
        #region PlayerData

        void SaveData() => Interface.Oxide.DataFileSystem.WriteObject("GUIAnnouncementsPlayerData", storedData);

        void LoadSavedData()
        {
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>("GUIAnnouncementsPlayerData");
            if (storedData == null)
            {
                PrintWarning("GUIAnnouncement's datafile is null. Recreating data file...");
                storedData = new StoredData();
                SaveData();
                timer.Once(5, () =>
                {
                    PrintWarning("Reloading...");
                    Interface.Oxide.ReloadPlugin(Title);
                });
            }
        }

        class StoredData
        {
            public Dictionary<ulong, PlayerData> PlayerData = new Dictionary<ulong, PlayerData>();
            public StoredData() { }
        }

        class PlayerData
        {
            public string Name;
            public string UserID;
            public int TimesJoined;
            public bool Dead;
            public PlayerData() { }
        }

        void CreatePlayerData(BasePlayer player)
        {
            var Data = new PlayerData
            {
                Name = player.displayName,
                UserID = player.userID.ToString(),
                TimesJoined = 0
            };
            storedData.PlayerData.Add(player.userID, Data);
            SaveData();
        }

        StoredData storedData;
        void OnServerSave() => SaveData();

        private Dictionary<ulong, AnnouncementInfo> AnnouncementsData = new Dictionary<ulong, AnnouncementInfo>();

        class AnnouncementInfo
        {
            public string BannerTintColor;
            public string TextColor;
            public bool IsTestAnnouncement;
            public AnnouncementInfo() { }
        }

        void StoreAnnouncementData(BasePlayer player, string BannerTintColor, string TextColor, bool IsTestAnnouncement)
        {
            var Data = new AnnouncementInfo
            {
                BannerTintColor = BannerTintColor,
                TextColor = TextColor,
                IsTestAnnouncement = IsTestAnnouncement
            };
            AnnouncementsData.Add(player.userID, Data);
        }

        #endregion
        //============================================================================================================
        #region Localization

        void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
                {
                //Commands
                    {"AnnouncementsCommandPrefix", "announce"},
                    {"OperationsCommandPrefix", "guia"},
                    {"CommandSuffixAnnounceToPlayer", "toplayer"},
                    {"CommandSuffixAnnounceToGroup", "togroup"},
                    {"CommandSuffixAnnouncementTest", "test"},
                    {"CommandSuffixDestroyAnnouncement", "destroy"},
                    {"CommandSuffixMuteBans", "mutebans"},
                    {"CommandSuffixToggleAnnouncements", "toggle"},
                    {"CommandSuffixScheduleRestart", "schedulerestart"},
                    {"CommandSuffixSuspendRestart", "suspendrestart"},
                    {"CommandSuffixResumeRestart", "resumerestart"},
                    {"CommandSuffixGetNextRestart", "nextrestart"},
                    {"CommandSuffixCancelScheduledRestart", "cancelscheduledrestart"},
                    {"CommandSuffixHelp", "help"},
                //NotFound
                    {"PlayerNotFound", "Player {playername} not found, check the name and if they are online."},
                    {"GroupNotFound", "Group {group} not found, check the name."},
                //Permission
                    {"NoPermission", "You do not possess the required permissions."},
                //CommandUsage
                    {"AnnouncementsCommandPrefixUsage", "Usage: /announce <message>, /announce toplayer <player> <message>, /announce togroup <group> <message>."},
                    {"OperationsCommandPrefixUsage", "Usage: /guia test, /guia destroy, /guia toggle [player], /guia mutebans, /guia schedulerestart <time> [reason], /guia cancelscheduledrestart, /guia suspendrestart, /guia resumerestart, /guia nextrestart, /guia help."},
                    {"AnnounceToPlayerUsage", "Usage: /announce toplayer <player> <message>."},
                    {"AnnounceToGroupUsage", "Usage: /announce togroup <group> <message>."},
                    {"AnnouncementsToggleUsage", "Usage: /guia toggle [player]."},
                    {"ScheduleRestartUsage", "Usage: /guia schedulerestart <hh:mm:ss>."},
                    {"RunTestAnnouncementFromInGame", "You must run this command from in the game."},
                //RestartMessages
                    {"ServerAboutToRestart", "Your server is about to restart, there is no need to schedule a restart right now."},
                    {"RestartScheduled", "Restart scheduled in {time}{reason}."},
                    {"RestartAlreadyScheduled", "A restart has already been scheduled for {time}, please cancel that restart first with /guia cancelscheduledrestart." },
                    {"LaterThanNextRestart", "Restart not scheduled. Your time will be scheduled later than the next restart at {time}, please make sure you schedule a restart before {time}." },
                    {"RestartNotScheduled", "A restart has not been scheduled for you to cancel. You can schedule one with /guia schedulerstart <time> [reason]."},
                    {"ScheduledRestartCancelled", "A manually scheduled restart for {time} has been cancelled."},
                    {"GetNextRestart", "Next restart is in {time1} at {time2}."},
                    {"NoRestartScheduled", "A restart has not been scheduled." },
                    {"RestartSuspended", "The next restart at {time} has been suspended. Type /guia resumerestart to resume that restart."},
                    {"RestartAlreadySuspended", "The next restart at {time} has already been suspended. Type /guia resumerestart to resume that restart."},
                    {"NoRestartToSuspend", "A restart has not been scheduled for you to suspend. You can schedule one with /guia schedulerstart <time> [reason]."},
                    {"RestartResumed", "The previously suspended restart at {time} has been resumed."},
                    {"RestartNotSuspended", "The restart at {time} has not been suspended and cannot be resumed. You can suspend it with /guia suspendrestart."},
                    {"NoRestartToResume", "A restart has not been suspended for you to resume. You can schedule one with /guia schedulerestart <time> [reason]."},
                    {"SuspendedRestartPassed", "The previously suspended restart at {time} has passed."},
                //ToggleMessages
                    {"Excluded", "{playername} has been excluded from announcements."},
                    {"ExcludedTo", "You have been excluded from announcements."},
                    {"Included", "{playername} is being included in announcements."},
                    {"IncludedTo", "You are being included in announcements."},
                    {"IsExcluded", "{playername} is currently excluded from announcements."},
                    {"YouAreExcluded", "You are excluded from announcements and cannot see that test announcement."},
                    {"CannotExcludeServer", "You cannot exclude the server console from announcements, try specifying a name."},
                //Bans
                    {"BansMuted", "Ban announcements have been muted."},
                    {"BansUnmuted", "Ban announcements have been unmuted."},
                //Help
                    {"PlayerHelp", "Commands: /guia toggle, /guia nextrestart."},
                //Time
                    {"Hours", "hours"},
                    {"Hour", "hour"},
                    {"Minutes", "minutes"},
                    {"Seconds", "seconds"},
                    {"Second", "second"}
            }, this);
        }

        #endregion
        //============================================================================================================
        #region Initialization

        void OnServerInitialized()
        {
            LoadGUIAnnouncementsConfig();
            LoadSavedData();
            LoadDefaultMessages();
            permission.RegisterPermission(PermAnnounce, this);
            permission.RegisterPermission(PermAnnounceToggle, this);
            permission.RegisterPermission(PermAnnounceGetNextRestart, this);
            permission.RegisterPermission(PermAnnounceJoinLeave, this);

            foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
            {
                if (!storedData.PlayerData.ContainsKey(activePlayer.userID))
                {
                    CreatePlayerData(activePlayer);
                    storedData.PlayerData[activePlayer.userID].TimesJoined = storedData.PlayerData[activePlayer.userID].TimesJoined + 1;
                    SaveData();
                }
            }
            foreach (BasePlayer sleepingPlayer in BasePlayer.sleepingPlayerList)
            {
                if (!storedData.PlayerData.ContainsKey(sleepingPlayer.userID))
                {
                    CreatePlayerData(sleepingPlayer);
                    storedData.PlayerData[sleepingPlayer.userID].TimesJoined = storedData.PlayerData[sleepingPlayer.userID].TimesJoined + 1;
                    SaveData();
                }
            }

            if (AutomaticGameTimeAnnouncementsEnabled)
                GameTimeAnnouncementsStart();

            if (AutomaticRealtimeAnnouncementsEnabled)
                AutomaticRealTimeAnnouncementsStart();

            if (AutomaticTimedAnnouncementsEnabled)
                AutomaticTimedAnnouncementsStart();

            if (RestartAnnouncementsEnabled)
                RestartAnnouncementsStart();

            cmd.AddChatCommand(Lang("AnnouncementsCommandPrefix"), this, "CMDHandler");
            cmd.AddChatCommand(Lang("OperationsCommandPrefix"), this, "CMDHandler");
            cmd.AddConsoleCommand(Lang("AnnouncementsCommandPrefix"), this, "ConsoleCMDInput");
            cmd.AddConsoleCommand(Lang("OperationsCommandPrefix"), this, "ConsoleCMDInput");
        }
        #endregion
        //============================================================================================================
        #region GUI

        [HookMethod("CreateAnnouncement")]
        void CreateAnnouncement(string Msg, string bannerTintColor, string textColor, BasePlayer player = null, float APIAdjustVPosition = 0f, bool isWelcomeAnnouncement = false, bool isRestartAnnouncement = false, string group = null, bool isTestAnnouncement = false)
        {
            CuiElementContainer GUITEXT = new CuiElementContainer();
            CuiElementContainer GUIBANNER = new CuiElementContainer();
            string BAMaxY = "", BAMinY = "", TAMaxY = "", TAMinY = "";
            if (APIAdjustVPosition != 0f)
            {
                BAMaxY = (float.Parse(BannerAnchorMaxYDefault) + APIAdjustVPosition).ToString();
                BAMinY = (float.Parse(BannerAnchorMinYDefault) + APIAdjustVPosition).ToString();
                TAMaxY = (float.Parse(TextAnchorMaxYDefault) + APIAdjustVPosition).ToString();
                TAMinY = (float.Parse(TextAnchorMinYDefault) + APIAdjustVPosition).ToString();
            }
            else if (isTestAnnouncement)
            {
                BAMaxY = TABannerAnchorMaxY; BAMinY = TABannerAnchorMinY; TAMaxY = TATextAnchorMaxY; TAMinY = TATextAnchorMinY;
            }
            else
            {
                BAMaxY = BannerAnchorMaxY; BAMinY = BannerAnchorMinY; TAMaxY = TextAnchorMaxY; TAMinY = TextAnchorMinY;
            }
            GUIBANNER.Add(new CuiElement
            {
                Name = "AnnouncementBanner",
                Components =
                        {
                            new CuiImageComponent {Color = ConvertBannerColor(bannerTintColor), FadeIn = FadeInTime},
                            new CuiRectTransformComponent {AnchorMin = BannerAnchorMinX + BAMinY, AnchorMax = BannerAnchorMaxX + BAMaxY}
                        },
                FadeOut = FadeOutTime
            });
            GUITEXT.Add(new CuiElement
            {
                Name = "AnnouncementText",
                Components =
                        {
                             new CuiTextComponent {Text = Msg, FontSize = FontSize, Align = TextAnchor.MiddleCenter, FadeIn = FadeInTime, Color = ConvertTextColor(textColor)},
                             new CuiRectTransformComponent {AnchorMin = TextAnchorMinX + TAMinY, AnchorMax = TextAnchorMaxX + TAMaxY}
                        },
                FadeOut = FadeOutTime
            });
            if (player == null)
            {
                var e = BasePlayer.activePlayerList.GetEnumerator();
                for (var i = 0; e.MoveNext(); i++)
                {
                    if (!Exclusions.ContainsKey(e.Current.userID))
                    {
                        if (group == null)
                        {
                            DestroyAllTimers(e.Current);
                            GlobalTimerPlayerList.Add(e.Current.userID);
                            if (AnnouncementsData.ContainsKey(e.Current.userID) && AnnouncementsData[e.Current.userID].IsTestAnnouncement == isTestAnnouncement)
                            {
                                if (AnnouncementsData[e.Current.userID].BannerTintColor != bannerTintColor)
                                {
                                    CuiHelper.DestroyUi(e.Current, "AnnouncementBanner");
                                    CuiHelper.AddUi(e.Current, GUIBANNER);
                                }
                                CuiHelper.DestroyUi(e.Current, "AnnouncementText");
                                CuiHelper.AddUi(e.Current, GUITEXT);
                                AnnouncementsData.Remove(e.Current.userID);
                            }
                            else
                            {
                                AnnouncementsData.Remove(e.Current.userID);
                                CuiHelper.DestroyUi(e.Current, "AnnouncementBanner");
                                CuiHelper.DestroyUi(e.Current, "AnnouncementText");
                                CuiHelper.AddUi(e.Current, GUIBANNER);
                                CuiHelper.AddUi(e.Current, GUITEXT);
                            }
                            StoreAnnouncementData(e.Current, bannerTintColor, textColor, isTestAnnouncement);
                        }
                        else if (group != null)
                        {
                            if (permission.GetUserGroups(e.Current.UserIDString).Any(group.ToLower().Contains))
                            {
                                DestroyAllTimers(e.Current);
                                GlobalTimerPlayerList.Add(e.Current.userID);
                                if (AnnouncementsData.ContainsKey(e.Current.userID) && AnnouncementsData[e.Current.userID].IsTestAnnouncement == isTestAnnouncement)
                                {
                                    if (AnnouncementsData[e.Current.userID].BannerTintColor != bannerTintColor)
                                    {
                                        CuiHelper.DestroyUi(e.Current, "AnnouncementBanner");
                                        CuiHelper.AddUi(e.Current, GUIBANNER);
                                    }
                                    CuiHelper.DestroyUi(e.Current, "AnnouncementText");
                                    CuiHelper.AddUi(e.Current, GUITEXT);
                                    AnnouncementsData.Remove(e.Current.userID);
                                }
                                else
                                {
                                    AnnouncementsData.Remove(e.Current.userID);
                                    CuiHelper.DestroyUi(e.Current, "AnnouncementBanner");
                                    CuiHelper.DestroyUi(e.Current, "AnnouncementText");
                                    CuiHelper.AddUi(e.Current, GUIBANNER);
                                    CuiHelper.AddUi(e.Current, GUITEXT);
                                }
                                StoreAnnouncementData(e.Current, bannerTintColor, textColor, isTestAnnouncement);
                            }
                        }
                    }
                    else if (isRestartAnnouncement)
                        SendReply(e.Current, Msg, e.Current.userID);
                }
                GlobalTimer = timer.Once(AnnouncementDuration, () => DestroyGlobalGUI());
                return;
            }
            if (player != null)
            {
                DestroyPrivateTimer(player);
                if (AnnouncementsData.ContainsKey(player.userID) && AnnouncementsData[player.userID].IsTestAnnouncement == isTestAnnouncement)
                {
                    if (AnnouncementsData[player.userID].BannerTintColor != bannerTintColor)
                    {
                        CuiHelper.DestroyUi(player, "AnnouncementBanner");
                        CuiHelper.AddUi(player, GUIBANNER);
                    }
                    CuiHelper.DestroyUi(player, "AnnouncementText");
                    CuiHelper.AddUi(player, GUITEXT);
                    AnnouncementsData.Remove(player.userID);
                }
                else
                {
                    if (AnnouncementsData.ContainsKey(player.userID))
                        AnnouncementsData.Remove(player.userID);
                    CuiHelper.DestroyUi(player, "AnnouncementBanner");
                    CuiHelper.DestroyUi(player, "AnnouncementText");
                    CuiHelper.AddUi(player, GUIBANNER);
                    CuiHelper.AddUi(player, GUITEXT);
                }
                if (JustJoined.Contains(player.userID) && WelcomeAnnouncementsEnabled && isWelcomeAnnouncement)
                {
                    JustJoined.Remove(player.userID);
                    PrivateTimers[player] = timer.Once(WelcomeAnnouncementDuration, () => DestroyPrivateGUI(player));
                }
                else PrivateTimers[player] = timer.Once(AnnouncementDuration, () => DestroyPrivateGUI(player));
                StoreAnnouncementData(player, bannerTintColor, textColor, isTestAnnouncement);
            }
        }

        #endregion
        //============================================================================================================
        #region Functions

        void OnPlayerConnected(BasePlayer player)
        {
            if (WelcomeAnnouncementsEnabled || NewPlayerAnnouncementsEnabled || RespawnAnnouncementsEnabled || GlobalJoinAnnouncementsEnabled)
                JustJoined.Add(player.userID);
            if (!storedData.PlayerData.ContainsKey(player.userID))
                CreatePlayerData(player);
            if (storedData.PlayerData.ContainsKey(player.userID))
            {
                storedData.PlayerData[player.userID].TimesJoined = storedData.PlayerData[player.userID].TimesJoined + 1;
                SaveData();
            }
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            if (JustJoined.Contains(player.userID))
                JustJoined.Remove(player.userID);
            NewPlayerPrivateTimers.TryGetValue(player, out NewPlayerTimer);
            if (NewPlayerTimer != null && !NewPlayerTimer.Destroyed)
                NewPlayerTimer.Destroy();
            PlayerRespawnedTimers.TryGetValue(player, out PlayerRespawnedTimer);
            if (PlayerRespawnedTimer != null && !PlayerRespawnedTimer.Destroyed)
                PlayerRespawnedTimer.Destroy();
            if (GlobalTimerPlayerList.Contains(player.userID))
                GlobalTimerPlayerList.Remove(player.userID);
            DestroyPrivateGUI(player);
            if (GlobalLeaveAnnouncementsEnabled)
            {
                BasePlayer.activePlayerList.Remove(player); //Need to remove player earlier than server, otherwise global leave will create announcement for the disconnecting player
                string Group = "";
                if (permission.GetUserGroups(player.UserIDString)[0].ToLower() != "default")
                    Group = char.ToUpper(permission.GetUserGroups(player.UserIDString)[0][0]) + permission.GetUserGroups(player.UserIDString)[0].Substring(1);
                if (GlobalJoinLeavePermissionOnly && HasPermission(player, PermAnnounceJoinLeave))
                    CreateAnnouncement(GlobalLeaveText.Replace("{playername}", player.displayName).Replace("{rank}", Group), GlobalLeaveAnnouncementBannerColor, GlobalLeaveAnnouncementTextColor);
                else CreateAnnouncement(GlobalLeaveText.Replace("{playername}", player.displayName).Replace("{rank}", Group), GlobalLeaveAnnouncementBannerColor, GlobalLeaveAnnouncementTextColor);
            }
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            if (!storedData.PlayerData.ContainsKey(player.userID))
            {
                CreatePlayerData(player);
                storedData.PlayerData[player.userID].TimesJoined = storedData.PlayerData[player.userID].TimesJoined + 1;
                SaveData();
            }
            bool wasDead = false;
            if (storedData.PlayerData[player.userID].Dead)
            {
                wasDead = true;
                storedData.PlayerData[player.userID].Dead = false;
            }
            if (JustJoined.Contains(player.userID))
            {
                float wait = 0f;
                if (GlobalJoinAnnouncementsEnabled)
                {
                    string Group = "";
                    if (permission.GetUserGroups(player.UserIDString)[0].ToLower() != "default")
                        Group = char.ToUpper(permission.GetUserGroups(player.UserIDString)[0][0]) + permission.GetUserGroups(player.UserIDString)[0].Substring(1);
                    if (GlobalJoinLeavePermissionOnly && HasPermission(player, PermAnnounceJoinLeave))
                    {
                        CreateAnnouncement(GlobalJoinText.Replace("{playername}", player.displayName).Replace("{rank}", Group), GlobalJoinAnnouncementBannerColor, GlobalJoinAnnouncementTextColor);
                        wait = wait + AnnouncementDuration;
                    }
                    else
                    {
                        CreateAnnouncement(GlobalJoinText.Replace("{playername}", player.displayName).Replace("{rank}", Group), GlobalJoinAnnouncementBannerColor, GlobalJoinAnnouncementTextColor);
                        wait = wait + AnnouncementDuration;
                    }
                }
                if (WelcomeAnnouncementsEnabled)
                {
                    timer.Once(wait, () => WelcomeAnnouncement(player));
                    wait = wait + WelcomeAnnouncementDuration + WelcomeAnnouncementDelay;
                }
                if (NewPlayerAnnouncementsEnabled)
                {
                    int timesJoined = storedData.PlayerData[player.userID].TimesJoined;
                    if (NewPlayerAnnouncementsList.ContainsKey(timesJoined) || NewPlayerAnnouncementsList.ContainsKey(0))
                    {
                        timer.Once(wait, () => NewPlayerAnnouncements(player));
                        if (NewPlayerAnnouncementsList.ContainsKey(0))
                            wait = wait + (NewPlayerAnnouncementsList[0].Count * AnnouncementDuration);
                        else wait = wait + (NewPlayerAnnouncementsList[timesJoined].Count * AnnouncementDuration);
                    }
                }
                if (wasDead == true && RespawnAnnouncementsEnabled)
                {
                    timer.Once(wait, () => RespawnedAnnouncements(player));
                    wasDead = false;
                }
            }
            else if (!JustJoined.Contains(player.userID) && wasDead == true && RespawnAnnouncementsEnabled)
            {
                RespawnedAnnouncements(player);
                wasDead = false;
            }
            if (!JustJoined.Contains(player.userID) && wasDead == true && !WelcomeAnnouncementsEnabled && !NewPlayerAnnouncementsEnabled && RespawnAnnouncementsEnabled) //Redundant??
            {
                RespawnedAnnouncements(player);
                wasDead = false;
            }
        }

        void DestroyAllGUI()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (AnnouncementsData.ContainsKey(player.userID))
                    AnnouncementsData.Remove(player.userID);
                DestroyAllTimers(player);
                CuiHelper.DestroyUi(player, "AnnouncementBanner");
                CuiHelper.DestroyUi(player, "AnnouncementText");
            }
        }

        void DestroyGlobalGUI()
        {
            if (GlobalTimer != null && !GlobalTimer.Destroyed)
                GlobalTimer.Destroy();
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (AnnouncementsData.ContainsKey(player.userID))
                    AnnouncementsData.Remove(player.userID);
                if (GlobalTimerPlayerList.Contains(player.userID))
                {
                    GlobalTimerPlayerList.Remove(player.userID);
                    CuiHelper.DestroyUi(player, "AnnouncementBanner");
                    CuiHelper.DestroyUi(player, "AnnouncementText");
                }
            }
        }

        void DestroyPrivateGUI(BasePlayer player)
        {
            if (AnnouncementsData.ContainsKey(player.userID))
                AnnouncementsData.Remove(player.userID);
            DestroyPrivateTimer(player);
            CuiHelper.DestroyUi(player, "AnnouncementBanner");
            CuiHelper.DestroyUi(player, "AnnouncementText");
        }

        void DestroyAllTimers(BasePlayer player)
        {
            if (GlobalTimer != null && !GlobalTimer.Destroyed)
                GlobalTimer.Destroy();
            if (GlobalTimerPlayerList.Contains(player.userID))
                GlobalTimerPlayerList.Remove(player.userID);
            PrivateTimers.TryGetValue(player, out PlayerTimer);
            if (PlayerTimer != null && !PlayerTimer.Destroyed)
                PlayerTimer.Destroy();
        }

        void DestroyPrivateTimer(BasePlayer player)
        {
            if (GlobalTimerPlayerList.Contains(player.userID))
                GlobalTimerPlayerList.Remove(player.userID);
            PrivateTimers.TryGetValue(player, out PlayerTimer);
            if (PlayerTimer != null && !PlayerTimer.Destroyed)
                PlayerTimer.Destroy();
        }

        void Unload()
        {
            DestroyAllGUI();
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                NewPlayerPrivateTimers.TryGetValue(player, out NewPlayerTimer);
                if (NewPlayerTimer != null && !NewPlayerTimer.Destroyed)
                    NewPlayerTimer.Destroy();
                PlayerRespawnedTimers.TryGetValue(player, out PlayerRespawnedTimer);
                if (PlayerRespawnedTimer != null && !PlayerRespawnedTimer.Destroyed)
                    PlayerRespawnedTimer.Destroy();
            }
            if (SixtySecondsTimer != null && !SixtySecondsTimer.Destroyed)
                SixtySecondsTimer.Destroy();
            if (AutomaticAnnouncementsTimer != null && !AutomaticAnnouncementsTimer.Destroyed)
                AutomaticAnnouncementsTimer.Destroy();
            if (RealTimeTimer != null && !RealTimeTimer.Destroyed)
                RealTimeTimer.Destroy();
            SaveData();
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity is PatrolHelicopter && info.Initiator is BasePlayer && HelicopterDestroyedAnnouncementWithDestroyer)
                HeliLastHitPlayer = info.Initiator.ToPlayer().displayName;
            if (entity is CH47Helicopter && info.Initiator is BasePlayer && CH47DestroyedAnnouncementsWithDestroyer)
                CH47LastHitPlayer = info.Initiator.ToPlayer().displayName;
            if (entity is BradleyAPC && info.Initiator is BasePlayer && APCDestroyedAnnouncementsWithDestroyer)
                APCLastHitPlayer = info.Initiator.ToPlayer().displayName;
        }

        string ConvertBannerColor(string BColor)
        {
            BColor = BColor.ToLower();
            if (BColor == "grey")
                return BannerTintGrey;
            if (BColor == "red")
                return BannerTintRed;
            if (BColor == "orange")
                return BannerTintOrange;
            if (BColor == "yellow")
                return BannerTintYellow;
            if (BColor == "green")
                return BannerTintGreen;
            if (BColor == "cyan")
                return BannerTintCyan;
            if (BColor == "blue")
                return BannerTintBlue;
            if (BColor == "purple")
                return BannerTintPurple;
            else PrintWarning("Banner color not found.");
            return BannerTintGrey;
        }

        string ConvertTextColor(string TColor)
        {
            TColor = TColor.ToLower();
            if (TColor == "red")
                return TextRed;
            if (TColor == "orange")
                return TextOrange;
            if (TColor == "yellow")
                return TextYellow;
            if (TColor == "green")
                return TextGreen;
            if (TColor == "cyan")
                return TextCyan;
            if (TColor == "blue")
                return TextBlue;
            if (TColor == "purple")
                return TextPurple;
            if (TColor == "white")
                return TextWhite;
            else PrintWarning("Text color not found.");
            return TextWhite;
        }

        void CheckBannerColor(string BColor, string Category, string Setting, string Default)
        {
            if (!BannerColorList.ToLower().Contains(BColor.ToLower()))
            {
                PrintWarning("\"" + Category + " - " + Setting + ": " + BColor + "\" is not a valid color, resetting to default.");
                Config[Category, Setting] = Default;
                ConfigUpdated = true;
            }
        }

        void CheckTextColor(string TColor, string Category, string Setting, string Default)
        {
            if (!TextColorList.ToLower().Contains(TColor.ToLower()))
            {
                PrintWarning("\"" + Category + " - " + Setting + ": " + TColor + "\" is not a valid color, resetting to default.");
                Config[Category, Setting] = Default;
                ConfigUpdated = true;
            }
        }

        private static BasePlayer FindPlayer(string IDName)
        {
            foreach (BasePlayer targetPlayer in BasePlayer.activePlayerList)
            {
                if (targetPlayer.UserIDString == IDName)
                    return targetPlayer;
                if (targetPlayer.displayName.Contains(IDName, CompareOptions.OrdinalIgnoreCase))
                    return targetPlayer;
            }
            return null;
        }

        private bool HasPermission(BasePlayer player, string perm)
        {
            if (!permission.UserHasPermission(player.userID.ToString(), perm))
                return false;
            return true;
        }

        void GameTimeAnnouncementsStart()
        {
            GameTimes = AutomaticGameTimeAnnouncementsList.Keys.ToList();
            timer.Every(5f, () => GameTimeAnnouncements());
        }

        void AutomaticRealTimeAnnouncementsStart()
        {
            RealTimes = AutomaticRealTimeAnnouncementsList.Keys.ToList();
            timer.Every(5f, () => RealTimeAnnouncements());
        }

        void AutomaticTimedAnnouncementsStart()
        {
            foreach (List<object> L in AutomaticTimedAnnouncementsList)
            {
                List<string> l = ConvertObjectListToString(L);
                AutomaticTimedAnnouncementsStringList.Add(l);
            }
            ATALEnum = AutomaticTimedAnnouncementsStringList.GetEnumerator();
            AutomaticAnnouncementsTimer = timer.Every((float)AutomaticTimedAnnouncementsRepeatTimeSpan.TotalSeconds, () =>
            {
                if (ATALEnum.MoveNext() == false)
                {
                    ATALEnum.Reset();
                    ATALEnum.MoveNext();
                }
                AutomaticTimedAnnouncements();
            });
        }

        void RestartAnnouncementsStart()
        {
            if (RestartAnnouncementsEnabled)
            {
                List<string> convertRestartTimesList = ConvertObjectListToString(RestartTimesList);
                RestartTimes = convertRestartTimesList.Select(date => DateTime.Parse(date)).ToList();
            }
            RestartAnnouncementsWhenStrings = ConvertObjectListToString(RestartAnnouncementsTimes);
            RestartAnnouncementsTimeSpans = RestartAnnouncementsWhenStrings.Select(date => TimeSpan.Parse(date)).ToList();
            GetNextRestart(RestartTimes);
            if (!RealTimeTimerStarted)
                RealTimeTimer = timer.Every(1f, () => RestartAnnouncements());
        }


        void GetNextRestart(List<DateTime> DateTimes)
        {
            var e = DateTimes.GetEnumerator();
            for (var i = 0; e.MoveNext(); i++)
            {
                if (DateTime.Compare(DateTime.Now, e.Current) < 0)
                    CalcNextRestartDict.Add(e.Current, e.Current.Subtract(DateTime.Now));
                if (DateTime.Compare(DateTime.Now, e.Current) > 0)
                    CalcNextRestartDict.Add(e.Current.AddDays(1), e.Current.AddDays(1).Subtract(DateTime.Now));
            }
            NextRestart = CalcNextRestartDict.Aggregate((l, r) => l.Value < r.Value ? l : r).Key;
            CalcNextRestartDict.Clear();
            Puts("Next restart is in " + NextRestart.Subtract(DateTime.Now).ToShortString() + " at " + NextRestart.ToLongTimeString());
        }

        private string GetGrid(Vector3 position, BasePlayer player = null)
        {
            char letter1 = 'A';
            char letter2 = '\0';
            float x = Mathf.Floor((position.x + (WorldSize / 2)) / 146.3f);
            if (x > 25)
                letter2 = 'A';
            x = x % 26;
            float z = (Mathf.Floor(WorldSize / 146.3f) - 1) - Mathf.Floor((position.z + (WorldSize / 2)) / 146.3f);
            letter1 = (char)(letter1 + x);
            return $"{letter2}{letter1}{z}".Replace("\0", "");
        }

        private void SendReply(BasePlayer Commander, string format, bool isConsole, params object[] args)
        {
            string message = args.Length > 0 ? string.Format(format, args) : format;
            if (Commander?.net != null && isConsole)
            {
                Commander.SendConsoleCommand("echo " + message); return;
            }
            if (Commander?.net == null && isConsole)
            {
                Puts(message); return;
            }
            if (Commander?.net != null)
            {
                PrintToChat(Commander, format, args); return;
            }
        }

        string Lang(string key, string userId = null) => lang.GetMessage(key, this, userId);

        #endregion
        //============================================================================================================
        #region Auto Announcements

        void RestartAnnouncements()
        {
            var currentTime = DateTime.Now;
            if (NextRestart <= currentTime)
            {
                if (RestartSuspended)
                {
                    Puts(Lang("SuspendedRestartPassed").Replace("{time}", NextRestart.ToLongTimeString()));
                    RestartSuspended = false;
                }
                if (RestartScheduled)
                {
                    RestartReason = String.Empty;
                    RestartTimes.Remove(ScheduledRestart);
                    RestartScheduled = false;
                }
                if (RestartAnnouncementsEnabled && DontCheckNextRestart == false)
                {
                    DontCheckNextRestart = true;
                    GetNextRestartTimer = timer.Once(3f, () =>
                    {
                        GetNextRestart(RestartTimes);
                        DontCheckNextRestart = false;
                    });
                }
                return;
            }
            if (!RestartSuspended)
            {
                TimeSpan timeLeft = NextRestart.Subtract(currentTime);
                string secondsString = String.Empty;
                int hoursLeft = timeLeft.Hours, minutesLeft = timeLeft.Minutes, secondsLeft = timeLeft.Seconds;
                if ((!RestartCountdown && RestartAnnouncementsWhenStrings.Contains(timeLeft.ToShortString()) && ((LastHour != currentTime.Hour) || (LastMinute != currentTime.Minute))) || RestartJustScheduled)
                {
                    string timeLeftString = String.Empty;
                    if (RestartJustScheduled)
                        RestartJustScheduled = false;
                    if (hoursLeft > 1)
                    {
                        timeLeftString = timeLeftString + hoursLeft + " " + Lang("Hours");
                        LastHour = currentTime.Hour;
                    }
                    if (hoursLeft == 1)
                    {
                        timeLeftString = timeLeftString + hoursLeft + " " + Lang("Hour");
                        LastHour = currentTime.Hour;
                    }
                    if (minutesLeft > 0)
                    {
                        timeLeftString = timeLeftString + minutesLeft + " " + Lang("Minutes");
                        LastMinute = currentTime.Minute;
                    }
                    if (String.IsNullOrEmpty(RestartReason) && timeLeft > new TimeSpan(00, 01, 00))
                    {
                        Puts(RestartAnnouncementsFormat.Replace("{time}", timeLeftString) + ".");
                        CreateAnnouncement(RestartAnnouncementsFormat.Replace("{time}", timeLeftString) + ".", RestartAnnouncementsBannerColor, RestartAnnouncementsTextColor, isRestartAnnouncement: true);
                    }
                    else if (timeLeft > new TimeSpan(00, 01, 00))
                    {
                        Puts(RestartAnnouncementsFormat.Replace("{time}", timeLeftString) + ":" + RestartReason);
                        CreateAnnouncement(RestartAnnouncementsFormat.Replace("{time}", timeLeftString) + ":" + RestartReason, RestartAnnouncementsBannerColor, RestartAnnouncementsTextColor, isRestartAnnouncement: true);
                    }
                }
                if (timeLeft <= new TimeSpan(00, 01, 00) && !RestartCountdown)
                {
                    int countDown = timeLeft.Seconds;
                    RestartCountdown = true;
                    if (String.IsNullOrEmpty(RestartReason))
                    {
                        Puts(RestartAnnouncementsFormat.Replace("{time}", countDown.ToString() + " " + Lang("Seconds")));
                        CreateAnnouncement(RestartAnnouncementsFormat.Replace("{time}", countDown.ToString()) + " " + Lang("Seconds"), RestartAnnouncementsBannerColor, RestartAnnouncementsTextColor, isRestartAnnouncement: true);
                    }
                    else
                    {
                        Puts(RestartAnnouncementsFormat.Replace("{time}", countDown.ToString()) + " " + Lang("Seconds") + ":" + RestartReason);
                        CreateAnnouncement(RestartAnnouncementsFormat.Replace("{time}", countDown.ToString()) + " " + Lang("Seconds") + ":" + RestartReason, RestartAnnouncementsBannerColor, RestartAnnouncementsTextColor, isRestartAnnouncement: true);
                    }
                    SixtySecondsTimer = timer.Repeat(1, countDown + 1, () =>
                        {
                            if (countDown == 1)
                                secondsString = " " + Lang("Second");
                            else secondsString = " " + Lang("Seconds");
                            if (String.IsNullOrEmpty(RestartReason))
                                CreateAnnouncement(RestartAnnouncementsFormat.Replace("{time}", countDown.ToString() + secondsString), RestartAnnouncementsBannerColor, RestartAnnouncementsTextColor);
                            else CreateAnnouncement(RestartAnnouncementsFormat.Replace("{time}", countDown.ToString() + secondsString + ":" + RestartReason), RestartAnnouncementsBannerColor, RestartAnnouncementsTextColor);
                            countDown = countDown - 1;
                            if (countDown == 0)
                            {
                                if (RealTimeTimer != null && RealTimeTimer.Destroyed)
                                    RealTimeTimer.Destroy();
                                Puts("Restart countdown finished.");
                                if (RestartScheduled)
                                    RestartScheduled = false;
                                RestartCountdown = false;
                                if (RestartServer)
                                {
                                    rust.RunServerCommand("save");
                                    timer.Once(3, () => rust.RunServerCommand("restart 0"));
                                }
                            }
                        });
                }
            }
        }

        void GameTimeAnnouncements()
        {
            if (!RestartCountdown)
            {
                DateTime CurrentGameTime = TOD_Sky.Instance.Cycle.DateTime;
                string CurrentGameTimeString = CurrentGameTime.ToShortTimeString();
                if (CurrentGameTimeString != LastGameTime)
                {
                    if (GameTimes.Contains(CurrentGameTimeString) && !AnnouncingGameTime)
                    {
                        LastGameTime = CurrentGameTimeString;
                        IEnumerator<object> e = AutomaticGameTimeAnnouncementsList[CurrentGameTimeString].GetEnumerator();
                        if (e.MoveNext())
                        {
                            int wait = 0;
                            if (AnnouncingRealTime)
                                wait = RealTimeCurrentCount * (int)AnnouncementDuration;
                            int count = AutomaticGameTimeAnnouncementsList[CurrentGameTimeString].Count;
                            AnnouncingGameTime = true;
                            GameTimeCurrentCount = count;
                            timer.Once(wait, () =>
                            {
                                CreateAnnouncement(e.Current.ToString(), AutomaticGameTimeAnnouncementsBannerColor, AutomaticGameTimeAnnouncementsTextColor);
                                if (count > 1)
                                {
                                    timer.Repeat(AnnouncementDuration, count, () =>
                                    {
                                        if (e.MoveNext())
                                        {
                                            CreateAnnouncement(e.Current.ToString(), AutomaticGameTimeAnnouncementsBannerColor, AutomaticGameTimeAnnouncementsTextColor);
                                            GameTimeCurrentCount = GameTimeCurrentCount - 1;
                                        }
                                        else
                                        {
                                            AnnouncingGameTime = false;
                                            GameTimeCurrentCount = 0;
                                        }
                                    });
                                }
                                else timer.Once(AnnouncementDuration, () =>
                                {
                                    AnnouncingGameTime = false;
                                    GameTimeCurrentCount = 0;
                                });
                            });
                        }
                    }
                }
            }
        }

        void RealTimeAnnouncements()
        {
            if (!RestartCountdown)
            {
                DateTime CurrentLocalTime = DateTime.Now;
                string CurrentLocalTimeString = CurrentLocalTime.ToShortTimeString();
                if (CurrentLocalTimeString != LastRealTime)
                {
                    if (RealTimes.Contains(CurrentLocalTimeString) && !AnnouncingRealTime)
                    {
                        LastRealTime = CurrentLocalTimeString;
                        IEnumerator<object> e = AutomaticRealTimeAnnouncementsList[CurrentLocalTimeString].GetEnumerator();
                        if (e.MoveNext())
                        {
                            int wait = 0;
                            if (AnnouncingGameTime)
                                wait = GameTimeCurrentCount * (int)AnnouncementDuration;
                            int count = AutomaticRealTimeAnnouncementsList[CurrentLocalTimeString].Count;
                            AnnouncingRealTime = true;
                            RealTimeCurrentCount = count;
                            timer.Once(wait, () =>
                            {
                                CreateAnnouncement(e.Current.ToString(), AutomaticRealTimeAnnouncementsBannerColor, AutomaticRealTimeAnnouncementsTextColor);
                                if (count > 1)
                                {
                                    timer.Repeat(AnnouncementDuration, count, () =>
                                    {
                                        if (e.MoveNext())
                                        {
                                            CreateAnnouncement(e.Current.ToString(), AutomaticRealTimeAnnouncementsBannerColor, AutomaticRealTimeAnnouncementsTextColor);
                                            RealTimeCurrentCount = RealTimeCurrentCount - 1;
                                        }
                                        else
                                        {
                                            AnnouncingRealTime = false;
                                            RealTimeCurrentCount = 0;
                                        }
                                    });
                                }
                                else timer.Once(AnnouncementDuration, () =>
                                {
                                    AnnouncingRealTime = false;
                                    RealTimeCurrentCount = 0;
                                });
                            });
                        }
                    }
                }
            }
        }

        void OnUserBanned(string id, string name, string IP, string reason)
        {
            if (!RestartCountdown)
            {
                if (PlayerBannedAnnouncementsEnabled && !MutingBans)
                    CreateAnnouncement(PlayerBannedAnnouncmentText.Replace("{playername}", name).Replace("{reason}", reason), PlayerBannedAnnouncementBannerColor, PlayerBannedAnnouncementTextColor);
            }
        }

        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (!RestartCountdown)
            {
                if (HelicopterSpawnAnnouncementEnabled && entity is PatrolHelicopter)
                    CreateAnnouncement(HelicopterSpawnAnnouncementText, HelicopterSpawnAnnouncementBannerColor, HelicopterSpawnAnnouncementTextColor);
                if (CH47SpawnAnnouncementsEnabled && entity is CH47Helicopter)
                {
                    CH47Helicopter CH47 = entity as CH47Helicopter;
                    timer.Once(0.5f, () =>
                    {
                        if (CH47.GetDriver()?.ShortPrefabName == "scientist_gunner")
                            CreateAnnouncement(CH47SpawnAnnouncementText, CH47SpawnAnnouncementBannerColor, CH47SpawnAnnouncementTextColor);
                    });
                }
                if (APCSpawnAnnouncementsEnabled && entity is BradleyAPC)
                    CreateAnnouncement(APCSpawnAnnouncementText, APCSpawnAnnouncementBannerColor, APCSpawnAnnouncementTextColor);
                if (CargoshipSpawnAnnouncementsEnabled && entity is CargoShip)
                    CreateAnnouncement(CargoshipSpawnAnnouncementText, CargoshipSpawnAnnouncementBannerColor, CargoshipSpawnAnnouncementTextColor);
                if (StockingRefillAnnouncementsEnabled && entity is XMasRefill)
                    CreateAnnouncement(StockingRefillAnnouncementText, StockingRefillAnnouncementBannerColor, StockingRefillAnnouncementTextColor);
            }
        }

        void OnEntityDeath(BaseCombatEntity entity)
        {
            if (!RestartCountdown)
            {
                if (entity is PatrolHelicopter)
                {
                    var entityNetID = entity.net.ID.Value;
                    if (HelicopterDespawnAnnouncementEnabled)
                        HeliNetIDs.Add(entityNetID);
                    if (HelicopterDestroyedAnnouncementEnabled)
                    {
                        if (HelicopterDestroyedAnnouncementWithDestroyer)
                        {
                            CreateAnnouncement(HelicopterDestroyedAnnouncementWithDestroyerText.Replace("{playername}", HeliLastHitPlayer), HelicopterDestroyedAnnouncementBannerColor, HelicopterDestroyedAnnouncementTextColor);
                            HeliLastHitPlayer = String.Empty;
                        }
                        else CreateAnnouncement(HelicopterDestroyedAnnouncementText, HelicopterDestroyedAnnouncementBannerColor, HelicopterDestroyedAnnouncementTextColor);
                    }
                }
                if (entity is CH47Helicopter)
                {
                    var entityNetID = entity.net.ID.Value;
                    if (CH47DespawnAnnouncementsEnabled)
                        CH47NetIDs.Add(entityNetID);
                    if (CH47DestroyedAnnouncementsEnabled)
                    {
                        if (CH47DestroyedAnnouncementsWithDestroyer)
                        {
                            CreateAnnouncement(CH47DestroyedAnnouncementWithDestroyerText.Replace("{playername}", CH47LastHitPlayer), CH47DestroyedAnnouncementBannerColor, CH47DestroyedAnnouncementTextColor);
                            CH47LastHitPlayer = String.Empty;
                        }
                        else CreateAnnouncement(CH47DestroyedAnnouncementText, CH47DestroyedAnnouncementBannerColor, CH47DestroyedAnnouncementTextColor);
                    }
                }
                if (APCDestroyedAnnouncementsEnabled && entity is BradleyAPC)
                {
                    if (APCDestroyedAnnouncementsWithDestroyer)
                    {
                        CreateAnnouncement(APCDestroyedAnnouncementWithDestroyerText.Replace("{playername}", APCLastHitPlayer), APCDestroyedAnnouncementBannerColor, APCDestroyedAnnouncementTextColor);
                        APCLastHitPlayer = String.Empty;
                    }
                    else CreateAnnouncement(APCDestroyedAnnouncementText, APCDestroyedAnnouncementBannerColor, APCDestroyedAnnouncementTextColor);
                }
                if (entity is BasePlayer && entity.net.connection != null)
                {
                    if (storedData.PlayerData.ContainsKey(entity.ToPlayer().userID))
                    {
                        storedData.PlayerData[entity.ToPlayer().userID].Dead = true;
                        SaveData();
                    }
                }
            }
        }

        void OnCargoShipEgress(CargoShip cargoship)
        {
            if (!RestartCountdown)
                if (CargoshipEgressAnnouncementsEnabled)
                    CreateAnnouncement(CargoshipEgressAnnouncementText, CargoshipEgressAnnouncementBannerColor, CargoshipEgressAnnouncementTextColor);
        }

        void OnEntityKill(BaseNetworkable entity)
        {
            if (!RestartCountdown)
            {
                if (entity is PatrolHelicopter)
                {
                    var entityNetID = entity.net.ID.Value;
                    timer.Once(2, () =>
                    {
                        if (HeliNetIDs.Contains(entityNetID))
                            HeliNetIDs.Remove(entityNetID);
                        else if (HelicopterDespawnAnnouncementEnabled)
                            CreateAnnouncement(HelicopterDespawnAnnouncementText, HelicopterDespawnAnnouncementBannerColor, HelicopterDespawnAnnouncementTextColor);
                    });
                }
                if (entity is CH47Helicopter)
                {
                    var entityNetID = entity.net.ID.Value;
                    timer.Once(2, () =>
                    {
                        if (CH47NetIDs.Contains(entityNetID))
                        {
                            CH47NetIDs.Remove(entityNetID);
                            KilledCH47NetIDs.Add(entityNetID);
                        }
                        else if (KilledCH47NetIDs.Contains(entityNetID))
                            KilledCH47NetIDs.Remove(entityNetID);
                        else if (CH47DespawnAnnouncementsEnabled)
                        {
                            KilledCH47NetIDs.Remove(entityNetID);
                            CreateAnnouncement(CH47DespawnAnnouncementText, CH47DespawnAnnouncementBannerColor, CH47DespawnAnnouncementTextColor);
                        }
                    });
                }
            }
        }

        void OnAirdrop(CargoPlane plane, Vector3 location)
        {
            if (!RestartCountdown)
            {
                timer.Once(0.5f, () =>
                {
                    if (AirdropAnnouncementsEnabled && !plane.dropped)
                    {
                        if (AirdropAnnouncementsLocation)
                            CreateAnnouncement(AirdropAnnouncementsTextWithGrid.Replace("{grid}", GetGrid(location)), AirdropAnnouncementsBannerColor, AirdropAnnouncementsTextColor);
                        else CreateAnnouncement(AirdropAnnouncementsText, AirdropAnnouncementsBannerColor, AirdropAnnouncementsTextColor);
                    }
                });
            }
        }

        void OnHelicopterDropCrate(CH47HelicopterAIController heli)
        {
            if (!RestartCountdown)
            {
                if (CH47CrateDroppedAnnouncementsEnabled && !CH47NetIDs.Contains(heli.net.ID.Value))
                {
                    if (CH47CrateDroppedAnnouncementsWithLocation)
                        CreateAnnouncement(CH47CrateDroppedAnnouncementTextWithGrid.Replace("{grid}", GetGrid(heli.GetDropPosition())), CH47CrateDroppedAnnouncementBannerColor, CH47CrateDroppedAnnouncementTextColor);
                    else CreateAnnouncement(CH47CrateDroppedAnnouncementText, CH47CrateDroppedAnnouncementBannerColor, CH47CrateDroppedAnnouncementTextColor);
                }
            }
        }

        void OnCrateHack(HackableLockedCrate crate)
        {
            if (!RestartCountdown)
            {
                if (CrateHackAnnouncementsEnabled)
                {
                    Vector3 cratePos = crate.transform.position;
                    float distance = Vector3Ex.Distance2D(CH47LandingZone.GetClosest(cratePos).transform.position, cratePos);
                    if (CrateHackSpecifyOilRig)
                    {
                        if (distance > 10.6f && distance < 12.6f)
                            CreateAnnouncement(CrateHackAnnouncementSmallOilRigText, CrateHackAnnouncementBannerColor, CrateHackAnnouncementTextColor);
                        if (distance > 40.6f && distance < 42.6f)
                            CreateAnnouncement(CrateHackAnnouncementLargeOilRigText, CrateHackAnnouncementBannerColor, CrateHackAnnouncementTextColor);
                    }
                    else if (distance < 50f)
                        CreateAnnouncement(CrateHackAnnouncementText, CrateHackAnnouncementBannerColor, CrateHackAnnouncementTextColor);
                }
            }
        }

        void WelcomeAnnouncement(BasePlayer player)
        {
            if (!RestartCountdown)
            {
                if (WelcomeAnnouncementsEnabled)
                {
                    timer.Once(WelcomeAnnouncementDelay, () =>
                    {
                        if (WelcomeBackAnnouncement && storedData.PlayerData[player.userID].TimesJoined > 1)
                            CreateAnnouncement(WelcomeBackAnnouncementText.Replace("{playername}", player.displayName).Replace("{playercount}", BasePlayer.activePlayerList.Count.ToString()), WelcomeAnnouncementBannerColor, WelcomeAnnouncementTextColor, player, isWelcomeAnnouncement: true);
                        else CreateAnnouncement(WelcomeAnnouncementText.Replace("{playername}", player.displayName).Replace("{playercount}", BasePlayer.activePlayerList.Count.ToString()), WelcomeAnnouncementBannerColor, WelcomeAnnouncementTextColor, player, isWelcomeAnnouncement: true);
                    });
                }
            }
        }

        void NewPlayerAnnouncements(BasePlayer player)
        {
            if (!RestartCountdown)
            {
                if (JustJoined.Contains(player.userID))
                    JustJoined.Remove(player.userID);
                List<string> AnnouncementList = new List<string>();
                if (NewPlayerAnnouncementsList.ContainsKey(storedData.PlayerData[player.userID].TimesJoined))
                    AnnouncementList = ConvertObjectListToString(NewPlayerAnnouncementsList[storedData.PlayerData[player.userID].TimesJoined]);
                else if (NewPlayerAnnouncementsList.ContainsKey(0))
                    AnnouncementList = ConvertObjectListToString(NewPlayerAnnouncementsList[0]);
                if (AnnouncementList.Count > 0)
                {
                    string Group = "";
                    if (permission.GetUserGroups(player.UserIDString)[0].ToLower() != "default")
                        Group = char.ToUpper(permission.GetUserGroups(player.UserIDString)[0][0]) + permission.GetUserGroups(player.UserIDString)[0].Substring(1);
                    IEnumerator<string> e = AnnouncementList.GetEnumerator();
                    if (storedData.PlayerData[player.userID].Dead == true && RespawnAnnouncementsEnabled)
                    {
                        PlayerRespawnedTimers[player] = timer.Once(AnnouncementDuration * AnnouncementList.Count, () => RespawnedAnnouncements(player));
                        storedData.PlayerData[player.userID].Dead = false;
                        SaveData();
                    }
                    if (e.MoveNext())
                    {
                        CreateAnnouncement(e.Current.Replace("{playername}", player.displayName).Replace("{rank}", Group), NewPlayerAnnouncementsBannerColor, NewPlayerAnnouncementsTextColor, player);
                        if (AnnouncementList.Count > 1)
                            NewPlayerPrivateTimers[player] = timer.Repeat(AnnouncementDuration, AnnouncementList.Count - 1, () =>
                            {
                                if (e.MoveNext())
                                    CreateAnnouncement(e.Current.Replace("{playername}", player.displayName).Replace("{rank}", Group), NewPlayerAnnouncementsBannerColor, NewPlayerAnnouncementsTextColor, player);
                            });
                    }
                }
            }
        }

        void RespawnedAnnouncements(BasePlayer player)
        {
            if (!RestartCountdown)
            {
                if (JustJoined.Contains(player.userID))
                    JustJoined.Remove(player.userID);
                List<string> ConvertRespawnAnnouncementsList = ConvertObjectListToString(RespawnAnnouncementsList);
                IEnumerator<string> e = ConvertRespawnAnnouncementsList.GetEnumerator();
                if (e.MoveNext())
                    CreateAnnouncement(e.Current.Replace("{playername}", player.displayName), RespawnAnnouncementsBannerColor, RespawnAnnouncementsTextColor, player);
                if (RespawnAnnouncementsList.Count > 1)
                    PlayerRespawnedTimers[player] = timer.Repeat(AnnouncementDuration, RespawnAnnouncementsList.Count - 1, () =>
                    {
                        if (e.MoveNext())
                            CreateAnnouncement(e.Current.Replace("{playername}", player.displayName), RespawnAnnouncementsBannerColor, RespawnAnnouncementsTextColor, player);
                    });
            }
        }

        void AutomaticTimedAnnouncements()
        {
            if (!RestartCountdown)
            {
                IEnumerator<string> e = ATALEnum.Current.GetEnumerator();
                if (e.MoveNext())
                    CreateAnnouncement(e.Current, AutomaticTimedAnnouncementsBannerColor, AutomaticTimedAnnouncementsTextColor);
                if (ATALEnum.Current.Count > 1)
                    timer.Repeat(AnnouncementDuration, ATALEnum.Current.Count - 1, () =>
                    {
                        if (e.MoveNext())
                            CreateAnnouncement(e.Current, AutomaticTimedAnnouncementsBannerColor, AutomaticTimedAnnouncementsTextColor);
                    });
            }
        }

        #endregion
        //============================================================================================================
        #region Commands

        void ConsoleCMDInput(ConsoleSystem.Arg inputter)
        {
            BasePlayer commander = (BasePlayer)inputter.Connection?.player;
            string cmd = inputter.cmd.Name, userID = inputter.Connection?.userid.ToString();
            string[] args = inputter.Args;
            CMDHandler(commander, cmd, args, true, inputter.IsAdmin, userID);
        }

        void CMDHandler(BasePlayer commander, string cmd, string[] args, bool isConsole = false, bool isAdmin = false, string userID = "")
        {
            if (userID == "" && !isConsole)
                userID = commander.UserIDString;
            if (isAdmin || commander.net.connection.authLevel > 0 || HasPermission(commander, PermAnnounce))
            {
                if (cmd == Lang("AnnouncementsCommandPrefix", userID))
                {
                    if (args?.Length != 0)
                    {
                        if (args?[0] == Lang("CommandSuffixAnnounceToPlayer", userID))
                        {
                            if (args?.Length > 2)
                                AnnounceToPlayer(commander, args, userID, isConsole);
                            else SendReply(commander, Lang("AnnounceToPlayerUsage", userID), isConsole); return;
                        }
                        if (args?[0] == Lang("CommandSuffixAnnounceToGroup", userID))
                        {
                            if (args?.Length > 2)
                                AnnounceToGroup(commander, args, isConsole);
                            else SendReply(commander, Lang("AnnounceToGroupUsage", userID), isConsole); return;
                        }
                    }
                    if (args?.Length > 0)
                    {
                        Announce(commander, args); return;
                    }
                    else SendReply(commander, Lang("AnnouncementsCommandPrefixUsage", userID), isConsole);
                }
                if (cmd == Lang("OperationsCommandPrefix", userID))
                {
                    if (args?.Length != 0)
                    {
                        if (args?[0] == Lang("CommandSuffixAnnouncementTest", userID))
                        {
                            AnnounceTest(commander, userID, isConsole); return;
                        }
                        if (args?[0] == Lang("CommandSuffixDestroyAnnouncement", userID))
                        {
                            DestroyAnnouncement(commander); return;
                        }
                        if (args?[0] == Lang("CommandSuffixMuteBans", userID))
                        {
                            MuteBans(commander, userID, isConsole); return;
                        }
                        if (args?[0] == Lang("CommandSuffixToggleAnnouncements", userID))
                        {
                            ToggleAnnouncements(commander, args, userID, isConsole); return;
                        }
                        if (args?[0] == Lang("CommandSuffixScheduleRestart", userID))
                        {
                            ScheduleRestart(commander, args, userID, isConsole); return;
                        }
                        if (args?[0] == Lang("CommandSuffixSuspendRestart", userID))
                        {
                            SuspendRestart(commander, userID, isConsole); return;
                        }
                        if (args?[0] == Lang("CommandSuffixResumeRestart", userID))
                        {
                            ResumeRestart(commander, userID, isConsole); return;
                        }
                        if (args?[0] == Lang("CommandSuffixGetNextRestart", userID))
                        {
                            GetNextRestart(commander, userID, isConsole); return;
                        }
                        if (args?[0] == Lang("CommandSuffixCancelScheduledRestart", userID))
                        {
                            CancelScheduledRestart(commander, userID, isConsole); return;
                        }
                        if (args?[0] == Lang("CommandSuffixHelp", userID))
                        {
                            SendReply(commander, Lang("AnnouncementsCommandPrefixUsage", userID), isConsole);
                            SendReply(commander, Lang("OperationsCommandPrefixUsage", userID), isConsole);
                            return;
                        }
                    }
                    SendReply(commander, Lang("OperationsCommandPrefixUsage", userID), isConsole); return;
                }
            }
            else if (cmd == Lang("OperationsCommandPrefix", userID))
            {
                if (args?.Length == 1 && args?[0] == Lang("CommandSuffixToggleAnnouncements", userID) && HasPermission(commander, PermAnnounceToggle) || Exclusions.ContainsKey(Convert.ToUInt64(userID)))
                {
                    ToggleAnnouncements(commander, args, userID, isConsole); return;
                }
                if (args?.Length == 1 && args?[0] == Lang("CommandSuffixGetNextRestart", userID) && HasPermission(commander, PermAnnounceGetNextRestart))
                {
                    GetNextRestart(commander, userID, isConsole); return;
                }
                if ((args?.Length == 1 && args?[0] == Lang("CommandSuffixHelp", userID) || args?.Length == 0) && (HasPermission(commander, PermAnnounceToggle) || HasPermission(commander, PermAnnounceGetNextRestart)))
                {
                    SendReply(commander, Lang("PlayerHelp", userID), isConsole); return;
                }
            }
            SendReply(commander, Lang("NoPermission", userID), isConsole);
        }

        void Announce(BasePlayer player, string[] args)
        {
            string Msg = "";
            for (int i = 0; i < args.Length; i++)
                Msg = Msg + " " + args[i];
            CreateAnnouncement(Msg, "Grey", "White");
        }

        void AnnounceToPlayer(BasePlayer player, string[] args, string userID, bool isConsole)
        {
            string targetPlayer = args[1].ToLower(), Msg = "";
            for (int i = 2; i < args.Length; i++)
                Msg = Msg + " " + args[i];
            BasePlayer targetedPlayer = FindPlayer(targetPlayer);
            if (targetedPlayer != null)
            {
                if (!Exclusions.ContainsKey(targetedPlayer.userID))
                    CreateAnnouncement(Msg, "Grey", "White", targetedPlayer);
                else SendReply(player, Lang("IsExcluded", userID).Replace("{playername}", targetedPlayer.displayName), isConsole);
            }
            else SendReply(player, Lang("PlayerNotFound", userID).Replace("{playername}", targetPlayer), isConsole);
        }

        void AnnounceToGroup(BasePlayer player, string[] args, bool isConsole)
        {
            string targetGroup = args[1].ToLower(), Msg = "";
            if (permission.GroupExists(targetGroup))
            {
                for (int i = 2; i < args.Length; i++)
                    Msg = Msg + " " + args[i];
                CreateAnnouncement(Msg, "Grey", "White", group: targetGroup);
            }
            else SendReply(player, Lang("GroupNotFound", player.UserIDString).Replace("{group}", targetGroup), isConsole);
        }

        void AnnounceTest(BasePlayer player, string userID, bool isConsole)
        {
            if (player?.net == null && isConsole)
                SendReply(player, Lang("RunTestAnnouncementFromInGame", userID), isConsole);
            else if (!Exclusions.ContainsKey(Convert.ToUInt64(userID)))
                CreateAnnouncement("GUIAnnouncements Test Announcement", TestAnnouncementBannerColor, TestAnnouncementsTextColor, player, isTestAnnouncement: true);
            else SendReply(player, Lang("YouAreExcluded", player.UserIDString), isConsole);
        }

        void DestroyAnnouncement(BasePlayer player)
        {
            DestroyAllGUI();
        }

        void MuteBans(BasePlayer player, string userID, bool isConsole)
        {
            if (MutingBans)
            {
                MutingBans = false;
                SendReply(player, Lang("BansUnmuted", userID), isConsole);
                return;
            }
            if (!MutingBans)
            {
                MutingBans = true;
                SendReply(player, Lang("BansMuted", userID), isConsole);
                return;
            }
        }

        void ToggleAnnouncements(BasePlayer player, string[] args, string userID, bool isConsole)
        {
            if (args.Length == 1) //Self
            {
                if (player?.net != null)
                {
                    if (Exclusions.ContainsKey(Convert.ToUInt64(userID))) //Include
                    {
                        Exclusions.Remove(Convert.ToUInt64(userID));
                        SendReply(player, Lang("IncludedTo", userID), isConsole);
                        return;
                    }
                    else //Exclude
                    {
                        Exclusions.Add(Convert.ToUInt64(userID), player.displayName);
                        SendReply(player, Lang("ExcludedTo", userID), isConsole);
                        return;
                    }
                }
                else SendReply(player, Lang("CannotExcludeServer", userID), isConsole);

            }
            if (args.Length > 1) //Not Self
            {
                string targetPlayer = args[1].ToLower();
                ulong targetPlayerUID64; ulong.TryParse(targetPlayer, out targetPlayerUID64);
                BasePlayer targetedPlayer = FindPlayer(targetPlayer);
                var GetKey = Exclusions.FirstOrDefault(x => x.Value.Contains(targetPlayer, CompareOptions.OrdinalIgnoreCase)).Key;
                if (Exclusions.ContainsKey(GetKey) || Exclusions.ContainsKey(targetPlayerUID64)) //Include
                {
                    string PlayerName = Exclusions[GetKey];
                    Exclusions.Remove(GetKey); Exclusions.Remove(targetPlayerUID64);
                    SendReply(player, Lang("Included", userID).Replace("{playername}", PlayerName), isConsole);
                    if (targetedPlayer != null)
                        SendReply(targetedPlayer, Lang("IncludedTo", targetedPlayer.UserIDString));
                }
                else if (targetedPlayer != null) //Exclude
                {
                    Exclusions.Add(targetedPlayer.userID, targetedPlayer.displayName);
                    SendReply(player, Lang("Excluded", userID).Replace("{playername}", targetedPlayer.displayName), isConsole);
                    SendReply(targetedPlayer, Lang("ExcludedTo", targetedPlayer.UserIDString));
                }
                else SendReply(player, Lang("PlayerNotFound", userID), isConsole);
            }
        }

        void ScheduleRestart(BasePlayer player, string[] args, string userID, bool isConsole)
        {
            if (args?.Length > 0)
            {
                if (!RestartCountdown)
                {
                    if (!RestartScheduled)
                    {
                        TimeSpan scheduleRestart;
                        var currentTime = DateTime.Now;
                        if (TimeSpan.TryParse(args[1], out scheduleRestart))
                        {
                            if (RestartAnnouncementsEnabled && currentTime.Add(scheduleRestart) > NextRestart)
                            {
                                SendReply(player, Lang("LaterThanNextRestart", userID).Replace("{time}", NextRestart.ToShortTimeString()), isConsole);
                                return;
                            }
                            if (args.Length > 2)
                            {
                                RestartReason = "";
                                for (int i = 2; i < args.Length; i++)
                                    RestartReason = RestartReason + " " + args[i];
                                if (player?.net != null && !isConsole)
                                    Puts(Lang("RestartScheduled").Replace("{time}", scheduleRestart.ToShortString()).Replace("{reason}", ":" + RestartReason));
                                SendReply(player, Lang("RestartScheduled", userID).Replace("{time}", scheduleRestart.ToShortString()).Replace("{reason}", ":" + RestartReason), isConsole);
                            }
                            else
                            {
                                if (player?.net != null && !isConsole)
                                    Puts(Lang("RestartScheduled").Replace("{time}", scheduleRestart.ToShortString()).Replace("{reason}", ""));
                                SendReply(player, Lang("RestartScheduled", userID).Replace("{time}", scheduleRestart.ToShortString()).Replace("{reason}", ""), isConsole);
                            }
                            RestartTimes.Add(currentTime.Add(scheduleRestart + new TimeSpan(00, 00, 01)));
                            ScheduledRestart = currentTime.Add(scheduleRestart + new TimeSpan(00, 00, 01));
                            RestartScheduled = true;
                            RestartJustScheduled = true;
                            if (!RestartAnnouncementsEnabled)
                                RestartAnnouncementsStart();
                            else GetNextRestart(RestartTimes);
                        }
                        else SendReply(player, Lang("ChatCommandScheduleRestartUsage", userID), isConsole);
                    }
                    else SendReply(player, Lang("RestartAlreadyScheduled", userID).Replace("{time}", NextRestart.ToShortTimeString()), isConsole);
                }
                else SendReply(player, Lang("ServerAboutToRestart", userID), isConsole);
            }
            else SendReply(player, Lang("ChatCommandScheduleRestartUsage", userID), isConsole);
        }

        void SuspendRestart(BasePlayer player, string userID, bool isConsole)
        {
            if (RestartScheduled)
            {
                if (!RestartSuspended)
                {
                    TimeSpan TimeLeft = NextRestart.Subtract(DateTime.Now);
                    if (SixtySecondsTimer != null && !SixtySecondsTimer.Destroyed && RestartCountdown)
                    {
                        SixtySecondsTimer.Destroy();
                        RestartCountdown = false;
                        CreateAnnouncement(RestartSuspendedAnnouncement.Replace("{time}", TimeLeft.Seconds.ToString() + " " + Lang("Seconds")), RestartAnnouncementsBannerColor, RestartAnnouncementsTextColor, isRestartAnnouncement: true);
                    }
                    RestartCountdown = false;
                    RestartSuspended = true;
                    SendReply(player, Lang("RestartSuspended", userID).Replace("{time}", NextRestart.ToLongTimeString()), isConsole);
                }
                else SendReply(player, Lang("RestartAlreadySuspended", userID).Replace("{time}", NextRestart.ToLongTimeString()), isConsole);
            }
            else SendReply(player, Lang("NoRestartToSuspend", userID), isConsole);
        }

        void ResumeRestart(BasePlayer player, string userID, bool isConsole)
        {
            if (RestartScheduled)
            {
                if (RestartSuspended)
                {
                    RestartSuspended = false;
                    SendReply(player, Lang("RestartResumed", userID).Replace("{time}", NextRestart.ToLongTimeString()), isConsole);
                }
                else SendReply(player, Lang("RestartNotSuspended", userID).Replace("{time}", NextRestart.ToLongTimeString()), isConsole);
            }
            else SendReply(player, Lang("NoRestartToResume", userID), isConsole);
        }

        void GetNextRestart(BasePlayer player, string userID, bool isConsole)
        {
            if (RestartScheduled)
            {
                var timeLeft = NextRestart.Subtract(DateTime.Now);
                SendReply(player, Lang("GetNextRestart", userID).Replace("{time1}", timeLeft.ToShortString()).Replace("{time2}", NextRestart.ToLongTimeString()), isConsole);
            }
            else SendReply(player, Lang("NoRestartScheduled", userID), isConsole);
        }

        void CancelScheduledRestart(BasePlayer player, string userID, bool isConsole)
        {
            if (RestartScheduled)
            {
                TimeSpan TimeLeft = NextRestart.Subtract(DateTime.Now);
                RestartReason = String.Empty;
                RestartTimes.Remove(ScheduledRestart);
                RestartScheduled = false;
                RestartSuspended = false;
                if (SixtySecondsTimer != null && !SixtySecondsTimer.Destroyed && RestartCountdown)
                {
                    SixtySecondsTimer.Destroy();
                    RestartCountdown = false;
                    CreateAnnouncement(RestartCancelledAnnouncement.Replace("{time}", TimeLeft.Seconds.ToString() + " " + Lang("Seconds")), RestartAnnouncementsBannerColor, RestartAnnouncementsTextColor, isRestartAnnouncement: true);
                }
                if (RestartAnnouncementsEnabled)
                    GetNextRestart(RestartTimes);
                else RestartScheduled = false;
                if (player?.net != null && !isConsole)
                    Puts(Lang("ScheduledRestartCancelled").Replace("{time}", ScheduledRestart.ToShortTimeString()));
                SendReply(player, (Lang("ScheduledRestartCancelled", userID).Replace("{time}", ScheduledRestart.ToShortTimeString())), isConsole);
            }
            else SendReply(player, Lang("RestartNotScheduled", userID), isConsole);
        }
#endregion
    }
}

// --- End of file: GUIAnnouncements.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/global-gamble ---
// --- Original File Path: G/GlobalGamble/GlobalGamble.cs ---

ï»¿using System.Collections.Generic;
using Newtonsoft.Json;
using System.Linq;
using System;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Global Gamble", "Trey", "1.2.2")]
    [Description("Gives every player currently online to enter X amount of scrap in to a gambling pot at the chance of winning everything.")]
    public class GlobalGamble : RustPlugin
    {
        #region Fields

        const string depositPerm = "globalgamble.deposit";
        const string gambleStartPerm = "globalgamble.start";

        private bool gambleActive;
        Timer remindActiveGamble;
        Timer initGlobalGamble;
        int currentScrapAmount;

        #endregion

        #region Data

        WinnerData _winnerCache;
        public class WinnerData
        {
            public List<string> WinnerList = new List<string>();
        }

        StandingDeposits standingDeposits;
        public class StandingDeposits
        {
            public Hash<string, double> Deposits = new Hash<string, double>();
        }

        #endregion

        #region Configuration

        Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Global Gamble Options")]
            public PluginOptions POptions = new PluginOptions();
        }

        public class PluginOptions
        {
            [JsonProperty(PropertyName = "Chat Command")]
            public string Ggccmd = "globalgamble";

            [JsonProperty(PropertyName = "Frequency of GlobalGamble(minutes)")]
            public float globalGambleTimer = 60;

            [JsonProperty(PropertyName = "Duration of Deposit Window(minutes)")]
            public float durationOfGamble = 10;

            [JsonProperty(PropertyName = "Remind Players of Active Gamble Every X Seconds")]
            public float remindEvery = 120;

            [JsonProperty(PropertyName = "Minimum Online Players")]
            public int minPlayer = 10;

            [JsonProperty(PropertyName = "Minimum Scrap Deposit")]
            public int minDeposit = 100;

            [JsonProperty(PropertyName = "Commission Permissions", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Hash<string, double> commissionPerms = new Hash<string, double>
            {
                {"globalgamble.default", 0.30 },
                {"globalgamble.vip1com", 0.25 },
                {"globalgamble.vip2com", 0.20 },
                {"globalgamble.vip3com", 0.15 },
                {"globalgamble.vip4com", 0.10 },
                {"globalgamble.vip5com", 0.05 },
            };

            [JsonProperty(PropertyName = "Wipe Total Earnings List")]
            public bool wipeEarnings = true;

            [JsonProperty(PropertyName = "Chat Icon (Steam64ID)")]
            public ulong chatIcon = 0;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) throw new Exception();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["AdminHelp"] = "<color=#C0C0C0><color=#66B2FF>/globalgamble deposit <amount></color> - This will deposit X amount of scrap in to the global pot.\n\n<color=#66B2FF>/globalgamble start</color> - This will begin a new global gamble.</color>",
                ["GambleAlreadyActive"] = "<color=#C0C0C0>There is already a gamble currently running, wait for it to end before starting another one.</color>!",
                ["GambleBegin"] = "<color=#C0C0C0>A new scrap gamble has started, type <color=#66B2FF>/globalgamble</color> to enter.</color>",
                ["GambleReminder"] = "<color=#C0C0C0>There is currently a scrap gamble occuring!, type <color=#66B2FF>/globalgamble</color> to read more info.</color>",
                ["IncorrectFormat"] = "<color=#C0C0C0>That wasn't a correct deposit statement. Example: <color=#66B2FF>/globalgamble deposit 150</color></color>",
                ["InsufficientFunds"] = "<color=#C0C0C0>You don't have <color=#66B2FF>{0} scrap</color> to deposit!</color>",
                ["MinimumDeposit"] = "<color=#C0C0C0>The minimum deposit to enter is <color=#66B2FF>{0} scrap</color>!",
                ["NewDeposit"] = "<color=#C0C0C0><color=#FF6666>{0}</color> has just deposited <color=#66B2FF>{1} scrap</color>, bringing the total pot to <color=#66B2FF>{2}</color>!</color>",
                ["NewWinner"] = "<color=#C0C0C0><color=#FF6666>{0}</color> is the winner of the scrap gamble, with a commission of <color=#66B2FF>{1}</color>, receiving a total of <color=#66B2FF>{2} scrap</color>!",
                ["NobodyPlayed"] = "<color=#C0C0C0>Nobody played in the gamble, so nobody won!</color>",
                ["NoPermission"] = "<color=#C0C0C0>You do not have permission to use this.</color>",
                ["NormalHelp"] = "<color=#C0C0C0><color=#66B2FF>/globalgamble deposit <amount></color> - This will deposit X amount of scrap in to the global pot.</color>",
                ["NotGambleTime"] = "<color=#C0C0C0>There are currently no scrap gambles occuring, try again later.</color>",
                ["Prefix"] = "<color=#FF6666>[Global Gamble]</color>",

            }, this);
        }

        #endregion

        #region Lottery Function

        public class GambleSystem
        {
            public class Ticket
            {
                public string Key;
                public double Weight;
                public Ticket(string key, double weight)
                {
                    Key = key;
                    Weight = weight;
                }
            }

            List<Ticket> tickets = new List<Ticket>();
            Hash<int, string> playerEntries = new Hash<int, string>();

            public void Add(string key, double weight)
            {
                tickets.Add(new Ticket(key, weight));
            }

            public string Draw()
            {
                int place = 1;
                foreach (Ticket playerEntry in tickets)
                {
                    for (var i = 0; i < playerEntry.Weight; i++)
                    {
                        playerEntries.Add(place++, playerEntry.Key);
                    }
                }

                int winnerPlace = UnityEngine.Random.Range(1, playerEntries.Count);
                string winnerId = playerEntries[winnerPlace];

                return winnerId;
            }
        }

        #endregion

        #region Core Methods

        private void OnServerInitialized()
        {
            permission.RegisterPermission(depositPerm, this);
            permission.RegisterPermission(gambleStartPerm, this);

            cmd.AddChatCommand(config.POptions.Ggccmd, this, "GlobalGambleChatCommand");

            foreach (KeyValuePair<string, double> commissionPerms in config.POptions.commissionPerms)
            {
                permission.RegisterPermission(commissionPerms.Key, this);
            }

            InitGambleTimer();

            gambleActive = false;
            currentScrapAmount = 0;

            standingDeposits = new StandingDeposits();
            _winnerCache = new WinnerData();
        }

        private void InitGambleTimer()
        {
            initGlobalGamble = timer.Repeat(config.POptions.globalGambleTimer * 60, 0, () => { BeginGamble(null); });
        }

        private void BeginGamble(BasePlayer player)
        {
            if (gambleActive)
            {
                if (player != null)
                {
                    PrintMsg(player, Lang("GambleAlreadyActive", player.UserIDString));
                    return;
                }
                return;
            }

            if (BasePlayer.activePlayerList.Count < config.POptions.minPlayer) return;

            foreach (BasePlayer players in BasePlayer.activePlayerList)
            {
                if (players == null) continue;

                PrintMsg(players, Lang("GambleBegin", players.UserIDString));
            }

            initGlobalGamble.Destroy();

            remindActiveGamble = timer.Repeat(config.POptions.remindEvery, 0, () => {

                foreach (BasePlayer players in BasePlayer.activePlayerList)
                {
                    if (players == null) continue;

                    PrintMsg(players, Lang("GambleReminder", players.UserIDString));
                }
            });

            timer.In(config.POptions.durationOfGamble * 60, () => { GetWinner(); });

            gambleActive = true;
        }

        private void ResetFields()
        {
            gambleActive = false;
            _winnerCache.WinnerList.Clear();
            standingDeposits.Deposits.Clear();
            currentScrapAmount = 0;
            remindActiveGamble.Destroy();
            InitGambleTimer();
        }

        private void GetWinner()
        {
            var lottery = new GambleSystem();

            if (standingDeposits.Deposits.Count == 0)
            {
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    if (player == null) continue;

                    PrintMsg(player, Lang("NobodyPlayed", player.UserIDString));
                    ResetFields();
                    return;
                }
            }

            foreach (KeyValuePair<string, double> playerEntries in standingDeposits.Deposits)
            {
                lottery.Add(playerEntries.Key, playerEntries.Value);
            }

            var winner = lottery.Draw();

            BasePlayer winnerPlayer = BasePlayer.FindAwakeOrSleeping(winner);

            AwardWinnerFunds(winnerPlayer, currentScrapAmount);
        }

        private void AwardWinnerFunds(BasePlayer winnerPlayer, double amt)
        {
            double commissionedAmt = amt * GetCommissionAmt(winnerPlayer.UserIDString);
            double finalAmt = amt - commissionedAmt;

            foreach (BasePlayer players in BasePlayer.activePlayerList)
            {
                if (players == null) continue;

                PrintMsg(players, Lang("NewWinner", players.UserIDString, winnerPlayer.displayName, GetCommissionAmt(winnerPlayer.UserIDString).ToString("P"), $"{finalAmt:###,###,###,###,###}"));
            }

            Item item = ItemManager.CreateByName("scrap", (int)finalAmt);

            item.MoveToContainer(winnerPlayer.inventory.containerMain);

            ResetFields();
        }

        private void AddDeposit(BasePlayer player, int amountDeposited)
        {
            standingDeposits.Deposits[player.UserIDString] += amountDeposited;

            foreach (BasePlayer players in BasePlayer.activePlayerList)
            {
                if (player == null) continue;

                PrintMsg(players, Lang("NewDeposit", players.UserIDString, player.displayName, $"{amountDeposited:###,###,###,###,###}", $"{GetCurrentDeposits():###,###,###,###,###}"));
            }

            currentScrapAmount += amountDeposited;
        }

        private double GetCurrentDeposits()
        {
            double currentDeposit = 0;

            foreach (KeyValuePair<string, double> deposits in standingDeposits.Deposits)
            {
                currentDeposit += deposits.Value;
            }

            return currentDeposit;
        }

        private double GetCommissionAmt(string playerID)
        {
            foreach (KeyValuePair<string, double> commisionamt in config.POptions.commissionPerms.OrderBy(cp => cp.Value))
            {
                if (permission.UserHasPermission(playerID, commisionamt.Key))
                {
                    return commisionamt.Value;
                }
            }

            return 0;
        }

        #endregion

        #region ChatCommands
        private void GlobalGambleChatCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, depositPerm))
            {
                PrintMsg(player, Lang("NoPermission", player.UserIDString));
                return;
            }

            if (args.Length == 0)
            {
                if (permission.UserHasPermission(player.UserIDString, gambleStartPerm))
                {
                    PrintMsg(player, Lang("AdminHelp", player.UserIDString));
                    return;
                }

                PrintMsg(player, Lang("NormalHelp", player.UserIDString));
            }

            if (args.Length > 0)
            {
                switch (args[0].ToLower())
                {
                    default:
                        {
                            if (permission.UserHasPermission(player.UserIDString, gambleStartPerm))
                            {
                                PrintMsg(player, Lang("AdminHelp", player.UserIDString));
                                return;
                            }

                            PrintMsg(player, Lang("NormalHelp", player.UserIDString));
                            return;
                        }

                    case "deposit":
                        {
                            var item = ItemManager.FindItemDefinition("scrap");
                            int amount;
                            bool success = int.TryParse(args[1], out amount);

                            if (!gambleActive)
                            {
                                PrintMsg(player, Lang("NotGambleTime", player.UserIDString));
                                return;
                            }

                            if (success)
                            {
                                if (amount < config.POptions.minDeposit)
                                {
                                    PrintMsg(player, Lang("MinimumDeposit", player.UserIDString, $"{config.POptions.minDeposit:###,###,###,###,###}"));
                                    return;
                                }

                                if (player.inventory.GetAmount(item.itemid) >= amount)
                                {
                                    player.inventory.Take(null, item.itemid, amount);
                                    AddDeposit(player, amount);
                                    return;
                                }

                                PrintMsg(player, Lang("InsufficientFunds", player.UserIDString, $"{amount:###,###,###,###,###}"));
                                return;
                            }

                            else
                            {
                                PrintMsg(player, Lang("IncorrectFormat", player.UserIDString));
                                return;
                            }
                        }

                    case "start":
                        {
                            if (!permission.UserHasPermission(player.UserIDString, gambleStartPerm))
                            {
                                PrintMsg(player, Lang("NoPermission", player.UserIDString));
                                return;
                            }

                            BeginGamble(null);
                            return;
                        }
                }
            }
        }

        #endregion

        #region Helpers

        private void PrintMsg(BasePlayer player, string message) => Player.Message(player, $"{Lang("Prefix", player.UserIDString)}\n\n{message}", config.POptions.chatIcon);

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion
    }
}



// --- End of file: GlobalGamble.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/guardian ---
// --- Original File Path: G/Guardian/Guardian.cs ---

using Facepunch;
using Facepunch.Math;
using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Rust;
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Guardian", "WhiteDragon", "1.7.9")]
    [Description("Protects the server from various annoyances, cheats, and macro attacks.")]
    class Guardian : CovalencePlugin
    {
        [PluginReference] private Plugin Friends, PlaytimeTracker;

        private static Guardian _instance;

        #region _action_queue_

        private class ActionQueue
        {
            private Queue<Action> actions;

            public ActionQueue(float interval)
            {
                actions = new Queue<Action>();

                Timers.Add(interval, () => Scan());
            }

            public void Clear() => actions.Clear();

            public void Enqueue(Action callback)
            {
                if(callback != null)
                {
                    actions.Enqueue(callback);
                }
            }

            private void Scan()
            {
                if(actions.Count > 0)
                {
                    actions.Dequeue()?.Invoke();
                }
            }
        }

        #endregion _action_queue_

        #region _admin_

        private class Admin
        {
            public class Settings
            {
                public bool Broadcast;
                public bool Bypass;

                public Settings()
                {
                    Broadcast = true;
                    Bypass    = true;
                }
            }
        }

        #endregion _admin_

        #region _anticheat_

        private class AntiCheat
        {
            public class Settings
            {
                public Aim.Settings        Aim;
                public FireRate.Settings   FireRate;
                public Gravity.Settings    Gravity;
                public MeleeRate.Settings  MeleeRate;
                public Recoil.Settings     Recoil;
                public Server.Settings     Server;
                public Stash.Settings      Stash;
                public Trajectory.Settings Trajectory;
                public WallHack.Settings   WallHack;

                public Settings()
                {
                    Aim        = new Aim.Settings();
                    FireRate   = new FireRate.Settings();
                    Gravity    = new Gravity.Settings();
                    MeleeRate  = new MeleeRate.Settings();
                    Recoil     = new Recoil.Settings();
                    Server     = new Server.Settings();
                    Stash      = new Stash.Settings();
                    Trajectory = new Trajectory.Settings();
                    WallHack   = new WallHack.Settings();
                }

                public void Validate()
                {
                    Configuration.Validate(ref Aim,        () => new Aim.Settings(), () => Aim.Validate());
                    Configuration.Validate(ref FireRate,   () => new FireRate.Settings());
                    Configuration.Validate(ref Gravity,    () => new Gravity.Settings());
                    Configuration.Validate(ref MeleeRate,  () => new MeleeRate.Settings());
                    Configuration.Validate(ref Recoil,     () => new Recoil.Settings());
                    Configuration.Validate(ref Server,     () => new Server.Settings());
                    Configuration.Validate(ref Stash,      () => new Stash.Settings());
                    Configuration.Validate(ref Trajectory, () => new Trajectory.Settings());
                    Configuration.Validate(ref WallHack,   () => new WallHack.Settings());
                }
            }

            private const Key category = Key.AntiCheat;

            private const float epsilon = 9.5367431640625E-7f;

            public static void Configure()
            {
                Aim.Configure();
                FireRate.Configure();
                Gravity.Configure();
                MeleeRate.Configure();
                Recoil.Configure();
                Server.Configure();
                Stash.Configure();
                Trajectory.Configure();
                WallHack.Configure();

                Gravity.Scan();
                Server.Scan();
            }

            public static void Unload()
            {
                Aim.Unload();
                FireRate.Unload();
                Gravity.Unload();
                MeleeRate.Unload();
                Recoil.Unload();
                Server.Unload();
                Stash.Unload();
                Trajectory.Unload();
                WallHack.Unload();
            }

            public class Aim
            {
                public class Settings
                {
                    public bool       Ban;
                    public ulong      Cooldown;
                    public bool       Enabled;
                    public float      Sensitivity;
                    public AimTrigger Trigger;
                    public bool       Warn;

                    public Settings()
                    {
                        Ban         = false;
                        Cooldown    = 300;
                        Enabled     = true;
                        Sensitivity = 0.5f;
                        Trigger     = new AimTrigger();
                        Warn        = true;
                    }

                    public class AimTrigger
                    {
                        public bool Animal;
                        public bool Bradley;
                        public bool Helicopter;
                        public bool NPC;
                    }

                    public void Validate()
                    {
                        Configuration.Validate(ref Trigger, () => new AimTrigger());
                    }
                    public Violation.Settings Validate(ulong max)
                    {
                        Configuration.Clamp(ref Cooldown,     1ul,  max);
                        Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                        return new Violation.Settings(Ban, Cooldown, Sensitivity, Warn);
                    }
                }

                private const Key type = Key.AntiCheatAim;

                private static readonly Violation violation = new Violation(category);

                private static float aim_distance;
                private static float headshot_scale;
                private static float hit_scale;
                private static float pvp_distance;

                private static float sensitivity_lo;
                private static float sensitivity_hi;

                private static float spin_angle;

                private static float swing_angle;

                private class History
                {
                    public HitArea      boneArea;
                    public Counter      headshot;
                    public Counter      hit;
                    public HashSet<int> hits;
                    public Counter      repeat;

                    private static readonly Dictionary<ulong, History> histories = new Dictionary<ulong, History>();

                    private History()
                    {
                        boneArea = 0;
                        headshot = new Counter();
                        hit      = new Counter();
                        hits     = new HashSet<int>();
                        repeat   = new Counter();
                    }

                    public static void Clear() => histories.Clear();

                    public static bool Contains(ulong userid) => histories.ContainsKey(userid);

                    public static History Get(ulong userid)
                    {
                        History history;

                        if(!histories.TryGetValue(userid, out history))
                        {
                            histories.Add(userid, history = new History());
                        }

                        return history;
                    }
                }

                public static void Configure()
                {
                    var settings = config.AntiCheat.Aim.Validate(900);

                    violation.Configure(settings, 2, 8, 900000);

                    aim_distance   =  6.00f + ( 6.0f * (1.0f - settings.Sensitivity));
                    headshot_scale =  1.50f +                  settings.Sensitivity;
                    hit_scale      =  0.25f +                  settings.Sensitivity;
                    pvp_distance   = 12.00f + (12.0f * (1.0f - settings.Sensitivity));
                    sensitivity_lo = -0.50f + ( 0.5f *         settings.Sensitivity);
                    sensitivity_hi = -1.00f - ( 0.5f * (1.0f - settings.Sensitivity));
                    spin_angle     = 35.00f + (35.0f * (1.0f - settings.Sensitivity));
                    swing_angle    = 10.00f + (10.0f * (1.0f - settings.Sensitivity));
                }

                public static void Trigger(BaseEntity entity, HitInfo info)
                {
                    var player = info.InitiatorPlayer;

                    if(Permissions.Bypass.AntiCheat.Aim(player.userID))
                    {
                        return;
                    }

                    var weapon = Weapon.Get(player.userID, info.ProjectileID);

                    if(weapon == null)
                    {
                        return;
                    }

                    _instance.NextTick(() =>
                    {
                        var position = info.HitPositionWorld;

                        var distance = Vector3.Distance(position, weapon.Position);

                        bool can_trigger = false, hit_location = true, pvp = false;

                        string target;

                        switch(Entity.GetType(entity, out target))
                        {
                        case Entity.Type.Animal:
                        case Entity.Type.Bear:
                        case Entity.Type.Boar:
                        case Entity.Type.Chicken:
                        case Entity.Type.Stag:       can_trigger = config.AntiCheat.Aim.Trigger.Animal; break;
                        case Entity.Type.Bradley:    can_trigger = config.AntiCheat.Aim.Trigger.Bradley; break;
                        case Entity.Type.Helicopter: can_trigger = config.AntiCheat.Aim.Trigger.Helicopter; break;
                        case Entity.Type.Bot:
                        case Entity.Type.Murderer:
                        case Entity.Type.NPC:
                        case Entity.Type.Scientist:  can_trigger = config.AntiCheat.Aim.Trigger.NPC; break;
                        case Entity.Type.Player:     can_trigger = pvp = true; break;
                        default:
                            hit_location = false; break;
                        }

                        if(can_trigger)
                        {
                            can_trigger = Entity.Health.Changed(entity);
                        }

                        var history = History.Get(player.userID);

                        if(hit_location)
                        {
                            if(info.boneArea == 0)
                            {
                                history.repeat.Decrement();
                            }
                            else
                            {
                                if(info.boneArea == history.boneArea)
                                {
                                    history.repeat.Increment();
                                }
                                else
                                {
                                    history.repeat.Decrement();
                                }
                            }

                            history.boneArea = info.boneArea;

                            if(pvp && (distance > pvp_distance))
                            {
                                if(history.boneArea == HitArea.Head)
                                {
                                    history.headshot.Increment();
                                }
                                else
                                {
                                    history.headshot.Decrement();
                                }
                            }
                        }

                        var range_modifier = (1.0f - (0.25f * history.repeat.Ratio())) * (1.0f - (0.025f * weapon.Speed));

                        var range_variance = 1.0f - (distance / (weapon.Range * range_modifier));

                        var angle = Vector3.Angle(weapon.AimAngle, info.ProjectileVelocity);

                        var angle_drop_off = 12.0f / (4.0f - (weapon.Range / weapon.Velocity));

                        var angle_variance = weapon.Accuracy - (angle / (angle_drop_off + weapon.AimCone));

                        var pvp_variance = weapon.Accuracy - (history.headshot.Ratio(headshot_scale) + history.hit.Ratio(hit_scale));

                        var deflection = false;

                        var violations = 0ul;

                        if(hit_location && (distance > aim_distance) && (can_trigger || (angle > spin_angle)))
                        {
                            history.hits.Add(info.ProjectileID);

                            if(range_variance < sensitivity_lo)
                            {
                                if(violation.Trigger(player.userID))
                                {
                                    ++violations;
                                }
                                else if((range_variance < sensitivity_hi) && violation.Trigger(player.userID))
                                {
                                    ++violations;
                                }
                            }

                            if(angle_variance < sensitivity_lo)
                            {
                                BasePlayer.FiredProjectile projectile;

                                if(player.firedProjectiles.TryGetValue(info.ProjectileID, out projectile))
                                {
                                    deflection = (projectile.ricochets > 0);
                                }

                                if(!deflection)
                                {
                                    var deflectors = Pool.GetList<BaseEntity>();

                                    Vis.Entities(position, aim_distance, deflectors);

                                    var d_squared = distance * distance;

                                    foreach(var deflector in deflectors)
                                    {
                                        if(deflector.SqrDistance(weapon.Position) < d_squared)
                                        {
                                            deflection = true;

                                            break;
                                        }
                                    }

                                    Pool.FreeList(ref deflectors);
                                }

                                if(!deflection || (angle > spin_angle))
                                {
                                    if(violation.Trigger(player.userID))
                                    {
                                        ++violations;
                                    }
                                    else if((angle_variance < sensitivity_hi) && violation.Trigger(player.userID))
                                    {
                                        ++violations;
                                    }

                                    if((angle > spin_angle) && violation.Trigger(player.userID))
                                    {
                                        ++violations;
                                    }
                                }
                            }

                            if(pvp && (distance > pvp_distance) && (pvp_variance < sensitivity_lo))
                            {
                                if(violation.Trigger(player.userID))
                                {
                                    ++violations;
                                }
                                else if((pvp_variance < sensitivity_hi) && violation.Trigger(player.userID))
                                {
                                    ++violations;
                                }
                            }

                            if((violations > 2) && (angle <= spin_angle))
                            {
                                violations = 2;
                            }
                        }

                        var bodypart = Text.BodyPart(info.boneArea);

                        if(config.Log.AntiCheat.Aim)
                        {
                            Log.Console(Key.LogAntiCheatAim, new Dictionary<string, string>
                            {
                                { "angle_variance", angle_variance.ToString("F6") },
                                { "bodypart", bodypart },
                                { "distance", distance.ToString("F1") },
                                { "playerid", player.UserIDString },
                                { "playername", Text.Sanitize(player.displayName) },
                                { "pvp_variance", pvp_variance.ToString("F6") },
                                { "range_variance", range_variance.ToString("F6") },
                                { "speed", weapon.Speed.ToString("F1") },
                                { "target", target },
                                { "weapon", $"{weapon.Name}{(deflection ? " (deflection)" : string.Empty)}" }
                            });
                        }

                        Projectile.Log.SetAim(player.userID, info.ProjectileID, angle_variance, pvp_variance, range_variance, pvp, deflection);

                        Projectile.Log.SetVictim(player.userID, info.ProjectileID, target);

                        Projectile.Log.SetHit(player.userID, info.ProjectileID, distance, info.boneArea);

                        if(config.AntiCheat.Aim.Enabled && (violations > 0))
                        {
                            Projectile.Log.SetAimViolations(player.userID, info.ProjectileID, violations);

                            var hit_angle = angle.ToString("F1");
                            var hit_distance = distance.ToString("F1");

                            violation.Trigger(player.userID, type, Text.GetPlain(Key.ViolationAim, new Dictionary<string, string>
                            {
                                { "angle", hit_angle },
                                { "bodypart", bodypart },
                                { "distance", hit_distance },
                                { "target", target },
                                { "weapon", weapon.Name }
                            }), violations, false, new Dictionary<string, string>
                            {
                                { "headshot_percent", history.headshot.Percent().ToString() },
                                { "hip_fire", (weapon.Zoom == 1.0f).ToString() },
                                { "hit_angle", hit_angle },
                                { "hit_area", Text.BodyPart(info.boneArea, "en") },
                                { "hit_distance", hit_distance },
                                { "hit_percent", history.hit.Percent().ToString() },
                                { "movement_speed", weapon.Speed.ToString("F1") },
                                { "projectile_id", info.ProjectileID.ToString() },
                                { "ricochet", deflection.ToString() },
                                { "swing_angle", "0.0" },
                                { "violation_id", weapon.Fired.Ticks.ToString() },
                                { "weapon_ammo", weapon.AmmoName },
                                { "weapon_attachments", string.Join(", ", weapon.Attachments) },
                                { "weapon_type", weapon.ShortName }
                            });
                        }
                    });
                }

                public static void Unload()
                {
                    History.Clear();

                    violation.Clear();
                }

                public static void Update(Weapon weapon)
                {
                    var player = weapon.Player;

                    if(!History.Contains(player.userID))
                    {
                        return;
                    }

                    var history = History.Get(player.userID);

                    foreach(var entry in weapon.Projectiles)
                    {
                        if(history.hits.Contains(entry))
                        {
                            history.hits.Remove(entry);

                            history.hit.Increment();

                            var angle = weapon.Swing;

                            if(config.AntiCheat.Aim.Enabled && (angle > swing_angle) && Projectile.Log.GetAimPvp(player.userID, entry))
                            {
                                var distance = Projectile.Log.GetHitDistance(player.userID, entry);
                                if(distance > pvp_distance)
                                {
                                    if(violation.Trigger(player.userID))
                                    {
                                        Projectile.Log.SetAimViolations(player.userID, entry, 1ul, true);

                                        var hit_angle    = Projectile.Log.GetAimAngle(player.userID, entry).ToString("F1");
                                        var hit_area     = Projectile.Log.GetHitLocation(player.userID, entry);
                                        var hit_distance = distance.ToString("F1");
                                        var swing_angle  = angle.ToString("F1");

                                        violation.Trigger(player.userID, type, Text.GetPlain(Key.ViolationAim, new Dictionary<string, string>
                                        {
                                            { "angle", $"{hit_angle}-{swing_angle}" },
                                            { "bodypart", Text.BodyPart(hit_area) },
                                            { "distance", hit_distance },
                                            { "target", Projectile.Log.GetVictim(player.userID, entry) },
                                            { "weapon", weapon.Name }
                                        }), 1ul, false, new Dictionary<string, string>
                                        {
                                            { "headshot_percent", history.headshot.Percent().ToString() },
                                            { "hip_fire", (weapon.Zoom == 1.0f).ToString() },
                                            { "hit_angle", hit_angle },
                                            { "hit_area", Text.BodyPart(hit_area, "en") },
                                            { "hit_distance", hit_distance },
                                            { "hit_percent", history.hit.Percent().ToString() },
                                            { "movement_speed", weapon.Speed.ToString("F1") },
                                            { "projectile_id", entry.ToString() },
                                            { "ricochet", Projectile.Log.GetRicochet(player.userID, entry).ToString() },
                                            { "swing_angle", swing_angle },
                                            { "violation_id", weapon.Fired.Ticks.ToString() },
                                            { "weapon_ammo", weapon.AmmoName },
                                            { "weapon_attachments", string.Join(", ", weapon.Attachments) },
                                            { "weapon_type", weapon.ShortName }
                                        });
                                    }
                                }
                            }
                        }
                        else
                        {
                            history.hit.Decrement();
                        }
                    }
                }
            }

            public class FireRate
            {
                public class Settings
                {
                    public bool  Ban;
                    public ulong Cooldown;
                    public bool  Enabled;
                    public float Sensitivity;
                    public bool  Warn;

                    public Settings()
                    {
                        Ban         = false;
                        Cooldown    = 10;
                        Enabled     = true;
                        Sensitivity = 0.5f;
                        Warn        = true;
                    }

                    public Violation.Settings Validate(ulong max)
                    {
                        Configuration.Clamp(ref Cooldown,     1ul,  max);
                        Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                        return new Violation.Settings(Ban, Cooldown, Sensitivity, Warn);
                    }
                }

                private const Key type = Key.AntiCheatFireRate;

                private static readonly Violation violation = new Violation(category);

                private static float sensitivity;

                private class History
                {
                    public int      entity;
                    public DateTime fired;
                    public float    repeat;

                    private static readonly Dictionary<ulong, History> histories = new Dictionary<ulong, History>();

                    private History()
                    {
                        entity = 0;
                        fired  = DateTime.MinValue;
                        repeat = 10.0f;
                    }

                    public static void Clear() => histories.Clear();

                    public static History Get(ulong userid)
                    {
                        History history;

                        if(!histories.TryGetValue(userid, out history))
                        {
                            histories.Add(userid, history = new History());
                        }

                        return history;
                    }
                }

                public static void Configure()
                {
                    var settings = config.AntiCheat.FireRate.Validate(30);

                    violation.Configure(settings, 2, 8, 5000);

                    sensitivity = 0.3f + (0.3f * settings.Sensitivity);
                }

                private static uint Percent(float min, float delay, float max) =>
                    (uint)(100.0f * (max - delay) / (max - min));

                public static void Trigger(BaseEntity entity, HitInfo info)
                {
                    var player = info.InitiatorPlayer;

                    if(Permissions.Bypass.AntiCheat.FireRate(player.userID))
                    {
                        return;
                    }

                    var weapon = Weapon.Get(player.userID, info.ProjectileID);

                    if(weapon == null)
                    {
                        return;
                    }

                    _instance.NextTick(() =>
                    {
                        var current = entity.GetInstanceID();
                        var history = History.Get(player.userID);

                        if((weapon.Repeat == history.repeat) && (current == history.entity))
                        {
                            var delay = (float)weapon.Fired.Subtract(history.fired).TotalSeconds;

                            var max = weapon.Repeat * sensitivity;
                            var min = max * 0.1f;

                            if(config.AntiCheat.FireRate.Enabled && (min <= delay) && (delay <= max) && violation.Trigger(player.userID))
                            {
                                Projectile.Log.SetFireRateViolations(player.userID, info.ProjectileID, 1);

                                var attack_rate = delay.ToString("F3");

                                violation.Trigger(player.userID, type, Text.GetPlain(Key.ViolationFireRate, new Dictionary<string, string>
                                {
                                    { "delay", attack_rate },
                                    { "weapon", weapon.Name }
                                }), false, new Dictionary<string, string>
                                {
                                    { "attack_rate", attack_rate },
                                    { "movement_speed", weapon.Speed.ToString("F1") },
                                    { "projectile_id", info.ProjectileID.ToString() },
                                    { "rate_percent", Percent(min, delay, max).ToString() },
                                    { "violation_id", weapon.Fired.Ticks.ToString() },
                                    { "weapon_ammo", weapon.AmmoName },
                                    { "weapon_attachments", string.Join(", ", weapon.Attachments) },
                                    { "weapon_type", weapon.ShortName }
                                });
                            }
                        }

                        history.entity = current;
                        history.fired = weapon.Fired;
                        history.repeat = weapon.Repeat;
                    });
                }

                public static void Unload()
                {
                    History.Clear();

                    violation.Clear();
                }
            }

            public class Gravity
            {
                public class Settings
                {
                    public bool  Ban;
                    public ulong Cooldown;
                    public bool  Enabled;
                    public float Sensitivity;
                    public bool  Warn;

                    public Settings()
                    {
                        Ban         = false;
                        Cooldown    = 10;
                        Enabled     = true;
                        Sensitivity = 0.5f;
                        Warn        = true;
                    }

                    public Violation.Settings Validate(ulong max)
                    {
                        Configuration.Clamp(ref Cooldown,     1ul,  max);
                        Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                        return new Violation.Settings(Ban, Cooldown, Sensitivity, Warn);
                    }
                }

                private const Key type = Key.AntiCheatGravity;

                private static readonly Violation violation = new Violation(category);

                private static float sensitivity_lo;
                private static float sensitivity_md;
                private static float sensitivity_hi;

                private class History
                {
                    private static readonly Dictionary<ulong, float> histories = new Dictionary<ulong, float>();

                    public static void Clear() => histories.Clear();

                    public static float Set(ulong userid, float new_value)
                    {
                        float old_value;

                        if(!histories.TryGetValue(userid, out old_value))
                        {
                            histories.Add(userid, new_value);

                            return float.MaxValue;
                        }

                        histories[userid] = new_value;

                        return old_value;
                    }
                }

                public static void Configure()
                {
                    var settings = config.AntiCheat.Gravity.Validate(30);

                    violation.Configure(settings, 2, 8, 500);

                    sensitivity_lo = 1.55f + 1.5f * (1.0f - settings.Sensitivity);
                    sensitivity_md = sensitivity_lo * 2.0f;
                    sensitivity_hi = sensitivity_md * 2.0f;
                }

                private static bool Check(BasePlayer player)
                {
                    var position = player.transform.position; position.y += 0.05f;

                    if((History.Set(player.userID, position.y) >= position.y) || player.HasParent())
                    {
                        return false;
                    }
                    else if(Physics.Raycast(position, Vector3.down, sensitivity_md))
                    {
                        return false;
                    }
                    else if(position.y <= (Map.Terrain.Height(position) + sensitivity_lo))
                    {
                        return false;
                    }

                    bool flying = true;

                    var entities = Pool.GetList<BaseEntity>();

                    Vis.Entities(position, sensitivity_hi, entities);

                    foreach(var entity in entities)
                    {
                        if(player.IsStandingOnEntity(entity, -1))
                        {
                            flying = false; break;
                        }

                        switch(entity.ShortPrefabName)
                        {
                        case "cave_lift":
                        case "elevator_lift":
                        case "floor.ladder.hatch":
                        case "floor.triangle.ladder.hatch":
                        case "hopperoutput":
                        case "miningquarry":
                        case "miningquarry_static":
                        case "watchtower.wood":

                            if(player.Distance(entity.bounds.ClosestPoint(position)) <= sensitivity_lo)
                            {
                                flying = false;
                            }

                            break;

                        default:

                            if((entity is BaseVehicle) || (entity is BaseVehicleSeat))
                            {
                                if(player.Distance(entity.bounds.ClosestPoint(position)) <= sensitivity_lo)
                                {
                                    flying = false;
                                }
                            }
                            else if(entity.ShortPrefabName == "ladder.wooden.wall")
                            {
                                if(player.Distance(entity.bounds.ClosestPoint(position)) <= sensitivity_md)
                                {
                                    flying = false;
                                }
                            }
                            else if((entity is BaseHelicopterVehicle) || (entity is SupplyDrop) || (entity is TreeEntity))
                            {
                                flying = false;
                            }
                            else
                            {
                                var top = entity.bounds.max.y;

                                if((position.y >= top) && ((position.y - top) <= sensitivity_lo))
                                {
                                    var bot = new Vector3(position.x, position.y - sensitivity_lo, position.z);

                                    if(Physics.CheckCapsule(position, bot, 0.25f))
                                    {
                                        flying = false;
                                    }
                                }
                            }

                            break;
                        }

                        if(!flying)
                        {
                            break;
                        }
                    }

                    if(flying && (entities.Count == 0) && Vis.AnyColliders(position, sensitivity_lo))
                    {
                        flying = false;
                    }

                    Pool.FreeList(ref entities);

                    return flying;
                }

                public static void Scan()
                {
                    Timers.Add(1.0f, () =>
                    {
                        if(config.AntiCheat.Gravity.Enabled)
                        {
                            foreach(var player in BasePlayer.activePlayerList)
                            {
                                if(User.ShouldIgnore(player) || User.CanFly(player))
                                {
                                    continue;
                                }

                                if(player.isMounted || player.HasParent() || player.IsSwimming() || player.IsOnGround())
                                {
                                    continue;
                                }

                                var position = player.transform.position;

                                if(Map.Water.IsSurface(position) && !Map.Monument.IsNearby(position) && !Map.Entities.InRange(position))
                                {
                                    if((History.Set(player.userID, position.y) <= position.y))
                                    {
                                        Trigger(player, position.y, true);
                                    }
                                }
                            }
                        }
                    });
                }

                public static void Trigger(BasePlayer player, float amount, bool scanned = false)
                {
                    if(Permissions.Bypass.AntiCheat.Gravity(player.userID))
                    {
                        return;
                    }

                    if(config.Log.AntiCheat.Gravity)
                    {
                        var position = player.transform.position;

                        Log.Console(Key.LogAntiCheatGravity, new Dictionary<string, string>
                        {
                            { "amount", amount.ToString("F6") },
                            { "playerid", player.UserIDString },
                            { "playername", Text.Sanitize(player.displayName) },
                            { "position", $"({(int)position.x},{(int)position.y},{(int)position.z})" }
                        });
                    }

                    if(config.AntiCheat.Gravity.Enabled && (scanned || Check(player)) && violation.Trigger(player.userID))
                    {
                        violation.Trigger(player.userID, type, Text.GetPlain(Key.ViolationGravity, new Dictionary<string, string>
                        {
                            { "amount", amount.ToString("F6") }
                        }), false, new Dictionary<string, string>
                        {
                            { "elevation", player.transform.position.y.ToString("F1") },
                            { "movement_speed", player.estimatedSpeed.ToString("F1") },
                            { "violation_id", DateTime.UtcNow.Ticks.ToString() }
                        });
                    }
                }

                public static void Unload()
                {
                    History.Clear();

                    violation.Clear();
                }
            }

            public class MeleeRate
            {
                public class Settings
                {
                    public bool  Ban;
                    public ulong Cooldown;
                    public bool  Enabled;
                    public float Sensitivity;
                    public bool  Warn;

                    public Settings()
                    {
                        Ban         = false;
                        Cooldown    = 300;
                        Enabled     = true;
                        Sensitivity = 0.5f;
                        Warn        = true;
                    }

                    public Violation.Settings Validate(ulong max)
                    {
                        Configuration.Clamp(ref Cooldown,     1ul,  max);
                        Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                        return new Violation.Settings(Ban, Cooldown, Sensitivity, Warn);
                    }
                }

                private const Key type = Key.AntiCheatMeleeRate;

                private static readonly Violation violation = new Violation(category);

                private static float sensitivity;

                private class History
                {
                    private static readonly Dictionary<ulong, DateTime> histories = new Dictionary<ulong, DateTime>();

                    public static void Clear() => histories.Clear();

                    public static float Set(ulong userid, DateTime new_value)
                    {
                        DateTime old_value;

                        if(!histories.TryGetValue(userid, out old_value))
                        {
                            histories.Add(userid, new_value);

                            return float.MaxValue;
                        }

                        histories[userid] = new_value;

                        return (float)new_value.Subtract(old_value).TotalSeconds;
                    }
                }

                public static void Configure()
                {
                    var settings = config.AntiCheat.MeleeRate.Validate(900);

                    violation.Configure(settings, 2, 8, 15000);

                    sensitivity = 0.4f + (0.3f * settings.Sensitivity);
                }

                private static uint Percent(float delay, float max) =>
                    (uint)(100.0f * (max - delay) / max);

                public static void Trigger(BasePlayer player, HitInfo info)
                {
                    if(Permissions.Bypass.AntiCheat.MeleeRate(player.userID))
                    {
                        return;
                    }

                    BaseMelee melee = info?.Weapon?.GetComponent<BaseMelee>();

                    if(melee == null)
                    {
                        return;
                    }

                    var item = info.Weapon.GetItem();

                    if(item == null)
                    {
                        return;
                    }

                    var current = DateTime.UtcNow;

                    _instance.NextTick(() =>
                    {
                        var itemid = item.info.itemid;

                        var delay = History.Set(player.userID, current);

                        string target = Entity.GetName(info.HitEntity);

                        var weapon = item.info.displayName.translated ?? "null";

                        if(config.Log.AntiCheat.MeleeRate)
                        {
                            var delay_string = (delay >= (melee.repeatDelay * 2.0f)) ? Text.Get(Key.idle) : $"{delay:0.00}{Text.Get(Key.DurationSecondsUnit)}";

                            Log.Console(Key.LogAntiCheatMeleeRate, new Dictionary<string, string>
                            {
                                { "delay", delay_string },
                                { "playerid", player.UserIDString },
                                { "playername", Text.Sanitize(player.displayName) },
                                { "target", target },
                                { "weapon", weapon }
                            });
                        }

                        var chainsaw   = (itemid == 1104520648);
                        var jackhammer = (itemid == 1488979457);

                        var max = melee.repeatDelay * sensitivity;

                        if((delay <= max) && !(jackhammer || chainsaw))
                        {
                            if(config.AntiCheat.MeleeRate.Enabled && violation.Trigger(player.userID))
                            {
                                var attack_rate = delay.ToString("F3");

                                violation.Trigger(player.userID, type, Text.GetPlain(Key.ViolationMeleeRate, new Dictionary<string, string>
                                {
                                    { "delay", attack_rate},
                                    { "target", target },
                                    { "weapon", weapon }
                                }), false, new Dictionary<string, string>
                                {
                                    { "attack_rate", attack_rate },
                                    { "movement_speed", player.estimatedSpeed.ToString("F1") },
                                    { "rate_percent", Percent(delay, max).ToString() },
                                    { "violation_id", DateTime.UtcNow.Ticks.ToString() },
                                    { "weapon_type", item.info.shortname }
                                });
                            }
                        }
                    });
                }

                public static void Unload()
                {
                    History.Clear();

                    violation.Clear();
                }
            }

            public class Recoil
            {
                public class Settings
                {
                    public bool  Ban;
                    public ulong Cooldown;
                    public bool  Enabled;
                    public float Sensitivity;
                    public bool  Warn;

                    public Settings()
                    {
                        Ban         = false;
                        Cooldown    = 10;
                        Enabled     = true;
                        Sensitivity = 0.5f;
                        Warn        = true;
                    }

                    public Violation.Settings Validate(ulong max)
                    {
                        Configuration.Clamp(ref Cooldown,     1ul,  max);
                        Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                        return new Violation.Settings(Ban, Cooldown, Sensitivity, Warn);
                    }
                }

                private const float latency_min = 0.075f;
                private const float latency_max = 0.175f;

                private const float recoil_max   = 9.765625e-4f;
                private const float recoil_range = recoil_max - epsilon;
                private const float recoil_scale = 100.0f / recoil_range;

                private const float repeat_interval = 1.25f;

                private const Key type = Key.AntiCheatRecoil;

                private static readonly Violation violation = new Violation(category);

                private static ulong reset_limit;
                private static float sensitivity;

                private class History
                {
                    public Counter  count_r;
                    public Counter  count_x;
                    public Counter  count_y;
                    public DateTime fired;
                    public ulong    repeats;

                    private static readonly Dictionary<ulong, History> histories = new Dictionary<ulong, History>();

                    private History()
                    {
                        count_r = new Counter();
                        count_x = new Counter();
                        count_y = new Counter();
                        fired   = DateTime.MinValue;
                        repeats = 0;
                    }

                    public static void Clear() => histories.Clear();

                    public static History Get(BasePlayer player)
                    {
                        History history;

                        if(!histories.TryGetValue(player.userID, out history))
                        {
                            histories.Add(player.userID, history = new History());
                        }

                        return history;
                    }
                }

                public static void Configure()
                {
                    var settings = config.AntiCheat.Recoil.Validate(30);

                    violation.Configure(settings, 2, 8, 1000);

                    reset_limit = settings.Count(12, 20);

                    sensitivity = 0.00001f + (0.00009f * settings.Sensitivity);
                }

                private static float Latency(BasePlayer player, Weapon weapon)
                {
                    var connection = player?.net?.connection;

                    var latency = 0.0f;

                    if(connection != null)
                    {
                        latency = 0.001f * (Net.sv.GetAveragePing(connection) >> 1);
                    }

                    if(latency < weapon.Repeat)
                    {
                        latency = weapon.Repeat;
                    }

                    return Generic.Clamp(latency, latency_min, latency_max);
                }

                private static uint Percent(float value) =>
                    (uint)((recoil_range - Generic.Clamp(value, epsilon, recoil_max)) * recoil_scale);

                public static void Trigger(BasePlayer player, Weapon weapon)
                {
                    if(Permissions.Bypass.AntiCheat.Recoil(player.userID))
                    {
                        return;
                    }

                    if(weapon == null)
                    {
                        return;
                    }

                    _instance.timer.In(Latency(player, weapon), () =>
                    {
                        var current = player.eyes.HeadRay().direction;

                        weapon.SetSwing(Vector3.Angle(current, weapon.AimAngle));

                        var x = Math.Abs(current.x - weapon.AimAngle.x) / weapon.Yaw;
                        var y = Math.Abs(current.y - weapon.AimAngle.y) / weapon.Pitch;

                        var history = History.Get(player);

                        x *= 0.25f + history.count_x.Ratio(true);
                        y *= 0.25f + history.count_y.Ratio(true);

                        var delay  = weapon.Fired.Subtract(history.fired).TotalSeconds;
                        var repeat = delay <= (weapon.Repeat * repeat_interval);
                        var reset  = false;
                        var reset_full = false;

                        if(Math.Abs(current.y) > 0.85f)
                        {
                            reset = true; y = 1.0f;
                        }
                        else if((x < epsilon) && (y < epsilon))
                        {
                            if(reset = (history.repeats == 0) || (history.repeats >= (weapon.Automatic ? 1ul : 2ul)))
                            {
                                reset_full = true;
                            }
                        }

                        var violations = 0ul;

                        if(reset_full && (history.repeats > 0))
                        {
                            history.count_r.Increment();

                            if(history.count_r.Total() >= reset_limit)
                            {
                                if(violation.Trigger(player.userID))
                                {
                                    ++violations;
                                }
                            }
                        }
                        else
                        {
                            history.count_r.Decrement();
                        }

                        var can_trigger = false;

                        if(repeat)
                        {
                            ++history.repeats;

                            can_trigger = !(reset || weapon.Shell);
                        }
                        else
                        {
                            history.repeats = 0;
                        }

                        if(can_trigger)
                        {
                            if(x <= sensitivity)
                            {
                                history.count_x.Increment();

                                if(violation.Trigger(player.userID))
                                {
                                    ++violations;
                                }
                            }

                            if(y <= sensitivity)
                            {
                                history.count_y.Increment();

                                if(violation.Trigger(player.userID))
                                {
                                    ++violations;
                                }
                            }
                        }
                        else if(!reset)
                        {
                            history.count_x.Decrement();
                            history.count_y.Decrement();
                        }

                        history.fired = weapon.Fired;

                        var playername = Text.Sanitize(player.displayName);

                        if(config.Log.AntiCheat.Recoil)
                        {
                            Log.Console(Key.LogAntiCheatRecoil, new Dictionary<string, string>
                            {
                                { "count_x", history.count_x.Total().ToString("D2") },
                                { "count_y", history.count_y.Total().ToString("D2") },
                                { "pitch", y.ToString("F6") },
                                { "playerid", player.UserIDString },
                                { "playername", playername },
                                { "swing", weapon.Swing.ToString("F1") },
                                { "weapon", $"{weapon.Name}[{history.repeats}{(reset ? $" (reset)" : string.Empty)}]" },
                                { "yaw", x.ToString("F6") }
                            });
                        }

                        foreach(var projectileid in weapon.Projectiles)
                        {
                            Projectile.Log.SetAttacker(player.userID, projectileid, playername, player.userID);

                            Projectile.Log.SetRecoil(player.userID, projectileid, y, history.repeats, x, weapon.Swing);

                            Projectile.Log.SetWeapon(player.userID, projectileid, weapon.Speed, weapon.Name);
                        }

                        if(config.AntiCheat.Recoil.Enabled && (violations > 0))
                        {
                            foreach(var projectileid in weapon.Projectiles)
                            {
                                Projectile.Log.SetRecoilViolations(player.userID, projectileid, violations);
                            }

                            violation.Trigger(player.userID, type, Text.GetPlain(Key.ViolationRecoil, new Dictionary<string, string>
                            {
                                { "pitch", y.ToString("F6") },
                                { "weapon", weapon.Name },
                                { "yaw", x.ToString("F6") }
                            }), violations, false, new Dictionary<string, string>
                            {
                                { "movement_speed", weapon.Speed.ToString("F1") },
                                { "recoil_pitch", Percent(y).ToString() },
                                { "recoil_repeats", history.repeats.ToString() },
                                { "recoil_yaw", Percent(x).ToString() },
                                { "violation_id", weapon.Fired.Ticks.ToString() },
                                { "weapon_ammo", weapon.AmmoName },
                                { "weapon_attachments", string.Join(", ", weapon.Attachments) },
                                { "weapon_type", weapon.ShortName }
                            });
                        }
                    });
                }

                public static void Unload()
                {
                    History.Clear();

                    violation.Clear();
                }
            }

            public class Server
            {
                public class Settings
                {
                    public bool  Ban;
                    public ulong Cooldown;
                    public bool  Enabled;
                    public float Sensitivity;
                    public bool  Warn;

                    public Settings()
                    {
                        Ban         = false;
                        Cooldown    = 300;
                        Enabled     = true;
                        Sensitivity = 0.5f;
                        Warn        = true;
                    }

                    public Violation.Settings Validate(ulong max)
                    {
                        Configuration.Clamp(ref Cooldown,     1ul,  max);
                        Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                        return new Violation.Settings(Ban, Cooldown, Sensitivity, Warn);
                    }
                }

                private static Vector3 sensitivity = Vector3.zero;

                private const Key type = Key.Server;

                private static readonly Violation violation = new Violation(category);

                public static void Configure()
                {
                    var settings = config.AntiCheat.Server.Validate(900);

                    sensitivity = new Vector3(0.0f, 0.125f + 0.25f * (1.0f - config.AntiCheat.Server.Sensitivity), 0.0f);

                    violation.Configure(settings, 4, 16, 60000);
                }

                public static void Scan()
                {
                    Timers.Add(1.0f, () =>
                    {
                        if(config.AntiCheat.Server.Enabled)
                        {
                            foreach(var player in BasePlayer.activePlayerList)
                            {
                                if(User.ShouldIgnore(player) || User.CanFly(player))
                                {
                                    continue;
                                }

                                if(player.isMounted || player.HasParent() || player.IsSwimming())
                                {
                                    continue;
                                }

                                if(!player.IsFlying)
                                {
                                    player.SendConsoleCommand("noclip");
                                    player.SendConsoleCommand("debugcamera");
                                    player.SendConsoleCommand("camspeed", "0");
                                }

                                var position = player.transform.position;
                                var highspot = position + sensitivity;

                                if(!Map.Cave.IsInside(highspot))
                                {
                                    if(Map.Terrain.IsInside(highspot, false))
                                    {
                                        _instance.OnPlayerViolation(player, AntiHackType.InsideTerrain, position.y);
                                    }
                                    else if(Map.Rock.IsInside(highspot, false))
                                    {
                                        _instance.OnPlayerViolation(player, AntiHackType.NoClip, position.y);
                                    }
                                }

                                if(Map.Building.InFoundation(highspot))
                                {
                                    _instance.OnPlayerViolation(player, AntiHackType.NoClip, position.y);
                                }
                            }
                        }
                    });
                }

                public static void Trigger(BasePlayer player, AntiHackType ahtype, float amount)
                {
                    if(Permissions.Bypass.AntiCheat.Server(player.userID))
                    {
                        return;
                    }

                    if(Math.Abs(amount) < epsilon)
                    {
                        return;
                    }

                    var position = player.transform.position;

                    if(config.Log.AntiCheat.Server)
                    {
                        var colliders = string.Empty;

                        if((ahtype == AntiHackType.InsideTerrain) || (ahtype == AntiHackType.NoClip))
                        {
                            colliders = Map.Collider.Info(position);
                        }

                        Log.Console(Key.LogAntiCheatServer, new Dictionary<string, string>
                        {
                            { "amount", amount.ToString("F6") },
                            { "colliders", colliders },
                            { "playerid", player.UserIDString },
                            { "playername", Text.Sanitize(player.displayName) },
                            { "position", $"({(int)position.x},{(int)position.y},{(int)position.z})" },
                            { "type", ahtype.ToString() }
                        });
                    }

                    if(violation.Trigger(player.userID))
                    {
                        var antihack_amount = amount.ToString("F6");
                        var antihack_type   = ahtype.ToString();

                        violation.Trigger(player.userID, type, $"{antihack_type}({antihack_amount})", false, new Dictionary<string, string>
                        {
                            { "antihack_amount", antihack_amount },
                            { "antihack_type", antihack_type },
                            { "movement_speed", player.estimatedSpeed.ToString("F1") },
                            { "violation_id", DateTime.UtcNow.Ticks.ToString() }
                        });
                    }
                }

                public static void Unload() => violation.Clear();
            }

            public class Stash
            {
                public class Settings
                {
                    public bool  Ban;
                    public ulong Cooldown;
                    public bool  Enabled;
                    public float Sensitivity;
                    public bool  Warn;

                    public Settings()
                    {
                        Ban         = false;
                        Cooldown    = 3600;
                        Enabled     = true;
                        Sensitivity = 0.5f;
                        Warn        = true;
                    }

                    public Violation.Settings Validate(ulong max)
                    {
                        Configuration.Clamp(ref Cooldown,     1ul,  max);
                        Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                        return new Violation.Settings(Ban, Cooldown, Sensitivity, Warn);
                    }
                }

                private const Key type = Key.AntiCheatStash;

                private static readonly Violation violation = new Violation(category);

                private class History
                {
                    private static readonly Dictionary<ulong, List<Vector3>> histories = new Dictionary<ulong, List<Vector3>>();

                    public static void Clear() => histories.Clear();

                    public static float Set(ulong userid, Vector3 position)
                    {
                        List<Vector3> history;

                        if(!histories.TryGetValue(userid, out history))
                        {
                            histories.Add(userid, history = new List<Vector3> { position });

                            return 0.0f;
                        }

                        var minimum = float.MaxValue;
                        var nearest = Vector3.zero;

                        foreach(var found in history)
                        {
                            var delta = (found - position).sqrMagnitude;

                            if(delta < minimum)
                            {
                                minimum = delta;
                                nearest = found;
                            }
                        }

                        if(!Map.InRange2D(position, nearest, 3.0f))
                        {
                            history.Add(position);
                        }

                        return (float)Math.Sqrt(minimum);
                    }
                }

                private static float sensitivity;

                public static void Configure()
                {
                    var settings = config.AntiCheat.Stash.Validate(14400);

                    violation.Configure(settings, 1, 1, 3600000);

                    sensitivity = 3.0f + 18.0f * (1.0f - settings.Sensitivity);
                }

                public static void Subscribe()
                {
                    if(config.AntiCheat.Stash.Enabled)
                    {
                        Hooks.Subscribe(nameof(CanSeeStash));
                    }
                    else
                    {
                        Hooks.Unsubscribe(nameof(CanSeeStash));
                    }
                }

                public static void Trigger(BasePlayer player, StashContainer stash)
                {
                    if(Permissions.Bypass.AntiCheat.Stash(player.userID))
                    {
                        return;
                    }

                    if((player.userID == stash.OwnerID) || User.IsTeamMate(player, stash.OwnerID) || User.IsFriend(player, stash.OwnerID))
                    {
                        return;
                    }

                    _instance.NextTick(() =>
                    {
                        var position = stash.transform.position;

                        var grid = Map.Grid(position);

                        if(config.Log.AntiCheat.Stash)
                        {
                            Log.Console(Key.LogAntiCheatStash, new Dictionary<string, string>
                            {
                                { "grid", grid },
                                { "ownerid", stash.OwnerID.ToString() },
                                { "playerid", player.UserIDString },
                                { "playername", Text.Sanitize(player.displayName) },
                                { "position", $"({(int)position.x},{(int)position.y},{(int)position.z})" }
                            });
                        }

                        float distance = History.Set(player.userID, position);

                        if(config.AntiCheat.Stash.Enabled && (distance >= sensitivity))
                        {
                            var triggered = violation.Trigger(player.userID);

                            if(triggered || config.AntiCheat.Stash.Warn)
                            {
                                var details = Text.GetPlain(Key.ViolationStash, new Dictionary<string, string>
                                {
                                    { "grid", grid },
                                    { "position", $"({(int)position.x},{(int)position.y},{(int)position.z})" }
                                });

                                var hook_details = new Dictionary<string, string>
                                {
                                    { "stash_distance", distance.ToString("F1") },
                                    { "movement_speed", player.estimatedSpeed.ToString("F1") },
                                    { "violation_id", DateTime.UtcNow.Ticks.ToString() }
                                };

                                if(triggered)
                                {
                                    violation.Trigger(player.userID, type, details, false, hook_details);
                                }
                                else
                                {
                                    violation.Warning(player.userID, type, details, hook_details);
                                }
                            }
                        }
                    });
                }

                public static void Unload()
                {
                    History.Clear();

                    violation.Clear();
                }
            }

            public class Trajectory
            {
                public class Settings
                {
                    public bool  Ban;
                    public ulong Cooldown;
                    public bool  Enabled;
                    public float Sensitivity;
                    public bool  Warn;

                    public Settings()
                    {
                        Ban         = false;
                        Cooldown    = 90;
                        Enabled     = true;
                        Sensitivity = 0.5f;
                        Warn        = true;
                    }

                    public Violation.Settings Validate(ulong max)
                    {
                        Configuration.Clamp(ref Cooldown,     1ul,  max);
                        Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                        return new Violation.Settings(Ban, Cooldown, Sensitivity, Warn);
                    }
                }

                private const Key type = Key.AntiCheatTrajectory;

                private static readonly Violation violation = new Violation(category);

                private static float sensitivity;
                private static float sensitivity_lo;
                private static float sensitivity_hi;

                public static void Configure()
                {
                    var settings = config.AntiCheat.Trajectory.Validate(300);

                    violation.Configure(settings, 2, 8, 1000);

                    sensitivity = 5.0f + (5.0f * (1.0f - settings.Sensitivity));

                    sensitivity_lo = 0.0625f + 0.125f * settings.Sensitivity;
                    sensitivity_hi = 0.5f * sensitivity_lo;
                }

                private static float Ratio(float a, float b) => (a + sensitivity) / (b + sensitivity);

                private static uint Percent(float value) =>
                    (uint)(100.0f * (1.0f - value));

                public static void Trigger(BaseCombatEntity entity, HitInfo info)
                {
                    var player = info.InitiatorPlayer;

                    if(Permissions.Bypass.AntiCheat.Trajectory(player.userID))
                    {
                        return;
                    }

                    var weapon = Weapon.Get(player.userID, info.ProjectileID);

                    if(weapon == null)
                    {
                        return;
                    }

                    var d_actual = Vector3.Distance(entity.transform.position, weapon.Position);

                    var d_server = info.ProjectileDistance;

                    _instance.NextTick(() =>
                    {
                        var variance = (d_actual < d_server) ? Ratio(d_actual, d_server) : Ratio(d_server, d_actual);

                        if(float.IsNaN(variance) || float.IsInfinity(variance))
                        {
                            variance = 1.0f;
                        }
                        else
                        {
                            variance = Math.Abs(variance);
                        }

                        ulong violations = 0;

                        if(variance < sensitivity_lo)
                        {
                            if(violation.Trigger(player.userID))
                            {
                                ++violations;
                            }

                            if((variance < sensitivity_hi) && violation.Trigger(player.userID))
                            {
                                ++violations;
                            }
                        }

                        if(config.Log.AntiCheat.Trajectory)
                        {
                            Log.Console(Key.LogAntiCheatTrajectory, new Dictionary<string, string>
                            {
                                { "distance", d_actual.ToString("F1") },
                                { "playerid", player.UserIDString },
                                { "playername", Text.Sanitize(player.displayName) },
                                { "reported", d_server.ToString("F1") },
                                { "weapon", $"{weapon.Name}[{Enum.GetName(typeof(DamageType), entity.lastDamage)}]" }
                            });
                        }

                        Projectile.Log.SetTrajectory(player.userID, info.ProjectileID, variance);

                        if(player.isMounted || User.HasParent<CargoShip>(player) || User.HasParent<HotAirBalloon>(player))
                        {
                            return;
                        }

                        if(config.AntiCheat.Trajectory.Enabled && (violations > 0))
                        {
                            Projectile.Log.SetTrajectoryViolations(player.userID, info.ProjectileID, violations);

                            var hit_distance = d_actual.ToString("F1");
                            var projectile_distance = d_server.ToString("F1");

                            violation.Trigger(player.userID, type, Text.GetPlain(Key.ViolationTrajectory, new Dictionary<string, string>
                            {
                                { "distance", hit_distance },
                                { "reported", projectile_distance },
                                { "weapon", weapon.Name }
                            }), violations, false, new Dictionary<string, string>
                            {
                                { "hit_distance", hit_distance },
                                { "movement_speed", weapon.Speed.ToString("F1") },
                                { "projectile_distance", projectile_distance },
                                { "projectile_id", info.ProjectileID.ToString() },
                                { "trajectory_percent", Percent(variance).ToString() },
                                { "violation_id", weapon.Fired.Ticks.ToString() },
                                { "weapon_ammo", weapon.AmmoName },
                                { "weapon_attachments", string.Join(", ", weapon.Attachments) },
                                { "weapon_type", weapon.ShortName }
                            });
                        }
                    });
                }

                public static void Unload() => violation.Clear();
            }

            public class WallHack
            {
                public class Settings
                {
                    public bool  Ban;
                    public ulong Cooldown;
                    public bool  Enabled;
                    public float Sensitivity;
                    public bool  Warn;

                    public Settings()
                    {
                        Ban         = false;
                        Cooldown    = 300;
                        Enabled     = true;
                        Sensitivity = 0.5f;
                        Warn        = true;
                    }

                    public Violation.Settings Validate(ulong max)
                    {
                        Configuration.Clamp(ref Cooldown,     1ul,  max);
                        Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                        return new Violation.Settings(Ban, Cooldown, Sensitivity, Warn);
                    }
                }

                private const Key type = Key.AntiCheatWallHack;

                private static readonly Violation violation = new Violation(category);

                public static void Configure()
                {
                    var settings = config.AntiCheat.WallHack.Validate(900);

                    violation.Configure(settings, 2, 8, 15000);
                }

                public static void Trigger(BasePlayer player, HitInfo info)
                {
                    if(Permissions.Bypass.AntiCheat.WallHack(player.userID))
                    {
                        return;
                    }

                    var victim = info.HitEntity as BasePlayer;

                    if((victim == null) || !victim.userID.IsSteamId())
                    {
                        return;
                    }

                    var weapon = Weapon.Get(player.userID, info.ProjectileID);

                    if((weapon == null) || weapon.Spread)
                    {
                        return;
                    }

                    _instance.NextTick(() =>
                    {
                        if(Physics.Linecast(info.PointStart, info.HitPositionWorld, Layers.Mask.Construction))
                        {
                            if(config.AntiCheat.WallHack.Enabled && violation.Trigger(player.userID))
                            {
                                Projectile.Log.SetWallHackViolations(player.userID, info.ProjectileID, 1);

                                violation.Trigger(player.userID, type, Text.GetPlain(Key.ViolationWallHack, new Dictionary<string, string>
                                {
                                    { "target", Text.Sanitize(victim.displayName) },
                                    { "weapon", weapon.Name }
                                }), false, new Dictionary<string, string>
                                {
                                    { "hit_distance", Vector3.Distance(victim.transform.position, weapon.Position).ToString("F1") },
                                    { "movement_speed", weapon.Speed.ToString("F1") },
                                    { "projectile_id", info.ProjectileID.ToString() },
                                    { "violation_id", weapon.Fired.Ticks.ToString() },
                                    { "weapon_ammo", weapon.AmmoName },
                                    { "weapon_attachments", string.Join(", ", weapon.Attachments) },
                                    { "weapon_type", weapon.ShortName }
                                });
                            }
                        }
                    });
                }

                public static void Unload() => violation.Clear();
            }
        }

        #endregion _anticheat_

        #region _antiflood_

        private class AntiFlood
        {
            public class Settings
            {
                public Chat.Settings     Chat;
                public Command.Settings  Command;
                public ItemDrop.Settings ItemDrop;

                public Settings()
                {
                    Chat     = new Chat.Settings();
                    Command  = new Command.Settings();
                    ItemDrop = new ItemDrop.Settings();
                }

                public void Validate()
                {
                    Configuration.Validate(ref Chat,     () => new Chat.Settings());
                    Configuration.Validate(ref Command,  () => new Command.Settings());
                    Configuration.Validate(ref ItemDrop, () => new ItemDrop.Settings());
                }
            }

            private const Key category = Key.AntiFlood;

            public static void Configure()
            {
                Chat.Configure();
                Command.Configure();
                ItemDrop.Configure();
            }

            public static void Unload()
            {
                Chat.Unload();
                Command.Unload();
                ItemDrop.Unload();
            }

            public class Chat
            {
                public class Settings
                {
                    public bool  Ban;
                    public ulong Cooldown;
                    public bool  Enabled;
                    public float Sensitivity;
                    public bool  Warn;

                    public Settings()
                    {
                        Ban         = false;
                        Cooldown    = 30;
                        Enabled     = true;
                        Sensitivity = 0.5f;
                        Warn        = false;
                    }

                    public Violation.Settings Validate(ulong max)
                    {
                        Configuration.Clamp(ref Cooldown,     1ul,  max);
                        Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                        return new Violation.Settings(Ban, Cooldown, Sensitivity, Warn);
                    }
                }

                private const Key type = Key.AntiFloodChat;

                private static readonly Violation violation = new Violation(category);

                public static void Configure()
                {
                    var settings = config.AntiFlood.Chat.Validate(3600);

                    violation.Configure(settings, 5, 15, 1000);
                }

                public static ulong Cooldown(ulong playerid)
                {
                    return violation.Cooldown(playerid);
                }

                public static void Subscribe()
                {
                    if(config.AntiFlood.Chat.Enabled)
                    {
                        Hooks.Subscribe(nameof(OnPlayerChat));
                    }
                    else
                    {
                        Hooks.Unsubscribe(nameof(OnPlayerChat));
                    }
                }

                public static bool Trigger(ulong playerid)
                {
                    return violation.Trigger(playerid);
                }

                public static void Unload() => violation.Clear();

                public static void Violation(BasePlayer player, string details)
                {
                    if(config.AntiFlood.Chat.Enabled)
                    {
                        violation.Trigger(player.userID, type, details);
                    }
                }
            }

            public class Command
            {
                public class Settings
                {
                    public bool  Ban;
                    public ulong Cooldown;
                    public bool  Enabled;
                    public float Sensitivity;
                    public bool  Warn;

                    public Settings()
                    {
                        Ban         = false;
                        Cooldown    = 30;
                        Enabled     = true;
                        Sensitivity = 0.5f;
                        Warn        = false;
                    }

                    public Violation.Settings Validate(ulong max)
                    {
                        Configuration.Clamp(ref Cooldown,     1ul,  max);
                        Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                        return new Violation.Settings(Ban, Cooldown, Sensitivity, Warn);
                    }
                }

                private const Key type = Key.AntiFloodCommand;

                private static readonly Violation violation = new Violation(category);

                public static void Configure()
                {
                    var settings = config.AntiFlood.Command.Validate(60);

                    violation.Configure(settings, 5, 15, 125);
                }

                public static ulong Cooldown(ulong playerid)
                {
                    return violation.Cooldown(playerid);
                }

                public static void Subscribe()
                {
                    if(config.AntiFlood.Command.Enabled)
                    {
                        Hooks.Subscribe(nameof(OnServerCommand));
                    }
                    else
                    {
                        Hooks.Unsubscribe(nameof(OnServerCommand));
                    }
                }

                public static bool Trigger(ulong playerid)
                {
                    return violation.Trigger(playerid);
                }

                public static void Unload() => violation.Clear();

                public static void Violation(BasePlayer player, string details)
                {
                    if(config.AntiFlood.Command.Enabled)
                    {
                        violation.Trigger(player.userID, type, details);
                    }
                }
            }

            public class ItemDrop
            {
                public class Settings
                {
                    public bool  Ban;
                    public ulong Cooldown;
                    public bool  Enabled;
                    public float Sensitivity;
                    public bool  Warn;

                    public Settings()
                    {
                        Ban         = false;
                        Cooldown    = 300;
                        Enabled     = true;
                        Sensitivity = 0.5f;
                        Warn        = false;
                    }

                    public Violation.Settings Validate(ulong max)
                    {
                        Configuration.Clamp(ref Cooldown,     1ul,  max);
                        Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                        return new Violation.Settings(Ban, Cooldown, Sensitivity, Warn);
                    }
                }

                private const Key type = Key.AntiFloodItemDrop;

                private static readonly Violation violation = new Violation(category);

                private static readonly Dictionary<ulong, int> history = new Dictionary<ulong, int>();

                public static void Configure()
                {
                    var settings = config.AntiFlood.ItemDrop.Validate(900);

                    violation.Configure(settings, 3, 7, 30000);
                }

                public static ulong CoolDown(ulong playerid, int itemid)
                {
                    history[playerid] = itemid;

                    return violation.Cooldown(playerid);
                }

                public static void Subscribe()
                {
                    if(config.AntiFlood.ItemDrop.Enabled)
                    {
                        Hooks.Subscribe(nameof(CanCraft));
                        Hooks.Subscribe(nameof(OnItemDropped));
                    }
                    else
                    {
                        Hooks.Unsubscribe(nameof(CanCraft));
                        Hooks.Unsubscribe(nameof(OnItemDropped));
                    }
                }

                public static bool Trigger(ulong playerid, int itemid)
                {
                    if(history.ContainsKey(playerid))
                    {
                        if(history[playerid] == itemid)
                        {
                            if(config.Log.AntiFlood.ItemDrop)
                            {
                                var playername = Text.Sanitize(BasePlayer.FindByID(playerid)?.displayName ?? Text.Get(Key.unknown));

                                var itemtext = ItemManager.FindItemDefinition(itemid)?.displayName;

                                var itemname = itemtext?.translated ?? itemtext?.english ?? Text.Get(Key.unknown);

                                Log.Console(Key.LogAntiSpamItemDrop, new Dictionary<string, string>
                                {
                                    { "itemid", itemid.ToString() },
                                    { "itemname", itemname },
                                    { "playerid", playerid.ToString() },
                                    { "playername", playername }
                                });
                            }

                            return config.AntiFlood.ItemDrop.Enabled && violation.Trigger(playerid);
                        }
                    }

                    return false;
                }

                public static void Unload()
                {
                    history.Clear();

                    violation.Clear();
                }

                public static void Violation(BasePlayer player, string details)
                {
                    violation.Trigger(player.userID, type, details);
                }
            }
        }

        #endregion _antiflood_

        #region _api_

        public class API
        {
            public class Settings
            {
                public string ApiKey;
                public bool   Enabled;

                public Settings()
                {
                    ApiKey  = string.Empty;
                    Enabled = false;
                }

                public void Validate()
                {
                    Configuration.Validate(ref ApiKey, () => { return string.Empty; });
                }
            }
        }

        #endregion _api_

        #region _ban_

        public class Ban
        {
            public class Settings
            {
                public bool    Inherit;
                public bool    Teleport;
                public BanTime Time;

                public Settings()
                {
                    Inherit  = true;
                    Teleport = false;
                    Time     = new BanTime();
                }

                public class BanTime
                {
                    public bool  Enforce;
                    public bool  Multiply;
                    public ulong Seconds;
                }

                public void Validate()
                {
                    Configuration.Validate(ref Time, () => new BanTime());
                }
            }
        }

        #endregion _ban_

        #region _chat_

        private class Chat
        {
            public static void Admin(Key key, Dictionary<string, string> parameters = null)
            {
                Log.Console(key, parameters);

                if(config.Admin.Broadcast)
                {
                    foreach(var player in BasePlayer.activePlayerList)
                    {
                        if(Permissions.Admin(player.userID))
                        {
                            Send(player, key, parameters);
                        }
                    }
                }
            }

            public static void Broadcast(Key key, Dictionary<string, string> parameters = null)
            {
                foreach(var player in BasePlayer.activePlayerList)
                {
                    Send(player, key, parameters);
                }
            }

            public static void Console(BasePlayer player, Key key, Dictionary<string, string> parameters = null)
            {
                if((player == null) || !player.IsConnected)
                {
                    return;
                }

                player.ConsoleMessage(Text.GetPlain(key, player, parameters));
            }

            public static void Reply(IPlayer iplayer, Key key, Dictionary<string, string> parameters = null)
            {
                if((iplayer == null) || iplayer.IsServer)
                {
                    Log.Console(key, parameters);
                }
                else
                {
                    if(iplayer.LastCommand == CommandType.Console)
                    {
                        iplayer.Reply(Text.GetPlain(key, iplayer, parameters));
                    }
                    else
                    {
                        Send(iplayer.Object as BasePlayer, key, parameters);
                    }
                }
            }

            public static void Send(BasePlayer player, Key key, Dictionary<string, string> parameters = null)
            {
                if((player == null) || !player.IsConnected)
                {
                    return;
                }

                var message = Text.Get(key, player, parameters);

                player.SendConsoleCommand("chat.add", 0, 76561199125814167UL, message);
            }
        }

        #endregion _chat_

        #region _command_

        private void CommandReceive(IPlayer iplayer, string command, string[] args) => Command.Receive(iplayer, command, args);

        private class Command
        {
            private static readonly Dictionary<string, Info> commands = new Dictionary<string, Info>();

            private static List<Info> info;

            private class Info
            {
                public Action<IPlayer, string, string[]> Action { get; protected set; }
                public List<string>                      Aliases { get; protected set; }
                public Key                               Title { get; protected set; }

                public Info(Action<IPlayer, string, string[]> action, Key title, params string[] aliases)
                {
                    Action  = action;
                    Aliases = new List<string>(aliases);
                    Title   = title;

                    foreach(var alias in aliases)
                    {
                        commands.Add(alias, this);
                    }
                }
            }

            public static void Load()
            {
                info = new List<Info>
                {
                    new Info(Config,   Key.CommandConfigTitle,   "g.config", "guardian.config"),
                    new Info(Help,     Key.CommandHelpTitle,     "g.help", "guardian", "guardian.help"),
                    new Info(Ip,       Key.CommandIpTitle,       "g.ip", "guardian.ip"),
                    new Info(Log,      Key.CommandLogTitle,      "g.log", "guardian.log"),
                    new Info(Server,   Key.CommandServerTitle,   "g.server", "guardian.server"),
                    new Info(Teleport, Key.CommandTeleportTitle, "g.tp", "g.tpv", "guardian.tp", "guardian.tpv"),
                    new Info(Users,    Key.CommandUserTitle,     "g.user", "guardian.user"),
                    new Info(Vpn,      Key.CommandVpnTitle,      "g.vpn", "guardian.vpn")
                };

                foreach(var command in commands)
                {
                    _instance.AddCovalenceCommand(command.Key, nameof(CommandReceive));
                }
            }

            public static void Receive(IPlayer iplayer, string command, string[] args)
            {
                Info entry;

                if(commands.TryGetValue(command = command.ToLower(), out entry))
                {
                    entry.Action(iplayer, command, args);
                }
                else
                {
                    Chat.Reply(iplayer, Key.CommandUnknown, new Dictionary<string, string>
                    {
                        { "command", (iplayer.LastCommand == CommandType.Console) ? command : ("/" + command) }
                    });
                }
            }

            public static void Unload()
            {
                commands.Clear();

                info.Clear();
                info = null;
            }

            private static void Config(IPlayer iplayer, string command, string[] args)
            {
                var command_replace = new Dictionary<string, string>
                {
                    { "command", (iplayer.LastCommand == CommandType.Console) ? command : ("/" + command) }
                };

                BasePlayer player = iplayer.IsServer ? null : iplayer.Object as BasePlayer;

                if((player != null) && !Permissions.Command.Config(player.userID))
                {
                    Chat.Reply(iplayer, Key.CommandNoPermission);

                    return;
                }
                else if(args.Length == 0)
                {
                    goto syntax_error;
                }

                var subsection = args[0].ToLower();
                var subcommand = subsection.Split('.')[0];

                bool success = false;

                switch(subcommand)
                {
                case "admin":
                    switch(subsection)
                    {
                    case "admin.broadcast": success = Config(iplayer, args, subsection, ref config.Admin.Broadcast); break;
                    case "admin.bypass":    success = Config(iplayer, args, subsection, ref config.Admin.Bypass);    break;
                    }

                    if(!success) Chat.Reply(iplayer, Key.CommandConfigAdminSyntax, command_replace);

                    return;

                case "anticheat":
                    switch(Config(subsection))
                    {
                    case "anticheat.aim":
                        switch(subsection)
                        {
                        case "anticheat.aim.ban":                success = Config(iplayer, args, subsection, ref config.AntiCheat.Aim.Ban,         AntiCheat.Aim.Configure); break;
                        case "anticheat.aim.cooldown":           success = Config(iplayer, args, subsection, ref config.AntiCheat.Aim.Cooldown,    AntiCheat.Aim.Configure); break;
                        case "anticheat.aim.enabled":            success = Config(iplayer, args, subsection, ref config.AntiCheat.Aim.Enabled);                              break;
                        case "anticheat.aim.sensitivity":        success = Config(iplayer, args, subsection, ref config.AntiCheat.Aim.Sensitivity, AntiCheat.Aim.Configure); break;
                        case "anticheat.aim.trigger.animal":     success = Config(iplayer, args, subsection, ref config.AntiCheat.Aim.Trigger.Animal);                       break;
                        case "anticheat.aim.trigger.bradley":    success = Config(iplayer, args, subsection, ref config.AntiCheat.Aim.Trigger.Bradley);                      break;
                        case "anticheat.aim.trigger.helicopter": success = Config(iplayer, args, subsection, ref config.AntiCheat.Aim.Trigger.Helicopter);                   break;
                        case "anticheat.aim.trigger.npc":        success = Config(iplayer, args, subsection, ref config.AntiCheat.Aim.Trigger.NPC);                          break;
                        case "anticheat.aim.warn":               success = Config(iplayer, args, subsection, ref config.AntiCheat.Aim.Warn,        AntiCheat.Aim.Configure); break;
                        }

                        if(!success) Chat.Reply(iplayer, Key.CommandConfigAntiCheatAimSyntax, command_replace);

                        return;

                    case "anticheat.firerate":
                        switch(subsection)
                        {
                        case "anticheat.firerate.ban":         success = Config(iplayer, args, subsection, ref config.AntiCheat.FireRate.Ban,         AntiCheat.FireRate.Configure); break;
                        case "anticheat.firerate.cooldown":    success = Config(iplayer, args, subsection, ref config.AntiCheat.FireRate.Cooldown,    AntiCheat.FireRate.Configure); break;
                        case "anticheat.firerate.enabled":     success = Config(iplayer, args, subsection, ref config.AntiCheat.FireRate.Enabled);                                   break;
                        case "anticheat.firerate.sensitivity": success = Config(iplayer, args, subsection, ref config.AntiCheat.FireRate.Sensitivity, AntiCheat.FireRate.Configure); break;
                        case "anticheat.firerate.warn":        success = Config(iplayer, args, subsection, ref config.AntiCheat.FireRate.Warn,        AntiCheat.FireRate.Configure); break;
                        }

                        if(!success) Chat.Reply(iplayer, Key.CommandConfigAntiCheatFireRateSyntax, command_replace);

                        return;

                    case "anticheat.gravity":
                        switch(subsection)
                        {
                        case "anticheat.gravity.ban":          success = Config(iplayer, args, subsection, ref config.AntiCheat.Gravity.Ban,         AntiCheat.Gravity.Configure); break;
                        case "anticheat.gravity.cooldown":     success = Config(iplayer, args, subsection, ref config.AntiCheat.Gravity.Cooldown,    AntiCheat.Gravity.Configure); break;
                        case "anticheat.gravity.enabled":      success = Config(iplayer, args, subsection, ref config.AntiCheat.Gravity.Enabled);                                  break;
                        case "anticheat.gravity.sensitivity":  success = Config(iplayer, args, subsection, ref config.AntiCheat.Gravity.Sensitivity, AntiCheat.Gravity.Configure); break;
                        case "anticheat.gravity.warn":         success = Config(iplayer, args, subsection, ref config.AntiCheat.Gravity.Warn,        AntiCheat.Gravity.Configure); break;
                        }

                        if(!success) Chat.Reply(iplayer, Key.CommandConfigAntiCheatGravitySyntax, command_replace);

                        return;

                    case "anticheat.meleerate":
                        switch(subsection)
                        {
                        case "anticheat.meleerate.ban":         success = Config(iplayer, args, subsection, ref config.AntiCheat.MeleeRate.Ban,         AntiCheat.MeleeRate.Configure); break;
                        case "anticheat.meleerate.cooldown":    success = Config(iplayer, args, subsection, ref config.AntiCheat.MeleeRate.Cooldown,    AntiCheat.MeleeRate.Configure); break;
                        case "anticheat.meleerate.enabled":     success = Config(iplayer, args, subsection, ref config.AntiCheat.MeleeRate.Enabled);                                    break;
                        case "anticheat.meleerate.sensitivity": success = Config(iplayer, args, subsection, ref config.AntiCheat.MeleeRate.Sensitivity, AntiCheat.MeleeRate.Configure); break;
                        case "anticheat.meleerate.warn":        success = Config(iplayer, args, subsection, ref config.AntiCheat.MeleeRate.Warn,        AntiCheat.MeleeRate.Configure); break;
                        }

                        if(!success) Chat.Reply(iplayer, Key.CommandConfigAntiCheatMeleeRateSyntax, command_replace);

                        return;

                    case "anticheat.recoil":
                        switch(subsection)
                        {
                        case "anticheat.recoil.ban":         success = Config(iplayer, args, subsection, ref config.AntiCheat.Recoil.Ban,         AntiCheat.Recoil.Configure); break;
                        case "anticheat.recoil.cooldown":    success = Config(iplayer, args, subsection, ref config.AntiCheat.Recoil.Cooldown,    AntiCheat.Recoil.Configure); break;
                        case "anticheat.recoil.enabled":     success = Config(iplayer, args, subsection, ref config.AntiCheat.Recoil.Enabled);                                 break;
                        case "anticheat.recoil.sensitivity": success = Config(iplayer, args, subsection, ref config.AntiCheat.Recoil.Sensitivity, AntiCheat.Recoil.Configure); break;
                        case "anticheat.recoil.warn":        success = Config(iplayer, args, subsection, ref config.AntiCheat.Recoil.Warn,        AntiCheat.Recoil.Configure); break;
                        }

                        if(!success) Chat.Reply(iplayer, Key.CommandConfigAntiCheatRecoilSyntax, command_replace);

                        return;

                    case "anticheat.server":
                        switch(subsection)
                        {
                        case "anticheat.server.ban":         success = Config(iplayer, args, subsection, ref config.AntiCheat.Server.Ban,         AntiCheat.Server.Configure); break;
                        case "anticheat.server.cooldown":    success = Config(iplayer, args, subsection, ref config.AntiCheat.Server.Cooldown,    AntiCheat.Server.Configure); break;
                        case "anticheat.server.enabled":     success = Config(iplayer, args, subsection, ref config.AntiCheat.Server.Enabled);                                 break;
                        case "anticheat.server.sensitivity": success = Config(iplayer, args, subsection, ref config.AntiCheat.Server.Sensitivity, AntiCheat.Server.Configure); break;
                        case "anticheat.server.warn":        success = Config(iplayer, args, subsection, ref config.AntiCheat.Server.Warn,        AntiCheat.Server.Configure); break;
                        }

                        if(!success) Chat.Reply(iplayer, Key.CommandConfigAntiCheatServerSyntax, command_replace);

                        return;

                    case "anticheat.stash":
                        switch(subsection)
                        {
                        case "anticheat.stash.ban":         success = Config(iplayer, args, subsection, ref config.AntiCheat.Stash.Ban,         AntiCheat.Stash.Configure); break;
                        case "anticheat.stash.cooldown":    success = Config(iplayer, args, subsection, ref config.AntiCheat.Stash.Cooldown,    AntiCheat.Stash.Configure); break;
                        case "anticheat.stash.enabled":     success = Config(iplayer, args, subsection, ref config.AntiCheat.Stash.Enabled,     AntiCheat.Stash.Subscribe); break;
                        case "anticheat.stash.sensitivity": success = Config(iplayer, args, subsection, ref config.AntiCheat.Stash.Sensitivity, AntiCheat.Stash.Configure); break;
                        case "anticheat.stash.warn":        success = Config(iplayer, args, subsection, ref config.AntiCheat.Stash.Warn,        AntiCheat.Stash.Configure); break;
                        }

                        if(!success) Chat.Reply(iplayer, Key.CommandConfigAntiCheatStashSyntax, command_replace);

                        return;

                    case "anticheat.trajectory":
                        switch(subsection)
                        {
                        case "anticheat.trajectory.ban":         success = Config(iplayer, args, subsection, ref config.AntiCheat.Trajectory.Ban,         AntiCheat.Trajectory.Configure); break;
                        case "anticheat.trajectory.cooldown":    success = Config(iplayer, args, subsection, ref config.AntiCheat.Trajectory.Cooldown,    AntiCheat.Trajectory.Configure); break;
                        case "anticheat.trajectory.enabled":     success = Config(iplayer, args, subsection, ref config.AntiCheat.Trajectory.Enabled);                                     break;
                        case "anticheat.trajectory.sensitivity": success = Config(iplayer, args, subsection, ref config.AntiCheat.Trajectory.Sensitivity, AntiCheat.Trajectory.Configure); break;
                        case "anticheat.trajectory.warn":        success = Config(iplayer, args, subsection, ref config.AntiCheat.Trajectory.Warn,        AntiCheat.Trajectory.Configure); break;
                        }

                        if(!success) Chat.Reply(iplayer, Key.CommandConfigAntiCheatTrajectorySyntax, command_replace);

                        return;

                    case "anticheat.wallhack":
                        switch(subsection)
                        {
                        case "anticheat.wallhack.ban":         success = Config(iplayer, args, subsection, ref config.AntiCheat.WallHack.Ban,         AntiCheat.WallHack.Configure); break;
                        case "anticheat.wallhack.cooldown":    success = Config(iplayer, args, subsection, ref config.AntiCheat.WallHack.Cooldown,    AntiCheat.WallHack.Configure); break;
                        case "anticheat.wallhack.enabled":     success = Config(iplayer, args, subsection, ref config.AntiCheat.WallHack.Enabled);                                   break;
                        case "anticheat.wallhack.sensitivity": success = Config(iplayer, args, subsection, ref config.AntiCheat.WallHack.Sensitivity, AntiCheat.WallHack.Configure); break;
                        case "anticheat.wallhack.warn":        success = Config(iplayer, args, subsection, ref config.AntiCheat.WallHack.Warn,        AntiCheat.WallHack.Configure); break;
                        }

                        if(!success) Chat.Reply(iplayer, Key.CommandConfigAntiCheatWallHackSyntax, command_replace);

                        return;
                    }

                    Chat.Reply(iplayer, Key.CommandConfigAntiCheatSyntax, command_replace);

                    return;

                case "antiflood":
                    switch(Config(subsection))
                    {
                    case "antiflood.chat":
                        switch(subsection)
                        {
                        case "antiflood.chat.ban":         success = Config(iplayer, args, subsection, ref config.AntiFlood.Chat.Ban,         AntiFlood.Chat.Configure); break;
                        case "antiflood.chat.cooldown":    success = Config(iplayer, args, subsection, ref config.AntiFlood.Chat.Cooldown,    AntiFlood.Chat.Configure); break;
                        case "antiflood.chat.enabled":     success = Config(iplayer, args, subsection, ref config.AntiFlood.Chat.Enabled,     AntiFlood.Chat.Subscribe); break;
                        case "antiflood.chat.sensitivity": success = Config(iplayer, args, subsection, ref config.AntiFlood.Chat.Sensitivity, AntiFlood.Chat.Configure); break;
                        case "antiflood.chat.warn":        success = Config(iplayer, args, subsection, ref config.AntiFlood.Chat.Warn,        AntiFlood.Chat.Configure); break;
                        }

                        if(!success) Chat.Reply(iplayer, Key.CommandConfigAntiFloodChatSyntax, command_replace);

                        return;

                    case "antiflood.command":
                        switch(subsection)
                        {
                        case "antiflood.command.ban":         success = Config(iplayer, args, subsection, ref config.AntiFlood.Command.Ban,         AntiFlood.Command.Configure); break;
                        case "antiflood.command.cooldown":    success = Config(iplayer, args, subsection, ref config.AntiFlood.Command.Cooldown,    AntiFlood.Command.Configure); break;
                        case "antiflood.command.enabled":     success = Config(iplayer, args, subsection, ref config.AntiFlood.Command.Enabled,     AntiFlood.Command.Subscribe); break;
                        case "antiflood.command.sensitivity": success = Config(iplayer, args, subsection, ref config.AntiFlood.Command.Sensitivity, AntiFlood.Command.Configure); break;
                        case "antiflood.command.warn":        success = Config(iplayer, args, subsection, ref config.AntiFlood.Command.Warn,        AntiFlood.Command.Configure); break;
                        }

                        if(!success) Chat.Reply(iplayer, Key.CommandConfigAntiFloodCommandSyntax, command_replace);

                        return;

                    case "antiflood.itemdrop":
                        switch(subsection)
                        {
                        case "antiflood.itemdrop.ban":         success = Config(iplayer, args, subsection, ref config.AntiFlood.ItemDrop.Ban,         AntiFlood.ItemDrop.Configure); break;
                        case "antiflood.itemdrop.cooldown":    success = Config(iplayer, args, subsection, ref config.AntiFlood.ItemDrop.Cooldown,    AntiFlood.ItemDrop.Configure); break;
                        case "antiflood.itemdrop.enabled":     success = Config(iplayer, args, subsection, ref config.AntiFlood.ItemDrop.Enabled,     AntiFlood.ItemDrop.Subscribe); break;
                        case "antiflood.itemdrop.sensitivity": success = Config(iplayer, args, subsection, ref config.AntiFlood.ItemDrop.Sensitivity, AntiFlood.ItemDrop.Configure); break;
                        case "antiflood.itemdrop.warn":        success = Config(iplayer, args, subsection, ref config.AntiFlood.ItemDrop.Warn,        AntiFlood.ItemDrop.Configure); break;
                        }

                        if(!success) Chat.Reply(iplayer, Key.CommandConfigAntiFloodItemDropSyntax, command_replace);

                        return;
                    }

                    Chat.Reply(iplayer, Key.CommandConfigAntiFloodSyntax, command_replace);

                    return;

                case "ban":
                    switch(subsection)
                    {
                    case "ban.inherit":       success = Config(iplayer, args, subsection, ref config.Ban.Inherit); break;
                    case "ban.teleport":      success = Config(iplayer, args, subsection, ref config.Ban.Teleport); break;
                    case "ban.time.enforce":  success = Config(iplayer, args, subsection, ref config.Ban.Time.Enforce); break;
                    case "ban.time.multiply": success = Config(iplayer, args, subsection, ref config.Ban.Time.Multiply); break;
                    case "ban.time.seconds":  success = Config(iplayer, args, subsection, ref config.Ban.Time.Seconds); break;
                    }

                    if(!success) Chat.Reply(iplayer, Key.CommandConfigBanSyntax, command_replace);

                    return;

                case "cripple":
                    switch(subsection)
                    {
                    case "cripple.heal":    success = Config(iplayer, args, subsection, ref config.Cripple.Heal); break;
                    case "cripple.inherit": success = Config(iplayer, args, subsection, ref config.Cripple.Inherit); break;
                    }

                    if(!success) Chat.Reply(iplayer, Key.CommandConfigCrippleSyntax, command_replace);

                    return;

                case "discord":
                    switch(subsection)
                    {
                    case "discord.enabled":                   success = Config(iplayer, args, subsection, ref config.Discord.Enabled, () => Discord.Subscribe()); break;
                    case "discord.webhook":                   success = Config(iplayer, args, subsection, ref config.Discord.WebHook); break;
                    case "discord.filters.anticheat.enabled": success = Config(iplayer, args, subsection, ref config.Discord.Filters.AntiCheat.Enabled); break;
                    case "discord.filters.anticheat.webhook": success = Config(iplayer, args, subsection, ref config.Discord.Filters.AntiCheat.WebHook); break;
                    case "discord.filters.antiflood.enabled": success = Config(iplayer, args, subsection, ref config.Discord.Filters.AntiFlood.Enabled); break;
                    case "discord.filters.antiflood.webhook": success = Config(iplayer, args, subsection, ref config.Discord.Filters.AntiFlood.WebHook); break;
                    case "discord.filters.ip.enabled":        success = Config(iplayer, args, subsection, ref config.Discord.Filters.IP.Enabled); break;
                    case "discord.filters.ip.webhook":        success = Config(iplayer, args, subsection, ref config.Discord.Filters.IP.WebHook); break;
                    case "discord.filters.steam.enabled":     success = Config(iplayer, args, subsection, ref config.Discord.Filters.Steam.Enabled); break;
                    case "discord.filters.steam.webhook":     success = Config(iplayer, args, subsection, ref config.Discord.Filters.Steam.WebHook); break;
                    case "discord.filters.vpn.enabled":       success = Config(iplayer, args, subsection, ref config.Discord.Filters.VPN.Enabled); break;
                    case "discord.filters.vpn.webhook":       success = Config(iplayer, args, subsection, ref config.Discord.Filters.VPN.WebHook); break;
                    }

                    if(!success) Chat.Reply(iplayer, Key.CommandConfigDiscordSyntax, command_replace);

                    return;

                case "entity":
                    switch(subsection)
                    {
                    case "entity.damage.animal":     success = Config(iplayer, args, subsection, ref config.Entity.Damage.Animal,     () => config.Entity.Damage.Validate()); break;
                    case "entity.damage.bradley":    success = Config(iplayer, args, subsection, ref config.Entity.Damage.Bradley,    () => config.Entity.Damage.Validate()); break;
                    case "entity.damage.building":   success = Config(iplayer, args, subsection, ref config.Entity.Damage.Building,   () => config.Entity.Damage.Validate()); break;
                    case "entity.damage.entity":     success = Config(iplayer, args, subsection, ref config.Entity.Damage.Entity,     () => config.Entity.Damage.Validate()); break;
                    case "entity.damage.friend":     success = Config(iplayer, args, subsection, ref config.Entity.Damage.Friend,     () => config.Entity.Damage.Validate()); break;
                    case "entity.damage.helicopter": success = Config(iplayer, args, subsection, ref config.Entity.Damage.Helicopter, () => config.Entity.Damage.Validate()); break;
                    case "entity.damage.npc":        success = Config(iplayer, args, subsection, ref config.Entity.Damage.NPC,        () => config.Entity.Damage.Validate()); break;
                    case "entity.damage.player":     success = Config(iplayer, args, subsection, ref config.Entity.Damage.Player,     () => config.Entity.Damage.Validate()); break;
                    case "entity.damage.team":       success = Config(iplayer, args, subsection, ref config.Entity.Damage.Team,       () => config.Entity.Damage.Validate()); break;
                    case "entity.damage.trap":       success = Config(iplayer, args, subsection, ref config.Entity.Damage.Trap,       () => config.Entity.Damage.Validate()); break;
                    }

                    if(!success) Chat.Reply(iplayer, Key.CommandConfigEntitySyntax, command_replace);

                    return;

                case "ip":
                    switch(subsection)
                    {
                    case "ip.filter.cooldown":   success = Config(iplayer, args, subsection, ref config.IP.Filter.Cooldown, IP.Configure); break;
                    case "ip.violation.ban":     success = Config(iplayer, args, subsection, ref config.IP.Violation.Ban); break;
                    case "ip.violation.enabled": success = Config(iplayer, args, subsection, ref config.IP.Violation.Enabled); break;
                    }

                    if(!success) Chat.Reply(iplayer, Key.CommandConfigIpSyntax, command_replace);

                    return;

                case "log":
                    switch(subsection)
                    {
                    case "log.anticheat.aim":        success = Config(iplayer, args, subsection, ref config.Log.AntiCheat.Aim); break;
                    case "log.anticheat.gravity":    success = Config(iplayer, args, subsection, ref config.Log.AntiCheat.Gravity); break;
                    case "log.anticheat.meleerate":  success = Config(iplayer, args, subsection, ref config.Log.AntiCheat.MeleeRate); break;
                    case "log.anticheat.recoil":     success = Config(iplayer, args, subsection, ref config.Log.AntiCheat.Recoil); break;
                    case "log.anticheat.server":     success = Config(iplayer, args, subsection, ref config.Log.AntiCheat.Server); break;
                    case "log.anticheat.stash":      success = Config(iplayer, args, subsection, ref config.Log.AntiCheat.Stash); break;
                    case "log.anticheat.trajectory": success = Config(iplayer, args, subsection, ref config.Log.AntiCheat.Trajectory); break;
                    case "log.antiflood.itemdrop":   success = Config(iplayer, args, subsection, ref config.Log.AntiFlood.ItemDrop); break;
                    case "log.ip.filter":            success = Config(iplayer, args, subsection, ref config.Log.IP.Filter); break;
                    case "log.projectile.collapse":  success = Config(iplayer, args, subsection, ref config.Log.Projectile.Collapse); break;
                    case "log.projectile.verbose":   success = Config(iplayer, args, subsection, ref config.Log.Projectile.Verbose); break;
                    case "log.user.bypass":          success = Config(iplayer, args, subsection, ref config.Log.User.Bypass); break;
                    case "log.user.connect":         success = Config(iplayer, args, subsection, ref config.Log.User.Connect); break;
                    case "log.vpn.check":            success = Config(iplayer, args, subsection, ref config.Log.VPN.Check); break;
                    }

                    if(!success) Chat.Reply(iplayer, Key.CommandConfigLogSyntax, command_replace);

                    return;

                case "save":
                    if((args.Length == 1) && (subsection == "save"))
                    {
                        Configuration.Save();

                        Chat.Reply(iplayer, Key.CommandConfig, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Saved, iplayer) },
                            { "info", Text.GetPlain(Key.file, iplayer) }
                        });

                        return;
                    }

                    Chat.Reply(iplayer, Key.CommandConfigSaveSyntax, command_replace);

                    return;

                case "steam":
                    switch(subsection)
                    {
                    case "steam.api.apikey":        success = Config(iplayer, args, subsection, ref config.Steam.API.ApiKey,        Steam.Configure); break;
                    case "steam.api.enabled":       success = Config(iplayer, args, subsection, ref config.Steam.API.Enabled,       Steam.Configure); break;
                    case "steam.ban.active":        success = Config(iplayer, args, subsection, ref config.Steam.Ban.Active,        Steam.Configure); break;
                    case "steam.ban.community":     success = Config(iplayer, args, subsection, ref config.Steam.Ban.Community,     Steam.Configure); break;
                    case "steam.ban.days":          success = Config(iplayer, args, subsection, ref config.Steam.Ban.Days,          Steam.Configure); break;
                    case "steam.ban.economy":       success = Config(iplayer, args, subsection, ref config.Steam.Ban.Economy,       Steam.Configure); break;
                    case "steam.ban.game":          success = Config(iplayer, args, subsection, ref config.Steam.Ban.Game,          Steam.Configure); break;
                    case "steam.ban.vac":           success = Config(iplayer, args, subsection, ref config.Steam.Ban.VAC,           Steam.Configure); break;
                    case "steam.game.count":        success = Config(iplayer, args, subsection, ref config.Steam.Game.Count,        Steam.Configure); break;
                    case "steam.game.hours":        success = Config(iplayer, args, subsection, ref config.Steam.Game.Hours,        Steam.Configure); break;
                    case "steam.profile.invalid":   success = Config(iplayer, args, subsection, ref config.Steam.Profile.Invalid,   Steam.Configure); break;
                    case "steam.profile.limited":   success = Config(iplayer, args, subsection, ref config.Steam.Profile.Limited,   Steam.Configure); break;
                    case "steam.profile.private":   success = Config(iplayer, args, subsection, ref config.Steam.Profile.Private,   Steam.Configure); break;
                    case "steam.share.family":      success = Config(iplayer, args, subsection, ref config.Steam.Share.Family,      Steam.Configure); break;
                    case "steam.violation.ban":     success = Config(iplayer, args, subsection, ref config.Steam.Violation.Ban); break;
                    case "steam.violation.enabled": success = Config(iplayer, args, subsection, ref config.Steam.Violation.Enabled); break;
                    case "steam.violation.warn":    success = Config(iplayer, args, subsection, ref config.Steam.Violation.Warn, Steam.Configure); break;
                    }

                    if(!success) Chat.Reply(iplayer, Key.CommandConfigSteamSyntax, command_replace);

                    return;

                case "user":
                    switch(subsection)
                    {
                    case "user.bypass.dayssincelastban": success = Config(iplayer, args, subsection, ref config.User.Bypass.DaysSinceBan); break;
                    case "user.bypass.enabled":          success = Config(iplayer, args, subsection, ref config.User.Bypass.Enabled); break;
                    case "user.bypass.hoursplayed":      success = Config(iplayer, args, subsection, ref config.User.Bypass.HoursPlayed); break;
                    case "user.bypass.multiply":         success = Config(iplayer, args, subsection, ref config.User.Bypass.Multiply); break;
                    case "user.friend.damage":           success = Config(iplayer, args, subsection, ref config.User.Friend.Damage); break;
                    case "user.team.damage":             success = Config(iplayer, args, subsection, ref config.User.Team.Damage); break;
                    }

                    if(!success) Chat.Reply(iplayer, Key.CommandConfigUserSyntax, command_replace);

                    return;
                case "violation":
                    switch(subsection)
                    {
                    case "violation.ban":         success = Config(iplayer, args, subsection, ref config.Violation.Ban,         Violation.Configure); break;
                    case "violation.cooldown":    success = Config(iplayer, args, subsection, ref config.Violation.Cooldown,    Violation.Configure); break;
                    case "violation.sensitivity": success = Config(iplayer, args, subsection, ref config.Violation.Sensitivity, Violation.Configure); break;
                    }

                    if(!success) Chat.Reply(iplayer, Key.CommandConfigViolationSyntax, command_replace);

                    return;

                case "vpn":
                    switch(subsection)
                    {
                    case "vpn.api.getipintel.apikey":      success = Config(iplayer, args, subsection, ref config.VPN.API.GetIpIntel.ApiKey); break;
                    case "vpn.api.getipintel.enabled":     success = Config(iplayer, args, subsection, ref config.VPN.API.GetIpIntel.Enabled); break;
                    case "vpn.api.ipapi.enabled":          success = Config(iplayer, args, subsection, ref config.VPN.API.IpApi.Enabled); break;
                    case "vpn.api.iphub.apikey":           success = Config(iplayer, args, subsection, ref config.VPN.API.IpHub.ApiKey, VPN.API.IpHub.Configure); break;
                    case "vpn.api.iphub.enabled":          success = Config(iplayer, args, subsection, ref config.VPN.API.IpHub.Enabled); break;
                    case "vpn.api.ipqualityscore.apikey":  success = Config(iplayer, args, subsection, ref config.VPN.API.IpQualityScore.ApiKey); break;
                    case "vpn.api.ipqualityscore.enabled": success = Config(iplayer, args, subsection, ref config.VPN.API.IpQualityScore.Enabled); break;
                    case "vpn.cache.hours":                success = Config(iplayer, args, subsection, ref config.VPN.Cache.Hours); break;
                    case "vpn.check.enabled":              success = Config(iplayer, args, subsection, ref config.VPN.Check.Enabled); break;
                    case "vpn.check.strict":               success = Config(iplayer, args, subsection, ref config.VPN.Check.Strict); break;
                    case "vpn.violation.ban":              success = Config(iplayer, args, subsection, ref config.VPN.Violation.Ban); break;
                    case "vpn.violation.enabled":          success = Config(iplayer, args, subsection, ref config.VPN.Violation.Enabled); break;
                    case "vpn.violation.warn":             success = Config(iplayer, args, subsection, ref config.VPN.Violation.Warn, VPN.Configure); break;
                    }

                    if(!success) Chat.Reply(iplayer, Key.CommandConfigVpnSyntax, command_replace);

                    return;
                }

            syntax_error:
                Chat.Reply(iplayer, Key.CommandConfigSyntax, command_replace);
            }
            private static string Config(string subsection)
            {
                var split = subsection.Split('.');

                if(split.Length >= 2)
                {
                    return split[0] + "." + split[1];
                }

                return subsection;
            }
            private static bool Config<T>(IPlayer iplayer, string[] args, string setting, ref T value, Action callback = null)
            {
                bool changed = false, success = false;

                if(args.Length == 1)
                {
                    success = true;
                }
                else if(args.Length == 2)
                {
                    if(typeof(T) == typeof(bool))
                    {
                        bool new_value;

                        if(bool.TryParse(args[1], out new_value))
                        {
                            if(!value.Equals(new_value))
                            {
                                changed = true; value = (T)Convert.ChangeType(new_value, typeof(T));
                            }

                            success = true;
                        }
                    }
                    else if(typeof(T) == typeof(float))
                    {
                        float new_value;

                        if(float.TryParse(args[1], out new_value))
                        {
                            if(!value.Equals(new_value))
                            {
                                changed = true; value = (T)Convert.ChangeType(new_value, typeof(T));
                            }

                            success = true;
                        }
                    }
                    else if(typeof(T) == typeof(string))
                    {
                        string new_value = args[1];

                        if(!value.Equals(new_value))
                        {
                            changed = true; value = (T)Convert.ChangeType(new_value, typeof(T));
                        }

                        success = true;
                    }
                    else if(typeof(T) == typeof(ulong))
                    {
                        ulong new_value;

                        if(ulong.TryParse(args[1], out new_value))
                        {
                            if(!value.Equals(new_value))
                            {
                                changed = true; value = (T)Convert.ChangeType(new_value, typeof(T));
                            }

                            success = true;
                        }
                    }
                    else
                    {
                        throw new NotImplementedException($"{_instance.Name}.Command.Config<T>: No conversion case exists for type T={typeof(T).Name}.");
                    }
                }

                if(success)
                {
                    if(changed)
                    {
                        Configuration.SetDirty();

                        callback?.Invoke();
                    }

                    Chat.Reply(iplayer, Key.CommandConfig, new Dictionary<string, string>
                    {
                        { "action", Text.GetPlain(changed ? Key.Changed : Key.Current, iplayer) },
                        { "info", $"{setting}={value}" }
                    });
                }

                return success;
            }

            private static void Help(IPlayer iplayer, string command, string[] args)
            {
                BasePlayer player = iplayer.IsServer ? null : iplayer.Object as BasePlayer;

                if((player != null) && !Permissions.Admin(player.userID))
                {
                    Chat.Reply(iplayer, Key.CommandNoPermission);

                    return;
                }

                var console = iplayer.IsServer || (iplayer.LastCommand == CommandType.Console);

                StringBuilder aliases = new StringBuilder(), entries = new StringBuilder();

                foreach(var entry in info)
                {
                    foreach(var alias in entry.Aliases)
                    {
                        aliases.Append(console ? "\n    " : "\n    /").Append(alias);
                    }

                    entries.Append(Text.Get(Key.CommandHelpEntry, iplayer, new Dictionary<string, string>
                    {
                        { "aliases", aliases.ToString() },
                        { "title", Text.GetPlain(entry.Title, iplayer) }
                    }));

                    aliases.Clear();
                }

                Chat.Reply(iplayer, Key.CommandHelp, new Dictionary<string, string>
                {
                    { "entries", entries.ToString() },
                    { "name", _instance.Name },
                    { "version", Version.String }
                });
            }

            private static void Ip(IPlayer iplayer, string command, string[] args)
            {
                BasePlayer player = iplayer.IsServer ? null : iplayer.Object as BasePlayer;

                if((player != null) && !Permissions.Command.Ip(player.userID))
                {
                    Chat.Reply(iplayer, Key.CommandNoPermission);

                    return;
                }
                else if(args.Length == 0)
                {
                    goto syntax_error;
                }

                switch(args[0].ToLower())
                {
                case "allow":
                    if(args.Length == 1)
                    {
                        Ip(iplayer, Key.Allowed, IP.GetAllows());

                        return;
                    }
                    else if(args.Length == 2)
                    {
                        var network = IP.Network(args[1]);

                        if(network?.Address != null)
                        {
                            Ip(iplayer, Key.Allowed, IP.GetAllows(network.Address));

                            return;
                        }
                    }
                    else if(args.Length == 3)
                    {
                        var network = IP.Network(args[2]);

                        if(network?.Address != null)
                        {
                            switch(args[1].ToLower())
                            {
                            case "add":
                                Ip(iplayer, Key.Allowed, network, true);

                                return;

                            case "remove":
                                Ip(iplayer, Key.Allowed, network, false);

                                return;
                            }
                        }
                    }

                    break;

                case "block":
                    if((args.Length == 2) && IP.IsValid(args[1]))
                    {
                        IP.Block(args[1]);

                        Chat.Reply(iplayer, Key.CommandIp, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Blocked, iplayer) },
                            { "info", args[1] }
                        });

                        return;
                    }

                    break;

                case "bypass":
                    if((args.Length == 2) && IP.IsValid(args[1]))
                    {
                        IP.Bypass(args[1]);

                        Chat.Reply(iplayer, Key.CommandIp, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Bypassed, iplayer) },
                            { "info", args[1] }
                        });

                        return;
                    }

                    break;

                case "deny":
                    if(args.Length == 1)
                    {
                        Ip(iplayer, Key.Denied, IP.GetDenies());

                        return;
                    }
                    else if(args.Length == 2)
                    {
                        var network = IP.Network(args[1]);

                        if(network?.Address != null)
                        {
                            Ip(iplayer, Key.Denied, IP.GetDenies(network.Address));

                            return;
                        }
                    }
                    else if(args.Length == 3)
                    {
                        var network = IP.Network(args[2]);

                        if(network?.Address != null)
                        {
                            switch(args[1].ToLower())
                            {
                            case "add":
                                Ip(iplayer, Key.Denied, network, true);

                                return;

                            case "remove":
                                Ip(iplayer, Key.Denied, network, false);

                                return;
                            }
                        }
                    }

                    break;

                case "save":
                    if(args.Length == 1)
                    {
                        IP.Save();

                        Chat.Reply(iplayer, Key.CommandIp, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Saved, iplayer) },
                            { "info", Text.GetPlain(Key.data, iplayer) }
                        });

                        return;
                    }

                    break;

                case "unblock":
                    if((args.Length == 2) && IP.IsValid(args[1]))
                    {
                        IP.Unblock(args[1]);

                        Chat.Reply(iplayer, Key.CommandIp, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Unblocked, iplayer) },
                            { "info", args[1] }
                        });

                        return;
                    }

                    break;
                }

            syntax_error:
                Chat.Reply(iplayer, Key.CommandIpSyntax, new Dictionary<string, string>
                {
                    { "command", (iplayer.LastCommand == CommandType.Console) ? command : ("/" + command) }
                });
            }
            private static void Ip(IPlayer iplayer, Key key, IP.NetworkInfo network, bool add)
            {
                bool success;

                if(key == Key.Allowed)
                {
                    if(success = IP.SetAllow(network, add))
                    {
                        IP.Bypass(network);
                    }
                }
                else
                {
                    if(success = IP.SetDeny(network, add))
                    {
                        IP.Block(network);
                    }
                }

                if(success)
                {
                    Chat.Reply(iplayer, Key.CommandIpEntry, new Dictionary<string, string>
                    {
                        { "action", Text.GetPlain(add ? Key.Added : Key.Removed, iplayer) },
                        { "entry", $"{network.Address}/{network.Bits}" }
                    });
                }
                else
                {
                    Chat.Reply(iplayer, Key.CommandIpEntryFailed, new Dictionary<string, string>
                    {
                        { "action", Text.GetPlain(add ? Key.add : Key.remove, iplayer) },
                        { "entry", $"{network.Address}/{network.Bits}" }
                    });
                }
            }
            private static void Ip(IPlayer iplayer, Key key, List<string> list)
            {
                StringBuilder addresses = new StringBuilder();

                if(list.Count == 0)
                {
                    addresses.Append(Text.GetPlain(Key.empty, iplayer));
                }
                else
                {
                    foreach(var address in list)
                    {
                        addresses.Append("\n    ").Append(address);
                    }
                }

                Chat.Reply(iplayer, Key.CommandIpList, new Dictionary<string, string>
                {
                    { "addresses", addresses.ToString() },
                    { "type", Text.GetPlain(key, iplayer) }
                });
            }

            private static void Log(IPlayer iplayer, string command, string[] args)
            {
                BasePlayer player = iplayer.IsServer ? null : iplayer.Object as BasePlayer;

                if((player != null) && !Permissions.Admin(player.userID))
                {
                    Chat.Reply(iplayer, Key.CommandNoPermission);

                    return;
                }
                else if((args.Length == 0) || (args.Length > 2))
                {
                    goto syntax_error;
                }

                var userids = User.Find(args[0]);

                if(userids.Count == 0)
                {
                    Chat.Reply(iplayer, Key.CommandUserNotFound);

                    return;
                }
                else if(userids.Count == 1)
                {
                    int lines = 0;

                    if(args.Length == 2)
                    {
                        int.TryParse(args[1], out lines);
                    }

                    if((lines = Generic.Clamp(lines, 0, 64)) == 0)
                    {
                        lines = 20;
                    }

                    foreach(var userid in userids)
                    {
                        Projectile.Log.Get(iplayer, userid, lines);

                        return;
                    }
                }
                else
                {
                    Users(iplayer, Key.CommandUserTooMany, userids);

                    return;
                }


            syntax_error:
                Chat.Reply(iplayer, Key.CommandLogSyntax, new Dictionary<string, string>
                {
                    { "command", (iplayer.LastCommand == CommandType.Console) ? command : ("/" + command) }
                });
            }

            private static void Server(IPlayer iplayer, string command, string[] args)
            {
                BasePlayer player = iplayer.IsServer ? null : iplayer.Object as BasePlayer;

                if((player != null) && !Permissions.Command.Server(player.userID))
                {
                    Chat.Reply(iplayer, Key.CommandNoPermission);

                    return;
                }
                else if(args.Length != 1)
                {
                    goto syntax_error;
                }

                switch(args[0].ToLower())
                {
                case "pardon": User.Pardon(iplayer); return;
                case "unban": User.Unban(iplayer); return;
                case "uncripple": User.Uncripple(iplayer); return;
                }

            syntax_error:
                Chat.Reply(iplayer, Key.CommandServerSyntax, new Dictionary<string, string>
                {
                    { "command", (iplayer.LastCommand == CommandType.Console) ? command : ("/" + command) }
                });
            }

            private static void Teleport(IPlayer iplayer, string command, string[] args)
            {
                BasePlayer player = iplayer.IsServer ? null : iplayer.Object as BasePlayer;

                if((player != null) && !Permissions.Command.Tp(player.userID))
                {
                    Chat.Reply(iplayer, Key.CommandNoPermission);

                    return;
                }
                else if(args.Length != 1)
                {
                    goto syntax_error;
                }

                var userids = User.Find(args[0]);

                if(userids.Count == 0)
                {
                    Chat.Reply(iplayer, Key.CommandUserNotFound);

                    return;
                }
                else if(userids.Count > 1)
                {
                    Users(iplayer, Key.CommandUserTooMany, userids);

                    return;
                }

                var position = Vector3.zero;

                if(command.EndsWith(".tp"))
                {
                    foreach(var userid in userids)
                    {
                        position = User.GetLastSeenPosition(userid);
                    }
                }
                else
                {
                    foreach(var userid in userids)
                    {
                        position = User.GetViolationPosition(userid);
                    }
                }

                var found = position != Vector3.zero;

                var parameters = new Dictionary<string, string>
                {
                    { "position", found ? $"({position.x:0.0} {position.y:0.0} {position.z:0.0})" : Text.GetPlain(Key.unknown, iplayer) }
                };

                if(command.EndsWith(".tp"))
                {
                    Chat.Reply(iplayer, Key.CommandTeleport, parameters);
                }
                else
                {
                    Chat.Reply(iplayer, Key.CommandTeleportViolation, parameters);
                }

                if(found && !iplayer.IsServer)
                {
                    iplayer.Teleport(position.x, position.y, position.z);
                }

                return;

            syntax_error:
                Chat.Reply(iplayer, Key.CommandTeleportSyntax, new Dictionary<string, string>
                {
                    { "command", (iplayer.LastCommand == CommandType.Console) ? command : ("/" + command) }
                });
            }

            private static void Users(IPlayer iplayer, string command, string[] args)
            {
                BasePlayer player = iplayer.IsServer ? null : iplayer.Object as BasePlayer;

                if((player != null) && !Permissions.Admin(player.userID))
                {
                    Chat.Reply(iplayer, Key.CommandNoPermission);

                    return;
                }
                else if(args.Length == 0)
                {
                    goto syntax_error;
                }

                var is_ip = IP.IsValid(args[0]);

                var userids = User.Find(args[0]);

                if(userids.Count == 0)
                {
                    Chat.Reply(iplayer, Key.CommandUserNotFound);

                    return;
                }
                else if(userids.Count == 1)
                {
                    if(args.Length == 1)
                    {
                        foreach(var userid in userids)
                        {
                            Chat.Reply(iplayer, Key.CommandUserInfo, new Dictionary<string, string>
                            {
                                { "info", User.InfoText(userid, iplayer) }
                            });

                            return;
                        }
                    }
                }
                else if(args.Length == 1)
                {
                    Users(iplayer, Key.CommandUserTooMany, userids);

                    return;
                }
                else if(!is_ip)
                {
                    goto syntax_error;
                }

                ulong duration = 0; string duration_string = null, reason = null;

                if(args.Length == 3)
                {
                    if(!Text.ParseTime(args[2], out duration))
                    {
                        reason = string.IsNullOrEmpty(args[2]) ? null : args[2];
                    }
                }
                else if(args.Length == 4)
                {
                    reason = string.IsNullOrEmpty(args[2]) ? null : args[2];

                    if(!Text.ParseTime(args[3], out duration))
                    {
                        goto syntax_error;
                    }
                }
                else if(args.Length > 4)
                {
                    goto syntax_error;
                }

                if(duration == 0)
                {
                    duration_string = Text.GetPlain(Key.permanently, iplayer);
                }
                else
                {
                    duration_string = $"{Text.GetPlain(Key.For, iplayer)} {Text.Duration.Short(TimeSpan.FromSeconds(duration), iplayer)}";
                }

                var subcommand = args[1].ToLower();

                if(subcommand.StartsWith("team"))
                {
                    var dot = subcommand.IndexOf('.') + 1;

                    if(subcommand.Length > dot)
                    {
                        subcommand = subcommand.Substring(dot);
                    }

                    var team = new HashSet<ulong>();

                    foreach(var userid in userids)
                    {
                        foreach(var entry in User.Team(userid))
                        {
                            team.Add(entry);
                        }
                    }

                    foreach(var entry in team)
                    {
                        userids.Add(entry);
                    }
                }

                switch(subcommand)
                {
                case "ban":
                    foreach(var userid in userids)
                    {
                        User.Ban(userid, reason, duration, iplayer);

                        Chat.Reply(iplayer, Key.CommandUser, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Banned, iplayer) },
                            { "duration", duration_string },
                            { "playername", Text.Sanitize(User.Name(userid)) },
                            { "playerid", userid.ToString() },
                            { "reason", reason }
                        });
                    }

                    return;

                case "ban.reset":
                    if(args.Length != 2)
                    {
                        goto syntax_error;
                    }

                    foreach(var userid in userids)
                    {
                        User.BanReset(userid, iplayer);

                        Chat.Reply(iplayer, Key.CommandUserAction, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.BanReset, iplayer) },
                            { "playername", Text.Sanitize(User.Name(userid)) },
                            { "playerid", userid.ToString() }
                        });
                    }

                    return;

                case "cripple":
                    foreach(var userid in userids)
                    {
                        User.Cripple(userid, reason, duration, iplayer);

                        Chat.Reply(iplayer, Key.CommandUser, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Crippled, iplayer) },
                            { "duration", duration_string },
                            { "playername", Text.Sanitize(User.Name(userid)) },
                            { "playerid", userid.ToString() },
                            { "reason", reason }
                        });
                    }

                    return;

                case "cripple.reset":
                    if(args.Length != 2)
                    {
                        goto syntax_error;
                    }

                    foreach(var userid in userids)
                    {
                        User.CrippleReset(userid, iplayer);

                        Chat.Reply(iplayer, Key.CommandUserAction, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.CrippleReset, iplayer) },
                            { "playername", Text.Sanitize(User.Name(userid)) },
                            { "playerid", userid.ToString() }
                        });
                    }

                    return;

                case "kick":
                    if((args.Length > 3) || ((args.Length == 3) && (reason == null)))
                    {
                        goto syntax_error;
                    }

                    foreach(var userid in userids)
                    {
                        User.Kick(userid, reason, iplayer);

                        Chat.Reply(iplayer, Key.CommandUserKick, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Kicked, iplayer) },
                            { "playername", Text.Sanitize(User.Name(userid)) },
                            { "playerid", userid.ToString() },
                            { "reason", reason }
                        });
                    }

                    return;

                case "pardon":
                    if(args.Length != 2)
                    {
                        goto syntax_error;
                    }

                    foreach(var userid in userids)
                    {
                        User.Pardon(userid, iplayer);

                        Chat.Reply(iplayer, Key.CommandUserAction, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Pardoned, iplayer) },
                            { "playername", Text.Sanitize(User.Name(userid)) },
                            { "playerid", userid.ToString() }
                        });
                    }

                    return;

                case "team":
                    if(args.Length != 2)
                    {
                        goto syntax_error;
                    }

                    Users(iplayer, Key.CommandUserTeam, userids);

                    return;

                case "unban":
                    if(args.Length != 2)
                    {
                        goto syntax_error;
                    }

                    foreach(var userid in userids)
                    {
                        User.Unban(userid, true, iplayer);

                        Chat.Reply(iplayer, Key.CommandUserAction, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Unbanned, iplayer) },
                            { "playername", Text.Sanitize(User.Name(userid)) },
                            { "playerid", userid.ToString() }
                        });
                    }

                    return;

                case "uncripple":
                    if(args.Length != 2)
                    {
                        goto syntax_error;
                    }

                    foreach(var userid in userids)
                    {
                        User.Uncripple(userid, true, iplayer);

                        Chat.Reply(iplayer, Key.CommandUserAction, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Uncrippled, iplayer) },
                            { "playername", Text.Sanitize(User.Name(userid)) },
                            { "playerid", userid.ToString() }
                        });
                    }

                    return;
                }

            syntax_error:
                Chat.Reply(iplayer, Key.CommandUserSyntax, new Dictionary<string, string>
                {
                    { "command", (iplayer.LastCommand == CommandType.Console) ? command : ("/" + command) }
                });
            }
            private static void Users(IPlayer iplayer, Key key, HashSet<ulong> userids)
            {
                var users = new StringBuilder();

                foreach(var userid in userids)
                {
                    users.Append("\n    ");
                    users.Append(userid.ToString());
                    users.Append(" - ");
                    users.Append(User.Name(userid));
                    users.Append(" (");
                    users.Append(User.StatusText(userid, iplayer));
                    users.Append(')');
                }

                Chat.Reply(iplayer, key, new Dictionary<string, string>
                {
                    { "users", users.ToString() }
                });

                users.Clear();
            }

            private static void Vpn(IPlayer iplayer, string command, string[] args)
            {
                BasePlayer player = iplayer.IsServer ? null : iplayer.Object as BasePlayer;

                if((player != null) && !Permissions.Command.Vpn(player.userID))
                {
                    Chat.Reply(iplayer, Key.CommandNoPermission);

                    return;
                }
                else if(args.Length != 2)
                {
                    goto syntax_error;
                }

                var address = args[1];

                if(!IP.IsValid(address))
                {
                    goto syntax_error;
                }

                switch(args[0].ToLower())
                {
                case "bypass":
                        VPN.Bypass(address);

                        IP.Unblock(address);

                        Vpn(iplayer, Key.Bypassed, address);

                        return;

                case "status":
                    Vpn(iplayer, Key.Current, address);

                    return;

                case "unblock":
                        VPN.Unblock(address);

                        IP.Unblock(address);

                        Vpn(iplayer, Key.Unblocked, address);

                        return;
                }

            syntax_error:
                Chat.Reply(iplayer, Key.CommandVpnSyntax, new Dictionary<string, string>
                {
                    { "command", (iplayer.LastCommand == CommandType.Console) ? command : ("/" + command) }
                });
            }
            private static void Vpn(IPlayer iplayer, Key key, string address)
            {
                var info = VPN.IsBlocked(address)  ? Text.GetPlain(Key.Blocked,   iplayer) :
                           VPN.IsBypassed(address) ? Text.GetPlain(Key.Bypassed,  iplayer) :
                                                     Text.GetPlain(Key.Unblocked, iplayer);

                Chat.Reply(iplayer, Key.CommandVpn, new Dictionary<string, string>
                {
                    { "action", Text.Get(key, iplayer) },
                    { "info", $"{info}({address})" }
                });
            }
        }

        #endregion _command_

        #region _configuration_

        private static Configuration config;

        private class Configuration
        {
            public Admin.Settings     Admin;
            public AntiCheat.Settings AntiCheat;
            public AntiFlood.Settings AntiFlood;
            public Ban.Settings       Ban;
            public Cripple.Settings   Cripple;
            public Discord.Settings   Discord;
            public Entity.Settings    Entity;
            public IP.Settings        IP;
            public Log.Settings       Log;
            public Steam.Settings     Steam;
            public User.Settings      User;
            public Version.Settings   Version;
            public Violation.Settings Violation;
            public VPN.Settings       VPN;

            private static bool corrupt  = false;
            private static bool dirty    = false;
            private static bool upgraded = false;

            public static void Clamp<T>(ref T value, T min, T max) where T : IComparable<T>
            {
                T clamped = Generic.Clamp(value, min, max);

                if(!value.Equals(clamped))
                {
                    dirty = true; value = clamped;
                }
            }

            public static void Load()
            {
                dirty = false;

                try
                {
                    config = _instance.Config.ReadObject<Configuration>();

                    config.Version.Compare(0, 0, 0);
                }
                catch(NullReferenceException)
                {
                    Guardian.Log.Warning("Configuration: Created new configuration with default settings.");

                    dirty = true; config = new Configuration();
                }
                catch(JsonException e)
                {
                    Guardian.Log.Error("Configuration: Using default settings. Delete the configuration file, or fix the following error, and reload; " + e.ToString());

                    corrupt = true; config = new Configuration();
                }

                Validate();
            }

            public static void Save()
            {
                if(dirty && !corrupt)
                {
                    dirty = false;

                    _instance.Config.WriteObject(config);
                }
            }

            public static void SetDirty() => dirty = true;

            public static void SetUpgrade(bool upgrade = true) => upgraded = upgrade;

            public static void Unload()
            {
                Save();

                config = null;
            }

            public static bool Upgraded() => upgraded;

            public static void Validate<T>(ref T value, Func<T> initializer, Action validator = null)
            {
                if(value == null)
                {
                    dirty = true; value = initializer();
                }
                else
                {
                    validator?.Invoke();
                }
            }

            private static void Validate()
            {
                Validate(ref config.Admin,     () => new Admin.Settings());
                Validate(ref config.AntiCheat, () => new AntiCheat.Settings(), () => config.AntiCheat.Validate());
                Validate(ref config.AntiFlood, () => new AntiFlood.Settings(), () => config.AntiFlood.Validate());
                Validate(ref config.Ban,       () => new Ban.Settings(),       () => config.Ban.Validate());
                Validate(ref config.Cripple,   () => new Cripple.Settings());
                Validate(ref config.Discord,   () => new Discord.Settings(),   () => config.Discord.Validate());
                Validate(ref config.Entity,    () => new Entity.Settings(),    () => config.Entity.Validate());
                Validate(ref config.IP,        () => new IP.Settings(),        () => config.IP.Validate());
                Validate(ref config.Log,       () => new Log.Settings(),       () => config.Log.Validate());
                Validate(ref config.Steam,     () => new Steam.Settings(),     () => config.Steam.Validate());
                Validate(ref config.User,      () => new User.Settings(),      () => config.User.Validate());
                Validate(ref config.Version,   () => new Version.Settings());
                Validate(ref config.Violation, () => new Violation.Settings());
                Validate(ref config.VPN,       () => new VPN.Settings(),       () => config.VPN.Validate());

                config.Version.Validate();
            }
        }

        #endregion _conifguration_

        #region _counter_

        private class Counter
        {
            private uint count;
            private uint delay;

            public Counter()
            {
                count = delay = 0;
            }

            public void Decrement()
            {
                if((delay >> 31) == 1)
                {
                    --count;
                }

                delay <<= 1;
            }

            public void Increment()
            {
                if((delay >> 31) == 0)
                {
                    ++count;
                }

                delay = (delay << 1) + 1;
            }

            public uint Percent()
            {
                return (100u * count) >> 5;
            }

            public float Ratio(bool inverse = false)
            {
                return inverse ? (1.0f - (count * 0.03125f)) : (count * 0.03125f);
            }

            public float Ratio(float scale, bool inverse = false)
            {
                return (inverse ? (1.0f - (count * 0.03125f)) : (count * 0.03125f)) * scale;
            }

            public ulong Total()
            {
                return count;
            }
        }

        #endregion _counter_

        #region _cripple_

        public class Cripple
        {
            public class Settings
            {
                public bool Heal;
                public bool Inherit;

                public Settings()
                {
                    Heal = false;
                    Inherit = true;
                }
            }
        }

        #endregion _cripple_

        #region _data_

        private class Data
        {
            private static DataFileSystem data = null;
            private static string         path = null;

            public static void Close()
            {
                data = null;
                path = null;
            }

            public static bool Exists(string name)
            {
                return data.ExistsDatafile(name);
            }

            public static void Open()
            {
                path = $"{Interface.Oxide.DataDirectory}\\{_instance.Name}";

                data = new DataFileSystem(path);
            }

            public static T ReadObject<T>(string name)
            {
                if(!string.IsNullOrEmpty(name) && data.ExistsDatafile(name))
                {
                    try
                    {
                        return data.ReadObject<T>(name);
                    }
                    catch(JsonException)
                    {
                        Log.Warning($"Data: recreating corrupted file \'{path}\\{name}.json\'.");
                    }
                }

                return default(T);
            }

            public static void WriteObject<T>(string name, T value)
            {
                data.WriteObject(name, value);
            }
        }

        #endregion _data_

        #region _data_file_

        private class DataFile<TKey, TValue>
        {
            private readonly Dictionary<TKey, TValue> data = new Dictionary<TKey, TValue>();

            private bool dirty;

            private string name;

            public DataFile(string name = null)
            {
                dirty = false; this.name = name;
            }

            public TValue this[TKey key]
            {
                get
                {
                    return data[key];
                }

                set
                {
                    data[key] = value;

                    SetDirty();
                }
            }

            public void Add(TKey key, TValue value)
            {
                if(!data.ContainsKey(key))
                {
                    this[key] = value;
                }
            }

            public bool Contains(TKey key)
            {
                return data.ContainsKey(key);
            }

            public void Clear()
            {
                data.Clear();

                SetDirty();
            }

            public bool Exists()
            {
                if(!string.IsNullOrEmpty(name))
                {
                    return Data.Exists(name);
                }

                return false;
            }

            public void ForEach(Action<TKey, TValue> action)
            {
                foreach(var entry in data)
                {
                    action(entry.Key, entry.Value);
                }
            }

            public TValue Get(TKey key, TValue default_value)
            {
                TValue value;

                if(data.TryGetValue(key, out value))
                {
                    return value;
                }

                return default_value;
            }

            public bool IsDirty() => dirty;

            public bool IsEmpty() => data.IsEmpty();

            public void Load()
            {
                if(string.IsNullOrEmpty(name))
                {
                    return;
                }

                try
                {
                    SetDirty(false);

                    var file = Data.ReadObject<Dictionary<TKey, TValue>>(name);

                    foreach(var entry in file)
                    {
                        data[entry.Key] = entry.Value;
                    }
                }
                catch
                {
                    SetDirty();
                }

                Save();
            }

            public void Load(string name)
            {
                SetName(name);

                Load();
            }

            public void Remove(TKey key)
            {
                if(data.ContainsKey(key))
                {
                    data.Remove(key);

                    SetDirty();
                }
            }

            public void Save()
            {
                if(IsDirty())
                {
                    if(!string.IsNullOrEmpty(name))
                    {
                        Data.WriteObject(name, data);
                    }

                    SetDirty(false);
                }
            }

            public void Save(string name)
            {
                SetName(name);

                Save();
            }

            public void SetDirty(bool value = true) => dirty = value;

            public void SetName(string name)
            {
                this.name = name;

                SetDirty();
            }

            public void Unload()
            {
                Save();

                data.Clear();
            }
        }

        #endregion _data_file_

        #region _discord_

        private class Discord
        {
            public class Settings
            {
                public bool           Enabled;
                public string         WebHook;
                public DiscordFilters Filters;

                public Settings()
                {
                    Enabled = false;
                    WebHook = string.Empty;
                    Filters = new DiscordFilters();
                }

                public class DiscordFilter
                {
                    public bool   Enabled;
                    public string WebHook;

                    public DiscordFilter()
                    {
                        Enabled = true;
                        WebHook = string.Empty;
                    }

                    public string URL() => Enabled ? WebHook : null;

                    public void Validate()
                    {
                        Configuration.Validate(ref WebHook, () => { return string.Empty; });
                    }
                }

                public class DiscordFilters
                {
                    public DiscordFilter AntiCheat;
                    public DiscordFilter AntiFlood;
                    public DiscordFilter IP;
                    public DiscordFilter Steam;
                    public DiscordFilter VPN;

                    public DiscordFilters()
                    {
                        AntiCheat = new DiscordFilter();
                        AntiFlood = new DiscordFilter();
                        IP        = new DiscordFilter();
                        Steam     = new DiscordFilter();
                        VPN       = new DiscordFilter();
                    }

                    public void Validate()
                    {
                        Configuration.Validate(ref AntiCheat, () => new DiscordFilter(), () => AntiCheat.Validate());
                        Configuration.Validate(ref AntiFlood, () => new DiscordFilter(), () => AntiFlood.Validate());
                        Configuration.Validate(ref IP,        () => new DiscordFilter(), () => IP.Validate());
                        Configuration.Validate(ref Steam,     () => new DiscordFilter(), () => Steam.Validate());
                        Configuration.Validate(ref VPN,       () => new DiscordFilter(), () => VPN.Validate());
                    }
                }

                public void Validate()
                {
                    Configuration.Validate(ref WebHook, () => { return string.Empty; });
                    Configuration.Validate(ref Filters, () => new DiscordFilters(), () => Filters.Validate());
                }
            }

            public static void Send(string category, Dictionary<string, object> message)
            {
                if(!config.Discord.Enabled || (message == null))
                {
                    return;
                }

                if((message.Count == 0) || !(message.ContainsKey("content") || message.ContainsKey("embeds")))
                {
                    Log.Console(Key.LogDiscordMessage);

                    return;
                }

                var url = Select(category);

                if(string.IsNullOrWhiteSpace(url))
                {
                    if(url != null)
                    {
                        Log.Console(Key.LogDiscordConfig);
                    }

                    return;
                }

                WebHook.Send(url, "Discord", JsonConvert.SerializeObject(message));
            }

            private static string Select(string category)
            {
                string url;

                switch(Violation.Category(category))
                {
                case Key.AntiCheat: url = config.Discord.Filters.AntiCheat.URL(); break;
                case Key.AntiFlood: url = config.Discord.Filters.AntiFlood.URL(); break;
                case Key.IP:        url = config.Discord.Filters.IP.URL();        break;
                case Key.Steam:     url = config.Discord.Filters.Steam.URL();     break;
                case Key.VPN:       url = config.Discord.Filters.VPN.URL();       break;
                default:            url = null;                                   break;
                }

                if((url != null) && string.IsNullOrWhiteSpace(url))
                {
                    url = config.Discord.WebHook;
                }

                return url;
            }

            public static void Subscribe()
            {
                if(config.Discord.Enabled)
                {
                    Hooks.Subscribe(nameof(OnGuardianViolation));
                }
                else
                {
                    Hooks.Unsubscribe(nameof(OnGuardianViolation));
                }
            }
        }

        #endregion _discord_

        #region _entity_

        private class Entity
        {
            public class Settings
            {
                public EntityDamage Damage;

                public Settings()
                {
                    Damage = new EntityDamage();
                }

                public class EntityDamage
                {
                    public float Animal;
                    public float Bradley;
                    public float Building;
                    public float Entity;
                    public float Friend;
                    public float Helicopter;
                    public float NPC;
                    public float Player;
                    public float Team;
                    public float Trap;

                    public EntityDamage()
                    {
                        Animal     = 1.0f;
                        Bradley    = 1.0f;
                        Building   = 1.0f;
                        Entity     = 1.0f;
                        Friend     = 1.0f;
                        Helicopter = 1.0f;
                        NPC        = 1.0f;
                        Player     = 1.0f;
                        Team       = 1.0f;
                        Trap       = 1.0f;
                    }

                    public void Validate()
                    {
                        Configuration.Clamp(ref Animal,     0.0f, 100.0f);
                        Configuration.Clamp(ref Bradley,    0.0f, 100.0f);
                        Configuration.Clamp(ref Building,   0.0f, 100.0f);
                        Configuration.Clamp(ref Entity,     0.0f, 100.0f);
                        Configuration.Clamp(ref Friend,     0.0f, 100.0f);
                        Configuration.Clamp(ref Helicopter, 0.0f, 100.0f);
                        Configuration.Clamp(ref NPC,        0.0f, 100.0f);
                        Configuration.Clamp(ref Player,     0.0f, 100.0f);
                        Configuration.Clamp(ref Team,       0.0f, 100.0f);
                        Configuration.Clamp(ref Trap,       0.0f, 100.0f);
                    }
                }

                public void Validate()
                {
                    Configuration.Validate(ref Damage, () => new EntityDamage(), () => Damage.Validate());
                }
            }

            public enum Type
            {
                Animal,
                AutoTurret,
                Bear,
                Boar,
                Bot,
                Bradley,
                Building,
                Chicken,
                Entity,
                FlameTurret,
                GunTrap,
                Helicopter,
                Murderer,
                NPC,
                Player,
                SAMSite,
                Scientist,
                Sentry,
                Stag,
                TC,
                NULL
            }

            public class Damage
            {
                private static readonly DamageTypeList cleared = new DamageTypeList();

                public static void Cancel(HitInfo info)
                {
                    info.damageTypes = cleared;
                    info.HitMaterial = 0;
                    info.PointStart  = Vector3.zero;
                    info.HitEntity   = null;
                }

                public static object Scale(HitInfo info, BasePlayer attacker, BaseCombatEntity victim)
                {
                    switch(Entity.GetType(info.HitEntity))
                    {
                    case Type.Animal:      return Scale(info, config.Entity.Damage.Animal);
                    case Type.AutoTurret:  return Scale(info, config.Entity.Damage.Trap);
                    case Type.Bear:        return Scale(info, config.Entity.Damage.Animal);
                    case Type.Boar:        return Scale(info, config.Entity.Damage.Animal);
                    case Type.Bot:         return Scale(info, config.Entity.Damage.NPC);
                    case Type.Bradley:     return Scale(info, config.Entity.Damage.Bradley);
                    case Type.Building:    return Scale(info, config.Entity.Damage.Building);
                    case Type.Chicken:     return Scale(info, config.Entity.Damage.Animal);
                    case Type.Entity:      return Scale(info, config.Entity.Damage.Entity);
                    case Type.FlameTurret: return Scale(info, config.Entity.Damage.Trap);
                    case Type.GunTrap:     return Scale(info, config.Entity.Damage.Trap);
                    case Type.Helicopter:  return Scale(info, config.Entity.Damage.Helicopter);
                    case Type.Murderer:    return Scale(info, config.Entity.Damage.NPC);
                    case Type.NPC:         return Scale(info, config.Entity.Damage.NPC);
                    case Type.Player:      return Scale(info, attacker, victim.ToPlayer());
                    case Type.SAMSite:     return Scale(info, config.Entity.Damage.Trap);
                    case Type.Scientist:   return Scale(info, config.Entity.Damage.NPC);
                    case Type.Sentry:      return Scale(info, config.Entity.Damage.Trap);
                    case Type.Stag:        return Scale(info, config.Entity.Damage.Animal);
                    case Type.TC:          return Scale(info, config.Entity.Damage.Building);
                    }

                    return null;
                }
                private static object Scale(HitInfo info, BasePlayer attacker, BasePlayer victim)
                {
                    if(victim == attacker)
                    {
                        return null;
                    }

                    var scale = 1.0f;

                    if((config.Entity.Damage.Friend != 1.0f) && User.IsFriend(attacker, victim))
                    {
                        scale = Math.Min(scale, config.Entity.Damage.Friend);
                    }

                    if((config.Entity.Damage.Team != 1.0f) && User.IsTeamMate(attacker, victim))
                    {
                        scale = Math.Min(scale, config.Entity.Damage.Team);
                    }

                    return Scale(info, scale * config.Entity.Damage.Player);
                }
                private static object Scale(HitInfo info, float scale)
                {
                    if(scale == 1.0f)
                    {
                        return null;
                    }

                    if(scale == 0.0f)
                    {
                        Cancel(info);
                    }
                    else
                    {
                        info.damageTypes.ScaleAll(scale);
                    }

                    return true;
                }
            }

            public static BasePlayer GetAttacker(BaseCombatEntity entity, HitInfo info)
            {
                var attacker = info?.Initiator ?? entity?.lastAttacker;

                if(attacker is FireBall)
                {
                    return Fire.Initiator(attacker as FireBall);
                }

                return attacker as BasePlayer;
            }

            public static string GetName(BaseEntity entity)
            {
                return GetName(entity, GetType(entity));
            }
            private static string GetName(BaseEntity entity, Type type)
            {
                switch(type)
                {
                case Type.Animal:      return $"{Text.GetPlain(Key.EntityAnimal)}({entity.GetType().Name})";
                case Type.AutoTurret:  return $"{Text.GetPlain(Key.EntityTrap)}({Text.GetPlain(Key.EntityAutoTurret)})";
                case Type.Bear:        return $"{Text.GetPlain(Key.EntityAnimal)}({Text.GetPlain(Key.EntityBear)})";
                case Type.Boar:        return $"{Text.GetPlain(Key.EntityAnimal)}({Text.GetPlain(Key.EntityBoar)})";
                case Type.Bot:         return $"{Text.GetPlain(Key.EntityNPC)}({Text.Sanitize((entity as BasePlayer).displayName)})";
                case Type.Bradley:     return $"{Text.GetPlain(Key.EntityNPC)}({Text.GetPlain(Key.EntityBradley)})";
                case Type.Building:    return $"{Text.GetPlain(Key.EntityBuilding)}({GetPrefabName(entity)})";
                case Type.Chicken:     return $"{Text.GetPlain(Key.EntityAnimal)}({Text.GetPlain(Key.EntityChicken)})";
                case Type.Entity:      return $"{Text.GetPlain(Key.Entity)}({GetPrefabName(entity)})";
                case Type.FlameTurret: return $"{Text.GetPlain(Key.EntityTrap)}({Text.GetPlain(Key.EntityFlameTurret)})";
                case Type.GunTrap:     return $"{Text.GetPlain(Key.EntityTrap)}({Text.GetPlain(Key.EntityGunTrap)})";
                case Type.Helicopter:  return $"{Text.GetPlain(Key.EntityNPC)}({Text.GetPlain(Key.EntityHelicopter)})";
                case Type.Murderer:    return $"{Text.GetPlain(Key.EntityNPC)}({Text.GetPlain(Key.EntityMurderer)})";
                case Type.NPC:         return $"{Text.GetPlain(Key.EntityNPC)}({entity.GetType().Name})";
                case Type.Player:      return $"{Text.GetPlain(Key.EntityPlayer)}({Text.Sanitize((entity as BasePlayer).displayName)})";
                case Type.SAMSite:     return $"{Text.GetPlain(Key.EntityTrap)}({Text.GetPlain(Key.EntitySAMSite)})";
                case Type.Scientist:   return $"{Text.GetPlain(Key.EntityNPC)}({Text.GetPlain(Key.EntityScientist)})";
                case Type.Sentry:      return $"{Text.GetPlain(Key.EntityNPC)}({Text.GetPlain(Key.EntityAutoTurret)})";
                case Type.Stag:        return $"{Text.GetPlain(Key.EntityAnimal)}({Text.GetPlain(Key.EntityStag)})";
                case Type.TC:          return $"{Text.GetPlain(Key.EntityBuilding)}({Text.GetPlain(Key.EntityTC)})";
                }

                return $"{Text.GetPlain(Key.Entity)}({Text.GetPlain(Key.NULL)})";
            }

            private static string GetPrefabName(BaseEntity entity)
            {
                if(string.IsNullOrEmpty(entity.ShortPrefabName))
                {
                    return entity.GetType().Name;
                }

                return entity.ShortPrefabName.Split('.')[0];
            }

            public static Type GetType(BaseEntity entity, out string name)
            {
                var type = GetType(entity);

                name = GetName(entity, type);

                return type;
            }
            public static Type GetType(BaseEntity entity)
            {
                if(entity == null)
                {
                    return Type.NULL;
                }

                switch(entity.GetType().Name)
                {
                case "AutoTurret":     return Type.AutoTurret;
                case "BaseHelicopter": return Type.Helicopter;
                case "BasePlayer":     return (entity as BasePlayer).userID.IsSteamId() ? Type.Player : Type.Bot;
                case "Bear":           return Type.Bear;
                case "Boar":           return Type.Boar;
                case "BradleyAPC":     return Type.Bradley;
                case "Chicken":        return Type.Chicken;
                case "FlameTurret":    return Type.FlameTurret;
                case "GunTrap":        return Type.GunTrap;
                case "HTNPlayer":      return Type.Scientist;
                case "NPCAutoTurret":  return Type.Sentry;
                case "NPCMurderer":    return Type.Murderer;
                case "SamSite":        return Type.SAMSite;
                case "Scientist":      return Type.Scientist;
                case "ScientistNPC":   return Type.Scientist;
                case "Stag":           return Type.Stag;
                }

                if(entity is BasePlayer)
                {
                    return Type.NPC;
                }
                else if(entity is BaseAnimalNPC)
                {
                    return Type.Animal;
                }
                else if(entity is BuildingBlock)
                {
                    return Type.Building;
                }
                else if(entity is BuildingPrivlidge)
                {
                    return Type.TC;
                }

                return Type.Entity;
            }

            public class Health
            {
                private static readonly Dictionary<int, float> health = new Dictionary<int, float>();

                public static bool Changed(BaseEntity entity)
                {
                    if(entity != null)
                    {
                        var instanceid = entity.GetInstanceID();

                        float current = entity.Health(), previous;

                        if(!health.TryGetValue(instanceid, out previous))
                        {
                            previous = float.MaxValue;
                        }

                        health[instanceid] = current;

                        return previous != current;
                    }

                    return false;
                }

                public static void Clear() => health.Clear();
                public static void Clear(BaseEntity entity)
                {
                    if(entity != null)
                    {
                        health.Remove(entity.GetInstanceID());
                    }
                }
            }

            public static void Unload() => Health.Clear();
        }

        #endregion _entity_

        #region _fire_

        private class Fire
        {
            private static Dictionary<int, BasePlayer> fires = new Dictionary<int, BasePlayer>();

            public static void Ignite(FireBall fire, BasePlayer initiator)
            {
                if((fire != null) && (initiator?.userID.IsSteamId() ?? false))
                {
                    fires[fire.GetInstanceID()] = initiator;
                }
            }

            public static BasePlayer Initiator(FireBall fire)
            {
                if(fire != null)
                {
                    BasePlayer initiator;

                    if(fires.TryGetValue(fire.GetInstanceID(), out initiator))
                    {
                        return initiator;
                    }
                }

                return null;
            }

            public static void Spread(FireBall fire, FireBall spread)
            {
                if((fire != null) || (spread != null))
                {
                    BasePlayer initiator;

                    if(fires.TryGetValue(fire.GetInstanceID(), out initiator))
                    {
                        fires.Add(spread.GetInstanceID(), initiator);
                    }
                }
            }

            public static void Quench(FireBall fire)
            {
                if(fire != null)
                {
                    fires.Remove(fire.GetInstanceID());
                }
            }

            public static void Unload() => fires.Clear();
        }

        #endregion _fire_

        #region _generic_

        private class Generic
        {
            public static T Clamp<T>(T value, T min, T max) where T : IComparable<T>
            {
                if(value.CompareTo(min) < 0)
                {
                    return min;
                }
                else if(value.CompareTo(max) > 0)
                {
                    return max;
                }

                return value;
            }
        }

        #endregion _generic_

        #region _hooks_

        private new class Hooks
        {
            private static HashSet<string> subscribed;
            private static HashSet<string> unsubscribed;

            public class Base
            {
                public static void Subscribe()
                {
                    Hooks.Subscribe(nameof(OnUserBanned));
                    Hooks.Subscribe(nameof(OnUserUnbanned));
                }
            }

            public class Core
            {
                public static void Subscribe()
                {
                    Hooks.Subscribe(nameof(CanBypassQueue));
                    Hooks.Subscribe(nameof(CanLootEntity));
                    Hooks.Subscribe(nameof(CanLootPlayer));
                    Hooks.Subscribe(nameof(CanUserLogin));
                    Hooks.Subscribe(nameof(OnEntityDeath));
                    Hooks.Subscribe(nameof(OnEntityKill));
                    Hooks.Subscribe(nameof(OnEntityTakeDamage));
                    Hooks.Subscribe(nameof(OnFireBallDamage));
                    Hooks.Subscribe(nameof(OnFireBallSpread));
                    Hooks.Subscribe(nameof(OnFlameExplosion));
                    Hooks.Subscribe(nameof(OnFlameThrowerBurn));
                    Hooks.Subscribe(nameof(OnGroupPermissionGranted));
                    Hooks.Subscribe(nameof(OnGroupPermissionRevoked));
                    Hooks.Subscribe(nameof(OnLootEntity));
                    Hooks.Subscribe(nameof(OnLootPlayer));
                    Hooks.Subscribe(nameof(OnPlayerAttack));
                    Hooks.Subscribe(nameof(OnPlayerConnected));
                    Hooks.Subscribe(nameof(OnPlayerDisconnected));
                    Hooks.Subscribe(nameof(OnPlayerViolation));
                    Hooks.Subscribe(nameof(OnRocketLaunched));
                    Hooks.Subscribe(nameof(OnUserPermissionGranted));
                    Hooks.Subscribe(nameof(OnUserPermissionRevoked));
                    Hooks.Subscribe(nameof(OnWeaponFired));
                }
            }

            public class Dynamic
            {
                public static void Subscribe()
                {
                    AntiCheat.Stash.Subscribe();
                    AntiFlood.Chat.Subscribe();
                    AntiFlood.Command.Subscribe();
                    AntiFlood.ItemDrop.Subscribe();
                    Discord.Subscribe();
                }
            }

            public static void Load()
            {
                subscribed = new HashSet<string>
                {
                    nameof(CanBypassQueue),
                    nameof(CanCraft),
                    nameof(CanLootEntity),
                    nameof(CanLootPlayer),
                    nameof(CanSeeStash),
                    nameof(CanUserLogin),
                    nameof(OnEntityDeath),
                    nameof(OnEntityKill),
                    nameof(OnEntityTakeDamage),
                    nameof(OnFireBallDamage),
                    nameof(OnFireBallSpread),
                    nameof(OnFlameExplosion),
                    nameof(OnFlameThrowerBurn),
                    nameof(OnGuardianViolation),
                    nameof(OnGroupPermissionGranted),
                    nameof(OnGroupPermissionRevoked),
                    nameof(OnItemDropped),
                    nameof(OnLootEntity),
                    nameof(OnLootPlayer),
                    nameof(OnPlayerAttack),
                    nameof(OnPlayerChat),
                    nameof(OnPlayerConnected),
                    nameof(OnPlayerDisconnected),
                    nameof(OnPlayerViolation),
                    nameof(OnRocketLaunched),
                    nameof(OnServerCommand),
                    nameof(OnUserBanned),
                    nameof(OnUserPermissionGranted),
                    nameof(OnUserPermissionRevoked),
                    nameof(OnUserUnbanned),
                    nameof(OnWeaponFired)
                };

                unsubscribed = new HashSet<string>();

                Unsubscribe();
            }

            public static void Subscribe(string hook)
            {
                if(unsubscribed.Contains(hook))
                {
                    unsubscribed.Remove(hook);

                    _instance.Subscribe(hook);

                    subscribed.Add(hook);
                }
            }

            public static void Unload()
            {
                Unsubscribe();

                subscribed = null;

                unsubscribed.Clear();
                unsubscribed = null;
            }

            private static void Unsubscribe()
            {
                foreach(var hook in subscribed)
                {
                    _instance.Unsubscribe(hook);

                    unsubscribed.Add(hook);
                }

                subscribed.Clear();
            }
            public static void Unsubscribe(string hook)
            {
                if(subscribed.Contains(hook))
                {
                    subscribed.Remove(hook);

                    _instance.Unsubscribe(hook);

                    unsubscribed.Add(hook);
                }
            }
        }

        #region _hooks_lifecycle_

        private void Init()
        {
            _instance = this;

            Data.Open();
            Configuration.Load();

            Hooks.Load();

            Permissions.Load();

            Text.Load();

            IP.Load();
            User.Load();

            Projectile.Load();
            Steam.Load();
            Violation.Load();
            VPN.Load();
            Weapon.Load();

            AntiCheat.Configure();
            AntiFlood.Configure();

            Command.Load();

            Configuration.Save();
        }

        private void Loaded()
        {
            Hooks.Base.Subscribe();
        }

        protected override void LoadDefaultConfig() { }

        protected override void LoadDefaultMessages() { }

        private void OnServerInitialized()
        {
            Hooks.Core.Subscribe();

            Hooks.Dynamic.Subscribe();

            Map.Load();

            User.Update();
        }

        private void OnServerSave()
        {
            Configuration.Save();

            IP.Save();
            User.Save();
            VPN.Save();
        }

        private void Unload()
        {
            Hooks.Unload();

            Timers.Destroy();

            Map.Unload();
            Fire.Unload();
            Entity.Unload();

            Command.Unload();

            AntiFlood.Unload();
            AntiCheat.Unload();

            Weapon.Unload();
            VPN.Unload();
            Violation.Unload();
            Steam.Unload();
            Projectile.Unload();

            User.Unload();
            IP.Unload();

            Text.Unload();

            Permissions.Unload();

            Configuration.Unload();
            Data.Close();

            _instance = null;
        }

        #endregion _hooks_lifecycle_

        #region _hooks_other_

        private object CanBypassQueue(Connection connection)
        {
            if(Permissions.Ignore(connection.userid, true))
            {
                return true;
            }
            else if(config.Admin.Bypass && Permissions.Admin(connection.userid, true))
            {
                return true;
            }

            return null;
        }

        private object CanCraft(ItemCrafter crafter, ItemBlueprint bp, int amount)
        {
            if(!config.AntiFlood.ItemDrop.Enabled)
            {
                return null;
            }

            var player = crafter.gameObject.GetComponent<BasePlayer>();

            if(User.ShouldIgnore(player))
            {
                return null;
            }

            var cooldown = AntiFlood.ItemDrop.CoolDown(player.userID, bp.targetItem.itemid);

            if(cooldown == 0)
            {
                return null;
            }

            Chat.Send(player, Key.Cooldown, new Dictionary<string, string>
            {
                { "cooldown", cooldown.ToString() },
                { "type", Text.Get(Key.Crafting) }
            });

            AntiFlood.ItemDrop.Violation(player, bp.targetItem.displayName.english);

            return false;
        }

        private object CanLootEntity(BasePlayer looter, DroppedItemContainer target) => User.CanLoot(looter, target.playerSteamID);

        private object CanLootEntity(BasePlayer looter, LootableCorpse target) => User.CanLoot(looter, target.playerSteamID);

        private object CanLootPlayer(BasePlayer target, BasePlayer looter) => User.CanLoot(looter, target.userID);

        private object CanSeeStash(BasePlayer player, StashContainer stash)
        {
            if(!config.AntiCheat.Stash.Enabled)
            {
                return null;
            }

            if(User.ShouldIgnore(player))
            {
                return null;
            }

            AntiCheat.Stash.Trigger(player, stash);

            return null;
        }

        private object CanUserLogin(string name, string id, string address)
        {
            return User.CanConnect(name, id, address);
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            Entity.Health.Clear(entity);

            var victim = entity.ToPlayer();

            if(User.ShouldIgnore(victim))
            {
                return;
            }

            var attacker = Entity.GetAttacker(entity, info);

            if(!User.ShouldIgnore(attacker))
            {
                User.AssignAttacker(attacker, victim);
            }

            User.AssignVictim(victim);
        }

        void OnEntityKill(BaseNetworkable entity)
        {
            if(entity is FireBall)
            {
                Fire.Quench(entity as FireBall);
            }
        }

        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            var attacker = Entity.GetAttacker(entity, info);

            if(User.ShouldIgnore(attacker))
            {
                return null;
            }

            if(info.IsProjectile())
            {
                AntiCheat.Aim.Trigger(entity, info);
                AntiCheat.FireRate.Trigger(entity, info);
                AntiCheat.Trajectory.Trigger(entity, info);
            }

            if((attacker.net?.connection?.authLevel ?? 0) > 0)
            {
                return null;
            }

            var victim = entity.ToPlayer();

            if(!User.ShouldIgnore(victim))
            {
                User.AssignAttacker(attacker, victim);

                if(User.IsCrippled(attacker.userID) && (victim != attacker))
                {
                    if(victim.IsWounded())
                    {
                        victim.StopWounded();
                    }

                    Entity.Damage.Cancel(info);

                    if(config.Cripple.Heal)
                    {
                        _instance.NextFrame(() =>
                        {
                            victim.Heal(100.0f);
                        });
                    }

                    return true;
                }
            }

            return Entity.Damage.Scale(info, attacker, entity);
        }

        private void OnFireBallDamage(FireBall fireball, BaseCombatEntity target, HitInfo info)
        {
            info.Initiator = fireball;
        }

        private void OnFireBallSpread(FireBall fireball, BaseEntity entity)
        {
            Fire.Spread(fireball, entity as FireBall);
        }

        private void OnFlameExplosion(FlameExplosive explosive, BaseEntity entity)
        {
            if(explosive.creatorEntity is BasePlayer)
            {
                var fire = entity as FireBall;

                var initiator = explosive.creatorEntity as BasePlayer;

                if(initiator.userID.IsSteamId() && (fire != null))
                {
                    Fire.Ignite(fire, initiator);
                }
            }
        }

        private void OnFlameThrowerBurn(FlameThrower flamethrower, BaseEntity entity)
        {
            var initiator = flamethrower.GetOwnerPlayer();

            if(initiator != null)
            {
                var fire = entity as FireBall;

                if(initiator.userID.IsSteamId() && (fire != null))
                {
                    Fire.Ignite(fire, initiator);
                }
            }
        }

        private void OnGroupPermissionGranted(string name, string perm)
        {
            if(Permissions.HasPrefix(perm))
            {
                foreach(var id in permission.GetUsersInGroup(name))
                {
                    var player = BasePlayer.FindAwakeOrSleeping(id);

                    if(player != null)
                    {
                        Permissions.Update(player.userID);
                    }
                }
            }
        }

        private void OnGroupPermissionRevoked(string name, string perm) => OnGroupPermissionGranted(name, perm);

        private void OnGuardianViolation(string playerid, Dictionary<string, string> details)
        {
            Discord.Send(details["category"], new Dictionary<string, object>
            {
                {
                    "embeds", new List<object>
                    {
                        new Dictionary<string, object>
                        {
                            { "color", int.Parse(details["color"]) },
                            { "description",
                                $"{details["actionicon"]} {details["action"]} [{details["playername"]}]" +
                                $"(https://steamcommunity.com/profiles/{playerid}) {playerid}\n" +
                                $"{details["categoryicon"]} {details["category"]} - {details["type"]}: {details["details"]}"
                            }
                        }
                    }
                }
            });
        }

        private void OnItemDropped(Item item, BaseEntity entity)
        {
            if(!config.AntiFlood.ItemDrop.Enabled)
            {
                return;
            }

            var player = item?.GetOwnerPlayer();

            if(User.ShouldIgnore(player))
            {
                return;
            }

            if(AntiFlood.ItemDrop.Trigger(player.userID, item.info.itemid))
            {
                entity?.Kill();
            }
        }

        private void OnLootEntity(BasePlayer looter, BaseEntity target)
        {
            if(target is LootableCorpse)
            {
                User.OnLoot(looter, (target as LootableCorpse).playerSteamID);
            }
            else if(target is DroppedItemContainer)
            {
                User.OnLoot(looter, (target as DroppedItemContainer).playerSteamID);
            }
        }

        private void OnLootPlayer(BasePlayer looter, BasePlayer target) => User.OnLoot(looter, target.userID);

        private object OnPlayerAttack(BasePlayer player, HitInfo info)
        {
            if(User.ShouldIgnore(player) || (info.Weapon == null))
            {
                return null;
            }

            if(info.IsProjectile())
            {
                AntiCheat.WallHack.Trigger(player, info);
            }
            else
            {
                AntiCheat.MeleeRate.Trigger(player, info);
            }


            return null;
        }

        private object OnPlayerChat(BasePlayer player, string message, ConVar.Chat.ChatChannel channel)
        {
            if(!config.AntiFlood.Chat.Enabled)
            {
                return null;
            }

            if(User.ShouldIgnore(player))
            {
                return null;
            }

            if(!AntiFlood.Chat.Trigger(player.userID))
            {
                return null;
            }

            Chat.Send(player, Key.Cooldown, new Dictionary<string, string>
            {
                { "cooldown", AntiFlood.Chat.Cooldown(player.userID).ToString() },
                { "type", Text.Get(Key.Chat) }
            });

            AntiFlood.Chat.Violation(player, Enum.GetName(typeof(ConVar.Chat.ChatChannel), channel));

            return true;
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            User.OnConnected(player);
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            User.OnDisconnected(player);
        }

        private object OnPlayerViolation(BasePlayer player, AntiHackType ahtype, float amount)
        {
            if(User.ShouldIgnore(player) || User.IsInactive(player))
            {
                return true;
            }

            if(ahtype == AntiHackType.FlyHack)
            {
                if(config.AntiCheat.Gravity.Enabled)
                {
                    NextFrame(() => AntiCheat.Gravity.Trigger(player, amount));

                    return true;
                }
            }
            else
            {
                if(config.AntiCheat.Server.Enabled)
                {
                    NextFrame(() => AntiCheat.Server.Trigger(player, ahtype, amount));

                    return true;
                }
            }

            return null;
        }

        private void OnRocketLaunched(BasePlayer player, BaseEntity entity)
        {
            if(User.ShouldIgnore(player))
            {
                return;
            }

            var projectile = player.GetActiveItem().GetHeldEntity() as BaseProjectile;

            if(projectile == null)
            {
                return;
            }

            var time = UnityEngine.Time.realtimeSinceStartup;

            var ammo = projectile.primaryMagazine.ammoType;

            var item = projectile.GetItem();

            var itemmod = ammo.GetComponent<ItemModProjectile>();

            var projectiles = Pool.Get<ProtoBuf.ProjectileShoot>();

            projectiles.ammoType    = ammo.itemid;
            projectiles.projectiles = Pool.Get<List<ProtoBuf.ProjectileShoot.Projectile>>();

            if((item?.info.shortname ?? string.Empty) != "pistol.eoka")
            {
                foreach(var fired in player.firedProjectiles)
                {
                    if((fired.Value.weaponSource as BaseProjectile) != projectile)
                    {
                        continue;
                    }

                    if((time - fired.Value.firedTime) > 0.01)
                    {
                        continue;
                    }

                    var entry = Pool.Get<ProtoBuf.ProjectileShoot.Projectile>();

                    entry.projectileID = fired.Key;
                    entry.startPos = fired.Value.initialPosition;
                    entry.startVel = fired.Value.initialVelocity;

                    projectiles.projectiles.Add(entry);
                }
            }

            OnWeaponFired(projectile, player, itemmod, projectiles);

            projectiles.ResetToPool();
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if(!config.AntiFlood.Command.Enabled)
            {
                return null;
            }

            var player = arg.Player();

            if(User.ShouldIgnore(player) || (arg.cmd.FullName == "craft.add"))
            {
                return null;
            }

            if(!AntiFlood.Command.Trigger(player.userID))
            {
                return null;
            }

            Chat.Send(player, Key.Cooldown, new Dictionary<string, string>
            {
                { "cooldown", AntiFlood.Command.Cooldown(player.userID).ToString() },
                { "type", Text.Get(Key.Command) }
            });

            AntiFlood.Command.Violation(player, arg.cmd.FullName);

            return true;
        }

        private void OnUserBanned(string playername, string playerid, string playerip, string reason)
        {
            ulong userid;

            if(ulong.TryParse(playerid, out userid))
            {
                if((userid != 0) && userid.IsSteamId())
                {
                    NextTick(() => User.OnBanned(userid, true));
                }
            }
        }

        private void OnUserPermissionGranted(string id, string perm)
        {
            if(Permissions.HasPrefix(perm))
            {
                var player = BasePlayer.FindAwakeOrSleeping(id);

                if(player != null)
                {
                    Permissions.Update(player.userID);
                }
            }
        }

        private void OnUserPermissionRevoked(string id, string perm) => OnUserPermissionGranted(id, perm);

        private void OnUserUnbanned(string playername, string playerid, string playerip)
        {
            ulong userid;

            if(ulong.TryParse(playerid, out userid))
            {
                if((userid != 0) && userid.IsSteamId())
                {
                    NextTick(() => User.OnBanned(userid, false));
                }
            }
        }

        private void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile itemmod, ProtoBuf.ProjectileShoot projectiles)
        {
            if(User.ShouldIgnore(player))
            {
                return;
            }

             AntiCheat.Recoil.Trigger(player, Weapon.Get(projectile, player, projectiles));
        }

        #endregion _hooks_other_

        #endregion _hooks_

        #region _ip_

        private class IP
        {
            public class Settings
            {
                public IpFilter    Filter;
                public IpViolation Violation;

                public Settings()
                {
                    Filter    = new IpFilter();
                    Violation = new IpViolation();
                }

                public class IpFilter
                {
                    public ulong Cooldown;

                    public IpFilter()
                    {
                        Cooldown = 30ul;
                    }

                    public void Validate()
                    {
                        Configuration.Clamp(ref Cooldown, 0ul, 60ul);
                    }
                }

                public class IpViolation
                {
                    public bool Ban;
                    public bool Enabled;

                    public IpViolation()
                    {
                        Ban     = false;
                        Enabled = true;
                    }
                }

                public void Validate()
                {
                    Configuration.Validate(ref Filter,    () => new IpFilter(), () => Filter.Validate());
                    Configuration.Validate(ref Violation, () => new IpViolation());
                }
            }

            private static readonly DataFile<string, uint> allows = new DataFile<string, uint>("ip_allows");
            private static readonly DataFile<string, bool> blocks = new DataFile<string, bool>();
            private static readonly DataFile<string, uint> denies = new DataFile<string, uint>("ip_denies");

            private static readonly HashSet<ulong> empty = new HashSet<ulong>();

            private static readonly DataFile<string, DateTime> filter = new DataFile<string, DateTime>();

            private static TimeSpan filter_cooldown;

            private static readonly DataFile<string, HashSet<ulong>> users = new DataFile<string, HashSet<ulong>>("ip_users");

            private static readonly Violation violation = new Violation(Key.IP);

            public class NetworkInfo
            {
                public string Address { get; protected set; }
                public uint   Bits { get; protected set; }

                public NetworkInfo(string address, uint bits)
                {
                    Address = address;
                    Bits    = bits;
                }
            }

            private static uint Bits(string address)
            {
                uint bits = 0;

                var octets = address.Split('.');

                foreach(var octet in octets)
                {
                    if(octet == "*")
                    {
                        return bits;
                    }
                    else
                    {
                        bits += 8;
                    }
                }

                return bits;
            }

            public static void Block(NetworkInfo network)
            {
                foreach(var address in Match(network))
                {
                    if(!IsAllowed(address))
                    {
                        Block(address);
                    }
                }
            }

            public static void Block(string address, ulong userid = 0)
            {
                blocks[address] = true;

                if(userid != 0)
                {
                    Violation(address, userid);
                }

                _instance.timer.In(5.0f, () =>
                {
                    foreach(var entry in users[address])
                    {
                        if(!User.IsConnected(entry) || Permissions.Ignore(entry))
                        {
                            continue;
                        }

                        Violation(address, userid);
                    }
                });
            }

            public static void Bypass(NetworkInfo network)
            {
                foreach(var address in Match(network))
                {
                    blocks[address] = false;
                }
            }

            public static void Bypass(string address) => blocks[address] = false;

            private static uint Decimal(string address)
            {
                uint result = 0;

                if(!string.IsNullOrEmpty(address))
                {
                    var octets = address.Split('.');

                    if(octets.Length <= 4)
                    {
                        foreach(var octet in octets)
                        {
                            uint value;

                            if(uint.TryParse(octet, out value) && (value <= 255))
                            {
                                result = (result << 8) + value;
                            }
                            else
                            {
                                return 0;
                            }
                        }

                        if(octets.Length < 4)
                        {
                            result <<= ((4 - octets.Length) << 3);
                        }
                    }
                }

                return result;
            }

            public static bool Cooldown(string address)
            {
                if(config.IP.Filter.Cooldown == 0)
                {
                    return false;
                }

                var current = DateTime.UtcNow;
                var elapsed = current.Subtract(filter.Get(address, DateTime.MinValue));

                if(elapsed >= filter_cooldown)
                {
                    filter[address] = current;

                    return false;
                }

                return true;
            }

            public static void Configure()
            {
                config.IP.Filter.Validate();

                if(config.IP.Filter.Cooldown > 0)
                {
                    filter_cooldown = TimeSpan.FromSeconds(config.IP.Filter.Cooldown);
                }
                else
                {
                    filter_cooldown = TimeSpan.MinValue;
                }
            }

            public static bool Filter(string address, ulong userid)
            {
                if(blocks.Contains(address))
                {
                    if(blocks[address])
                    {
                        if(config.Log.IP.Filter)
                        {
                            Log.Console(Key.LogIpFilter, new Dictionary<string, string>
                            {
                                { "action", Text.Get(Key.Blocked) },
                                { "address", address },
                            });
                        }

                        Block(address, userid);

                        return false;
                    }
                }
                else if(IsDenied(address))
                {
                    if(!IsAllowed(address))
                    {
                        if(config.Log.IP.Filter)
                        {
                            Log.Console(Key.LogIpFilter, new Dictionary<string, string>
                            {
                                { "action", Text.Get(Key.Denied) },
                                { "address", address },
                            });
                        }

                        Block(address, userid);

                        return false;
                    }
                }

                if(config.Log.IP.Filter)
                {
                    Log.Console(Key.LogIpFilter, new Dictionary<string, string>
                    {
                        { "action", Text.Get(Key.Allowed) },
                        { "address", address },
                    });
                }

                return true;
            }

            public static HashSet<ulong> Find(string address)
            {
                if(users.Contains(address))
                {
                    return users[address];
                }

                return empty;
            }

            private static List<string> Get(DataFile<string, uint> data, string address)
            {
                bool all = (address == null);

                uint ip = all ? 0 : Decimal(address);

                var results = new List<string>();

                data.ForEach((network, bits) =>
                {
                    if(all || Match(ip, Decimal(network), bits))
                    {
                        results.Add($"{network}/{bits}");
                    }
                });

                return results;
            }

            public static List<string> GetAllows(string address = null) => Get(allows, address);

            public static List<string> GetDenies(string address = null) => Get(denies, address);

            public static bool IsAllowed(string address) => IsMatched(allows, address);

            public static bool IsBlocked(string address) => blocks.Get(address, false);

            public static bool IsDenied(string address) => IsMatched(denies, address);

            private static bool IsMatched(DataFile<string, uint> data, string address)
            {
                var ip = Decimal(address);

                bool match = false;

                data.ForEach((network, bits) =>
                {
                    if(!match)
                    {
                        match = Match(ip, Decimal(network), bits);
                    }
                });

                return match;
            }

            public static bool IsValid(string address, bool full = true, bool wildcard = false)
            {
                if(string.IsNullOrEmpty(address))
                {
                    return false;
                }

                var octets = address.Split('.');

                if(full ? (octets.Length != 4) : (octets.Length > 4))
                {
                    return false;
                }

                bool found_wildcard = false;

                foreach(var octet in octets)
                {
                    uint value;

                    if(octet == "*")
                    {
                        if(wildcard)
                        {
                            found_wildcard = true;
                        }
                        else
                        {
                            return false;
                        }
                    }
                    if(!uint.TryParse(octet, out value) || (value > 255) || found_wildcard)
                    {
                        return false;
                    }
                }

                return true;
            }

            public static void Load()
            {
                violation.Configure(new Violation.Settings(true, 3600), 1, 1, 1);

                allows.Load();
                denies.Load();

                users.Load();

                Configure();
            }

            private static bool Match(uint ip, uint network, uint bits)
            {
                bool match = false;

                if(bits == 0)
                {
                    match = true;
                }
                else
                {
                    var mask = uint.MaxValue << (32 - (int)bits);

                    if((ip & mask) == (network & mask))
                    {
                        match = true;
                    }
                }

                return match;
            }

            private static List<string> Match(NetworkInfo network)
            {
                var addresses = new List<string>();

                uint network_address = Decimal(network.Address);

                blocks.ForEach((address, blocked) =>
                {
                    if(Match(Decimal(address), network_address, network.Bits))
                    {
                        addresses.Add(address);
                    }
                });

                return addresses;
            }

            public static NetworkInfo Network(string address)
            {
                if(string.IsNullOrEmpty(address))
                {
                    return null;
                }

                uint bits = uint.MaxValue;

                var split = address.Split('/');

                if((split.Length == 1) && IsValid(split[0], false, true))
                {
                    bits = Bits(split[0]);
                }
                else if((split.Length == 2) && IsValid(split[0], false))
                {
                    if(!uint.TryParse(split[1], out bits))
                    {
                        bits = uint.MaxValue;
                    }
                }

                if(bits <= 32)
                {
                    var ip = Decimal(split[0].Replace('*', '0'));

                    var mask = uint.MaxValue << (32 - (int)bits);

                    return new NetworkInfo(ToString(ip & mask), bits);
                }

                return null;
            }

            public static string Parse(string address)
            {
                if(string.IsNullOrEmpty(address))
                {
                    return null;
                }

                int length = address.IndexOf(':');

                if(length > 0)
                {
                    return address.Substring(0, length);
                }

                if(IsValid(address))
                {
                    return address;
                }

                return null;
            }

            public static void Save()
            {
                allows.Save();
                denies.Save();

                users.Save();
            }

            private static bool Set(DataFile<string, uint> data, NetworkInfo network, bool add)
            {
                var matches = Get(data, network.Address);

                if(add)
                {
                    if(matches.Count == 0)
                    {
                        data[network.Address] = network.Bits;

                        return true;
                    }
                }
                else
                {
                    if(matches.Count > 0)
                    {
                        foreach(var match in matches)
                        {
                            data.Remove(match.Split('/')[0]);
                        }

                        return true;
                    }
                }

                return false;
            }

            public static bool SetAllow(NetworkInfo network, bool add) => Set(allows, network, add);

            public static bool SetDeny(NetworkInfo network, bool add) => Set(denies, network, add);

            public static string ToString(uint ip)
            {
                StringBuilder result = new StringBuilder(16);

                result.Append(((ip >> 24) & 255u).ToString()).Append('.');
                result.Append(((ip >> 16) & 255u).ToString()).Append('.');
                result.Append(((ip >>  8) & 255u).ToString()).Append('.');
                result.Append(( ip        & 255u).ToString());

                return result.ToString();
            }

            public static void Unblock(NetworkInfo network)
            {
                foreach(var address in Match(network))
                {
                    blocks.Remove(address);
                }
            }

            public static void Unblock(string address) => blocks.Remove(address);

            public static void Unload()
            {
                allows.Unload();
                blocks.Unload();
                denies.Unload();

                filter.Clear();

                users.Unload();

                violation.Clear();
            }

            public static void Update(string address, ulong userid)
            {
                if(!string.IsNullOrEmpty(address))
                {
                    if(!users.Contains(address))
                    {
                        users.Add(address, new HashSet<ulong>());
                    }

                    if(users[address].Add(userid))
                    {
                        users.SetDirty();
                    }
                }
            }

            private static void Violation(string address, ulong userid)
            {
                if(config.IP.Violation.Enabled)
                {
                    ulong violations = config.IP.Violation.Ban ? ulong.MaxValue : 1ul;

                    violation.Trigger(userid, Key.Blocked, address, violations, true);
                }
                else
                {
                    if(User.IsConnected(userid))
                    {
                        User.Kick(userid, Text.GetPlain(Key.IpBlocked));
                    }
                }
            }
        }

        #endregion _ip_

        #region _log_

        private new class Log
        {
            public class Settings
            {
                public LogAntiCheat  AntiCheat;
                public LogAntiFlood  AntiFlood;
                public LogIp         IP;
                public LogProjectile Projectile;
                public LogUser       User;
                public LogVpn        VPN;

                public Settings()
                {
                    AntiCheat  = new LogAntiCheat();
                    AntiFlood  = new LogAntiFlood();
                    IP         = new LogIp();
                    Projectile = new LogProjectile();
                    User       = new LogUser();
                    VPN        = new LogVpn();
                }

                public class LogAntiCheat
                {
                    public bool Aim;
                    public bool Gravity;
                    public bool MeleeRate;
                    public bool Recoil;
                    public bool Server;
                    public bool Stash;
                    public bool Trajectory;
                }

                public class LogAntiFlood
                {
                    public bool ItemDrop;
                }

                public class LogIp
                {
                    public bool Filter;

                    public LogIp()
                    {
                        Filter = true;
                    }
                }

                public class LogProjectile
                {
                    public bool Collapse;
                    public bool Verbose;

                    public LogProjectile()
                    {
                        Collapse = true;
                    }
                }

                public class LogUser
                {
                    public bool Bypass;
                    public bool Connect;

                    public LogUser()
                    {
                        Connect = true;
                    }
                }

                public class LogVpn
                {
                    public bool Check;

                    public LogVpn()
                    {
                        Check = true;
                    }
                }

                public void Validate()
                {
                    Configuration.Validate(ref AntiCheat,  () => new LogAntiCheat());
                    Configuration.Validate(ref AntiFlood,  () => new LogAntiFlood());
                    Configuration.Validate(ref IP,         () => new LogIp());
                    Configuration.Validate(ref Projectile, () => new LogProjectile());
                    Configuration.Validate(ref User,       () => new LogUser());
                    Configuration.Validate(ref VPN,        () => new LogVpn());
                }
            }

            public static void Console(Key key, Dictionary<string, string> parameters = null)
            {
                _instance.Puts(Text.GetPlain(key, parameters));
            }

            public static void Error(string message)
            {
                _instance.LogError(message);
            }

            public static void Warning(string message)
            {
                _instance.LogWarning(message);
            }
        }

        #endregion _log_

        #region _map_

        private class Map
        {
            public class Building
            {
                public static bool HasPrivilege(DecayEntity entity) =>
                    entity.GetBuildingPrivilege() != null;

                public static bool InFoundation(Vector3 position)
                {
                    try
                    {
                        RaycastHit hit;

                        Physics.queriesHitBackfaces = true;

                        if(Physics.Raycast(position, Vector3.up, out hit, 4.5f, Layers.Mask.Construction, QueryTriggerInteraction.Ignore))
                        {
                            var block = hit.GetEntity() as BuildingBlock;

                            if((block != null) && Hit.IsFoundation(hit))
                            {
                                switch(block.grade)
                                {
                                case BuildingGrade.Enum.Stone:
                                case BuildingGrade.Enum.Metal:
                                case BuildingGrade.Enum.TopTier:
                                    return true;
                                }
                            }
                        }
                    }
                    finally
                    {
                        Physics.queriesHitBackfaces = false;
                    }

                    return false;
                }

                public static bool IsNearby(Vector3 position, bool check_privilege = true)
                {
                    var blocks = Pool.GetList<BuildingBlock>();

                    Vis.Entities(position, 16.0f, blocks, Layers.Mask.Construction, QueryTriggerInteraction.Ignore);

                    bool nearby = false;

                    foreach(var block in blocks)
                    {
                        if(check_privilege)
                        {
                            if(HasPrivilege(block))
                            {
                                nearby = true; break;
                            }
                        }
                        else
                        {
                            nearby = true; break;
                        }
                    }

                    Pool.FreeList(ref blocks);

                    return nearby;
                }
            }

            public class Cave
            {
                public static bool IsInside(Vector3 position)
                {
                    foreach(var hit in Physics.RaycastAll(position, Vector3.up, 125f, Layers.Mask.World))
                    {
                        if(Hit.IsCave(hit) || Hit.IsRock(hit))
                        {
                            return true;
                        }
                    }

                    foreach(var hit in Physics.RaycastAll(position, Vector3.down, 125f, Layers.Mask.World))
                    {
                        if(Hit.IsCave(hit))
                        {
                            return true;
                        }
                    }

                    return false;
                }
            }

            public class Collider
            {
                public static string Info(Vector3 position)
                {
                    var colliders = new List<string>();

                    foreach(var hit in Physics.RaycastAll(position, Vector3.up, 50.0f, Layers.Mask.World, QueryTriggerInteraction.Ignore))
                    {
                        colliders.Add($"{hit.collider.name} ({hit.distance}m)");
                    }

                    try
                    {
                        RaycastHit hit;

                        Physics.queriesHitBackfaces = true;

                        if(Physics.Raycast(new Vector3(position.x, position.y + 0.1f, position.z), Vector3.up, out hit, 4.5f, Layers.Mask.Construction, QueryTriggerInteraction.Ignore))
                        {
                            if(Hit.IsFoundation(hit))
                            {
                                colliders.Add($"foundation ({hit.distance}m)");
                            }
                        }
                    }
                    finally
                    {
                        Physics.queriesHitBackfaces = false;
                    }

                    var up = colliders.Count > 0 ? $"\nUp: {string.Join(", ", colliders)}" : string.Empty;

                    colliders.Clear();

                    foreach(var hit in Physics.RaycastAll(position, Vector3.down, 50.0f, Layers.Mask.World, QueryTriggerInteraction.Ignore))
                    {
                        colliders.Add($"{hit.collider.name} ({hit.distance}m)");
                    }

                    var dn = colliders.Count > 0 ? $"\nDn: {string.Join(", ", colliders)}" : string.Empty;

                    return $"{up}{dn}";
                }
            }

            public class Entities
            {
                public static bool InRange(Vector3 position, float radius = 3.0f)
                {
                    var entities = Pool.GetList<DecayEntity>();

                    Vis.Entities(position, radius, entities);

                    bool nearby = entities.Count > 0;

                    Pool.FreeList(ref entities);

                    return nearby;
                }
            }

            public static string Grid(Vector3 position)
            {
                const double scale = 1.0 / 146.304;

                float normal = World.Size >> 1;

                if((Math.Abs(position.x) > normal) || (Math.Abs(position.z) > normal))
                {
                    return string.Empty;
                }

                int x = (int)((normal + position.x) * scale);
                int y = (int)((normal - position.z) * scale);

                int r, q = Math.DivRem(x, 26, out r);

                if(q > 0)
                {
                    return $"{Convert.ToChar(64 + q)}{Convert.ToChar(65 + r)}{y}";
                }
                else
                {
                    return $"{Convert.ToChar(65 + r)}{y}";
                }
            }

            private class Hit
            {
                private static string Collider(RaycastHit hit) =>
                    hit.collider?.name.ToLower() ?? string.Empty;

                public static bool IsBunker(RaycastHit hit) =>
                    IsBunker(Collider(hit));
                public static bool IsBunker(string collider) =>
                    collider.Contains("bunker.");

                public static bool IsCave(RaycastHit hit) =>
                    IsCave(Collider(hit));
                public static bool IsCave(string collider) =>
                    collider.Contains("cave_");

                public static bool IsCorridor(RaycastHit hit) =>
                    IsCorridor(Collider(hit));
                public static bool IsCorridor(string collider) =>
                    collider.Contains("corridor_");

                public static bool IsDuct(RaycastHit hit) =>
                    IsDuct(Collider(hit));
                public static bool IsDuct(string collider) =>
                    collider.Contains("duct_");

                public static bool IsFoundation(RaycastHit hit) =>
                    IsFoundation(Collider(hit));
                public static bool IsFoundation(string collider) =>
                    collider.Contains("foundation.");

                public static bool IsMine(RaycastHit hit) =>
                    IsMine(Collider(hit));
                public static bool IsMine(string collider) =>
                    collider.Contains("mine_tnl_");

                public static bool IsRoad(RaycastHit hit) =>
                    IsRoad(Collider(hit));
                public static bool IsRoad(string collider) =>
                    collider.Contains("road");

                public static bool IsRock(RaycastHit hit) =>
                    IsRock(Collider(hit));
                public static bool IsRock(string collider) =>
                    collider.Contains("rock_");

                public static bool IsStairwell(RaycastHit hit) =>
                    IsStairwell(Collider(hit));
                public static bool IsStairwell(string collider) =>
                    collider.Contains("stairwell_");

                public static bool IsTunnel(RaycastHit hit) =>
                    IsTunnel(Collider(hit));
                public static bool IsTunnel(string collider) =>
                    collider.Contains("tunnel");

                public static bool IsUnderground(RaycastHit hit) =>
                    IsUnderground(Collider(hit));
                public static bool IsUnderground(string collider)
                {
                    foreach(var partition in collider.Split('_', '.'))
                    {
                        switch(partition)
                        {
                        case "bunker":
                        case "corridor":
                        case "duct":
                        case "mine":
                        case "stairwell":
                        case "tunnel":
                            return true;
                        }
                    }

                    return false;
                }
            }

            public static bool InRange(Vector3 a, Vector3 b, float distance) =>
                (a - b).sqrMagnitude <= distance * distance;
            public static bool InRange2D(Vector3 a, Vector3 b, float distance) =>
                InRange(new Vector3(a.x, 0f, a.z), new Vector3(b.x, 0f, b.z), distance);

            public static void Load()
            {
                _instance.timer.In(0.1f, () => Monument.Load());
            }

            public class Monument
            {
                private static SparseMap global = new SparseMap(4.0f);
                private static SparseMap tunnel = new SparseMap(4.0f);

                public static bool IsNearby(Vector3 position) =>
                    global.Test(position);

                public static bool IsTunnel(Vector3 position) =>
                    tunnel.Test(position);

                public static void Load()
                {
                    foreach(var monument in TerrainMeta.Path.Monuments)
                    {
                        var center = monument.transform.position;
                        var radius = Range(monument);

                        global.Set(center, radius);

                        if(monument.name.Contains("entrance"))
                        {
                            tunnel.Set(center, radius);
                        }
                    }
                }

                private static float Range(MonumentInfo monument)
                {
                    var separator = monument.name.LastIndexOf('/');

                    switch((separator > 0) ? monument.name.Substring(separator + 1).Replace(".prefab", "") : monument.name)
                    {
                    case "airfield_1":              return 255f;
                    case "bandit_town":             return 105f;
                    case "cave_large_hard":
                    case "cave_large_medium":
                    case "cave_large_sewers_hard":
                    case "cave_medium_easy":
                    case "cave_medium_hard":
                    case "cave_medium_medium":
                    case "cave_small_easy":
                    case "cave_small_hard":
                    case "cave_small_medium":       return  75f;
                    case "compound":                return 255f;
                    case "entrance":                return  20f;
                    case "excavator_1":             return 150f;
                    case "fishing_village_a":
                    case "fishing_village_b":
                    case "fishing_village_c":       return  55f;
                    case "gas_station_1":           return  60f;
                    case "harbor_1":
                    case "harbor_2":                return 135f;
                    case "junkyard_1":              return 105f;
                    case "launch_site_1":           return 245f;
                    case "lighthouse":              return  50f;
                    case "military_tunnel_1":       return 105f;
                    case "mining_quarry_a":
                    case "mining_quarry_b":
                    case "mining_quarry_c":         return  30f;
                    case "OilrigAI":                return 100f;
                    case "OilrigAI2":               return 200f;
                    case "power_sub_big_1":
                    case "power_sub_big_2":         return  30f;
                    case "power_sub_small_1":
                    case "power_sub_small_2":       return  25f;
                    case "powerplant_1":            return 145f;
                    case "radtown_small_3":         return  95f;
                    case "satellite_dish":          return  85f;
                    case "sphere_tank":             return  75f;
                    case "stables_a":
                    case "stables_b":               return  80f;
                    case "supermarket_1":           return  60f;
                    case "swamp_a":
                    case "swamp_b":                 return  30f;
                    case "swamp_c":                 return  55f;
                    case "trainyard_1":             return 145f;
                    case "warehouse":               return  50f;
                    case "water_treatment_plant_1": return 175f;
                    case "water_well_a":
                    case "water_well_b":
                    case "water_well_c":
                    case "water_well_d":
                    case "water_well_e":            return  30f;
                    }

                    return 50.0f;
                }

                public static void Unload()
                {
                    global.Clear();
                    tunnel.Clear();
                }
            }

            public class Position
            {
                [Flags]
                public enum Check : ulong
                {
                    None     =  0ul,
                    Building =  1ul,
                    Entities =  1ul << 1,
                    Monument =  1ul << 2,
                    Road     =  1ul << 3,
                    Terrain  =  1ul << 4,
                    Water    =  1ul << 5,
                    All      = ~0ul
                }

                private static bool HasCheck(Check checks, Check check) =>
                    (checks & check) == check;

                public static Vector3 Random(Check checks = Check.All)
                {
                    var max = (float)(World.Size >> 1);
                    var min = -max;

                    Vector3 position;

                    do
                    {
                        position = Surface(Random(min, max, min, max));

                        if(HasCheck(checks, Check.Terrain))
                        {
                            if(!Terrain.IsSurface(position))
                            {
                                continue;
                            }
                        }
                        else if(HasCheck(checks, Check.Water) && !Water.IsSurface(position))
                        {
                            continue;
                        }

                        if(HasCheck(checks, Check.Monument) && Monument.IsNearby(position))
                        {
                            continue;
                        }

                        if(HasCheck(checks, Check.Road) && Road.IsNearby(position))
                        {
                            continue;
                        }

                        if(HasCheck(checks, Check.Building) && Building.IsNearby(position))
                        {
                            continue;
                        }

                        if(HasCheck(checks, Check.Entities) && Entities.InRange(position))
                        {
                            continue;
                        }
                    }
                    while(Rock.IsInside(position));

                    return position;
                }
                private static Vector3 Random(float min_x, float max_x, float min_z, float max_z) =>
                    new Vector3(Core.Random.Range(min_x, max_x), 0.0f, Core.Random.Range(min_z, max_z));
            }

            public class Road
            {
                public static bool IsNearby(Vector3 position)
                {
                    position = Terrain.Level(position, 0.5f);

                    foreach(var hit in Physics.RaycastAll(position, Vector3.down, 25.0f, Layers.Mask.World, QueryTriggerInteraction.Ignore))
                    {
                        if(Hit.IsRoad(hit))
                        {
                            return true;
                        }
                    }

                    return false;
                }
            }

            public class Rock
            {
                public static bool IsInside(Vector3 position, bool check_cave = true)
                {
                    if(check_cave && Cave.IsInside(position))
                    {
                        return false;
                    }

                    try
                    {
                        RaycastHit hit;

                        Physics.queriesHitBackfaces = true;

                        if(Physics.Raycast(position, Vector3.up, out hit, 25.0f, Layers.Mask.World, QueryTriggerInteraction.Ignore))
                        {
                            return Hit.IsRock(hit);
                        }
                    }
                    finally
                    {
                        Physics.queriesHitBackfaces = false;
                    }

                    return false;
                }
            }

            public static Vector3 Surface(Vector3 position, float offset = 0.0f) =>
                Terrain.IsSurface(position) ? Terrain.Level(position, offset) : Water.Level(position, offset);

            public class Terrain
            {
                public static float Height(Vector3 position) =>
                    TerrainMeta.HeightMap.GetHeight(position);

                public static bool IsInside(Vector3 position, bool check_cave = true)
                {
                    var elevation = Height(position);

                    if((elevation - 1.0f) > position.y)
                    {
                        float c_x = position.x + 1.0f, f_x = position.x - 1.0f;
                        float c_z = position.z + 1.0f, f_z = position.z - 1.0f;

                        elevation = Math.Min(elevation, Height(new Vector3(c_x, 0, c_z)));
                        elevation = Math.Min(elevation, Height(new Vector3(c_x, 0, f_z)));
                        elevation = Math.Min(elevation, Height(new Vector3(f_x, 0, c_z)));
                        elevation = Math.Min(elevation, Height(new Vector3(f_x, 0, f_z)));

                        if((elevation - 1.0f) > position.y)
                        {
                            if(check_cave && Cave.IsInside(position))
                            {
                                return false;
                            }
                            else if(Underground.IsInside(position))
                            {
                                return false;
                            }
                            else if(Monument.IsNearby(position))
                            {
                                return (elevation - 51.0f) > position.y;
                            }

                            return true;
                        }
                    }

                    return false;
                }

                public static bool IsSurface(Vector3 position) =>
                    Height(position) > Water.Height(position);

                public static Vector3 Level(Vector3 position, float offset = 0.0f) =>
                    new Vector3(position.x, Height(position) + offset, position.z);
            }

            public class Underground
            {
                public static bool IsInside(Vector3 position)
                {
                    if(Monument.IsTunnel(position))
                    {
                        return true;
                    }

                    foreach(var hit in Physics.RaycastAll(position, Vector3.up, 25.0f, Layers.Mask.World, QueryTriggerInteraction.Ignore))
                    {
                        if(Hit.IsUnderground(hit))
                        {
                            return true;
                        }
                    }

                    foreach(var hit in Physics.RaycastAll(position, Vector3.down, 25.0f, Layers.Mask.World, QueryTriggerInteraction.Ignore))
                    {
                        if(Hit.IsUnderground(hit))
                        {
                            return true;
                        }
                    }

                    return false;
                }
            }

            public static void Unload() => Monument.Unload();

            public class Water
            {
                public static float Height(Vector3 position) =>
                    TerrainMeta.WaterMap.GetHeight(position);

                public static bool IsSurface(Vector3 position) =>
                    Height(position) > Terrain.Height(position);

                public static Vector3 Level(Vector3 position, float offset = 0.0f) =>
                    new Vector3(position.x, Height(position) + offset, position.z);
            }
        }

        #endregion _map_

        #region _permissions_

        private class Permissions
        {
            private static string PERMISSION_ADMIN;
            private static string PERMISSION_ALL;
            private static string PERMISSION_IGNORE;
            private static string PERMISSION_PREFIX;

            private static readonly HashSet<ulong> all      = new HashSet<ulong>();
            private static readonly HashSet<ulong> admin    = new HashSet<ulong>();
            private static readonly HashSet<ulong> ignore   = new HashSet<ulong>();

            public static bool Admin(ulong userid, bool forced = false) =>
                (forced ? HasPermission(userid, PERMISSION_ADMIN) : admin.Contains(userid)) || All(userid, forced);

            public static bool All(ulong userid, bool forced = false) =>
                (forced ? HasPermission(userid, PERMISSION_ALL) : all.Contains(userid));

            public class Bypass
            {
                private static string PERMISSION_PREFIX;
                private static string PERMISSION_STEAM;
                private static string PERMISSION_VPN;

                private static readonly HashSet<ulong> steam = new HashSet<ulong>();
                private static readonly HashSet<ulong> vpn   = new HashSet<ulong>();

                public class AntiCheat
                {
                    private static readonly HashSet<ulong> aim        = new HashSet<ulong>();
                    private static readonly HashSet<ulong> firerate   = new HashSet<ulong>();
                    private static readonly HashSet<ulong> gravity    = new HashSet<ulong>();
                    private static readonly HashSet<ulong> meleerate  = new HashSet<ulong>();
                    private static readonly HashSet<ulong> recoil     = new HashSet<ulong>();
                    private static readonly HashSet<ulong> server     = new HashSet<ulong>();
                    private static readonly HashSet<ulong> stash      = new HashSet<ulong>();
                    private static readonly HashSet<ulong> trajectory = new HashSet<ulong>();
                    private static readonly HashSet<ulong> wallhack   = new HashSet<ulong>();

                    private static string PERMISSION_AIM;
                    private static string PERMISSION_FIRERATE;
                    private static string PERMISSION_GRAVITY;
                    private static string PERMISSION_MELEERATE;
                    private static string PERMISSION_PREFIX;
                    private static string PERMISSION_RECOIL;
                    private static string PERMISSION_SERVER;
                    private static string PERMISSION_STASH;
                    private static string PERMISSION_TRAJECTORY;
                    private static string PERMISSION_WALLHACK;

                    public static void Load()
                    {
                        PERMISSION_PREFIX = Bypass.PERMISSION_PREFIX + "anticheat.";

                        PERMISSION_AIM        = PERMISSION_PREFIX + "aim";
                        PERMISSION_FIRERATE   = PERMISSION_PREFIX + "firerate";
                        PERMISSION_GRAVITY    = PERMISSION_PREFIX + "gravity";
                        PERMISSION_MELEERATE  = PERMISSION_PREFIX + "meleerate";
                        PERMISSION_RECOIL     = PERMISSION_PREFIX + "recoil";
                        PERMISSION_SERVER     = PERMISSION_PREFIX + "server";
                        PERMISSION_STASH      = PERMISSION_PREFIX + "stash";
                        PERMISSION_TRAJECTORY = PERMISSION_PREFIX + "trajectory";
                        PERMISSION_WALLHACK   = PERMISSION_PREFIX + "wallhack";

                        _instance.permission.RegisterPermission(PERMISSION_AIM,        _instance);
                        _instance.permission.RegisterPermission(PERMISSION_FIRERATE,   _instance);
                        _instance.permission.RegisterPermission(PERMISSION_GRAVITY,    _instance);
                        _instance.permission.RegisterPermission(PERMISSION_MELEERATE,  _instance);
                        _instance.permission.RegisterPermission(PERMISSION_RECOIL,     _instance);
                        _instance.permission.RegisterPermission(PERMISSION_SERVER,     _instance);
                        _instance.permission.RegisterPermission(PERMISSION_STASH,      _instance);
                        _instance.permission.RegisterPermission(PERMISSION_TRAJECTORY, _instance);
                        _instance.permission.RegisterPermission(PERMISSION_WALLHACK,   _instance);
                    }

                    public static bool Aim(ulong userid, bool forced = false) =>
                       (forced ? HasPermission(userid, PERMISSION_AIM) : aim.Contains(userid)) || All(userid, forced);

                    public static bool FireRate(ulong userid, bool forced = false) =>
                        (forced ? HasPermission(userid, PERMISSION_FIRERATE) : firerate.Contains(userid)) || All(userid, forced);

                    public static bool Gravity(ulong userid, bool forced = false) =>
                        (forced ? HasPermission(userid, PERMISSION_GRAVITY) : gravity.Contains(userid)) || All(userid, forced);

                    public static bool MeleeRate(ulong userid, bool forced = false) =>
                        (forced ? HasPermission(userid, PERMISSION_MELEERATE) : meleerate.Contains(userid)) || All(userid, forced);

                    public static bool Recoil(ulong userid, bool forced = false) =>
                        (forced ? HasPermission(userid, PERMISSION_RECOIL) : recoil.Contains(userid)) || All(userid, forced);

                    public static void Reset(ulong userid)
                    {
                        aim.Remove(userid);
                        firerate.Remove(userid);
                        gravity.Remove(userid);
                        meleerate.Remove(userid);
                        recoil.Remove(userid);
                        server.Remove(userid);
                        stash.Remove(userid);
                        trajectory.Remove(userid);
                        wallhack.Remove(userid);
                    }

                    public static bool Server(ulong userid, bool forced = false) =>
                        (forced ? HasPermission(userid, PERMISSION_SERVER) : server.Contains(userid)) || All(userid, forced);

                    public static bool Stash(ulong userid, bool forced = false) =>
                        (forced ? HasPermission(userid, PERMISSION_STASH) : stash.Contains(userid)) || All(userid, forced);

                    public static bool Trajectory(ulong userid, bool forced = false) =>
                        (forced ? HasPermission(userid, PERMISSION_TRAJECTORY) : trajectory.Contains(userid)) || All(userid, forced);

                    public static void Unload()
                    {
                        PERMISSION_AIM = null;
                        PERMISSION_FIRERATE = null;
                        PERMISSION_GRAVITY = null;
                        PERMISSION_MELEERATE = null;
                        PERMISSION_PREFIX = null;
                        PERMISSION_RECOIL = null;
                        PERMISSION_SERVER = null;
                        PERMISSION_STASH = null;
                        PERMISSION_TRAJECTORY = null;
                        PERMISSION_WALLHACK = null;

                        aim.Clear();
                        firerate.Clear();
                        gravity.Clear();
                        meleerate.Clear();
                        recoil.Clear();
                        server.Clear();
                        stash.Clear();
                        trajectory.Clear();
                        wallhack.Clear();
                    }

                    public static void Update(ulong userid)
                    {
                        if(!userid.IsSteamId())
                        {
                            return;
                        }

                        Permissions.Update(userid, PERMISSION_AIM,        aim);
                        Permissions.Update(userid, PERMISSION_FIRERATE,   firerate);
                        Permissions.Update(userid, PERMISSION_GRAVITY,    gravity);
                        Permissions.Update(userid, PERMISSION_MELEERATE,  meleerate);
                        Permissions.Update(userid, PERMISSION_RECOIL,     recoil);
                        Permissions.Update(userid, PERMISSION_SERVER,     server);
                        Permissions.Update(userid, PERMISSION_STASH,      stash);
                        Permissions.Update(userid, PERMISSION_TRAJECTORY, trajectory);
                        Permissions.Update(userid, PERMISSION_WALLHACK,   wallhack);
                    }

                    public static bool WallHack(ulong userid, bool forced = false) =>
                        (forced ? HasPermission(userid, PERMISSION_WALLHACK) : wallhack.Contains(userid)) || All(userid, forced);
                }

                public static void Load()
                {
                    PERMISSION_PREFIX = Permissions.PERMISSION_PREFIX + "bypass.";

                    PERMISSION_STEAM = PERMISSION_PREFIX + "steam";
                    PERMISSION_VPN   = PERMISSION_PREFIX + "vpn";

                    _instance.permission.RegisterPermission(PERMISSION_STEAM, _instance);
                    _instance.permission.RegisterPermission(PERMISSION_VPN,   _instance);

                    AntiCheat.Load();
                }

                public static void Reset(ulong userid)
                {
                    steam.Remove(userid);
                    vpn.Remove(userid);

                    AntiCheat.Reset(userid);
                }

                public static bool Steam(ulong userid, bool forced = false) =>
                    (forced ? HasPermission(userid, PERMISSION_STEAM) : steam.Contains(userid)) || All(userid, forced);

                public static void Unload()
                {
                    PERMISSION_PREFIX = null;
                    PERMISSION_STEAM  = null;
                    PERMISSION_VPN    = null;

                    steam.Clear();
                    vpn.Clear();

                    AntiCheat.Unload();
                }

                public static void Update(ulong userid)
                {
                    Permissions.Update(userid, PERMISSION_STEAM, vpn);
                    Permissions.Update(userid, PERMISSION_VPN,   vpn);

                    AntiCheat.Update(userid);
                }

                public static bool Vpn(ulong userid, bool forced = false) =>
                    (forced ? HasPermission(userid, PERMISSION_VPN) : vpn.Contains(userid)) || All(userid, forced);
            }

            public class Command
            {
                private static readonly HashSet<ulong> config = new HashSet<ulong>();
                private static readonly HashSet<ulong> ip     = new HashSet<ulong>();
                private static readonly HashSet<ulong> server = new HashSet<ulong>();
                private static readonly HashSet<ulong> tp     = new HashSet<ulong>();
                private static readonly HashSet<ulong> vpn    = new HashSet<ulong>();

                private static string PERMISSION_CONFIG;
                private static string PERMISSION_IP;
                private static string PERMISSION_PREFIX;
                private static string PERMISSION_SERVER;
                private static string PERMISSION_TP;
                private static string PERMISSION_VPN;

                public static void Load()
                {
                    PERMISSION_PREFIX = Permissions.PERMISSION_PREFIX + "command.";

                    PERMISSION_CONFIG = PERMISSION_PREFIX + "config";
                    PERMISSION_IP     = PERMISSION_PREFIX + "ip";
                    PERMISSION_SERVER = PERMISSION_PREFIX + "server";
                    PERMISSION_TP     = PERMISSION_PREFIX + "teleport";
                    PERMISSION_VPN    = PERMISSION_PREFIX + "vpn";

                    _instance.permission.RegisterPermission(PERMISSION_CONFIG, _instance);
                    _instance.permission.RegisterPermission(PERMISSION_IP,     _instance);
                    _instance.permission.RegisterPermission(PERMISSION_SERVER, _instance);
                    _instance.permission.RegisterPermission(PERMISSION_TP,     _instance);
                    _instance.permission.RegisterPermission(PERMISSION_VPN,    _instance);
                }

                public static bool Config(ulong userid, bool forced = false) =>
                   (forced ? HasPermission(userid, PERMISSION_CONFIG) : config.Contains(userid)) || All(userid, forced);

                public static bool Ip(ulong userid, bool forced = false) =>
                    (forced ? HasPermission(userid, PERMISSION_IP) : ip.Contains(userid)) || All(userid, forced);

                public static void Reset(ulong userid)
                {
                    config.Remove(userid);
                    ip.Remove(userid);
                    server.Remove(userid);
                    tp.Remove(userid);
                    vpn.Remove(userid);
                }

                public static bool Server(ulong userid, bool forced = false) =>
                    (forced ? HasPermission(userid, PERMISSION_SERVER) : server.Contains(userid)) || All(userid, forced);

                public static bool Tp(ulong userid, bool forced = false) =>
                    (forced ? HasPermission(userid, PERMISSION_SERVER) : server.Contains(userid)) || All(userid, forced);

                public static void Unload()
                {
                    PERMISSION_CONFIG = null;
                    PERMISSION_IP     = null;
                    PERMISSION_PREFIX = null;
                    PERMISSION_SERVER = null;
                    PERMISSION_TP     = null;
                    PERMISSION_VPN    = null;

                    config.Clear();
                    ip.Clear();
                    server.Clear();
                    tp.Clear();
                    vpn.Clear();
                }

                public static void Update(ulong userid)
                {
                    Permissions.Update(userid, PERMISSION_CONFIG, config);
                    Permissions.Update(userid, PERMISSION_IP,     ip);
                    Permissions.Update(userid, PERMISSION_SERVER, server);
                    Permissions.Update(userid, PERMISSION_TP,     tp);
                    Permissions.Update(userid, PERMISSION_VPN,    vpn);
                }

                public static bool Vpn(ulong userid, bool forced = false) =>
                    (forced ? HasPermission(userid, PERMISSION_VPN) : vpn.Contains(userid)) || All(userid, forced);
            }

            public static string[] Groups(ulong userid) =>
                _instance.permission.GetUserGroups(userid.ToString());

            private static bool HasPermission(ulong userid, string permission) =>
                _instance.permission.UserHasPermission(userid.ToString(), permission);

            public static bool HasPrefix(string permission) =>
                permission.StartsWith(PERMISSION_PREFIX);

            public static bool Ignore(ulong userid, bool forced = false) =>
                (forced ? HasPermission(userid, PERMISSION_IGNORE) : ignore.Contains(userid)) || All(userid, forced);

            public static void Load()
            {
                PERMISSION_PREFIX = _instance.Name.ToLower() + ".";

                PERMISSION_ALL      = PERMISSION_PREFIX + "all";
                PERMISSION_ADMIN    = PERMISSION_PREFIX + "admin";
                PERMISSION_IGNORE   = PERMISSION_PREFIX + "ignore";

                _instance.permission.RegisterPermission(PERMISSION_ALL,    _instance);
                _instance.permission.RegisterPermission(PERMISSION_ADMIN,  _instance);
                _instance.permission.RegisterPermission(PERMISSION_IGNORE, _instance);

                Bypass.Load();
                Command.Load();
            }

            public static void Reset(ulong userid)
            {
                all.Remove(userid);
                admin.Remove(userid);
                ignore.Remove(userid);

                Bypass.Reset(userid);
                Command.Reset(userid);
            }

            public static void Unload()
            {
                PERMISSION_ALL      = null;
                PERMISSION_ADMIN    = null;
                PERMISSION_IGNORE   = null;
                PERMISSION_PREFIX   = null;

                all.Clear();
                admin.Clear();
                ignore.Clear();

                Bypass.Unload();
                Command.Unload();
            }

            public static void Update(ulong userid)
            {
                if(!userid.IsSteamId())
                {
                    return;
                }

                Update(userid, PERMISSION_ALL,    all);
                Update(userid, PERMISSION_ADMIN,  admin);
                Update(userid, PERMISSION_IGNORE, ignore);

                Bypass.Update(userid);
                Command.Update(userid);
            }

            private static bool Update(ulong userid, string permission, HashSet<ulong> cache) =>
                HasPermission(userid, permission) ? cache.Add(userid) : cache.Remove(userid);
        }

        #endregion _permissions_

        #region _projectile_

        private class Projectile
        {
            public class Log
            {
                private static readonly Queue<Entry>                              expired = new Queue<Entry>();
                private static readonly Dictionary<ulong, Queue<Entry>>           history = new Dictionary<ulong, Queue<Entry>>();
                private static readonly Dictionary<ulong, Dictionary<int, Entry>> pending = new Dictionary<ulong, Dictionary<int, Entry>>();
                private static readonly Queue<Request>                            request = new Queue<Request>();
                private static readonly Queue<Entry>                              reserve = new Queue<Entry>();

                static readonly StringBuilder buffer = new StringBuilder();

                private class Entry
                {
                    public float    aim_angle;
                    public float    aim_pvp;
                    public float    aim_range;
                    public ulong    aim_violations;
                    public string   attacker;
                    public ulong    attacker_id;
                    public ulong    firerate_violations;
                    public float    hit_distance;
                    public HitArea  hit_location;
                    public bool     pvp;
                    public float    recoil_pitch;
                    public ulong    recoil_repeats;
                    public float    recoil_swing;
                    public ulong    recoil_violations;
                    public float    recoil_yaw;
                    public bool     ricochet;
                    public float    speed;
                    public DateTime timestamp;
                    public float    trajectory;
                    public ulong    trajectory_violations;
                    public string   victim;
                    public bool     violations;
                    public ulong    wallhack_violations;
                    public string   weapon;

                    private static readonly Queue<Entry> pool = new Queue<Entry>();

                    private Entry(DateTime timestamp)
                    {
                        Default().Set(timestamp);
                    }

                    private Entry Default()
                    {
                        aim_angle = 1;
                        aim_pvp = 1;
                        aim_range = 1;
                        aim_violations = 0;
                        attacker = null;
                        attacker_id = 0;
                        firerate_violations = 0;
                        hit_distance = 0;
                        hit_location = 0;
                        pvp = false;
                        recoil_pitch = 1;
                        recoil_repeats = 0;
                        recoil_swing = 0;
                        recoil_violations = 0;
                        recoil_yaw = 1;
                        speed = 0;
                        trajectory = 1;
                        trajectory_violations = 0;
                        victim = null;
                        violations = false;
                        wallhack_violations = 0;
                        weapon = null;

                        return this;
                    }

                    public string Format(bool collapse, bool id, bool time)
                    {
                        buffer.Clear();

                        if(time)
                        {
                            var delta = DateTime.UtcNow.Subtract(timestamp);

                            buffer.Append(((int)delta.TotalSeconds).ToString("D5")).Append('.').Append((delta.Milliseconds / 10).ToString("D2")).Append("s ");
                        }

                        buffer.Append("Recoil[").Append(recoil_repeats.ToString("D2"));
                        buffer.Append("](x=").Append(recoil_yaw.ToString("F6"));
                        buffer.Append(", y=").Append(recoil_pitch.ToString("F6"));
                        buffer.Append(", a=").Append(recoil_swing.ToString("F1"));
                        buffer.Append(')');

                        if(!(collapse && string.IsNullOrEmpty(victim)))
                        {
                            buffer.Append(" Trajectory(").Append(trajectory.ToString("F6")).Append(')');

                            buffer.Append(" Aim(a=").Append(aim_angle.ToString("F6")).Append(", p=").Append(aim_pvp.ToString("F6")).Append(", r=").Append(aim_range.ToString("F6")).Append(')');
                        }

                        if(id)
                        {
                            buffer.Append(' ').Append(attacker).Append('[').Append(attacker_id.ToString()).Append(']');
                        }

                        buffer.Append(" (").Append(speed.ToString("F1")).Append("m/s, ").Append(weapon).Append(')');

                        if(victim != null)
                        {
                            buffer.Append(": ").Append(victim).Append('[').Append(Text.BodyPart(hit_location)).Append(", ").Append(hit_distance.ToString("F1")).Append("m]");
                        }

                        if(violations)
                        {
                            buffer.Append(' ');

                            if(       aim_violations > 0) buffer.Append("[A]");
                            if(  firerate_violations > 0) buffer.Append("[F]");
                            if(    recoil_violations > 0) buffer.Append("[R]");
                            if(trajectory_violations > 0) buffer.Append("[T]");
                            if(  wallhack_violations > 0) buffer.Append("[W]");
                        }

                        return buffer.ToString();
                    }

                    public static Entry Get(DateTime timestamp) => (pool.Count > 0) ? pool.Dequeue().Set(timestamp) : new Entry(timestamp);

                    public void Release() => pool.Enqueue(Default());

                    private Entry Set(DateTime timestamp)
                    {
                        this.timestamp = timestamp;

                        return this;
                    }

                    public static void Unload() => pool.Clear();
                }

                private class Request
                {
                    public IPlayer actor;
                    public int     lines;
                    public ulong   userid;
                }

                public static void Add(Weapon weapon)
                {
                    Dictionary<int, Entry> _pending;

                    if(!pending.TryGetValue(weapon.Player.userID, out _pending))
                    {
                        pending.Add(weapon.Player.userID, _pending = new Dictionary<int, Entry>());
                    }

                    foreach(var projectileid in weapon.Projectiles)
                    {
                        try
                        {
                            _pending.Add(projectileid, Entry.Get(weapon.Fired));
                        }
                        catch(Exception e)
                        {
                            Guardian.Log.Warning($"Projectile.Log.Add({projectileid}): {weapon.Name}({e.Message})");
                        }
                    }
                }

                public static void Expire(Weapon weapon)
                {
                    Dictionary<int, Entry> _pending;

                    if(pending.TryGetValue(weapon.Player.userID, out _pending))
                    {
                        foreach(var projectileid in weapon.Projectiles)
                        {
                            Entry entry;

                            if(_pending.TryGetValue(projectileid, out entry))
                            {
                                _pending.Remove(projectileid);

                                if(config.Log.Projectile.Verbose || entry.violations || (entry.victim != null) || (weapon.Projectiles.Count == 1))
                                {
                                    reserve.Enqueue(entry);
                                }
                                else
                                {
                                    expired.Enqueue(entry);
                                }
                            }
                        }

                        while(expired.Count > 0)
                        {
                            expired.Dequeue().Release();
                        }

                        Queue<Entry> _history;

                        if(!history.TryGetValue(weapon.Player.userID, out _history))
                        {
                            history.Add(weapon.Player.userID, _history = new Queue<Entry>());
                        }

                        while(reserve.Count > 0)
                        {
                            if(_history.Count > 64)
                            {
                                _history.Dequeue().Release();
                            }

                            _history.Enqueue(reserve.Dequeue());
                        }
                    }
                }

                public static void Get(IPlayer actor, ulong userid, int lines)
                {
                    request.Enqueue(new Request { actor = actor, lines = lines, userid = userid });
                }

                public static float GetAimAngle(ulong userid, int id)
                {
                    var aim_angle = 0.0f;

                    TrySetEntry(userid, id, entry =>
                    {
                        aim_angle = entry.aim_angle;
                    });

                    return aim_angle;
                }

                public static bool GetAimPvp(ulong userid, int id)
                {
                    var pvp = false;

                    TrySetEntry(userid, id, entry =>
                    {
                        pvp = entry.pvp;
                    });

                    return pvp;
                }

                public static float GetHitDistance(ulong userid, int id)
                {
                    var hit_distance = 0.0f;

                    TrySetEntry(userid, id, entry =>
                    {
                        hit_distance = entry.hit_distance;
                    });

                    return hit_distance;
                }

                public static HitArea GetHitLocation(ulong userid, int id)
                {
                    var hit_location = (HitArea)0;

                    TrySetEntry(userid, id, entry =>
                    {
                        hit_location = entry.hit_location;
                    });

                    return hit_location;
                }

                public static bool GetRicochet(ulong userid, int id)
                {
                    var ricochet = false;

                    TrySetEntry(userid, id, entry =>
                    {
                        ricochet = entry.ricochet;
                    });

                    return ricochet;
                }

                public static string GetVictim(ulong userid, int id)
                {
                    var victim = string.Empty;

                    TrySetEntry(userid, id, entry =>
                    {
                        victim = entry.victim;
                    });

                    return victim;
                }

                public static void Send()
                {
                    if(request.Count == 0)
                    {
                        return;
                    }

                    var send = request.Dequeue();

                    Queue<Entry> _history;

                    if(!history.TryGetValue(send.userid, out _history) || (_history.Count == 0))
                    {
                        Chat.Reply(send.actor, Key.CommandLogNoEntries, new Dictionary<string, string>
                        {
                            { "playerid", send.userid.ToString() },
                            { "playername", Text.Sanitize(User.Name(send.userid)) }
                        });

                        return;
                    }

                    if(send.actor.LastCommand == CommandType.Chat)
                    {
                        Chat.Reply(send.actor, Key.CommandLogSeeConsole);

                        send.actor.LastCommand = CommandType.Console;
                    }

                    Chat.Reply(send.actor, Key.CommandLogHeading, new Dictionary<string, string>
                    {
                        { "playerid", send.userid.ToString() },
                        { "playername", Text.Sanitize(User.Name(send.userid)) }
                    });

                    var skip = (_history.Count > send.lines) ? (_history.Count - send.lines) : 0;

                    foreach(var entry in _history)
                    {
                        if(skip > 0)
                        {
                            --skip; continue;
                        }

                        Chat.Reply(send.actor, Key.CommandLogLine, new Dictionary<string, string>
                        {
                            { "info", entry.Format(config.Log.Projectile.Collapse, false, true) }
                        });
                    }
                }

                public static void SetAim(ulong userid, int id, float aim_angle, float aim_pvp, float aim_range, bool pvp, bool ricochet)
                {
                    TrySetEntry(userid, id, entry =>
                    {
                        entry.aim_angle = aim_angle;
                        entry.aim_pvp   = aim_pvp;
                        entry.aim_range = aim_range;
                        entry.pvp       = pvp;
                        entry.ricochet  = ricochet;
                    });
                }
                public static void SetAimViolations(ulong userid, int id, ulong aim_violations, bool add = false)
                {
                    TrySetEntry(userid, id, entry =>
                    {
                        entry.aim_violations = add ? (aim_violations += aim_violations) : aim_violations;
                        entry.violations     = entry.violations || (entry.aim_violations > 0);
                    });
                }

                public static void SetAttacker(ulong userid, int id, string attacker, ulong attaker_id)
                {
                    TrySetEntry(userid, id, entry =>
                    {
                        entry.attacker    = attacker;
                        entry.attacker_id = attaker_id;
                    });
                }

                public static void SetFireRateViolations(ulong userid, int id, ulong firerate_violations)
                {
                    TrySetEntry(userid, id, entry =>
                    {
                        entry.violations = entry.violations || ((entry.firerate_violations = firerate_violations) > 0);
                    });
                }

                public static void SetHit(ulong userid, int id, float hit_distance, HitArea hit_location)
                {
                    TrySetEntry(userid, id, entry =>
                    {
                        entry.hit_distance = hit_distance;
                        entry.hit_location = hit_location;
                    });
                }

                public static void SetRecoil(ulong userid, int id, float recoil_pitch, ulong recoil_repeats, float recoil_yaw, float recoil_swing)
                {
                    TrySetEntry(userid, id, entry =>
                    {
                        entry.recoil_pitch   = recoil_pitch;
                        entry.recoil_repeats = recoil_repeats;
                        entry.recoil_swing   = recoil_swing;
                        entry.recoil_yaw     = recoil_yaw;
                    });
                }
                public static void SetRecoilViolations(ulong userid, int id, ulong recoil_violations)
                {
                    TrySetEntry(userid, id, entry =>
                    {
                        entry.violations = entry.violations || ((entry.recoil_violations = recoil_violations) > 0);
                    });
                }

                public static void SetTrajectory(ulong userid, int id, float trajectory)
                {
                    TrySetEntry(userid, id, entry =>
                    {
                        entry.trajectory = trajectory;
                    });
                }
                public static void SetTrajectoryViolations(ulong userid, int id, ulong trajectory_violations)
                {
                    TrySetEntry(userid, id, entry =>
                    {
                        entry.violations = entry.violations || ((entry.trajectory_violations = trajectory_violations) > 0);
                    });
                }

                public static void SetVictim(ulong userid, int id, string victim)
                {
                    TrySetEntry(userid, id, entry =>
                    {
                        entry.victim = victim;
                    });
                }

                public static void SetWallHackViolations(ulong userid, int id, ulong wallhack_violations)
                {
                    TrySetEntry(userid, id, entry =>
                    {
                        entry.violations = entry.violations || ((entry.wallhack_violations = wallhack_violations) > 0);
                    });
                }

                public static void SetWeapon(ulong userid, int id, float speed, string weapon)
                {
                    TrySetEntry(userid, id, entry =>
                    {
                        entry.speed  = speed;
                        entry.weapon = weapon;
                    });
                }

                private static void TrySetEntry(ulong userid, int id, Action<Entry> set)
                {
                    Dictionary<int, Entry> _pending;

                    if(pending.TryGetValue(userid, out _pending))
                    {
                        Entry entry;

                        if(_pending.TryGetValue(id, out entry))
                        {
                            set(entry);
                        }
                    }
                }

                public static void Unload()
                {
                    buffer.Clear();

                    expired.Clear();
                    history.Clear();
                    pending.Clear();
                    request.Clear();
                    reserve.Clear();

                    Entry.Unload();
                }
            }

            private static readonly List<Weapon>                               expired = new List<Weapon>();
            private static readonly Dictionary<ulong, Dictionary<int, Weapon>> reverse = new Dictionary<ulong, Dictionary<int, Weapon>>();
            private static readonly Dictionary<ulong, Queue<Weapon>>           weapons = new Dictionary<ulong, Queue<Weapon>>();

            public static void Add(Weapon weapon)
            {
                Queue<Weapon> _weapons;

                if(!weapons.TryGetValue(weapon.Player.userID, out _weapons))
                {
                    weapons.Add(weapon.Player.userID, _weapons = new Queue<Weapon>());
                }

                _weapons.Enqueue(weapon);

                Dictionary<int, Weapon> _reverse;

                if(!reverse.TryGetValue(weapon.Player.userID, out _reverse))
                {
                    reverse.Add(weapon.Player.userID, _reverse = new Dictionary<int, Weapon>());
                }

                foreach(var projectileid in weapon.Projectiles)
                {
                    _reverse[projectileid] = weapon;
                }

                Log.Add(weapon);
            }

            public static void Load()
            {
                Timers.Add(0.1f, () =>
                {
                    var time = DateTime.UtcNow;

                    foreach(var user in weapons)
                    {
                        var _weapons = user.Value;

                        while(_weapons.Count > 0)
                        {
                            if(time.Subtract(_weapons.Peek().Fired).TotalSeconds > 9.0)
                            {
                                expired.Add(_weapons.Dequeue());
                            }
                            else
                            {
                                break;
                            }
                        }
                    }

                    expired.Sort((x, y) => DateTime.Compare(x.Fired, y.Fired));

                    foreach(var weapon in expired)
                    {
                        AntiCheat.Aim.Update(weapon);

                        Dictionary<int, Weapon> _reverse;

                        if(reverse.TryGetValue(weapon.Player.userID, out _reverse))
                        {
                            foreach(var projectileid in weapon.Projectiles)
                            {
                                _reverse.Remove(projectileid);
                            }

                            Log.Expire(weapon);

                            weapon.Release();
                        }

                    }

                    expired.Clear();

                    Log.Send();
                });
            }

            public static void Unload()
            {
                expired.Clear();
                reverse.Clear();
                weapons.Clear();

                Log.Unload();
            }

            public static Weapon Weapon(ulong userid, int projectileid)
            {
                Dictionary<int, Weapon> _reverse;

                if(reverse.TryGetValue(userid, out _reverse))
                {
                    Weapon weapon;

                    if(_reverse.TryGetValue(projectileid, out weapon))
                    {
                        return weapon;
                    }
                }

                return null;
            }
        }

        #endregion _projectile_

        #region _sparse_map_

        private class SparseMap
        {
            private Dictionary<Texel, Cell> map;
            private float map_scale;

            private struct Cell
            {
                private ulong pixels;

                public bool IsEmpty() =>
                    pixels == 0;

                private static ulong Mask(Delta delta) =>
                    1ul << (((delta.Y + 4) << 3) + delta.X + 4);

                public Cell Reset(Delta delta) =>
                    new Cell { pixels = pixels & ~Mask(delta) };

                public Cell Set(Delta delta) =>
                    new Cell { pixels = pixels | Mask(delta) };

                public bool Test(Delta delta) =>
                    (pixels & Mask(delta)) != 0;
            }

            private struct Delta
            {
                public int X { get; private set; }
                public int Y { get; private set; }

                public Delta(Texel texel, Pixel pixel)
                {
                    X = pixel.X - texel.X;
                    Y = pixel.Y - texel.Y;
                }
            }

            private struct Pixel
            {
                public int X { get; private set; }
                public int Y { get; private set; }

                public Pixel(int x, int y)
                {
                    X = x;
                    Y = y;
                }

                public Pixel(Vector3 position, SparseMap map)
                {
                    X = map.Scale(position.x);
                    Y = map.Scale(position.z);
                }
            }

            private struct Texel
            {
                public int X { get; private set; }
                public int Y { get; private set; }

                public Texel(Pixel pixel)
                {
                    X = pixel.X & ~7;
                    Y = pixel.Y & ~7;
                }

                public override bool Equals(object o) =>
                    (o is Texel) ? (this == (Texel)o) : false;

                public static bool operator ==(Texel a, Texel b) =>
                    (a.X == b.X) && (a.Y == b.Y);
                public static bool operator !=(Texel a, Texel b) =>
                    (a.X != b.X) || (a.Y != b.Y);

                public override int GetHashCode() =>
                    (((X * 1664525 + 1013904223) & 0x3fffffff) >> 3) ^ ((Y * 1103515245 + 12345) << 2);
            }

            public SparseMap(float scale)
            {
                map = new Dictionary<Texel, Cell>();

                SetScale(scale);
            }

            public void Clear() => map.Clear();
            public int Count() => map.Count;

            public void Reset(float scale = 0.0f)
            {
                Clear();

                if(scale != 0.0f)
                {
                    SetScale(scale);
                }
            }
            private void Reset(Pixel pixel)
            {
                var texel = new Texel(pixel);

                Cell value;

                if(!map.TryGetValue(texel, out value))
                {
                    return;
                }

                value = value.Reset(new Delta(texel, pixel));

                if(value.IsEmpty())
                {
                    map.Remove(texel);
                }
                else
                {
                    map[texel] = value;
                }
            }
            public void Reset(Vector3 position) =>
                Reset(new Pixel(position, this));

            public float Scale() => map_scale;
            private int Scale(float n) =>
                (int)(n * map_scale);

            private void Set(Pixel pixel)
            {
                var texel = new Texel(pixel);

                Cell value;

                if(!map.TryGetValue(texel, out value))
                {
                    value = new Cell();
                }

                map[texel] = value.Set(new Delta(texel, pixel));
            }
            public void Set(Vector3 position) =>
                Set(new Pixel(position, this));
            public int Set(Vector3 origin, float range)
            {
                var pixels = 0;
                var center = new Pixel(origin, this);

                var r = Scale(range);

                if(r < 0)
                {
                    return pixels;
                }

                var r_squared = r * r;

                if(r_squared == 0)
                {
                    if(range >= 0.25f)
                    {
                        Set(center); ++pixels;
                    }

                    return pixels;
                }

                for(int delta_x = -r; delta_x < r; ++delta_x)
                {
                    int delta_y = (int)Math.Sqrt(r_squared - delta_x * delta_x);

                    int x = center.X + delta_x, limit_y = center.Y + delta_y;

                    for(int y = center.Y - delta_y; y < limit_y; ++y)
                    {
                        Set(new Pixel(x, y)); ++pixels;
                    }
                }

                return pixels;
            }

            private void SetScale(float scale)
            {
                scale = Math.Abs(scale);

                scale = (scale < 0.125f) ? 0.125f : scale;

                map_scale = 1.0f / scale;
            }

            private bool Test(Pixel pixel)
            {
                var texel = new Texel(pixel);

                Cell value;

                if(map.TryGetValue(texel, out value))
                {
                    return value.Test(new Delta(texel, pixel));
                }

                return false;
            }
            public bool Test(Vector3 position) =>
                Test(new Pixel(position, this));
        }

        #endregion _sparse_map_

        #region _steam_

        private class Steam
        {
            public class Settings
            {
                public API.Settings   API;
                public SteamBan       Ban;
                public SteamGame      Game;
                public SteamProfile   Profile;
                public SteamShare     Share;
                public SteamViolation Violation;

                public Settings()
                {
                    API       = new API.Settings();
                    Ban       = new SteamBan();
                    Game      = new SteamGame();
                    Profile   = new SteamProfile();
                    Share     = new SteamShare();
                    Violation = new SteamViolation();
                }

                public class SteamBan
                {
                    public bool  Active;
                    public bool  Community;
                    public ulong Days;
                    public bool  Economy;
                    public ulong Game;
                    public ulong VAC;
                }
                public class SteamGame
                {
                    public ulong Count;
                    public ulong Hours;
                }
                public class SteamProfile
                {
                    public bool Invalid;
                    public bool Limited;
                    public bool Private;
                }
                public class SteamShare
                {
                    public bool Family;
                }

                public class SteamViolation
                {
                    public bool Ban;
                    public bool Enabled;
                    public bool Warn;

                    public SteamViolation()
                    {
                        Ban     = false;
                        Enabled = true;
                        Warn    = false;
                    }
                }

                public void Validate()
                {
                    Configuration.Validate(ref API,       () => new API.Settings(), () => API.Validate());
                    Configuration.Validate(ref Ban,       () => new SteamBan());
                    Configuration.Validate(ref Game,      () => new SteamGame());
                    Configuration.Validate(ref Profile,   () => new SteamProfile());
                    Configuration.Validate(ref Share,     () => new SteamShare());
                    Configuration.Validate(ref Violation, () => new SteamViolation());
                }
            }

            private static uint appid;

            private static ActionQueue checks;

            private static readonly Violation violation = new Violation(Key.Steam);

            public static void Check(ulong userid)
            {
                if(!config.Steam.API.Enabled || Permissions.Bypass.Steam(userid))
                {
                    return;
                }

                if(string.IsNullOrEmpty(config.Steam.API.ApiKey))
                {
                    Log.Console(Key.LogSteamConfig, new Dictionary<string, string>
                    {
                        { "api", "API" },
                        { "link", $"https://steamcommunity.com/dev/apikey" }
                    });

                    return;
                }

                if(Ban.check)
                {
                    checks.Enqueue(() => Ban.Check(userid));
                }
            }

            public static void Configure()
            {
                violation.Configure(new Violation.Settings(true, 3600, 0.5f, config.Steam.Violation.Warn), 1, 1, 1);

                Game.check = Share.check = Profile.check = Summaries.check = Ban.check = false;

                if(config.Steam.API.Enabled)
                {
                    Game.check =
                        config.Steam.Game.Count > 0 ||
                        config.Steam.Game.Hours > 0;

                    Share.check =
                        Game.check ||
                        config.Steam.Share.Family;

                    Profile.check =
                        Share.check ||
                        config.Steam.Profile.Invalid ||
                        config.Steam.Profile.Limited;

                    Summaries.check =
                        Profile.check ||
                        config.Steam.Profile.Private;

                    Ban.check =
                        Summaries.check ||
                        config.Steam.Ban.Active ||
                        config.Steam.Ban.Community ||
                        config.Steam.Ban.Days > 0 ||
                        config.Steam.Ban.Economy ||
                        config.Steam.Ban.Game > 0 ||
                        config.Steam.Ban.VAC > 0;
                }
            }

            public static void Load()
            {
                appid = _instance.covalence.ClientAppId;

                Configure();

                checks = new ActionQueue(1.0f);
            }

            public static void Unload()
            {
                checks.Clear();
                checks = null;

                violation.Clear();
            }

            private static void Violation(ulong userid, Key type, string details, bool ban = false)
            {
                if(config.Steam.Violation.Enabled)
                {
                    ulong violations = (config.Steam.Violation.Ban || ban) ? ulong.MaxValue : 1ul;

                    violation.Trigger(userid, type, details, violations, true);
                }
                else
                {
                    if(User.IsConnected(userid))
                    {
                        User.Kick(userid, $"Steam: {type}");
                    }
                }
            }

            private class Ban
            {
                [JsonProperty("players")]
                public Player[] Players;

                public class Player
                {
                    [JsonProperty("CommunityBanned")]
                    public bool CommunityBanned;

                    [JsonProperty("VACBanned")]
                    public bool VacBanned;

                    [JsonProperty("NumberOfVACBans")]
                    public ulong NumberOfVacBans;

                    [JsonProperty("DaysSinceLastBan")]
                    public ulong DaysSinceLastBan;

                    [JsonProperty("NumberOfGameBans")]
                    public ulong NumberOfGameBans;

                    [JsonProperty("EconomyBan")]
                    public string EconomyBan;
                }

                [JsonIgnore]
                private static readonly string api = nameof(Ban);

                [JsonIgnore]
                public static bool check = false;

                public static void Check(ulong userid)
                {
                    var url = $"https://api.steampowered.com/ISteamUser/GetPlayerBans/v1/?key={config.Steam.API.ApiKey}&steamids={userid}";

                    _instance.webrequest.Enqueue(url, string.Empty, (code, reply) =>
                    {
                        if(code != 200 || string.IsNullOrEmpty(reply))
                        {
                            Log.Console(Key.LogSteam, new Dictionary<string, string>
                            {
                                { "api", api },
                                { "info", $"({code}: {reply})" },
                                { "playerid", userid.ToString() },
                                { "playername", Text.Sanitize(User.Name(userid)) },
                                { "type", "HTTP" }
                            });

                            return;
                        }

                        try
                        {
                            var response = JsonConvert.DeserializeObject<Ban>(reply).Players[0];

                            var has_bans = (response.NumberOfGameBans + response.NumberOfVacBans) > 0;

                            if(config.Steam.Ban.Active && response.VacBanned)
                            {
                                Violation(userid, Key.SteamBanActive, $"{true}");
                            }
                            else if(config.Steam.Ban.Community && response.CommunityBanned)
                            {
                                Violation(userid, Key.SteamBanCommunity, $"{true}");
                            }
                            else if((config.Steam.Ban.Days > 0) && (config.Steam.Ban.Days > response.DaysSinceLastBan) && has_bans)
                            {
                                Violation(userid, Key.SteamBanDays, $"{response.DaysSinceLastBan}");
                            }
                            else if(config.Steam.Ban.Economy && (response.EconomyBan == "banned"))
                            {
                                Violation(userid, Key.SteamBanEconomy, $"{true}");
                            }
                            else if((config.Steam.Ban.Game > 0) && (config.Steam.Ban.Game <= response.NumberOfGameBans))
                            {
                                Violation(userid, Key.SteamBanGame, $"{response.NumberOfGameBans}", true);
                            }
                            else if((config.Steam.Ban.VAC > 0) && (config.Steam.Ban.VAC <= response.NumberOfVacBans))
                            {
                                Violation(userid, Key.SteamBanVAC, $"{response.NumberOfVacBans}", true);
                            }
                            else if(Summaries.check)
                            {
                                Summaries.Check(userid);
                            }
                        }
                        catch
                        {
                            Log.Console(Key.LogSteam, new Dictionary<string, string>
                            {
                                { "api", api },
                                { "info", reply },
                                { "playerid", userid.ToString() },
                                { "playername", Text.Sanitize(User.Name(userid)) },
                                { "type", "JSON" }
                            });
                        }
                    }, _instance);
                }
            }

            private class Game
            {
                [JsonProperty("response")]
                public Content Response;

                public class Content
                {
                    [JsonProperty("game_count")]
                    public ulong GameCount;

                    [JsonProperty("games")]
                    public Game[] Games;

                    public class Game
                    {
                        [JsonProperty("appid")]
                        public uint AppId;

                        [JsonProperty("playtime_forever")]
                        public ulong PlaytimeForever;
                    }
                }

                [JsonIgnore]
                private static readonly string api = nameof(Game);

                [JsonIgnore]
                public static bool check = false;

                public static void Check(ulong userid, bool private_profile, bool is_sharing)
                {
                    if(private_profile || is_sharing)
                    {
                        if(config.Steam.Game.Count > 0)
                        {
                            Violation(userid, Key.SteamGameCount, "(null)");
                        }
                        else if(config.Steam.Game.Hours > 0)
                        {
                            Violation(userid, Key.SteamGameHours, "(null)");
                        }

                        return;
                    }

                    var url = $"https://api.steampowered.com/IPlayerService/GetOwnedGames/v0001/?key={config.Steam.API.ApiKey}&steamid={userid}";

                    _instance.webrequest.Enqueue(url, string.Empty, (code, reply) =>
                    {
                        if(code != 200 || string.IsNullOrEmpty(reply))
                        {
                            Log.Console(Key.LogSteam, new Dictionary<string, string>
                            {
                                { "api", api },
                                { "info", $"({code}: {reply})" },
                                { "playerid", userid.ToString() },
                                { "playername", Text.Sanitize(User.Name(userid)) },
                                { "type", "HTTP" }
                            });

                            return;
                        }

                        try
                        {
                            var response = JsonConvert.DeserializeObject<Game>(reply).Response;

                            if((config.Steam.Game.Count > 0) && (config.Steam.Game.Count > response.GameCount))
                            {
                                Violation(userid, Key.SteamGameCount, $"{response.GameCount}");
                            }
                            else if(config.Steam.Game.Hours > 0)
                            {
                                foreach(var game in response.Games)
                                {
                                    if(game.AppId == appid)
                                    {
                                        var hours_played = game.PlaytimeForever / 60ul;

                                        if(config.Steam.Game.Hours > hours_played)
                                        {
                                            Violation(userid, Key.SteamGameHours, $"{hours_played}");

                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        catch
                        {
                            Log.Console(Key.LogSteam, new Dictionary<string, string>
                            {
                                { "api", api },
                                { "info", reply },
                                { "playerid", userid.ToString() },
                                { "playername", Text.Sanitize(User.Name(userid)) },
                                { "type", "JSON" }
                            });
                        }
                    }, _instance);
                }
            }

            private class Profile
            {
                private static readonly string api = nameof(Profile);

                public static bool check = false;

                public static void Check(ulong userid, bool private_profile)
                {
                    var url = $"https://steamcommunity.com/profiles/{userid}/?xml=1";

                    _instance.webrequest.Enqueue(url, string.Empty, (code, reply) =>
                    {
                        if(code != 200 || string.IsNullOrEmpty(reply))
                        {
                            Log.Console(Key.LogSteam, new Dictionary<string, string>
                            {
                                { "api", api },
                                { "info", $"({code}: {reply})" },
                                { "playerid", userid.ToString() },
                                { "playername", Text.Sanitize(User.Name(userid)) },
                                { "type", "HTTP" }
                            });

                            return;
                        }

                        var response = reply.ToLower();

                        var has_profile = !response.Contains("this user has not yet set up their steam community profile");

                        if(config.Steam.Profile.Invalid && !has_profile)
                        {
                            Violation(userid, Key.SteamProfileInvalid, $"{true}");
                        }
                        else if(config.Steam.Profile.Limited && has_profile && response.Contains("<islimitedaccount>1</islimitedaccount>"))
                        {
                            Violation(userid, Key.SteamProfileLimited, $"{true}");
                        }
                        else if(Share.check)
                        {
                            Share.Check(userid, private_profile);
                        }
                    }, _instance);
                }
            }

            private class Share
            {
                [JsonProperty("response")]
                public Content Response;

                public class Content
                {
                    [JsonProperty("lender_steamid")]
                    public ulong LenderSteamId;
                }

                [JsonIgnore]
                private static readonly string api = nameof(Share);

                [JsonIgnore]
                public static bool check = false;

                public static void Check(ulong userid, bool private_profile)
                {
                    var url = $"https://api.steampowered.com/IPlayerService/IsPlayingSharedGame/v0001/?key={config.Steam.API.ApiKey}&steamid={userid}&appid_playing={appid}";

                    _instance.webrequest.Enqueue(url, string.Empty, (code, reply) =>
                    {
                        if(code != 200 || string.IsNullOrEmpty(reply))
                        {
                            Log.Console(Key.LogSteam, new Dictionary<string, string>
                            {
                                { "api", api },
                                { "info", $"({code}: {reply})" },
                                { "playerid", userid.ToString() },
                                { "playername", Text.Sanitize(User.Name(userid)) },
                                { "type", "HTTP" }
                            });

                            return;
                        }

                        try
                        {
                            var response = JsonConvert.DeserializeObject<Share>(reply).Response;

                            var is_sharing = (response.LenderSteamId > 0);

                            if(config.Steam.Share.Family && is_sharing)
                            {
                                Violation(userid, Key.SteamShareFamily, $"{true}");
                            }
                            else if(Game.check)
                            {
                                Game.Check(userid, private_profile, is_sharing);
                            }
                        }
                        catch
                        {
                            Log.Console(Key.LogSteam, new Dictionary<string, string>
                            {
                                { "api", api },
                                { "info", reply },
                                { "playerid", userid.ToString() },
                                { "playername", Text.Sanitize(User.Name(userid)) },
                                { "type", "JSON" }
                            });
                        }
                    }, _instance);
                }
            }

            private class Summaries
            {
                [JsonProperty("response")]
                public Content Response;

                public class Content
                {
                    [JsonProperty("players")]
                    public Player[] Players;

                    public class Player
                    {
                        [JsonProperty("communityvisibilitystate")]
                        public int CommunityVisibilityState;
                    }
                }

                [JsonIgnore]
                private static readonly string api = nameof(Summaries);

                [JsonIgnore]
                public static bool check = false;

                public static void Check(ulong userid)
                {
                    var url = $"https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v0002/?key={config.Steam.API.ApiKey}&steamids={userid}";

                    _instance.webrequest.Enqueue(url, string.Empty, (code, reply) =>
                    {
                        if(code != 200 || string.IsNullOrEmpty(reply))
                        {
                            Log.Console(Key.LogSteam, new Dictionary<string, string>
                            {
                                { "api", api },
                                { "info", $"({code}: {reply})" },
                                { "playerid", userid.ToString() },
                                { "playername", Text.Sanitize(User.Name(userid)) },
                                { "type", "HTTP" }
                            });

                            return;
                        }

                        try
                        {
                            var response = JsonConvert.DeserializeObject<Summaries>(reply).Response.Players[0];

                            var private_profile = (response.CommunityVisibilityState < 3);

                            if(config.Steam.Profile.Private && private_profile)
                            {
                                Violation(userid, Key.SteamProfilePrivate, $"{true}");
                            }
                            else if(Profile.check)
                            {
                                Profile.Check(userid, private_profile);
                            }
                        }
                        catch
                        {
                            Log.Console(Key.LogSteam, new Dictionary<string, string>
                            {
                                { "api", api },
                                { "info", reply },
                                { "playerid", userid.ToString() },
                                { "playername", Text.Sanitize(User.Name(userid)) },
                                { "type", "JSON" }
                            });
                        }
                    }, _instance);
                }
            }
        }

        #endregion _steam_

        #region _text_

        private enum Key
        {
            add,
            Added,
            Address,
            ago,
            Allowed,
            AllUsers,
            and,
            AntiCheat,
            AntiCheatAim,
            AntiCheatFireRate,
            AntiCheatGravity,
            AntiCheatMeleeRate,
            AntiCheatRecoil,
            AntiCheatStash,
            AntiCheatTrajectory,
            AntiCheatWallHack,
            AntiFlood,
            AntiFloodChat,
            AntiFloodCommand,
            AntiFloodItemDrop,
            BanCount,
            BanInherited,
            Banned,
            banned,
            BanReason,
            BanReset,
            Blocked,
            BodyPart,
            BodyPartArm,
            BodyPartChest,
            BodyPartFoot,
            BodyPartHand,
            BodyPartHead,
            BodyPartLeg,
            BodyPartStomach,
            Bypassed,
            Changed,
            Chat,
            Command,
            CommandConfig,
            CommandConfigAdminSyntax,
            CommandConfigAntiCheatAimSyntax,
            CommandConfigAntiCheatFireRateSyntax,
            CommandConfigAntiCheatGravitySyntax,
            CommandConfigAntiCheatMeleeRateSyntax,
            CommandConfigAntiCheatRecoilSyntax,
            CommandConfigAntiCheatServerSyntax,
            CommandConfigAntiCheatStashSyntax,
            CommandConfigAntiCheatSyntax,
            CommandConfigAntiCheatTrajectorySyntax,
            CommandConfigAntiCheatWallHackSyntax,
            CommandConfigAntiFloodChatSyntax,
            CommandConfigAntiFloodCommandSyntax,
            CommandConfigAntiFloodItemDropSyntax,
            CommandConfigAntiFloodSyntax,
            CommandConfigBanSyntax,
            CommandConfigCrippleSyntax,
            CommandConfigDiscordSyntax,
            CommandConfigEntitySyntax,
            CommandConfigIpSyntax,
            CommandConfigLogSyntax,
            CommandConfigSaveSyntax,
            CommandConfigSteamSyntax,
            CommandConfigSyntax,
            CommandConfigTitle,
            CommandConfigUserSyntax,
            CommandConfigViolationSyntax,
            CommandConfigVpnSyntax,
            CommandHelp,
            CommandHelpEntry,
            CommandHelpTitle,
            CommandIp,
            CommandIpEntry,
            CommandIpEntryFailed,
            CommandIpList,
            CommandIpSyntax,
            CommandIpTitle,
            CommandLogHeading,
            CommandLogLine,
            CommandLogNoEntries,
            CommandLogSeeConsole,
            CommandLogSyntax,
            CommandLogTitle,
            CommandNoPermission,
            CommandServerSyntax,
            CommandServerTitle,
            CommandTeleport,
            CommandTeleportSyntax,
            CommandTeleportTitle,
            CommandTeleportViolation,
            CommandUnknown,
            CommandUser,
            CommandUserAction,
            CommandUserInfo,
            CommandUserKick,
            CommandUserNotFound,
            CommandUserSyntax,
            CommandUserTeam,
            CommandUserTitle,
            CommandUserTooMany,
            CommandVpn,
            CommandVpnSyntax,
            CommandVpnTitle,
            connected,
            CONSOLE,
            Cooldown,
            Crafting,
            CrippleCount,
            Crippled,
            crippled,
            CrippleReason,
            CrippleReset,
            Current,
            data,
            Denied,
            Detected,
            DurationDay,
            DurationDays,
            DurationHour,
            DurationHours,
            DurationMinute,
            DurationMinutes,
            DurationSecond,
            DurationSeconds,
            DurationSecondsUnit,
            empty,
            Entity,
            EntityAnimal,
            EntityAutoTurret,
            EntityBear,
            EntityBoar,
            EntityBradley,
            EntityBuilding,
            EntityChicken,
            EntityFlameTurret,
            EntityGunTrap,
            EntityHelicopter,
            EntityMurderer,
            EntityNPC,
            EntityPlayer,
            EntitySAMSite,
            EntityScientist,
            EntityStag,
            EntityTC,
            EntityTrap,
            file,
            For,
            idle,
            InvalidSteamId,
            IP,
            IpBlocked,
            IpCooldown,
            Kicked,
            LogAntiCheatAim,
            LogAntiCheatGravity,
            LogAntiCheatMeleeRate,
            LogAntiCheatRecoil,
            LogAntiCheatServer,
            LogAntiCheatStash,
            LogAntiCheatTrajectory,
            LogAntiSpamItemDrop,
            LogConnect,
            LogDiscordConfig,
            LogDiscordMessage,
            LogIpFilter,
            LogSteam,
            LogSteamConfig,
            LogUserBypass,
            LogVpnCheck,
            LogVpnCheckConfig,
            LogVpnCheckError,
            LogWebHook,
            Name,
            never,
            NoReasonGiven,
            NULL,
            offline,
            OnAntiCheatTriggered,
            online,
            OxideGroups,
            Pardoned,
            permanently,
            Played,
            remove,
            Removed,
            Saved,
            Server,
            SERVER,
            Status,
            Steam,
            SteamBanActive,
            SteamBanCommunity,
            SteamBanDays,
            SteamBanEconomy,
            SteamBanGame,
            SteamBanVAC,
            SteamGameCount,
            SteamGameHours,
            SteamID,
            SteamProfileInvalid,
            SteamProfileLimited,
            SteamProfilePrivate,
            SteamShareFamily,
            True,
            Unbanned,
            Unblocked,
            Uncrippled,
            unknown,
            UnknownKey,
            UserAction,
            UserBanTeleport,
            UserBanTeleported,
            UserConnectBanInherit,
            UserConnectIpBlocked,
            UserConnectSteamIdInvalid,
            UserInfoText,
            UserInfoTextBullet,
            UserInfoTextLabel,
            UserPardonProgress,
            Violation,
            ViolationAim,
            ViolationFireRate,
            ViolationGravity,
            ViolationMeleeRate,
            ViolationRecoil,
            ViolationStash,
            ViolationTrajectory,
            ViolationWallHack,
            VPN,
            VpnCache,
            VpnDetected,
            Warning
        }

        private class Text
        {
            private static readonly Dictionary<string, Dictionary<Key, string>> decorated = new Dictionary<string, Dictionary<Key, string>>();
            private static readonly Dictionary<string, Dictionary<Key, string>> unadorned = new Dictionary<string, Dictionary<Key, string>>();

            private static string server_language;

            private class RegEx
            {
                public static Regex clean1;
                public static Regex clean2;
                public static Regex clean3;
                public static Regex markup;
                public static Regex spaces;

                public static void Load()
                {
                    clean1 = new Regex(@"\p{Cc}+|\p{Cs}+", RegexOptions.Compiled);
                    clean2 = new Regex(@"\{+|\}+",         RegexOptions.Compiled);
                    markup = new Regex(@"<[^>]+>",         RegexOptions.Compiled);
                    spaces = new Regex(@"\s{2,}",          RegexOptions.Compiled);
                }

                public static void Unload()
                {
                    clean1 = clean2 = clean3 = markup = spaces = null;
                }
            }

            public static string Actor(IPlayer actor) =>
                Actor(actor, server_language);
            public static string Actor(IPlayer actor, BasePlayer player) =>
                Actor(actor, Language(player.UserIDString));
            public static string Actor(IPlayer actor, IPlayer iplayer) =>
                Actor(actor, iplayer.IsServer ? server_language : Language(iplayer.Id));
            public static string Actor(IPlayer actor, ulong userid) =>
                Actor(actor, Language(userid.ToString()));
            public static string Actor(IPlayer actor, string language)
            {
                if(actor == null)
                {
                    return GetPlain(Key.SERVER, language);
                }
                else if(actor.IsServer)
                {
                    return GetPlain(Key.CONSOLE, language);
                }
                else
                {
                    return Sanitize(actor.Name);
                }
            }

            public static string BodyPart(HitArea area) =>
                BodyPart(area, server_language);
            public static string BodyPart(HitArea area, BasePlayer player) =>
                BodyPart(area, Language(player.UserIDString));
            public static string BodyPart(HitArea area, IPlayer iplayer) =>
                BodyPart(area, iplayer.IsServer ? server_language : Language(iplayer.Id));
            public static string BodyPart(HitArea area, ulong userid) =>
                BodyPart(area, Language(userid.ToString()));
            public static string BodyPart(HitArea area, string language)
            {
                switch(area)
                {
                case HitArea.Head:    return GetPlain(Key.BodyPartHead);
                case HitArea.Chest:   return GetPlain(Key.BodyPartChest);
                case HitArea.Stomach: return GetPlain(Key.BodyPartStomach);
                case HitArea.Arm:     return GetPlain(Key.BodyPartArm);
                case HitArea.Hand:    return GetPlain(Key.BodyPartHand);
                case HitArea.Leg:     return GetPlain(Key.BodyPartLeg);
                case HitArea.Foot:    return GetPlain(Key.BodyPartFoot);
                }

                return GetPlain(Key.BodyPart, language);
            }

            public class Duration
            {
                public static string Hours(TimeSpan time) =>
                    Hours(time, server_language);
                public static string Hours(TimeSpan time, BasePlayer player) =>
                    Hours(time, Language(player.UserIDString));
                public static string Hours(TimeSpan time, IPlayer iplayer) =>
                    Hours(time, iplayer.IsServer ? server_language : Language(iplayer.Id));
                public static string Hours(TimeSpan time, ulong userid) =>
                    Hours(time, Language(userid.ToString()));
                public static string Hours(TimeSpan time, string language) =>
                    $"{time.Duration().TotalHours:0.00} {GetPlain(Key.DurationHours, language)}";

                public static string Short(TimeSpan time) =>
                    Short(time, server_language);
                public static string Short(TimeSpan time, BasePlayer player) =>
                    Short(time, Language(player.UserIDString));
                public static string Short(TimeSpan time, IPlayer iplayer) =>
                    Short(time, iplayer.IsServer ? server_language : Language(iplayer.Id));
                public static string Short(TimeSpan time, ulong userid) =>
                    Short(time, Language(userid.ToString()));
                public static string Short(TimeSpan time, string language)
                {
                    var duration = time.Duration();

                    if(duration.Days != 0)
                    {
                        return $"{duration.TotalDays:0.00} {GetPlain(Key.DurationDays, language)}";
                    }
                    else if(duration.Hours != 0)
                    {
                        return $"{duration.TotalHours:0.00} {GetPlain(Key.DurationHours, language)}";
                    }
                    else if(duration.Minutes != 0)
                    {
                        return $"{duration.TotalMinutes:0.00} {GetPlain(Key.DurationMinutes, language)}";
                    }
                    else
                    {
                        return $"{duration.TotalSeconds:0.00} {GetPlain(Key.DurationSeconds, language)}";
                    }
                }
            }

            public static string Get(Key key, Dictionary<string, string> parameters = null) =>
                Get(key, server_language, parameters);
            public static string Get(Key key, BasePlayer player, Dictionary<string, string> parameters = null) =>
                Get(key, Language(player.UserIDString), parameters);
            public static string Get(Key key, IPlayer iplayer, Dictionary<string, string> parameters = null)
            {
                if(iplayer.LastCommand == CommandType.Console)
                {
                    return GetPlain(key, iplayer.IsServer ? server_language : Language(iplayer.Id), parameters);
                }
                else
                {
                    return Get(key, iplayer.IsServer ? server_language : Language(iplayer.Id), parameters);
                }
            }
            public static string Get(Key key, ulong userid, Dictionary<string, string> parameters = null) =>
                Get(key, Language(userid.ToString()), parameters);
            public static string Get(Key key, string language, Dictionary<string, string> parameters = null) =>
                Get(key, Messages(decorated, language), parameters);
            private static string Get(Key key, Dictionary<Key, string> cache, Dictionary<string, string> parameters)
            {
                string message = null;

                if(cache?.TryGetValue(key, out message) ?? false)
                {
                    return Replace(message, parameters);
                }

                return Enum.GetName(typeof(Key), key);
            }

            public static string GetPlain(Key key, Dictionary<string, string> parameters = null) =>
                GetPlain(key, server_language, parameters);
            public static string GetPlain(Key key, BasePlayer player, Dictionary<string, string> parameters = null) =>
                GetPlain(key, Language(player.UserIDString), parameters);
            public static string GetPlain(Key key, IPlayer iplayer, Dictionary<string, string> parameters = null) =>
                GetPlain(key, iplayer.IsServer ? server_language : Language(iplayer.Id), parameters);
            public static string GetPlain(Key key, ulong userid, Dictionary<string, string> parameters = null) =>
                GetPlain(key, Language(userid.ToString()), parameters);
            public static string GetPlain(Key key, string language, Dictionary<string, string> parameters = null) =>
                Get(key, Messages(unadorned, language), parameters);

            public static string Language(string userid = null)
            {
                if(string.IsNullOrEmpty(userid))
                {
                    return server_language;
                }

                var language = _instance.lang.GetLanguage(userid) ?? server_language;

                return decorated.ContainsKey(language) ? language : server_language;
            }

            public static void Load()
            {
                var languages = _instance.lang.GetLanguages(_instance);

                if((languages.Length == 0) || Configuration.Upgraded())
                {
                    RegisterMessages();

                    languages = _instance.lang.GetLanguages(_instance);
                }

                var requested = _instance.lang.GetServerLanguage();

                if(!string.IsNullOrEmpty(requested) && languages.Contains(requested))
                {
                    server_language = requested;
                }
                else
                {
                    server_language = "en";
                }

                RegEx.Load();

                foreach(var language in languages)
                {
                    var m_decorated = decorated[language] = new Dictionary<Key, string>();
                    var m_unadorned = unadorned[language] = new Dictionary<Key, string>();

                    foreach(var entry in _instance.lang.GetMessages(language, _instance))
                    {
                        if(string.IsNullOrEmpty(entry.Key))
                        {
                            continue;
                        }

                        Key key;

                        if(Enum.TryParse(entry.Key, out key))
                        {
                            m_decorated.Add(key, entry.Value);
                            m_unadorned.Add(key, Strip(entry.Value));
                        }
                        else
                        {
                            Log.Console(Key.UnknownKey, new Dictionary<string, string>
                            {
                                { "key", entry.Key },
                                { "language", language }
                            });
                        }
                    }
                }
            }

            private static Dictionary<Key, string> Messages(Dictionary<string, Dictionary<Key, string>> cache, string language)
            {
                Dictionary<Key, string> messages;

                if(!cache.TryGetValue(language, out messages))
                {
                    if(!cache.TryGetValue(server_language, out messages))
                    {
                        return null;
                    }
                }

                return messages;
            }

            public static bool ParseTime(string message, out ulong seconds)
            {
                seconds = 0;

                if(string.IsNullOrEmpty(message))
                {
                    return false;
                }

                ulong amount = 0; char units = 's';

                for(int i = 0; i < message.Length; ++i)
                {
                    var current = message[i];

                    if(char.IsDigit(current))
                    {
                        amount *= 10;
                        amount += (ulong)(current - '0');
                    }
                    else
                    {
                        if((i + 1) != message.Length)
                        {
                            return false;
                        }

                        units = char.ToLower(current);
                    }
                }

                switch(units)
                {
                case 'd': seconds = amount * 86400ul; return true;
                case 'h': seconds = amount *  3600ul; return true;
                case 'm': seconds = amount *    60ul; return true;
                case 's': seconds = amount;           return true;
                }

                return false;
            }

            private static void RegisterMessages()
            {
                _instance.lang.RegisterMessages(new Dictionary<string, string>(), _instance, "en");
                _instance.lang.RegisterMessages(new Dictionary<string, string>
                {
                    { nameof(Key.add), "add" },
                    { nameof(Key.Added), "Added" },
                    { nameof(Key.Address), "Address" },
                    { nameof(Key.ago), "ago" },
                    { nameof(Key.Allowed), "Allowed" },
                    { nameof(Key.AllUsers), "All Users" },
                    { nameof(Key.and), "and" },
                    { nameof(Key.AntiCheat), "AntiCheat" },
                    { nameof(Key.AntiCheatAim), "Aim" },
                    { nameof(Key.AntiCheatFireRate), "Fire Rate" },
                    { nameof(Key.AntiCheatGravity), "Gravity" },
                    { nameof(Key.AntiCheatMeleeRate), "Melee Rate" },
                    { nameof(Key.AntiCheatRecoil), "Recoil" },
                    { nameof(Key.AntiCheatStash), "Stash" },
                    { nameof(Key.AntiCheatTrajectory), "Trajectory" },
                    { nameof(Key.AntiCheatWallHack), "Wall Hack" },
                    { nameof(Key.AntiFlood), "AntiFlood" },
                    { nameof(Key.AntiFloodChat), "Chat" },
                    { nameof(Key.AntiFloodCommand), "Command" },
                    { nameof(Key.AntiFloodItemDrop), "Dropped Items" },
                    { nameof(Key.BanCount), "Ban Count" },
                    { nameof(Key.BanInherited), "Ban inherited" },
                    { nameof(Key.Banned), "Banned" },
                    { nameof(Key.banned), "banned" },
                    { nameof(Key.BanReason), "Ban Reason" },
                    { nameof(Key.BanReset), "Reset ban data for" },
                    { nameof(Key.Blocked), "Blocked" },
                    { nameof(Key.BodyPart), "Body" },
                    { nameof(Key.BodyPartArm), "Arm" },
                    { nameof(Key.BodyPartChest), "Chest" },
                    { nameof(Key.BodyPartFoot), "Foot" },
                    { nameof(Key.BodyPartHand), "Hand" },
                    { nameof(Key.BodyPartHead), "Head" },
                    { nameof(Key.BodyPartLeg), "Leg" },
                    { nameof(Key.BodyPartStomach), "Stomach" },
                    { nameof(Key.Bypassed), "Bypassed" },
                    { nameof(Key.Changed), "Changed" },
                    { nameof(Key.Chat), "Chat" },
                    { nameof(Key.Command), "Command" },
                    { nameof(Key.CommandConfig), "<size=12><color=#c0ffc0>{action} configuration: </color><color=#c0c0ff>{info}</color></size>" },
                    { nameof(Key.CommandConfigAdminSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} admin.broadcast [true|false]\n    {command} admin.bypass [true|false]</color></size>" },
                    { nameof(Key.CommandConfigAntiCheatAimSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} anticheat.aim.ban [true|false]\n    {command} anticheat.aim.cooldown [SECONDS]\n    {command} anticheat.aim.enabled [true|false]\n    {command} anticheat.aim.sensitivity [0.0-1.0]\n    {command} anticheat.aim.trigger.animal [true|false]\n    {command} anticheat.aim.trigger.bradley [true|false]\n    {command} anticheat.aim.trigger.helicopter [true|false]\n    {command} anticheat.aim.trigger.npc [true|false]\n    {command} anticheat.aim.warn [true|false]</color></size>" },
                    { nameof(Key.CommandConfigAntiCheatFireRateSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} anticheat.firerate.ban [true|false]\n    {command} anticheat.firerate.cooldown [SECONDS]\n    {command} anticheat.firerate.enabled [true|false]\n    {command} anticheat.firerate.sensitivity [0.0-1.0]\n    {command} anticheat.firerate.warn [true|false]</color></size>" },
                    { nameof(Key.CommandConfigAntiCheatGravitySyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} anticheat.gravity.ban [true|false]\n    {command} anticheat.gravity.cooldown [SECONDS]\n    {command} anticheat.gravity.enabled [true|false]\n    {command} anticheat.gravity.sensitivity [0.0-1.0]\n    {command} anticheat.gravity.warn [true|false]</color></size>" },
                    { nameof(Key.CommandConfigAntiCheatMeleeRateSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} anticheat.meleerate.ban [true|false]\n    {command} anticheat.meleerate.cooldown [SECONDS]\n    {command} anticheat.meleerate.enabled [true|false]\n    {command} anticheat.meleerate.sensitivity [0.0-1.0]\n    {command} anticheat.meleerate.warn [true|false]</color></size>" },
                    { nameof(Key.CommandConfigAntiCheatRecoilSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} anticheat.recoil.ban [true|false]\n    {command} anticheat.recoil.cooldown [SECONDS]\n    {command} anticheat.recoil.enabled [true|false]\n    {command} anticheat.recoil.sensitivity [0.0-1.0]\n    {command} anticheat.recoil.warn [true|false]</color></size>" },
                    { nameof(Key.CommandConfigAntiCheatServerSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} anticheat.server.ban [true|false]\n    {command} anticheat.server.cooldown [SECONDS]\n    {command} anticheat.server.enabled [true|false]\n    {command} anticheat.server.sensitivity [0.0-1.0]\n    {command} anticheat.server.warn [true|false]</color></size>" },
                    { nameof(Key.CommandConfigAntiCheatStashSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} anticheat.stash.ban [true|false]\n    {command} anticheat.stash.cooldown [SECONDS]\n    {command} anticheat.stash.enabled [true|false]\n    {command} anticheat.stash.sensitivity [0.0-1.0]\n    {command} anticheat.stash.warn [true|false]</color></size>" },
                    { nameof(Key.CommandConfigAntiCheatSyntax), "<size=12><color=#ffc0c0>Syntax:</color><color=#c0c0ff>\n    {command} anticheat.aim\n    {command} anticheat.firerate\n    {command} anticheat.gravity\n    {command} anticheat.meleerate\n    {command} anticheat.recoil\n    {command} anticheat.server\n    {command} anticheat.stash\n    {command} anticheat.trajetory\n    {command} anticheat.wallhack</color></size>" },
                    { nameof(Key.CommandConfigAntiCheatTrajectorySyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} anticheat.trajectory.ban [true|false]\n    {command} anticheat.trajectory.cooldown [SECONDS]\n    {command} anticheat.trajectory.enabled [true|false]\n    {command} anticheat.trajectory.sensitivity [0.0-1.0]\n    {command} anticheat.trajectory.warn [true|false]</color></size>" },
