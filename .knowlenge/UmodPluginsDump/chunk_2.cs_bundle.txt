ds"] = "Use /rw or /rw help.",
                ["norewards"] = "No Rewards to claim.",
                ["rwlistitem"] = "Reward ({0}) {1} x {2}",
                ["rwlistsuccess"] = "Showing max 8 results. Use /gimme <nr> or /discard <nr>",
                ["rwreceived"] = "You received {0} x {1}",
                ["invfull"] = "Unable to give inventory full.",
                ["noperm"] = "You don't have permission to use this command!",
                ["rwhelpcr"] = "Use /rw to see what u can claim.",
                ["rwhelpclaimcr"] = "Use /gimme <nr> to claim a reward.",
                ["rwhelpdiscardcr"] = "Use /discard <nr> to dispose a reward.",
                ["rwhelpnextcr"] = "Use /nextreward to see your kills and next reward.",
                ["noclaims"] = "No rewards to claim, you have 0 kills.",
                ["crclaim"] = "Use /gimme <nr>",
                ["badrwnumber"] = "No reward with nr:{0}",
                ["norwdiscard"] = "No rewards to discard, you have 0 kills.",
                ["discard"] = "Use /discard <nr>",
                ["discarded"] = "Discarded {0}",
                ["nodiscard"] = "Unable to discard:{0} not in list!",
                ["nextrwinfo"] = "You have {0} kills next reward in {1} kills {2} x {3}",
                ["nonext"] = "You have {0}, you need {1} kills to reset and start again."
            }, this);
        }

        #endregion
        #region Chat Commands
        private void Cmdrw(BasePlayer player, string command, string[] args)
        {

            if (!HasPerm(player)) { return; }

            if (args.Length == 1 && args[0] == "help")
            {
                player.ChatMessage(msg("rwhelpcr", player.UserIDString));
                player.ChatMessage(msg("rwhelpclaimcr", player.UserIDString));
                player.ChatMessage(msg("rwhelpdiscardcr", player.UserIDString));
                player.ChatMessage(msg("rwhelpnextcr", player.UserIDString));
                return;
            }
            else
            {
                Listrewards(player);
            }
        }


        private void Cmdclaim(BasePlayer player, string command, string[] args)
        {
            if (!HasPerm(player)) { return; }

            if (!PlayerData.TryGetValue(player.userID, out PData))
            {
                PlayerData[player.userID] = PData = new Dictionary<string, string>();
                PData.Add("mykills", "0");
                player.ChatMessage(msg("noclaims", player.UserIDString));
                return;
            }

            if (args.Length == 0)
            {
                player.ChatMessage(msg("crclaim", player.UserIDString));
                return;
            }

            if (args.Length == 1)
            {
                var atKill = args[0];
                int value;
                if (int.TryParse(atKill, out value))
                {

                    if (PlayerData.TryGetValue(player.userID, out PData))
                    {

                        if (PData.ContainsKey(atKill))
                        {
                            var reward = PData[atKill];
                            GiveClaimedReward(player, reward, atKill);
                            return;
                        }
                        player.ChatMessage(msg("badrwnumber", player.UserIDString, atKill));
                        return;
                    }

                }
                player.ChatMessage(msg("crclaim", player.UserIDString));
            }

        }


        private void Cmddiscard(BasePlayer player, string command, string[] args)
        {
            if (!HasPerm(player)) { return; }

            if (!PlayerData.TryGetValue(player.userID, out PData))
            {
                PlayerData[player.userID] = PData = new Dictionary<string, string>();
                PData.Add("mykills", "0");
                player.ChatMessage(msg("norwdiscard", player.UserIDString));
                return;
            }

            if (args.Length == 0)
            {
                player.ChatMessage(msg("discard", player.UserIDString));
                return;
            }

            if (args.Length == 1)
            {
                var str = args[0];
                int value;
                if (int.TryParse(str, out value))
                {

                    if (PlayerData.TryGetValue(player.userID, out PData))
                    {

                        if (PData.ContainsKey(str))
                        {
                            var rw = Getitemdetails(PData[str]);

                            if (rw == null)
                            {
                                return;
                            }
                            player.ChatMessage(msg("discarded", player.UserIDString, rw.Item3));
                            PData.Remove(str);
                            Listrewards(player);
                            return;
                        }

                    }
                    player.ChatMessage(msg("nodiscard", player.UserIDString, str));
                    return;
                }
                player.ChatMessage(msg("discard", player.UserIDString));
            }
        }


        private void Cmdnextreward(BasePlayer player)
        {

            if (!HasPerm(player)) { return; }

            if (!PlayerData.TryGetValue(player.userID, out PData))
            {
                PlayerData[player.userID] = PData = new Dictionary<string, string>();
                PData.Add("mykills", "0");
            }


            var it = 0;
            var nrofkills = 0;
            if (PlayerData.TryGetValue(player.userID, out PData))
            {

                if (int.TryParse(PData["mykills"], out nrofkills))
                {

                    nrofkills += 1;

                    for (int ic = nrofkills; ic < config.conf.maxKills; ic++)
                    {
                        it += 1;

                        if (Config["Rewards", ic.ToString()] != null)
                        {
                            var reward = (string)Config["Rewards", ic.ToString()];
                            var numkills = nrofkills - 1;

                            var rw = Getitemdetails(reward);

                            if (rw == null)
                            {
                                return;
                            }

                            player.ChatMessage(msg("nextrwinfo", player.UserIDString, numkills.ToString(), it.ToString(), rw.Item3, rw.Item2));
                            return;
                        }
                    }

                }

            }

            player.ChatMessage(msg("nonext", player.UserIDString, nrofkills, config.conf.maxKills));
            //return;
        }
        #endregion
        #region ConsoleCommands
        [ConsoleCommand("vcr")]
        void vcrConsole(ConsoleSystem.Arg arg)
        {
            var errs = 0;
            for (int ivcr = 1; ivcr < config.conf.maxKills; ivcr++)
            {

                if (Config["Rewards", ivcr.ToString()] == null)
                {

                }
                else
                {
                    var chkstr = Config["Rewards", ivcr.ToString()].ToString();
                    string amount;
                    if (chkstr != "recycler.give")
                    {
                        if (chkstr.IndexOf(' ') == -1)
                        {
                            PrintError("bad format in ClaimRewards.json at string: " + chkstr + " Usage EX: 'metal.facemask 1' ");
                            errs += 1;
                        }
                        else
                        {
                            int stind = chkstr.IndexOf(' ');
                            amount = chkstr.Substring(stind, chkstr.Length - stind);
                            chkstr = chkstr.Substring(0, stind);

                            if (!items.ContainsKey(chkstr))
                            {
                                PrintError("Bad shortname in ClaimRewards.json at string: " + chkstr);
                                errs += 1;
                            }
                        }
                    }
                }
            }

            if (errs == 0)
            {
                PrintWarning("Validation done!");
                return;
            }
            PrintWarning("Found " + errs + " bad item(s) in config.");
        }
        #endregion

    }
}

// --- End of file: ClaimRewards.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/chopper-survival ---
// --- Original File Path: C/ChopperSurvival/ChopperSurvival.cs ---

﻿// Requires: EventManager
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using Oxide.Plugins.EventManagerEx;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UI = Oxide.Plugins.EMInterface.UI;
using UI4 = Oxide.Plugins.EMInterface.UI4;

namespace Oxide.Plugins
{
    [Info("ChopperSurvival", "k1lly0u", "3.0.2"), Description("Chopper survival event mode for EventManager")]
    class ChopperSurvival : RustPlugin, IEventPlugin
    {
        private const string HELICOPTER_PREFAB = "assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab";

        #region Oxide Hooks
        private void OnServerInitialized()
        {
            EventManager.RegisterEvent(Title, this);

            GetMessage = Message;
        }

        protected override void LoadDefaultMessages() => lang.RegisterMessages(Messages, this);

        private void OnEntityTakeDamage(PatrolHelicopter baseHelicopter, HitInfo hitInfo)
        {
            if (baseHelicopter == null || hitInfo == null)
                return;

            if (baseHelicopter.GetComponent<EventHelicopter>())
            {
                if (EventManager.GetUser(hitInfo.InitiatorPlayer) == null)
                    EventManager.ClearDamage(hitInfo);
            }            
        }

        private void Unload()
        {
            EventHelicopter[] eventHelicopters = UnityEngine.Object.FindObjectsOfType<EventHelicopter>();
            for (int i = 0; i < eventHelicopters.Length; i++)
                UnityEngine.Object.Destroy(eventHelicopters[i]);

            if (!EventManager.IsUnloading)
                EventManager.UnregisterEvent(Title);

            Configuration = null;
        }
        #endregion

        #region Event Checks
        public bool InitializeEvent(EventManager.EventConfig config) => EventManager.InitializeEvent<ChopperSurvivalEvent>(this, config);

        public bool CanUseClassSelector => true;

        public bool RequireTimeLimit => false;

        public bool RequireScoreLimit => false;

        public bool UseScoreLimit => false;

        public bool UseTimeLimit => false;

        public bool IsTeamEvent => false;

        public void FormatScoreEntry(EventManager.ScoreEntry scoreEntry, ulong langUserId, out string score1, out string score2)
        {
            score1 = string.Empty;
            score2 = string.Format(Message("Score.HitPoints", langUserId), scoreEntry.value1);
        }

        public List<EventManager.EventParameter> AdditionalParameters { get; } = new List<EventManager.EventParameter>
        {
            new EventManager.EventParameter
            {
                DataType = "int",
                Field = "playerLives",
                Input = EventManager.EventParameter.InputType.InputField,                
                IsRequired = true,
                DefaultValue = 1,
                Name = "Player Lives"
            },
            new EventManager.EventParameter
            {
                DataType = "int",
                Field = "rounds",
                Input = EventManager.EventParameter.InputType.InputField,
                IsRequired = true,
                DefaultValue = 5,
                Name = "Rounds"
            },
            new EventManager.EventParameter
            {
                DataType = "int",
                Field = "maxHelicopters",
                Input = EventManager.EventParameter.InputType.InputField,
                IsRequired = true,
                DefaultValue = 3,
                Name = "Maximum Helicopters"
            },
            new EventManager.EventParameter
            {
                DataType = "float",
                Field = "damageScaler",
                Input = EventManager.EventParameter.InputType.InputField,
                IsRequired = true,
                DefaultValue = 1.0f,
                Name = "Damage Scale"
            },
            new EventManager.EventParameter
            {
                DataType = "int",
                Field = "heliHealth",
                Input = EventManager.EventParameter.InputType.InputField,
                IsRequired = true,
                DefaultValue = 5000,
                Name = "Heli Health"
            }
        };

        public string ParameterIsValid(string fieldName, object value) => null;
        #endregion

        #region Functions
        private static string ToOrdinal(int i) => (i + "th").Replace("1th", "1st").Replace("2th", "2nd").Replace("3th", "3rd");
        #endregion

        #region Event Classes
        public class ChopperSurvivalEvent : EventManager.BaseEventGame
        {
            public List<EventManager.BaseEventPlayer> winners;

            private int playerLives;

            private int rounds;

            private int maxHelicopters;

            private int heliHealth;

            private float damageScaler;

            private int currentRound = 0;

            private List<EventHelicopter> eventHelicopters;

            private Color COLOR_GREEN = new Color(0.0745098039215f, 0.79215686274509f, 0.329411764705882f);
            private Color COLOR_RED = new Color(0.79215686274509f, 0.2588235294117647f, 0.074509803921568f);

            internal override void InitializeEvent(IEventPlugin plugin, EventManager.EventConfig config)
            {
                playerLives = config.GetParameter<int>("playerLives");
                rounds = config.GetParameter<int>("rounds");
                maxHelicopters = config.GetParameter<int>("maxHelicopters");
                heliHealth = config.GetParameter<int>("heliHealth");
                damageScaler = config.GetParameter<float>("damageScaler");

                eventHelicopters = Facepunch.Pool.Get<List<EventHelicopter>>();
                winners = Facepunch.Pool.Get<List<EventManager.BaseEventPlayer>>();

                base.InitializeEvent(plugin, config);
            }

            protected override void OnDestroy()
            {
                for (int i = eventHelicopters.Count - 1; i >= 0; i--)
                    Destroy(eventHelicopters[i]);

                Facepunch.Pool.FreeUnmanaged(ref eventHelicopters);
                Facepunch.Pool.FreeUnmanaged(ref winners);

                base.OnDestroy();
            }

            internal override void PrestartEvent()
            {
                CloseEvent();
                base.PrestartEvent();
            }

            protected override void StartEvent()
            {
                base.StartEvent();

                GodmodeEnabled = true;

                InvokeHandler.Invoke(this, StartRound, Configuration.TimeBetweenRounds);

                BroadcastToPlayers(GetMessage, "Notification.RoundStartsIn", Configuration.TimeBetweenRounds);

                InvokeHandler.InvokeRepeating(this, UpdateScoreboard, 1f, 1f);
            }

            internal override void EndEvent()
            {
                InvokeHandler.CancelInvoke(this, UpdateScoreboard);
                
                base.EndEvent();
            }

            protected override EventManager.BaseEventPlayer AddPlayerComponent(BasePlayer player)
            {
                ChopperSurvivalPlayer eventPlayer = player.gameObject.AddComponent<ChopperSurvivalPlayer>();
                eventPlayer.LivesRemaining = playerLives;
                return eventPlayer;
            }

            protected override void OnPlayerSpawned(EventManager.BaseEventPlayer eventPlayer)
            {
                if (Status == EventManager.EventStatus.Started)
                    BroadcastToPlayer(eventPlayer, string.Format(GetMessage("Notification.LivesRemaining", eventPlayer.Player.userID), (eventPlayer as ChopperSurvivalPlayer).LivesRemaining));
            }

            internal override bool CanDealEntityDamage(EventManager.BaseEventPlayer attacker, BaseEntity entity, HitInfo hitInfo)
            {
                EventHelicopter eventHelicopter = entity.GetComponent<EventHelicopter>();
                if (eventHelicopter == null)
                    return false;

                if (damageScaler != 1f)
                    hitInfo.damageTypes.ScaleAll(damageScaler);

                if (!eventHelicopter.DealDamage(hitInfo, out int hitPoints))
                    EventManager.ClearDamage(hitInfo);

                (attacker as ChopperSurvivalPlayer).HitPoints += hitPoints;

                return true;
            }

            internal void OnHelicopterKilled(EventHelicopter eventHelicopter)
            {
                eventHelicopters.Remove(eventHelicopter);

                if (eventHelicopters.Count == 0)
                    EndRound();
            }

            internal override void OnPlayerTakeDamage(EventManager.BaseEventPlayer eventPlayer, HitInfo hitInfo)
            {
                EventManager.BaseEventPlayer attacker = EventManager.GetUser(hitInfo.InitiatorPlayer);
                if (attacker != null)
                {
                    EventManager.ClearDamage(hitInfo);
                    return;
                }

                base.OnPlayerTakeDamage(eventPlayer, hitInfo);
            }

            internal override void OnEventPlayerDeath(EventManager.BaseEventPlayer victim, EventManager.BaseEventPlayer attacker = null, HitInfo info = null)
            {
                if (victim == null)
                    return;

                (victim as ChopperSurvivalPlayer).LivesRemaining -= 1;

                if (GetPlayersRemainingCount() == 0)
                {
                    victim.AddPlayerDeath(null);

                    InvokeHandler.Invoke(this, EndEvent, 0.1f);
                    return;
                }

                victim.OnPlayerDeath(attacker, Configuration.RespawnTime);

                base.OnEventPlayerDeath(victim, attacker);
            }
            
            protected override void DisplayKillToChat(EventManager.BaseEventPlayer victim, string attackerName)
            {
                if (victim.IsOutOfBounds)
                    BroadcastToPlayers(GetMessage, "Notification.Death.OOB", victim.Player.displayName);
                else BroadcastToPlayers(GetMessage, "Notification.Death.Killed", victim.Player.displayName);
            }

            private int GetPlayersRemainingCount()
            {
                int count = 0;

                for (int i = 0; i < eventPlayers.Count; i++)
                {
                    if ((eventPlayers[i] as ChopperSurvivalPlayer).LivesRemaining > 0)
                        count++;
                }

                return count;
            }

            protected override void GetWinningPlayers(ref List<EventManager.BaseEventPlayer> winners)
            {
                winners.AddRange(this.winners);
            }

            #region Round Management
            private void StartRound()
            {
                GodmodeEnabled = false;

                currentRound += 1;

                StartCoroutine(SpawnRoundHelicopters());
            }

            private void EndRound()
            {
                GodmodeEnabled = true;

                if (currentRound >= rounds)
                {
                    winners.AddRange(eventPlayers);
                    InvokeHandler.Invoke(this, EndEvent, 0.1f);
                }
                else
                {
                    InvokeHandler.Invoke(this, StartRound, Configuration.TimeBetweenRounds);
                    BroadcastToPlayers(GetMessage, "Notification.RoundStartsIn", Configuration.TimeBetweenRounds);

                    StartCoroutine(ResetPlayers());
                }
            }

            private IEnumerator ResetPlayers()
            {
                List<EventManager.BaseEventPlayer> currentPlayers = Facepunch.Pool.Get<List<EventManager.BaseEventPlayer>>();
                currentPlayers.AddRange(eventPlayers);

                for (int i = 0; i < currentPlayers.Count; i++)
                {
                    EventManager.BaseEventPlayer eventPlayer = currentPlayers[i];
                    if (eventPlayer != null)
                    {
                        if (eventPlayer.IsDead)
                            EventManager.ResetPlayer(eventPlayer.Player);
                        else
                        {
                            EventManager.StripInventory(eventPlayer.Player);
                            EventManager.ResetMetabolism(eventPlayer.Player);
                            EventManager.GiveKit(eventPlayer.Player, eventPlayer.Kit);
                        }
                    }

                    yield return CoroutineEx.waitForEndOfFrame;
                    yield return CoroutineEx.waitForEndOfFrame;
                }

                Facepunch.Pool.FreeUnmanaged(ref currentPlayers);
            }
            #endregion

            #region Spawn Helicopters
            private IEnumerator SpawnRoundHelicopters()
            {
                int helicoptersToSpawn = Mathf.Max(1, Mathf.RoundToInt((float)maxHelicopters * ((float)currentRound / (float)rounds)));

                for (int i = 0; i < helicoptersToSpawn; i++)
                {
                    Vector3 destination = _spawnSelectorA.GetSpawnPoint();
                    Vector2 random = (UnityEngine.Random.insideUnitCircle.normalized * Configuration.MaxTravelDistance);

                    Vector3 position = destination + new Vector3(random.x, 50f, random.y);

                    PatrolHelicopter baseHelicopter = GameManager.server.CreateEntity(HELICOPTER_PREFAB, position) as PatrolHelicopter;
                    baseHelicopter.enableSaving = false;
                    baseHelicopter.Spawn();

                    EventHelicopter eventHelicopter = baseHelicopter.gameObject.AddComponent<EventHelicopter>();
                    eventHelicopter.OnHelicopterSpawned(this, i + 1);

                    eventHelicopter.Entity.health = heliHealth;
                    eventHelicopter.Entity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                    eventHelicopters.Add(eventHelicopter);

                    yield return CoroutineEx.waitForSeconds(1f);

                    eventHelicopter.SetPositionDestination(position, destination);
                }
            }
            #endregion

            #region Scoreboards
            protected override void BuildScoreboard()
            {
                scoreContainer = EMInterface.CreateScoreboardBase(this);

                int index = -1;

                EMInterface.CreatePanelEntry(scoreContainer, string.Format(GetMessage("Score.RoundNumber", 0UL), currentRound, rounds), index += 1);

                for (int i = 0; i < eventHelicopters.Count; i++)
                {
                    EventHelicopter eventHelicopter = eventHelicopters[i];

                    CreateHealthBar(scoreContainer, string.Format(GetMessage("Score.Heli", 0UL), eventHelicopter.ID), eventHelicopter.Entity.health / heliHealth, index += 1);
                }

                EMInterface.CreatePanelEntry(scoreContainer, string.Format(GetMessage("Score.Remaining", 0UL), eventPlayers.Count), index += 1);
                
                for (int i = 0; i < Mathf.Min(scoreData.Count, 15); i++)
                {
                    EventManager.ScoreEntry score = scoreData[i];
                    EMInterface.CreateScoreEntry(scoreContainer, $"{score.displayName} | ({score.value1} pts)", string.Empty, string.Empty, i + index + 1);
                }
            }

            private void CreateHealthBar(CuiElementContainer container, string text, float health, int index)
            {
                float yMax = -(1f * index);
                float yMin = -(1f * (index + 1));

                UI.Panel(container, EMInterface.UI_SCORES, EMInterface.Configuration.Scoreboard.Foreground.Get, new UI4(0f, yMin + 0.02f, 1f, yMax - 0.02f));

                UI.Label(container, EMInterface.UI_SCORES, text, 11, new UI4(0.05f, yMin, 1f, yMax), TextAnchor.MiddleLeft);

                UI.Panel(container, EMInterface.UI_SCORES, GetInterpolatedColor(health, 0.75f), new UI4(0.25f, yMin + 0.05f, 0.25f + (0.74f * health), yMax - 0.05f));
            }

            private string GetInterpolatedColor(float delta, float alpha)
            {
                Color col = Color.Lerp(COLOR_RED, COLOR_GREEN, delta);
                return $"{col.r} {col.g} {col.b} {alpha}";
            }

            protected override float GetFirstScoreValue(EventManager.BaseEventPlayer eventPlayer) => (eventPlayer as ChopperSurvivalPlayer).HitPoints;

            protected override float GetSecondScoreValue(EventManager.BaseEventPlayer eventPlayer) => (eventPlayer as ChopperSurvivalPlayer).LivesRemaining;

            protected override void SortScores(ref List<EventManager.ScoreEntry> list)
            {
                list.Sort(delegate (EventManager.ScoreEntry a, EventManager.ScoreEntry b)
                {
                    int primaryScore = a.value1.CompareTo(b.value1);

                    if (primaryScore == 0)
                        return a.value2.CompareTo(b.value2);

                    return primaryScore;
                });
            }
            #endregion

            internal override void GetAdditionalEventDetails(ref List<KeyValuePair<string, object>> list, ulong playerId)
            {
                list.Add(new KeyValuePair<string, object>(GetMessage("UI.Rounds", playerId), rounds));
                list.Add(new KeyValuePair<string, object>(GetMessage("UI.PlayerLives", playerId), playerLives));
                list.Add(new KeyValuePair<string, object>(GetMessage("UI.MaxHelicopters", playerId), maxHelicopters));
                list.Add(new KeyValuePair<string, object>(GetMessage("UI.DamageScaler", playerId), damageScaler));
            }
        }

        private class ChopperSurvivalPlayer : EventManager.BaseEventPlayer
        {
            internal int LivesRemaining { get; set; }

            internal int HitPoints { get; set; }

            internal override void OnPlayerDeath(EventManager.BaseEventPlayer attacker = null, float respawnTime = 5)
            {
                AddPlayerDeath();

                DestroyUI();

                string message = string.Empty;

                if (LivesRemaining <= 0)
                {
                    int position = Event.GetAlivePlayerCount();

                    message = IsOutOfBounds ? string.Format(GetMessage("UI.Death.OOB.Kicked", Player.userID), ToOrdinal(position + 1), position) :
                              string.Format(GetMessage("UI.Death.Killed.Kicked", Player.userID), ToOrdinal(position + 1), position);
                }
                else
                {
                    _respawnDurationRemaining = respawnTime;

                    InvokeHandler.InvokeRepeating(this, RespawnTick, 1f, 1f);

                    message = IsOutOfBounds ? GetMessage("UI.Death.OOB", Player.userID) :
                              GetMessage("UI.Death.Killed", Player.userID);
                }

                EMInterface.DisplayDeathScreen(this, message, LivesRemaining > 0);
            }
        }

        internal class EventHelicopter : MonoBehaviour
        {
            internal PatrolHelicopter Entity { get; private set; }

            internal PatrolHelicopterAI AI { get; private set; }

            internal ChopperSurvivalEvent Event { get; private set; }

            internal int ID { get; private set; }

            private Transform tr;

            private Vector3 centerDestination;

            private RaycastHit raycastHit;

            private uint tailRotorBone;
            private uint mainRotorBone;

            private List<PatrolHelicopterAI.targetinfo> _targets;

            private const string HELIEXPLOSION_EFFECT = "assets/prefabs/npc/patrol helicopter/effects/heli_explosion.prefab";

            private void Awake()
            {
                Entity = GetComponent<PatrolHelicopter>();
                AI = Entity.myAI;

                tr = Entity.transform;
                AI.enabled = false;

                _targets = Facepunch.Pool.Get<List<PatrolHelicopterAI.targetinfo>>();

                tailRotorBone = StringPool.Get("tail_rotor_col");
                mainRotorBone = StringPool.Get("main_rotor_col");
            }

            internal void OnHelicopterSpawned(ChopperSurvivalEvent chopperSurvivalEvent, int id)
            {
                this.Event = chopperSurvivalEvent;
                this.ID = id;
            }

            private void Update()
            {
                if (AI.isDead)
                {
                    KillHelicopter();
                    return;
                }

                if (Vector3Ex.Distance2D(tr.position, centerDestination) > Configuration.MaxTravelDistance)
                    AI.SetTargetDestination(centerDestination);

                UpdateTargetList();

                AI.MoveToDestination();
                AI.UpdateRotation();
                AI.UpdateSpotlight();
                AI.AIThink();
                AI.DoMachineGuns();                
            }

            private void OnDestroy()
            {
                Facepunch.Pool.FreeUnmanaged(ref _targets);

                if (Entity != null && !Entity.IsDestroyed)
                    Entity.Kill(BaseNetworkable.DestroyMode.None);
            }

            internal void SetPositionDestination(Vector3 position, Vector3 destination)
            {
                tr.position = position;
                centerDestination = destination;

                AI.SetTargetDestination(destination);
            }

            private void UpdateTargetList()
            {
                BasePlayer strafeTarget = null;
                bool isStrafing = false;
                bool shouldUseNapalm = false;
                for (int i = _targets.Count - 1; i >= 0; i--)
                {
                    PatrolHelicopterAI.targetinfo targetinfo = _targets[i];

                    if (targetinfo == null || !targetinfo.ent)
                        _targets.Remove(targetinfo);                    
                    else
                    {
                        if (Time.realtimeSinceStartup > targetinfo.nextLOSCheck)
                        {
                            targetinfo.nextLOSCheck = Time.realtimeSinceStartup + 1f;
                            if (PlayerVisible(targetinfo.ply))
                            {
                                targetinfo.lastSeenTime = Time.realtimeSinceStartup;
                                targetinfo.visibleFor += 1f;
                            }
                            else targetinfo.visibleFor = 0f;                            
                        }

                        bool isDead = targetinfo.ply ? targetinfo.ply.IsDead() : (targetinfo.ent.Health() <= 0f);

                        if (targetinfo.TimeSinceSeen() >= 6f || isDead)
                        {
                            if ((CanStrafe() || CanUseNapalm()) && AI.IsAlive() && !isStrafing && !isDead && (targetinfo.ply == AI.leftGun._target || targetinfo.ply == AI.rightGun._target))
                            {
                                shouldUseNapalm = (!ValidStrafeTarget(targetinfo.ply) || UnityEngine.Random.Range(0f, 1f) > 0.75f);    
                                isStrafing = true;
                            }

                            _targets.Remove(targetinfo);
                        }
                    }
                }

                foreach (EventManager.BaseEventPlayer eventPlayer in Event.eventPlayers)
                {
                    BasePlayer player = eventPlayer.Player;

                    if (Vector3Ex.Distance2D(tr.position, player.transform.position) <= 150f)
                    {
                        bool isCurrentTarget = false;
                        for (int i = 0; i < _targets.Count; i++)
                        {
                            PatrolHelicopterAI.targetinfo targetInfo = _targets[i];

                            if (targetInfo.ply == player)
                            {
                                isCurrentTarget = true;
                                break;
                            }
                        }
                       
                        if (!isCurrentTarget && PlayerVisible(player))
                        {
                            _targets.Add(new PatrolHelicopterAI.targetinfo(player, player));
                        }
                    }
                }
                
                if (isStrafing && _targets.Count > 0)
                {
                    AI.ExitCurrentState();
                    AI.State_Strafe_Enter(_targets.GetRandom().ply, shouldUseNapalm);
                }

                AI._targetList.Clear();
                AI._targetList.AddRange(_targets);
            }

            private bool PlayerVisible(BasePlayer player)
            {                             
                Vector3 targetPosition = player.eyes.position;
                
                Vector3 position = AI.transform.position - (Vector3.up * 6f);                
                Vector3 direction = (targetPosition - position).normalized;
                float maxDistance = Vector3.Distance(targetPosition, position);

                if (GamePhysics.Trace(new Ray(position + (direction * 5f), direction), 0f, out raycastHit, maxDistance * 1.1f, 1218652417, QueryTriggerInteraction.UseGlobal) && raycastHit.collider.gameObject.ToBaseEntity() == player)                
                    return true;                
                return false;
            }

            private bool ValidStrafeTarget(BasePlayer player)
            {                
                return !player.IsNearEnemyBase();
            }

            private bool CanStrafe()
            {                
                if (Time.realtimeSinceStartup - AI.lastStrafeTime < 20f)
                    return false;                
                return AI.CanInterruptState();
            }

            private bool CanUseNapalm()
            {                
                return Time.realtimeSinceStartup - AI.lastNapalmTime >= 30f;
            }

            internal bool DealDamage(HitInfo hitInfo, out int hitPoints)
            {
                hitPoints = hitInfo.HitBone == mainRotorBone || hitInfo.HitBone == tailRotorBone ? Configuration.RotorHitPoints : Configuration.HeliHitPoints;

                float totalDamage = hitInfo.damageTypes.Total();
                if (totalDamage >= Entity.health)
                {
                    KillHelicopter();
                    return false;
                }

                return true;
            }

            private void KillHelicopter()
            {
                Event.OnHelicopterKilled(this);
                Effect.server.Run(HELIEXPLOSION_EFFECT, tr.position);
                Destroy(this);
            }
        }
        #endregion

        #region Config        
        private static ConfigData Configuration;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Respawn time (seconds)")]
            public int RespawnTime { get; set; }

            [JsonProperty(PropertyName = "Maximum distance helicopters can travel away from the arena")]
            public float MaxTravelDistance { get; set; }

            [JsonProperty(PropertyName = "Amount of points given to players when they shoot a rotor")]
            public int RotorHitPoints { get; set; }

            [JsonProperty(PropertyName = "Amount of points given to players when they shoot the heli")]
            public int HeliHitPoints { get; set; }

            [JsonProperty(PropertyName = "Amount of time between rounds (seconds)")]
            public int TimeBetweenRounds { get; set; }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Configuration = Config.ReadObject<ConfigData>();

            if (Configuration.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(Configuration, true);
        }

        protected override void LoadDefaultConfig() => Configuration = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                RespawnTime = 5,
                MaxTravelDistance = 200f,
                RotorHitPoints = 10,
                HeliHitPoints = 1,
                TimeBetweenRounds = 10,
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(Configuration, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            Configuration.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        #region Localization
        public string Message(string key, ulong playerId = 0U) => lang.GetMessage(key, this, playerId != 0U ? playerId.ToString() : null);

        private static Func<string, ulong, string> GetMessage;

        private readonly Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["Score.HitPoints"] = "Hit Points: {0}",
            ["Score.Name"] = "Hit Points",
            ["Score.RoundNumber"] = "Round {0} / {1}",
            ["Score.HelisRemaining"] = "Helicopters Remaining : {0}",
            ["Score.Remaining"] = "Players Remaining : {0}",
            ["Score.Heli"] = "Heli {0}",

            ["Notification.LivesRemaining"] = "You have {0} lives remaining!",
            ["Notification.Death.OOB"] = "<color=#007acc>{0}</color> tried to run away...",
            ["Notification.Death.Killed"] = "<color=#007acc>{0}</color> has been killed",

            ["UI.Death.Killed.Kicked"] = "You was killed...\nYou placed {0}\n{1} players remain",
            ["UI.Death.OOB.Kicked"] = "You left the playable area\nYou placed {0}\n{1} players remain",

            ["UI.Death.Killed"] = "You was killed...",
            ["UI.Death.OOB"] = "You left the playable area",

            ["UI.Rounds"] = "Rounds",
            ["UI.PlayerLives"] = "Player Lives",
            ["UI.MaxHelicopters"] = "Maximum Helicopters",
            ["UI.DamageScaler"] = "Damage Scale",
            ["UI.HelicoptersRemaining"] = "Helicopters Remaining : {0}",

            ["Notification.RoundStartsIn"] = "Next round starts in <color=#007acc>{0}</color> seconds"
        };
        #endregion
    }
}


// --- End of file: ChopperSurvival.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/car-spawn-settings ---
// --- Original File Path: C/CarSpawnSettings/CarSpawnSettings.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Rust.Modular;

namespace Oxide.Plugins
{
    [Info("Car Spawn Settings", "WhiteThunder", "2.3.1")]
    [Description("Allows modular cars to spawn with configurable modules, health, fuel, and engine parts.")]
    internal class CarSpawnSettings : CovalencePlugin
    {
        #region Fields

        private readonly object False = false;
        private Configuration _config;
        private VanillaPresetCache _vanillaPresetCache = new();

        #endregion

        #region Hooks

        private void Init()
        {
            // Make sure presets are ready as soon as possible
            // Cars can spawn while generating a new map before OnServerInitialized()
            _config.Init(this);
        }

        private object OnVehicleModulesAssign(ModularCar car)
        {
            var vanillaPresets = car.spawnSettings.configurationOptions;
            if (vanillaPresets.Length == 1)
            {
                // Ignore the car if there's only 1 preset because it's probably a spawnable preset.
                return null;
            }

            var presetConfiguration = _config.ModulePresetMap.GetPresetConfigurationForSockets(car.TotalSockets);
            var numCustomPresets = presetConfiguration?.CustomPresets.Length ?? 0;

            var numTotalPresets = numCustomPresets;
            if (presetConfiguration is { UseVanillaPresets: true })
            {
                numTotalPresets += vanillaPresets.Length;
            }

            if (numTotalPresets > 0)
            {
                IList<IModuleDefinition> moduleDefinitions;

                var randomPresetIndex = UnityEngine.Random.Range(0, numTotalPresets);
                if (randomPresetIndex < numCustomPresets)
                {
                    moduleDefinitions = presetConfiguration.CustomPresets[randomPresetIndex];
                }
                else
                {
                    moduleDefinitions = _vanillaPresetCache.GetModulePreset(
                        vanillaPresets[randomPresetIndex - numCustomPresets]
                    );
                }

                AddCarModules(car, moduleDefinitions);
            }

            NextTick(() =>
            {
                if (car == null || car.IsDestroyed)
                    return;

                ProcessCar(car);
            });

            return False;
        }

        #endregion

        #region Commands

        [Command("carspawnsettings.fillcars")]
        private void CommandFillCars(IPlayer player)
        {
            if (!player.IsAdmin)
                return;

            var carsProcessed = 0;

            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var car = entity as ModularCar;
                if (car == null || car.IsDestroyed)
                    continue;

                ProcessCar(car);
                carsProcessed++;
            }

            player.Reply(GetMessage(player.Id, Lang.FillSuccess, carsProcessed));
        }

        #endregion

        #region Helper Methods

        private bool BootstrapWasBlocked(ModularCar car)
        {
            return Interface.CallHook("CanBootstrapSpawnedCar", car) is false;
        }

        private void ProcessCar(ModularCar car)
        {
            if (car.OwnerID != 0 || BootstrapWasBlocked(car))
                return;

            BootstrapAfterModules(car);
        }

        private void AddCarModules(ModularCar car, IList<IModuleDefinition> modulePreset)
        {
            for (var i = 0; i < car.TotalSockets && i < modulePreset.Count; i++)
            {
                var moduleDefinition = modulePreset[i];
                var existingItem = car.Inventory.ModuleContainer.GetSlot(i);
                if (existingItem != null)
                    continue;

                var moduleItem = moduleDefinition.Create();
                if (moduleItem == null)
                    continue;

                moduleItem.conditionNormalized = _config.RandomizeModuleCondition();

                if (!car.TryAddModule(moduleItem, i))
                {
                    moduleItem.Remove();
                    break;
                }

                // Skip ahead if the current module takes multiple sockets.
                i += moduleDefinition.NumSockets - 1;
            }
        }

        private void BootstrapAfterModules(ModularCar car)
        {
            MaybeAddFuel(car);
            MaybeAddEngineParts(car);
        }

        private void MaybeAddFuel(ModularCar car)
        {
            var fuelAmount = _config.RandomizeFuelAmount();
            if (fuelAmount == 0)
                return;

            if (car.GetFuelSystem() is not EntityFuelSystem fuelSystem)
                return;

            var fuelContainer = fuelSystem.GetFuelContainer();
            if (fuelAmount < 0)
            {
                fuelAmount = fuelContainer.allowedItem.stackable;
            }

            var fuelItem = fuelContainer.inventory.FindItemByItemID(fuelContainer.allowedItem.itemid);
            if (fuelItem == null)
            {
                fuelContainer.inventory.AddItem(fuelContainer.allowedItem, fuelAmount);
            }
        }

        private void MaybeAddEngineParts(ModularCar car)
        {
            if (!_config.CanHaveEngineParts())
                return;

            foreach (var child in car.children)
            {
                var engineModule = child as VehicleModuleEngine;
                if (engineModule == null)
                    continue;

                var engineStorage = engineModule.GetContainer() as EngineStorage;
                if (engineStorage == null || !engineStorage.inventory.IsEmpty())
                    continue;

                AddPartsToEngineStorage(engineStorage);
                engineModule.RefreshPerformanceStats(engineStorage);
            }
        }

        private void AddPartsToEngineStorage(EngineStorage engineStorage)
        {
            if (engineStorage.inventory == null)
                return;

            var inventory = engineStorage.inventory;
            for (var i = 0; i < inventory.capacity; i++)
            {
                // Do nothing if there is an existing engine part
                var item = inventory.GetSlot(i);
                if (item != null)
                    continue;

                var tier = _config.RandomizeEnginePartTier();
                if (tier > 0)
                {
                    TryAddEngineItem(engineStorage, i, tier);
                }
            }
        }

        private bool TryAddEngineItem(EngineStorage engineStorage, int slot, int tier)
        {
            if (!engineStorage.allEngineItems.TryGetItem(tier, engineStorage.slotTypes[slot], out var output))
                return false;

            var component = output.GetComponent<ItemDefinition>();
            var item = ItemManager.Create(component);
            if (item == null)
                return false;

            item.conditionNormalized = _config.RandomizePartCondition();
            item.MoveToContainer(engineStorage.inventory, slot, allowStack: false);
            return true;
        }

        #endregion

        #region Module Definitions

        private interface IModuleDefinition
        {
            Item Create();
            int NumSockets { get; }
        }

        private class VanillaModuleDefinition : IModuleDefinition
        {
            public int NumSockets { get; }

            private ItemDefinition _itemDefinition;

            public VanillaModuleDefinition(ItemModVehicleModule socketItemDefinition)
            {
                NumSockets = socketItemDefinition.SocketsTaken;
                _itemDefinition = socketItemDefinition.GetComponent<ItemDefinition>();
            }

            public Item Create()
            {
                if ((object)_itemDefinition == null)
                    return null;

                return ItemManager.Create(_itemDefinition);
            }
        }

        private class VanillaPresetCache
        {
            private Dictionary<ModularCarPresetConfig, IList<IModuleDefinition>> _cache = new();

            public IList<IModuleDefinition> GetModulePreset(ModularCarPresetConfig presetConfig)
            {
                if (!_cache.TryGetValue(presetConfig, out var modules))
                {
                    var moduleDefinitionList = new List<IModuleDefinition>();

                    foreach (var socketItemDefinition in presetConfig.socketItemDefs)
                    {
                        if (socketItemDefinition == null)
                            continue;

                        moduleDefinitionList.Add(new VanillaModuleDefinition(socketItemDefinition));
                    }

                    modules = moduleDefinitionList.ToArray();
                    _cache[presetConfig] = modules;
                }

                return modules;
            }
        }

        #endregion

        #region Configuration

        private Configuration GetDefaultConfig() => new();

        private class Configuration : SerializableConfiguration
        {
            [JsonProperty("EnginePartsTier")]
            private int DeprecatedEnginePartsTier
            {
                set
                {
                    if (value == 1)
                    {
                        EngineParts.Tier1Chance = 100;
                    }
                    else if (value == 2)
                    {
                        EngineParts.Tier2Chance = 100;
                    }
                    else if (value == 3)
                    {
                        EngineParts.Tier3Chance = 100;
                    }
                }
            }

            [JsonProperty("FuelAmount", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private int DeprecatedFuelAmount = 0;

            [JsonProperty("Engine parts")]
            public EnginePartConfiguration EngineParts = new();
            [JsonProperty("EngineParts")]
            public EnginePartConfiguration DeprecatedEngineParts { set => EngineParts = value; }

            [JsonProperty("Min fuel amount")]
            public int MinFuelAmount = 0;
            [JsonProperty("MinFuelAmount")]
            public int DeprecatedMinFuelAmount { set => MinFuelAmount = value; }

            [JsonProperty("Max fuel amount")]
            public int MaxFuelAmount = 0;
            [JsonProperty("MaxFuelAmount")]
            private int DeprecatedMaxFuelAmount { set => MaxFuelAmount = value; }

            [JsonProperty("Min health percent")]
            public float MinHealthPercent = 15.0f;
            [JsonProperty("MinHealthPercent")]
            private float DeprecatedMinHealthPercent { set => MinHealthPercent = value; }

            [JsonProperty("Max health percent")]
            public float MaxHealthPercent = 50.0f;
            [JsonProperty("MaxHealthPercent")]
            private float DeprecatedMaxHealthPercent { set => MaxHealthPercent = value; }
            [JsonProperty("HealthPercentage")]
            private float DeprecatedHealthPercentage
            {
                set
                {
                    MinHealthPercent = value;
                    MaxHealthPercent = value;
                }
            }

            [JsonProperty("Module presets")]
            public ModulePresetMap ModulePresetMap = new();
            [JsonProperty("ModulePresets")]
            private ModulePresetMap DeprecatedModulePresetMap { set => ModulePresetMap = value; }

            public void Init(CarSpawnSettings plugin)
            {
                ModulePresetMap.Init(plugin);
            }

            public float RandomizeModuleCondition()
            {
                return RandomizeCondition(MinHealthPercent, MaxHealthPercent);
            }

            public int RandomizeFuelAmount()
            {
                if (DeprecatedFuelAmount != 0)
                    return DeprecatedFuelAmount;

                if (MinFuelAmount == 0 && MaxFuelAmount == 0)
                    return 0;

                if (MinFuelAmount == MaxFuelAmount)
                    return MinFuelAmount;

                return UnityEngine.Random.Range(MinFuelAmount, MaxFuelAmount + 1);
            }

            public bool CanHaveEngineParts()
            {
                return EngineParts.Tier1Chance > 0
                       || EngineParts.Tier2Chance > 0
                       || EngineParts.Tier3Chance > 0;
            }

            public int RandomizeEnginePartTier()
            {
                if (EngineParts.Tier3Chance > 0
                    && (EngineParts.Tier3Chance >= 100 || UnityEngine.Random.Range(0, 100) < EngineParts.Tier3Chance))
                    return 3;

                if (EngineParts.Tier2Chance > 0
                    && (EngineParts.Tier2Chance >= 100 || UnityEngine.Random.Range(0, 100) < EngineParts.Tier2Chance))
                    return 2;

                if (EngineParts.Tier1Chance > 0
                    && (EngineParts.Tier1Chance >= 100 || UnityEngine.Random.Range(0, 100) < EngineParts.Tier1Chance))
                    return 1;

                return 0;
            }

            public float RandomizePartCondition()
            {
                return RandomizeCondition(
                    EngineParts.MinConditionPercent,
                    EngineParts.MaxConditionPercent
                );
            }

            private float RandomizeCondition(float minPercent, float maxPercent)
            {
                if (minPercent >= 100)
                    return 1;

                return UnityEngine.Mathf.Round(
                    UnityEngine.Random.Range(minPercent, Math.Max(minPercent, maxPercent))
                ) / 100f;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class EnginePartConfiguration
        {
            [JsonProperty("Tier 1 chance")]
            public int Tier1Chance = 0;
            [JsonProperty("Tier1Chance")]
            private int DeprecatedTier1Chance { set => Tier1Chance = value; }

            [JsonProperty("Tier 2 chance")]
            public int Tier2Chance = 0;
            [JsonProperty("Tier2Chance")]
            private int DeprecatedTier2Chance { set => Tier2Chance = value; }

            [JsonProperty("Tier 3 chance")]
            public int Tier3Chance = 0;
            [JsonProperty("Tier3Chance")]
            private int DeprecatedTier3Chance { set => Tier3Chance = value; }

            [JsonProperty("Min condition percent")]
            public float MinConditionPercent = 100f;
            [JsonProperty("MinConditionPercent")]
            private float DeprecatedMinConditionPercent { set => MinConditionPercent = value; }

            [JsonProperty("Max condition percent")]
            public float MaxConditionPercent = 100f;
            [JsonProperty("MaxConditionPercent")]
            private float DeprecatedMaxConditionPercent { set => MaxConditionPercent = value; }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class ModulePresetMap
        {
            [JsonProperty("2 sockets")]
            public ModulePresetConfiguration PresetsFor2Sockets = new();
            [JsonProperty("2Sockets")]
            private ModulePresetConfiguration DeprecatedPresetsFor2Sockets { set => PresetsFor2Sockets = value; }

            [JsonProperty("3 sockets")]
            public ModulePresetConfiguration PresetsFor3Sockets = new();
            [JsonProperty("3Sockets")]
            private ModulePresetConfiguration DeprecatedPresetsFor3Sockets { set => PresetsFor3Sockets = value; }

            [JsonProperty("4 sockets")]
            public ModulePresetConfiguration PresetsFor4Sockets = new();
            [JsonProperty("4Sockets")]
            private ModulePresetConfiguration DeprecatedPresetsFor4Sockets { set => PresetsFor4Sockets = value; }

            public void Init(CarSpawnSettings plugin)
            {
                PresetsFor2Sockets.Init(plugin);
                PresetsFor3Sockets.Init(plugin);
                PresetsFor4Sockets.Init(plugin);
            }

            public ModulePresetConfiguration GetPresetConfigurationForSockets(int totalSockets)
            {
                if (totalSockets == 4)
                    return PresetsFor4Sockets;

                if (totalSockets == 3)
                    return PresetsFor3Sockets;

                if (totalSockets == 2)
                    return PresetsFor2Sockets;

                return null;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class ModuleDefinition : IModuleDefinition
        {
            [JsonProperty("Item short name")]
            public string ItemShortName;

            [JsonProperty("Item skin ID")]
            public ulong SkinId;

            [JsonIgnore]
            public int NumSockets { get; private set; }= 1;

            [JsonIgnore]
            private ItemDefinition _itemDefinition;

            public void Init(CarSpawnSettings plugin = null)
            {
                // Null/empty short name indicates a blank socket between modules.
                if (string.IsNullOrEmpty(ItemShortName))
                    return;

                _itemDefinition = ItemManager.FindItemDefinition(ItemShortName);
                if (_itemDefinition == null)
                {
                    plugin?.LogError($"Unrecognized module item short name: {ItemShortName}");
                    return;
                }

                var vehicleMod = _itemDefinition.GetComponent<ItemModVehicleModule>();
                if (vehicleMod == null)
                {
                    plugin?.LogError("No vehicle module found for item: {0}", ItemShortName);
                    _itemDefinition = null;
                    return;
                }

                NumSockets = vehicleMod.SocketsTaken;
            }

            public Item Create()
            {
                if ((object)_itemDefinition == null)
                    return null;

                return ItemManager.Create(_itemDefinition, 1, SkinId);
            }
        }

        private class ModulePresetConfiguration
        {
            [JsonProperty("Use vanilla presets")]
            public bool UseVanillaPresets = true;
            [JsonProperty("UseVanillaPresets")]
            private bool DeprecatedUseVanillaPresets { set => UseVanillaPresets = value; }

            [JsonProperty("Custom presets")]
            public ModuleDefinition[][] CustomPresets = Array.Empty<ModuleDefinition[]>();
            [JsonProperty("CustomPresets")]
            private object[][] DeprecatedCustomPresets { set => CustomPresets = ParseLegacyPresets(value); }

            public void Init(CarSpawnSettings plugin)
            {
                foreach (var presetList in CustomPresets)
                {
                    foreach (var moduleDefinition in presetList)
                    {
                        moduleDefinition.Init(plugin);
                    }
                }
            }

            private ModuleDefinition[][] ParseLegacyPresets(object[][] legacyPresetList)
            {
                var presetList = new List<ModuleDefinition[]>();

                foreach (var moduleIdentifierList in legacyPresetList)
                {
                    var modulePreset = new List<ModuleDefinition>();
                    foreach (var moduleIdentifier in moduleIdentifierList)
                    {
                        modulePreset.Add(ParseLegacyModuleDefinition(moduleIdentifier));
                    }
                    presetList.Add(modulePreset.ToArray());
                }

                return presetList.ToArray();
            }

            private ModuleDefinition ParseLegacyModuleDefinition(object moduleIdentifier)
            {
                if (moduleIdentifier is int or long)
                {
                    var moduleId = moduleIdentifier is long identifier
                        ? Convert.ToInt32(identifier)
                        : (int)moduleIdentifier;

                    if (moduleId == 0)
                        return new ModuleDefinition();

                    var itemDefinition = ItemManager.FindItemDefinition(moduleId);
                    if (itemDefinition == null)
                        return new ModuleDefinition();

                    return new ModuleDefinition
                    {
                        ItemShortName = itemDefinition.shortname,
                    };
                }

                if (moduleIdentifier is string moduleString)
                {
                    if (int.TryParse(moduleString, out var parsedItemId))
                    {
                        if (parsedItemId == 0)
                            return new ModuleDefinition();

                        var itemDefinition = ItemManager.FindItemDefinition(parsedItemId);
                        if (itemDefinition == null)
                            return new ModuleDefinition();
                    }

                    return new ModuleDefinition
                    {
                        ItemShortName = moduleString,
                    };
                }

                return new ModuleDefinition();
            }
        }

        #region Configuration Helpers

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                if (currentRaw.TryGetValue(key, out var currentRawValue))
                {
                    var currentDictValue = currentRawValue as Dictionary<string, object>;
                    if (currentWithDefaults[key] is Dictionary<string, object> defaultDictValue)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion

        #region Localization

        private string GetMessage(string userId, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, userId);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        private static class Lang
        {
            public const string FillSuccess = "Fill.Success";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.FillSuccess] = "Processed {0} cars.",
            }, this, "en");
        }

        #endregion
    }
}


// --- End of file: CarSpawnSettings.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/compound-options ---
// --- Original File Path: C/CompoundOptions/CompoundOptions.cs ---

using System.Collections.Generic;
using System.Linq;
using Rust.Ai;
using Oxide.Core;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Compound Options", "FastBurst", "1.2.6")]
    [Description("Compound monument options")]
    class CompoundOptions : RustPlugin
    {
        #region Vars
        private bool dataChanged;
        private StorageData data;
        private StorageData defaultOrders;
        #endregion

        #region Oxide hooks
        private void Loaded()
        {
            try
            {
                data = Interface.Oxide.DataFileSystem.ReadObject<StorageData>(Name);
                defaultOrders = Interface.Oxide.DataFileSystem.ReadObject<StorageData>(Name + "_default");
            }
            catch { }

            if (data == null)
            {
                data = new StorageData();
            }
            if (defaultOrders == null)
            {
                defaultOrders = new StorageData();
            }

            if (data.VendingMachinesOrders == null)
            {
                data.VendingMachinesOrders = new Dictionary<string, Order[]>();
            }
            if (defaultOrders.VendingMachinesOrders == null)
            {
                defaultOrders.VendingMachinesOrders = new Dictionary<string, Order[]>();
            }
        }

        private void Unload()
        {
            foreach (var entity in BaseNetworkable.serverEntities.ToList())
            {
                if (entity is NPCVendingMachine)
                {
                    var vending = entity as NPCVendingMachine;
                    if (configData.General.allowConsoleOutput)
                        Puts($"Restoring default orders for {vending.ShortPrefabName}");
                    if (defaultOrders.VendingMachinesOrders != null)
                    {
                        vending.vendingOrders.orders = GetDefaultOrders(vending);
                        vending.InstallFromVendingOrders();
                    }
                }
            }
        }

        private void Init()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            //LoadVariables();
        }

        private void OnServerInitialized()
        {
            Subscribe(nameof(OnEntitySpawned));

            foreach (var entity in BaseNetworkable.serverEntities.ToList())
            {
                if (entity is NPCVendingMachine)
                {
                    var vending = entity as NPCVendingMachine;
                    AddVendingOrders(vending, true);
                    UpdateVending(vending);
                }
                else if (entity is NPCPlayer)
                {
                    KillNPCPlayer(entity as NPCPlayer);
                }
                else if (entity is NPCAutoTurret)
                {
                    ProcessNPCTurret(entity as NPCAutoTurret);
                }
            }

            //LoadVariables();
            SaveData();
        }

        private void OnEntityEnter(TriggerBase trigger, BaseEntity entity)
        {
            if (!(trigger is TriggerSafeZone) && !(entity is BasePlayer)) return;

            var safeZone = trigger as TriggerSafeZone;
            if (safeZone == null) return;

            safeZone.enabled = !configData.General.disableCompoundTrigger;
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity is NPCVendingMachine)
            {
                UpdateVending(entity as NPCVendingMachine);
                SaveData();
            }
            else if (entity is NPCPlayer)
            {
                KillNPCPlayer(entity as NPCPlayer);
            }
            else if (entity is NPCAutoTurret)
            {
                ProcessNPCTurret(entity as NPCAutoTurret);
            }
        }
        #endregion

        #region Implementation
        private void KillNPCPlayer(NPCPlayer npcPlayer)
        {
            var npcSpawner = npcPlayer.gameObject.GetComponent<ScientistSpawner>();
            if (npcSpawner == null) return;

            if (npcSpawner.IsMilitaryTunnelLab && configData.General.disallowCompoundNPC || npcSpawner.IsBandit && configData.General.disallowBanditNPC)
            {
                if (!npcPlayer.IsDestroyed) npcPlayer.Kill(BaseNetworkable.DestroyMode.Gib);
            }
        }

        private void ProcessNPCTurret(NPCAutoTurret npcAutoTurret)
        {
            npcAutoTurret.SetFlag(NPCAutoTurret.Flags.On, !configData.General.disableCompoundTurrets, !configData.General.disableCompoundTurrets);
            npcAutoTurret.UpdateNetworkGroup();
            npcAutoTurret.SendNetworkUpdateImmediate();
        }

        private void AddVendingOrders(NPCVendingMachine vending, bool def = false)
        {
            if (vending == null || vending.IsDestroyed)
            {
                Puts("Null or destroyed machine...");
                return;
            }
            if (!def)
            {
                if (data.VendingMachinesOrders.ContainsKey(vending.vendingOrders.name))
                {
                    return;
                }
            }
            List<Order> orders = new List<Order>();
            foreach (var order in vending.vendingOrders.orders)
            {
                orders.Add(new Order
                {
                    _comment = $"Sell {order.sellItem.displayName.english} x {order.sellItemAmount} for {order.currencyItem.displayName.english} x {order.currencyAmount}",
                    sellAmount = order.currencyAmount,
                    currencyAmount = order.sellItemAmount,
                    sellId = order.sellItem.itemid,
                    sellAsBP = order.sellItemAsBP,
                    currencyId = order.currencyItem.itemid,
                    weight = 100,
                    refillAmount = 100000,
                    refillDelay = 0.0f
                });
            }
            if (def)
            {
                if (orders == null) return;

                if (configData.General.allowConsoleOutput)
                    Puts($"Trying to save default vendingOrders for {vending.vendingOrders.name}");

                if (defaultOrders == null) defaultOrders = new StorageData();
                if (defaultOrders.VendingMachinesOrders.ContainsKey(vending.vendingOrders.name)) return;
                defaultOrders.VendingMachinesOrders.Add(vending.vendingOrders.name, orders.ToArray());
            }
            else
            {
                data.VendingMachinesOrders.Add(vending.vendingOrders.name, orders.ToArray());
            }
            if (configData.General.allowConsoleOutput)
                Puts($"Added Vending Machine: {vending.vendingOrders.name} to data file!");
            dataChanged = true;
        }

        private void UpdateVending(NPCVendingMachine vending)
        {
            if (vending == null || vending.IsDestroyed)
            {
                return;
            }

            AddVendingOrders(vending);
            NextTick(() =>
            {
                vending.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                vending.SendNetworkUpdateImmediate();
            });

            if (configData.General.disableCompoundVendingMachines)
            {
                vending.ClearSellOrders();
                vending.inventory.Clear();
            }
            else if (configData.General.allowCustomCompoundVendingMachines)
            {
                vending.vendingOrders.orders = GetNewOrders(vending);
                vending.InstallFromVendingOrders();
            }
        }

        private NPCVendingOrder.Entry[] GetDefaultOrders(NPCVendingMachine vending)
        {
            List<NPCVendingOrder.Entry> temp = new List<NPCVendingOrder.Entry>();
            foreach (var order in defaultOrders.VendingMachinesOrders[vending.vendingOrders.name])
            {
                temp.Add(new NPCVendingOrder.Entry
                {
                    currencyAmount = order.sellAmount,
                    currencyAsBP = order.currencyAsBP,
                    currencyItem = ItemManager.FindItemDefinition(order.currencyId),
                    sellItem = ItemManager.FindItemDefinition(order.sellId),
                    sellItemAmount = order.currencyAmount,
                    sellItemAsBP = order.sellAsBP,
                    refillAmount = 100000,
                    refillDelay = 0.0f,
                    randomDetails = new NPCVendingOrder.EntryRandom
                    {
                        weight = 100
                    }
                });
            }
            return temp.ToArray();
        }

        private NPCVendingOrder.Entry[] GetNewOrders(NPCVendingMachine vending)
        {
            List<NPCVendingOrder.Entry> temp = new List<NPCVendingOrder.Entry>();
            foreach (var order in data.VendingMachinesOrders[vending.vendingOrders.name])
            {
                ItemDefinition currencyItem = ItemManager.FindItemDefinition(order.currencyId);
                if (currencyItem == null)
                {
                    PrintError($"Item id {order.currencyId} is invalid. Skipping sell order.");
                    continue;
                }

                ItemDefinition sellItem = ItemManager.FindItemDefinition(order.sellId);
                if (sellItem == null)
                {
                    PrintError($"Item id {order.sellId} is invalid. Skipping sell order.");
                    continue;
                }

                temp.Add(new NPCVendingOrder.Entry
                {
                    currencyAmount = order.sellAmount,
                    currencyAsBP = order.currencyAsBP,
                    currencyItem = currencyItem,
                    sellItem = sellItem,
                    sellItemAmount = order.currencyAmount,
                    sellItemAsBP = order.sellAsBP,
                    refillAmount = 100000,
                    refillDelay = 0.0f,
                    randomDetails = new NPCVendingOrder.EntryRandom
                    {
                        weight = 100
                    }
                });
            }
            return temp.ToArray();
        }
        #endregion       

        #region Commmands
        [ChatCommand("compreset")]
        private void cmdCompReset(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin)
            {
                SendReply(player, "You doesn't have permission to that!");
                return;
            }

            Interface.Oxide.ReloadPlugin(Name);
        }

        [ConsoleCommand("compreset")]
        private void ccmdCompReset(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
                return;

            if (arg.IsAdmin == false)
            {
                Puts("You doesn't have permission to that!");
                return;
            }

            Interface.Oxide.ReloadPlugin(Name);
        }
        #endregion

        #region Save data classes
        private class StorageData
        {
            public Dictionary<string, Order[]> VendingMachinesOrders { get; set; }
        }

        private class Order
        {
            public string _comment;
            public int sellId;
            public int sellAmount;
            public bool sellAsBP;
            public int currencyId;
            public int currencyAmount;
            public bool currencyAsBP;
            public int weight;
            public int refillAmount;
            public float refillDelay;
        }
        private void SaveData()
        {
            if (dataChanged)
            {
                Interface.Oxide.DataFileSystem.WriteObject(Name, data);
                Interface.Oxide.DataFileSystem.WriteObject(Name + "_default", defaultOrders);
                dataChanged = false;
            }
        }

        #endregion

        #region Config
        private static ConfigData configData;
        class ConfigData
        {
            [JsonProperty(PropertyName = "General Settings")]
            public GeneralSettings General { get; set; }

            public class GeneralSettings
            {
                [JsonProperty(PropertyName = "Allow console status outputs")]
                public bool allowConsoleOutput { get; set; }
                [JsonProperty(PropertyName = "Allow custom sell list for Compound vending machines (see in data)")]
                public bool allowCustomCompoundVendingMachines { get; set; }
                [JsonProperty(PropertyName = "Disallow Bandit NPC")]
                public bool disallowBanditNPC { get; set; }
                [JsonProperty(PropertyName = "Disallow Compound NPC")]
                public bool disallowCompoundNPC { get; set; }
                [JsonProperty(PropertyName = "Disable Compound Turrets")]
                public bool disableCompoundTurrets { get; set; }
                [JsonProperty(PropertyName = "Disable Compound SafeZone trigger")]
                public bool disableCompoundTrigger { get; set; }
                [JsonProperty(PropertyName = "Disable Compound Vending Machines")]
                public bool disableCompoundVendingMachines { get; set; }
            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();
        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                General = new ConfigData.GeneralSettings
                {
                    allowConsoleOutput = true,
                    allowCustomCompoundVendingMachines = true,
                    disallowBanditNPC = false,
                    disallowCompoundNPC = false,
                    disableCompoundTurrets = false,
                    disableCompoundTrigger = false,
                    disableCompoundVendingMachines = false
                },
                Version = Version
            };
        }
        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();
            if (configData.Version < new Core.VersionNumber(1, 2, 5))
            {
                configData = baseConfig;
            }

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion
    }
}

// --- End of file: CompoundOptions.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/card-reader-doors ---
// --- Original File Path: C/CardReaderDoors/CardReaderDoors.cs ---

using System;
using System.Linq;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using Oxide.Core.Configuration;
using UnityEngine;
using Oxide.Core;

using System.Globalization;

namespace Oxide.Plugins
{
    [Info("Card Reader Doors", "Ts3Hosting", "2.1.1")]
    [Description("Create access doors with card readers")]
    public class CardReaderDoors : RustPlugin
    {
        PlayerEntity pcdData;
        private DynamicConfigFile PCDDATA;
        private bool Changed;
        private static string theadmin = "cardreaderdoors.admin";
        public Dictionary<ulong, int> activate = new Dictionary<ulong, int>();
		
        public ulong CardskinID;
        public int close;
		public float damagetotal;
		public bool damage;
		public bool damageNo;
		
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["nope"] = "You do not have the perms to do that!",
                ["nopeperm"] = "You do not have the permission to access this room!",
                ["dooradd"] = "You just added this door to the list.",
                ["lockadd"] = "You just added lock for door name {0}.",
                ["nodoor"] = "There is no saved door file {0}.",
                ["fail"] = "Usage /setlock <DoorSavedName>",
                ["faillock"] = "Usage /lockdoor <DoorSavedName> <permission>",
				["UsageActive"] = "Usage /lockdoor active <AccessLevel Number 1 = green, 2 = blue 3 = red>",
                ["dooraddfail"] = "Somthing went wrong is this door name already in the list or you are not close enuf..",
                ["nodoorfail"] = "This is not a door..",
                ["noreader"] = "This is not a cardreader..",
                ["active"] = "You must activate the mode /doorlock active to enable/disable",
                ["activeon"] = "You now active to place cardreaders",
                ["activeoff"] = "You are no longer in active mode.",
				["WrongCard"] = "Wrong Access Key Card Color",
            }, this);
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Creating a new configuration file!");
            LoadVariables();
        }
        void LoadVariables()
        {
            //  CardskinID = Convert.ToUInt64(GetConfig("Keycard", "CardSkinID", 1566879106));
            close = Convert.ToInt32(GetConfig("Door Settings", "Time in seconds to close the door", 5));
			damageNo = Convert.ToBoolean(GetConfig("Card Settings", "Disable KeyCard Damage", false));
			damage = Convert.ToBoolean(GetConfig("Card Settings", "Add More Damage On Card use", false));
			damagetotal = Convert.ToSingle(GetConfig("Card Settings", "Damage Amount", 0.10));

            Puts("Config Loaded");
            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }
        void Init()
        {
            PCDDATA = Interface.Oxide.DataFileSystem.GetFile(Name + "/Rooms");
            LoadData();
            RegisterPermissions();
            LoadVariables();
        }
        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
        private void RegisterPermissions()
        {
            permission.RegisterPermission(theadmin, this);
			if (pcdData.pEntity == null) return;
            foreach (var perm in pcdData.pEntity.Values)
            {
                if (!string.IsNullOrEmpty(perm.permission) && !permission.PermissionExists(perm.permission))
                    permission.RegisterPermission(perm.permission, this);
            }
        }

        void LoadData()
        {
            try
            {
                pcdData = Interface.Oxide.DataFileSystem.ReadObject<PlayerEntity>(Name + "/Rooms");
            }
            catch
            {
                Puts("Couldn't load Rooms data, creating new Rooms file");
                pcdData = new PlayerEntity();
            }

        }
        class Access
        {
            public string displayName;
            public ulong steamID;
        }
        class Reader
        {
            //  public ulong NetID;
        }
        class PlayerEntity
        {
            public Dictionary<string, PCDInfo> pEntity = new Dictionary<string, PCDInfo>();


            public PlayerEntity() { }
        }
        class PCDInfo
        {
            public uint SpawnEntity;
            public ulong doorID;
            public string roomName;
            public string permission;
            public Dictionary<ulong, Reader> reader = new Dictionary<ulong, Reader>();
            public List<Access> access = new List<Access>();
        }
        void SaveData()
        {
            PCDDATA.WriteObject(pcdData);
        }

		private void OnHammerHit(BasePlayer player, HitInfo info)
        {
            CardReader reader = info?.HitEntity as CardReader;
            if (reader != null)
            {
                if (!permission.UserHasPermission(player.UserIDString, theadmin) || !activate.ContainsKey(player.userID.Get()))
                    return;
				reader.Kill();
			}
		}
		
        void OnEntityBuilt(Planner plan, GameObject go)
        {
            var player = plan?.GetOwnerPlayer();
            if (player == null) return;
            if (!permission.UserHasPermission(player.UserIDString, theadmin) || !activate.ContainsKey(player.userID.Get()))
            {
                return;
            }
            var entity = go?.ToBaseEntity() ?? null;
            if (entity == null) return;
            if (entity is BaseEntity)
            {
                if (entity.ShortPrefabName == "laserdetector")
                {
					CardReader changed = null;
                    var reader = GameManager.server.CreateEntity("assets/prefabs/io/electric/switches/cardreader.prefab");
                    if (reader == null) return;
                    reader.transform.localPosition = entity.transform.localPosition + new Vector3(0f, -1.35f, 0f);
                    reader.transform.localRotation = entity.transform.localRotation;
                    reader.gameObject.SetActive(true);
					if (reader is CardReader)
						changed = reader as CardReader; 
					if (changed != null)
					changed.accessLevel = activate[player.userID.Get()];
                    reader.Spawn();
                    reader.SetFlag(BaseEntity.Flags.Reserved8, true, false, true);
                    SpawnRefresh(reader);
                    reader.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    reader.SendNetworkUpdateImmediate();
					NextTick(() => { entity.Kill(); });
                }
            }
        }

        private string checkdoor(ulong netID)
        {
            foreach (var door in pcdData.pEntity.Values.ToList())
            {
                if (door.reader.ContainsKey(netID))
                {
                    return door.roomName;
                }
            }
            return null;
        }

        object OnCardSwipe(CardReader reader1, Keycard card1, BasePlayer player)
        {			
            var check = checkdoor(reader1.net.ID.Value);
            if (check == null) return null;
			if (!pcdData.pEntity.ContainsKey(check)) return null;
			float access = card1.accessLevel;
			if (damage || damageNo)
			{
				Item item = card1.GetItem();
				NextTick(() =>
				{
					if (item != null && damageNo)
					{
						item.condition = item.condition + 1;
					}
					else if (item != null && damage)
						item.condition = item.condition - damagetotal;
				});
			}
				
			if (card1.accessLevel != reader1.accessLevel)
			{
				SendReply(player, lang.GetMessage("WrongCard", this, player.UserIDString));
				return null;
			}
			var perm = pcdData.pEntity[check].permission;
            if (perm == null) return null;
            if (!permission.UserHasPermission(player.UserIDString, perm))
            {
                SendReply(player, lang.GetMessage("nopeperm", this, player.UserIDString));
                return null;
            }
			
            var doorID = pcdData.pEntity[check].doorID;
            Door door = BaseNetworkable.serverEntities.Find(new NetworkableId(doorID)) as Door;
            if (door == null) return null;

            if (!door.IsOpen() && (door.GetComponent<Door>()))
            {
                door.SetFlag(BaseEntity.Flags.Open, true);				
                timer.Once(close, () => { door?.SetFlag(BaseEntity.Flags.Open, false); if (reader1 != null) { reader1.CancelInvoke(new Action(reader1.GrantCard)); reader1.CancelInvoke(new Action(reader1.CancelAccess)); reader1.CancelAccess(); } });
            }
            return null;
        }
		
        void SpawnRefresh(BaseNetworkable entity1)
        {
            UnityEngine.Object.Destroy(entity1.GetComponent<Collider>());
        }

        [ChatCommand("lockdoor")]
        private void lockdoor(BasePlayer player, string command, string[] args)
        {
			bool checkN = false;
            if (!permission.UserHasPermission(player.UserIDString, theadmin))
            {
                SendReply(player, lang.GetMessage("nope", this, player.UserIDString));
                return;
            }
			if (args.Length == 0)
			{
				SendReply(player, lang.GetMessage("faillock", this, player.UserIDString));
				return;
			}				
            if (args[0].ToLower() == "active")
            {
								
                if (activate.ContainsKey(player.userID.Get()))
                {
					activate.Remove(player.userID.Get());
                    SendReply(player, lang.GetMessage("activeoff", this, player.UserIDString));
                    return;
                }
                else
                {
					if (args.Length != 2)
					{
						SendReply(player, lang.GetMessage("UsageActive", this, player.UserIDString));
						return;
					}
					if (args[1] == "1") checkN = true;
					if (args[1] == "2") checkN = true;
					if (args[1] == "3") checkN = true;

					if (!checkN)
					{
						SendReply(player, lang.GetMessage("UsageActive", this, player.UserIDString));
						return;
					}
					var ids = default(int);
					if (!int.TryParse(args[1], out ids))
					{
						SendReply(player, lang.GetMessage("faillock", this));
						return;
					}
                    activate.Add(player.userID.Get(), ids);
                    SendReply(player, lang.GetMessage("activeon", this, player.UserIDString));
                    return;
                }
            }
            if (args.Length != 2)
            {
                SendReply(player, lang.GetMessage("faillock", this, player.UserIDString));
                return;
            }
            var rayResult = raydoor(player);
            if (rayResult == null)
            {
                SendReply(player, lang.GetMessage("nodoorfail", this, player.UserIDString));
                return;
            }
            if (rayResult is Door)
            {
                var entity = rayResult as BaseEntity;
                var DoorId = entity.net.ID.Value;

                if (!pcdData.pEntity.ContainsKey(args[0].ToLower()))
                {
                    var perm = "cardreaderdoors." + args[1].ToLower();

                    pcdData.pEntity.Add(args[0].ToLower(), new PCDInfo());
                    pcdData.pEntity[args[0].ToLower()].roomName = args[0].ToLower();
                    pcdData.pEntity[args[0].ToLower()].doorID = entity.net.ID.Value;
                    pcdData.pEntity[args[0].ToLower()].permission = perm;
                    SaveData();
                    if (!string.IsNullOrEmpty(perm) && !permission.PermissionExists(perm))
                        permission.RegisterPermission(perm, this);
                    entity.SetFlag(BaseEntity.Flags.Locked, true, false, true);
                    SendReply(player, lang.GetMessage("dooradd", this, player.UserIDString));
                    return;
                }
                SendReply(player, lang.GetMessage("dooraddfail", this, player.UserIDString));
                return;
            }
            SendReply(player, lang.GetMessage("nodoorfail", this, player.UserIDString));
        }

        [ChatCommand("setlock")]
        private void setlock(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, theadmin))
            {
                SendReply(player, lang.GetMessage("nope", this, player.UserIDString));
                return;
            }
			
            if (args.Length != 1)
            {
                SendReply(player, lang.GetMessage("fail", this, player.UserIDString));
                return;
            }
            var rayResult = raydoor(player);
            if (rayResult == null)
            {
                SendReply(player, lang.GetMessage("noreader", this, player.UserIDString));
                return;
            }
            if (!pcdData.pEntity.ContainsKey(args[0].ToLower()))
            {
                SendReply(player, lang.GetMessage("nodoor", this, player.UserIDString), args[0]);
				return;
            }
            if (rayResult is CardReader)
            {
                var entity = rayResult as CardReader;
                pcdData.pEntity[args[0].ToLower()].reader.Add(entity.net.ID.Value, new Reader());
                SaveData();
                SendReply(player, lang.GetMessage("lockadd", this, player.UserIDString), args[0]);
                return;
            }
            SendReply(player, lang.GetMessage("noreader", this, player.UserIDString));
        }
        private BaseEntity raydoor(BasePlayer player)
        {
            RaycastHit doorhit;
            if (!Physics.Raycast(player.eyes.HeadRay(), out doorhit, 1f)) {return null;}
            return doorhit.GetEntity();
        }

    }
}



// --- End of file: CardReaderDoors.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/custom-skins-stacks-fix ---
// --- Original File Path: C/CustomSkinsStacksFix/CustomSkinsStacksFix.cs ---

using Oxide.Core.Plugins;
using System;

namespace Oxide.Plugins
{
    [Info("Custom Skins Stacks Fix", "The Friendly Chap", "1.0.4")]
    [Description("Fixing problem with stacking/splitting/moving custom items (skins)")]
    public class CustomSkinsStacksFix : RustPlugin
    {
        [PluginReference] Plugin StackModifier;
        private object CanStackItem(Item original, Item target)
        {
            if (original.skin == 0 && target.skin == 0)
            {
                return null;
            }
            
            if (original.skin != target.skin)
            {
                return false;
            }

            if (original.contents != null || target.contents != null)
            {
                return false;
            }

            if (Math.Abs(original._condition - target._condition) > 0f)
            {
                return false;
            }

            if (Math.Abs(original._maxCondition - target._maxCondition) > 0f)
            {
                return false;
            }

            return null;
        }
        
        private Item OnItemSplit(Item item, int amount)
        {
            if (StackModifier != null)
            {
                return null;
            }

            if (item.skin == 0)
            {
                return null;
            }

            item.amount -= amount;
            var newItem = ItemManager.Create(item.info, amount, item.skin);
            newItem.name = item.name;
            newItem._condition = item._condition;
            newItem._maxCondition = item._maxCondition;
            
            if (item.IsBlueprint())
            {
                newItem.blueprintTarget = item.blueprintTarget;
            }
                
            item.MarkDirty();
            return newItem;
        }
        
        private object CanAcceptItem(ItemContainer container, Item movingItem, int targetPos)
        {
            if (movingItem.skin == 0)
            {
                return null;
            }
            
            var containerItem = container.parent;
            if (containerItem == null || containerItem.skin == 0)
            {
                return null;
            }
            
            if (movingItem.contents != null && movingItem.contents.capacity > 4)
            {
                return ItemContainer.CanAcceptResult.CannotAccept;
            }
            
            return null;
        }
        
        private object CanCombineDroppedItem(WorldItem first, WorldItem second)
        {
            return CanStackItem(first.item, second.item);
        }

        void OnServerInitialized()
        {
            if (StackModifier != null)
            {
                Puts("Error : Conflict with StackModifier, Custom Skins Stack Fix not needed, please unload.");
            }
        }
    }
}

// --- End of file: CustomSkinsStacksFix.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/cornucopia ---
// --- Original File Path: C/Cornucopia/Cornucopia.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Cornucopia", "Deicide666ra", "1.1.8", ResourceId = 1264)]
    class Cornucopia : RustPlugin
    {
        class CornuConfig
        {
            public CornuConfig()
            {
                // Animals
                Animals.Add(new CornuConfigItem { Prefab = "assets/bundled/prefabs/autospawn/animals/chicken.prefab", Min = -1, Max = -1, IgnoreIrridiated = true });
                Animals.Add(new CornuConfigItem { Prefab = "assets/bundled/prefabs/autospawn/animals/horse.prefab", Min = -1, Max = -1, IgnoreIrridiated = true });
                Animals.Add(new CornuConfigItem { Prefab = "assets/bundled/prefabs/autospawn/animals/boar.prefab", Min = -1, Max = -1, IgnoreIrridiated = true });
                Animals.Add(new CornuConfigItem { Prefab = "assets/bundled/prefabs/autospawn/animals/stag.prefab", Min = -1, Max = -1, IgnoreIrridiated = true });
                Animals.Add(new CornuConfigItem { Prefab = "assets/bundled/prefabs/autospawn/animals/wolf.prefab", Min = -1, Max = -1, IgnoreIrridiated = true });
                Animals.Add(new CornuConfigItem { Prefab = "assets/bundled/prefabs/autospawn/animals/bear.prefab", Min = -1, Max = -1, IgnoreIrridiated = true });

                // Ore nodes
                Ores.Add(new CornuConfigItem { Prefab = "assets/bundled/prefabs/autospawn/resource/ores/stone-ore.prefab", Min = -1, Max = -1, IgnoreIrridiated = true });
                Ores.Add(new CornuConfigItem { Prefab = "assets/bundled/prefabs/autospawn/resource/ores/metal-ore.prefab", Min = -1, Max = -1, IgnoreIrridiated = true });
                Ores.Add(new CornuConfigItem { Prefab = "assets/bundled/prefabs/autospawn/resource/ores/sulfur-ore.prefab", Min = -1, Max = -1, IgnoreIrridiated = true });

                // Silver barrels
                Loots.Add(new CornuConfigItem { Prefab = "assets/bundled/prefabs/radtown/loot_barrel_1.prefab", Min = -1, Max = -1, IgnoreIrridiated = true, DeleteEmtpy = false });

                // Brown barrels
                Loots.Add(new CornuConfigItem { Prefab = "assets/bundled/prefabs/radtown/loot_barrel_2.prefab", Min = -1, Max = -1, IgnoreIrridiated = true, DeleteEmtpy = false });

                // Oil Drums
                Loots.Add(new CornuConfigItem { Prefab = "assets/bundled/prefabs/radtown/oil_barrel.prefab", Min = -1, Max = -1, IgnoreIrridiated = true, DeleteEmtpy = false });

                // Trashcans
                Loots.Add(new CornuConfigItem { Prefab = "assets/bundled/prefabs/radtown/loot_trash.prefab", Min = -1, Max = -1, IgnoreIrridiated = true, DeleteEmtpy = false });

                // Trash piles (food)
                Loots.Add(new CornuConfigItem { Prefab = "assets/bundled/prefabs/autospawn/resource/loot/trash-pile-1.prefab", Min = -1, Max = -1, IgnoreIrridiated = true, DeleteEmtpy = false });

                // Weapon crates
                Loots.Add(new CornuConfigItem { Prefab = "assets/bundled/prefabs/radtown/crate_normal.prefab", Min = -1, Max = -1, IgnoreIrridiated = true, DeleteEmtpy = false });

                // Box crates
                Loots.Add(new CornuConfigItem { Prefab = "assets/bundled/prefabs/radtown/crate_normal_2.prefab", Min = -1, Max = -1, IgnoreIrridiated = true, DeleteEmtpy = false });
            }

            // Refresh Interval in minutes
            public int RefreshMinutes = 15;

            // Apply the loot fix to prevent stacked rad town loot crates
            public bool ApplyLootFix = true;

            // Run the cycle on start
            public bool RefreshOnStart = false;

            // If true, any item that has a maximum will be prevented from spawning outside of the Cornucopia spawn cycle
            //public bool MaxSpawnBlock = true;

            public List<CornuConfigItem> Animals = new List<CornuConfigItem>();
            public List<CornuConfigItem> Ores = new List<CornuConfigItem>();
            public List<CornuConfigItem> Loots = new List<CornuConfigItem>();
        }

        class CornuConfigItem
        {
            public string Prefab;
            public int Min;
            public int Max;
            public bool IgnoreIrridiated;
            public bool DeleteEmtpy;
        }

        CornuConfig g_config;
        Timer g_refreshTimer;
        //bool g_spawnBlock = true;

        void Loaded() => LoadConfigValues();

        protected override void LoadDefaultConfig()
        {
            g_config = new CornuConfig();
            Config.WriteObject(g_config, true);
            Puts("New configuration file created.");
        }

        void LoadConfigValues()
        {
            try
            {
                g_config = Config.ReadObject<CornuConfig>();
            }
            catch
            {
                Puts("Could not read config, creating new default config.");
                LoadDefaultConfig();
            }

            //g_spawnBlock = g_config.MaxSpawnBlock;
        }

        void SendHelpText(BasePlayer player)
        {
            var sb = new StringBuilder();
            sb.Append("<color=yellow>Cornucopia 1.1.4.0</color> · Controls resource abundance\n");
            if (player.IsAdmin)
            {
                sb.Append("  · ").AppendLine("<color=lime>/cdump</color> (<color=orange>cornu.dump</color>) for RCON stats");
                sb.Append("  · ").AppendLine("<color=lime>/cspawn</color> (<color=orange>cornu.spawn</color>) adjusts resources");
                sb.Append("  · ").AppendLine("<color=lime>/cfixloot</color> (<color=orange>cornu.fixloot</color>) loot box stacking fix");
                sb.Append("  · ").Append("<color=lime>/cpurge</color> (<color=orange>cornu.purge</color>) deletes ALL resources");
            }
            player.ChatMessage(sb.ToString());
        }

        void OnServerInitialized()
        {
            g_refreshTimer = timer.Every(g_config.RefreshMinutes * 60, OnTimer);
        }

        void OnTimer()
        {
            if (g_config.ApplyLootFix) FixLoot(null);

            //g_spawnBlock = false;
            try
            {
                MainSpawnCycle();
            }
            finally
            {
                //g_spawnBlock = g_config.MaxSpawnBlock;
            }
        }

        void Unloaded()
        {
            if (g_refreshTimer == null) return;

            g_refreshTimer.Destroy();
            g_refreshTimer = null;
        }

        Dictionary<string, int> GetCollectibles()
        {
            // wood
            // stone-1
            // metalore-2
            // sulfurore-3
            // mushroom-cluster-1
            // mushroom-cluster-2
            // mushroom-cluster-3
            // mushroom-cluster-4
            // mushroom-cluster-5
            // mushroom-cluster-6
            // hemp
            return Resources.FindObjectsOfTypeAll<CollectibleEntity>()
                .Where(c => c.isActiveAndEnabled && !c.ShortPrefabName.Contains("hemp") && !c.ShortPrefabName.Contains("mushroom"))
                .GroupBy(c => c.ShortPrefabName).ToDictionary(c => c.Key, c => c.Count());
        }

        Dictionary<string, IGrouping<string, BaseEntity>> GetOreNodes()
        {
            // stone-ore
            // metal-ore
            // sulfur-ore
            return Resources.FindObjectsOfTypeAll<ResourceEntity>()
                .Where(c => /*c.name.StartsWith("autospawn") &&*/ c.isActiveAndEnabled)
                .Cast<BaseEntity>()
                .GroupBy(c => c.ShortPrefabName).ToDictionary(c => c.Key, c => c);
        }

        Dictionary<string, IGrouping<string, BaseEntity>> GetLootContainers()
        {
            // loot_trash
            // loot_barrel_1
            // loot_barrel_2
            // crate_normal
            // crate_normal_2
            return Resources.FindObjectsOfTypeAll<LootContainer>()
                .Where(c => c.isActiveAndEnabled)
                .Cast<BaseEntity>()
                .GroupBy(c => c.ShortPrefabName).ToDictionary(c => c.Key, c => c);
        }

        Dictionary<string, IGrouping<string, BaseEntity>> GetAnimals()
        {
            // chicken
            // horse
            // boar
            // stag
            // wolf
            // bear
            return Resources.FindObjectsOfTypeAll<BaseNpc>()
                .Where(c => c.isActiveAndEnabled)
                .Cast<BaseEntity>()
                .GroupBy(c => c.ShortPrefabName).ToDictionary(c => c.Key, c => c);
        }

        void DumpSpawns(Dictionary<string, int> entities)
        {
            foreach (var t in entities)
                Puts($"{t.Key.PadRight(50)} {t.Value}");
        }

        void DumpSpawns(Dictionary<string, IGrouping<string, BaseEntity>> entities)
        {
            foreach (var t in entities)
                Puts($"{t.Key.PadRight(50)} {t.Value.Count()}");
        }

        [ConsoleCommand("cornu.dump")]
        void DumpCommand(ConsoleSystem.Arg arg)
        {
            if (arg != null && arg.Player() != null && arg.Player().IsAdmin == false) return;
            DumpEntities();
        }

        [ConsoleCommand("cornu.spawn")]
        void SpawnCommand(ConsoleSystem.Arg arg)
        {
            if (arg != null && arg.Player() != null && arg.Player().IsAdmin == false) return;
            MainSpawnCycle();
        }

        [ConsoleCommand("cornu.fixloot")]
        void FixLootCommand(ConsoleSystem.Arg arg)
        {
            if (arg != null && arg.Player() != null && arg.Player().IsAdmin == false) return;
            FixLoot(null);
        }

        [ConsoleCommand("cornu.purge")]
        void PurgeCommand(ConsoleSystem.Arg arg)
        {
            if (arg != null && arg.Player() != null && arg.Player().IsAdmin == false) return;
            Purge();
        }

        void DumpEntities()
        {
            Puts("= COLLECTIBLES ================");
            DumpSpawns(GetCollectibles());
            Puts("= NODES =======================");
            DumpSpawns(GetOreNodes());
            Puts("= CONTAINERS ==================");
            DumpSpawns(GetLootContainers());
            Puts("= ANIMALS =====================");
            DumpSpawns(GetAnimals());
        }

        Vector2 GetBoxPos(LootContainer box) => new Vector2(box.transform.position.x, box.transform.position.z);

        [ChatCommand("cpurge")]
        void cmdPurge(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin)
            {
                player.ChatMessage("You need to be admin to run this command, sorry buddy!");
                return;
            }
            Purge();
        }

        [ChatCommand("cfixloot")]
        void cmdFixLoot(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin)
            {
                player.ChatMessage("You need to be admin to run this command, sorry buddy!");
                return;
            }
            FixLoot(player);
        }

        [ChatCommand("cdump")]
        void cmdDump(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin)
            {
                player.ChatMessage("You need to be admin to run this command, sorry buddy!");
                return;
            }
            DumpEntities();
        }

        [ChatCommand("cspawn")]
        void cmdSpawn(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin)
            {
                player.ChatMessage("You need to be admin to run this command, sorry buddy!");
                return;
            }
            player.ChatMessage("Respawning the lost ones!");
            MainSpawnCycle();
            player.ChatMessage("... and done!");
        }

        [ChatCommand("ctest")]
        void cmdTest(BasePlayer player, string command, string[] args)
        {

            var toto = Resources.FindObjectsOfTypeAll<LootContainer>()
                .Where(c => c.isActiveAndEnabled && c.ShortPrefabName.Contains("trash-pile"));

            Puts($"{toto.First().PrefabName}");
        }

        void SubCycle(IEnumerable<BaseEntity> entities, IEnumerable<CornuConfigItem> limits, List<CollectibleEntity> collectibles, ref bool aborted)
        {
            foreach (var spawn in limits)
            {
                if (spawn.Min == -1 && spawn.Max == -1) continue;

                var matches = entities.Where(r => r.PrefabName == spawn.Prefab);

                if (matches.Count() < spawn.Min && spawn.Min != -1)
                {
                    if (!aborted) BatchSpawn(matches.Count(), spawn.Min, spawn.Prefab, collectibles, ref aborted);
                }
                else if (matches.Count() > spawn.Max && spawn.Max != -1)
                {
                    PopulationControl(matches, spawn.Max);
                }

                var deleted = 0;
                if (spawn.DeleteEmtpy)
                {
                    foreach (var match in matches.OfType<LootContainer>())
                    {
                        if (!match.inventory.itemList.Any())
                        {
                            match.Kill();
                            deleted++;
                        }
                    }
                }
                if (deleted > 0) Puts($"Deleted {deleted} empty {spawn.Prefab}");
            }
        }

        void MainSpawnCycle()
        {
            var doAnimals = g_config.Animals.Any(a => a.Min != -1 || a.Max != -1);
            var doOres = g_config.Ores.Any(a => a.Min != -1 || a.Max != -1);
            var doLoots = g_config.Loots.Any(a => a.Min != -1 || a.Max != -1);

            if (!doAnimals && !doOres && !doLoots)
            {
                Puts("Nothing to process, skipping MainSpawnCycle()");
                return;
            }

            var tick = DateTime.Now;
            var collectibles = Resources.FindObjectsOfTypeAll<CollectibleEntity>().Where(c => c.isActiveAndEnabled).ToList();
            //Puts($"collectibles: {(DateTime.Now - tick).TotalMilliseconds} ms");

            var aborted = false;

            if (doAnimals)
            {
                tick = DateTime.Now;
                SubCycle(Resources.FindObjectsOfTypeAll<BaseNpc>().Where(c => c.isActiveAndEnabled).Cast<BaseEntity>(), g_config.Animals, collectibles, ref aborted);
                //Puts($"npc: {(DateTime.Now - tick).TotalMilliseconds} ms");
            }

            if (doOres)
            {
                tick = DateTime.Now;
                SubCycle(Resources.FindObjectsOfTypeAll<ResourceEntity>().Where(c => c.isActiveAndEnabled).Cast<BaseEntity>(), g_config.Ores, collectibles, ref aborted);
                //Puts($"res: {(DateTime.Now - tick).TotalMilliseconds} ms");
            }

            if (doLoots)
            {
                tick = DateTime.Now;
                SubCycle(Resources.FindObjectsOfTypeAll<LootContainer>().Where(c => c.isActiveAndEnabled).Cast<BaseEntity>(), g_config.Loots, collectibles, ref aborted);
                //Puts($"loot: {(DateTime.Now - tick).TotalMilliseconds} ms");
            }
        }

        void PopulationControl(IEnumerable<BaseEntity> matches, int cap)
        {
            if (cap < 0) return;
            if (matches.Count() < cap) return;
            if (matches.Count() == 0) return;
            var toDelete = matches.Count() - cap;

            var killed = 0;
            var shortPrefabName = matches.First().ShortPrefabName;

            while (killed != toDelete)
            {
                var idx = Random.Range(0, matches.Count() - 1);
                var match = matches.ElementAt(idx);
                if (!match.enabled) continue;
                match.enabled = false;
                match.Kill();
                killed++;
            }

            Puts($"Destroying {toDelete}X {shortPrefabName}!");
        }

        void BatchSpawn(int current, int wanted, string prefab, List<CollectibleEntity> collectibles, ref bool aborted)
        {
            if (aborted) return;

            var toSpawn = wanted - current;
            if (toSpawn <= 0) return;

            if (toSpawn > collectibles.Count)
            {
                Puts($"Could not find enough collectibles to complete the spawn cycle (this is normal after a server restart, it takes time!)");
                aborted = true;
                toSpawn = collectibles.Count;
            }

            Puts($"Spawning {toSpawn}X {prefab}!");
            for (var i = 0; i < toSpawn; i++)
                ReplaceCollectibleWithSomething(prefab, collectibles);
        }

        void ReplaceCollectibleWithSomething(string prefabName, List<CollectibleEntity> collectibles)
        {
            // Pick a collectible that we did not replace yet and remove it from the list
            var pick = Random.Range(0, collectibles.Count - 1);
            var spawnToReplace = collectibles.ElementAt(pick);
            collectibles.RemoveAt(pick);

            // save the position
            var position = spawnToReplace.transform.position;

            // delete the collectible (we are replacing it)
            spawnToReplace.Kill();

            var entity = GameManager.server.CreateEntity(prefabName, position, new Quaternion(0, 0, 0, 0));
            if (entity == null)
            {
                Puts($"Tried to spawn {prefabName} but entity could not be spawned.");
                return;
            }

            entity.name = prefabName;
            entity.Spawn();
        }

        void FixLoot(BasePlayer player)
        {
            var spawns = Resources.FindObjectsOfTypeAll<LootContainer>()
                .Where(c => c.isActiveAndEnabled && c.ShortPrefabName.StartsWith("crate")).
                OrderBy(c => c.transform.position.x).ThenBy(c => c.transform.position.z).ThenBy(c => c.transform.position.z)
                .ToList();

            var count = spawns.Count;
            var racelimit = count * count;

            var antirace = 0;
            var deleted = 0;

            for (var i = 0; i < count; i++)
            {
                var box = spawns[i];
                var pos = GetBoxPos(box);

                if (++antirace > racelimit)
                {
                    Puts("Race condition detected ?! report to author");
                    return;
                }

                var next = i + 1;
                while (next < count)
                {
                    var box2 = spawns[next];
                    var pos2 = GetBoxPos(box2);
                    var distance = Vector2.Distance(pos, pos2);

                    if (++antirace > racelimit)
                    {
                        Puts("Race condition detected ?! report to author");
                        return;
                    }

                    if (distance < 5)
                    {
                        spawns.RemoveAt(next);
                        count--;
                        box2.Kill();
                        deleted++;
                    }
                    else break;
                }
            }

            if (deleted > 0) Puts($"Deleted {deleted} stacked loot boxes (out of {count})");
            player?.ChatMessage($"Deleted {deleted} stacked loot boxes (out of {count})");
        }

        void Purge()
        {
            // Delete all spawnables
            var ores = GetOreNodes();
            foreach (var grp in ores)
                foreach (var ore in grp.Value) ore.Kill();

            var loots = GetLootContainers();
            foreach (var grp in loots)
                foreach (var loot in grp.Value) loot.Kill();

            var animals = GetAnimals();
            foreach (var grp in animals)
                foreach (var animal in grp.Value) animal.Kill();
        }

        //void OnEntitySpawned(BaseNetworkable entity)
        //{
        //    if (!g_spawnBlock) return;

        //    var controlled = g_config.Animals.Union(g_config.Ores).Union(g_config.Loots);
        //    var prefab = entity.PrefabName;
        //    if (controlled.Any(c => c.Prefab == prefab && c.Max != -1))
        //    {
        //        entity.Kill();
        //        //Puts($"BLOCKED OnEntitySpawned {entity.ShortPrefabName}");
        //    }
        //}
    }
}

// --- End of file: Cornucopia.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/cupboard-protection ---
// --- Original File Path: C/CupboardProtection/CupboardProtection.cs ---

﻿using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using Oxide.Core;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("CupboardProtection", "Wulf/lukespragg and birthdates Maintained by NooBlet", "1.9.4")]
    [Description("Makes cupboards and their foundations invulnerable, unable to be destroyed.")]

    public class CupboardProtection : RustPlugin
    {
        private readonly int Mask = LayerMask.GetMask("Construction");

        #region Hooks

        private object OnEntityTakeDamage(DecayEntity entity, HitInfo info)
        {
            var Initiator = info.Initiator;
            if (!Initiator) return null;

            if (entity.name.Contains("cupboard"))
            {
                if (Configuration.OwnerCanDoDamage)
                {
                    if (Configuration.teamCanDoDamage)
                    {
                        if (info.InitiatorPlayer != null && canBreakTC(info.InitiatorPlayer, entity)) return null;
                    }

                    if (info.InitiatorPlayer != null && info.InitiatorPlayer.userID == entity.OwnerID) return null;
                }
                return CHook("CanDamageTc", Initiator, entity);
            }

            if (!Configuration.foundation || !entity.name.Contains("foundation")) return null;
           
           
            return IDData.IDs.Values.ToList().Exists(id => id == entity.net.ID.Value) ? CHook("CanDamageTcFloor", Initiator, entity) : null;
        }

        private static object CHook(string Name, BaseEntity Player, DecayEntity Entity)
        {
            var Hook = Interface.CallHook(Name, Player, Entity);
            return Hook is bool ? Hook : false;
        }

        private void Init()
        {
            LoadConfig();
            if (!Configuration.foundation)
            {
                Unsubscribe("OnEntityBuilt");
                Unsubscribe("OnEntityKill");
            }           
            timer10m();
            IDData = Interface.Oxide.DataFileSystem.ReadObject<Data>(Name);
        }

        private void OnNewSave(string filename)
        {
            Puts("Wipe Detected Clearing Data File");
            IDData.IDs.Clear();
            SaveData();
        }

        private void Unload() => SaveData();

        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            if (go == null)
            {
                return;
            }


            var Priv = go.GetComponent<BaseEntity>() as BuildingPrivlidge;
            if (Priv == null)
            {
                return;
            }


            Vector3 oldPosition = Priv.transform.position;
            Vector3 tempPosition = new Vector3(Priv.transform.position.x, Priv.transform.position.y + 1F, Priv.transform.position.z);
            Priv.transform.position = tempPosition;
            var Foundation = GetFoundation(Priv);
            Priv.transform.position = oldPosition;


            if (Foundation == null)
            {
                return;
            }


            IDData.IDs.Add(Priv.net.ID.Value, Foundation.net.ID.Value);
            SaveData();
        }
        //private void OnEntityBuilt(Planner plan, GameObject go)
        //{
        //    var Priv = go.GetComponent<BaseEntity>() as BuildingPrivlidge;
        //    if (!Priv) return;
        //    Vector3 oldPosition = Priv.transform.position;
        //    Vector3 tempPosition = new Vector3(Priv.transform.position.x, Priv.transform.position.y + 1F, Priv.transform.position.z);
        //    Priv.transform.position = tempPosition;
        //    var Foundation = GetFoundation(Priv);
        //    Priv.transform.position = oldPosition;
        //    if (!Foundation) return;           
        //    IDData.IDs.Add(Priv.net.ID.Value, Foundation.net.ID.Value);
        //}

        private BuildingBlock GetFoundation(BuildingPrivlidge Priv) => Physics.RaycastAll(Priv.transform.position, Vector3.down, 2f, Mask, QueryTriggerInteraction.Ignore).Select(Hit => Hit.GetEntity() as BuildingBlock).FirstOrDefault(E => E);

        private void OnEntityKill(BuildingPrivlidge entity)
        {
            if (IDData.IDs.ContainsKey(entity.net.ID.Value))
            {
                IDData.IDs.Remove(entity.net.ID.Value);
            }
        }
        #endregion

        #region Methods

        void CheckTCs()
        {
            foreach (var go in BuildingPrivlidge.serverEntities)
            {
                var Priv = go.GetComponent<BaseEntity>() as BuildingPrivlidge;
                if (!Priv) continue;
                if (IDData.IDs.ContainsKey(Priv.net.ID.Value)) { continue; }
                Vector3 oldPosition = Priv.transform.position;
                Vector3 tempPosition = new Vector3(Priv.transform.position.x, Priv.transform.position.y + 1F, Priv.transform.position.z);
                Priv.transform.position = tempPosition;
                var Foundation = GetFoundation(Priv);
                Priv.transform.position = oldPosition;
                if (!Foundation) continue;
                IDData.IDs.Add(Priv.net.ID.Value, Foundation.net.ID.Value);
            }
        }
        private void timer10m()
        {
            timer.Every(600f, () =>
            {
                CheckTCs();

            });
        }
        private bool canBreakTC(BasePlayer player, DecayEntity Entity)
        {
            foreach(var p in player.currentTeam.ToString())
            {
                if (p == Entity.OwnerID) { return true; }
            }
            return false;
        }

        #endregion Methods

        #region Data
        private Data IDData;

        private class Data
        {
            public readonly Dictionary<ulong, ulong> IDs = new Dictionary<ulong, ulong>();
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, IDData);
        }
        #endregion

        #region Configuration

        private ConfigFile Configuration;

        public class ConfigFile
        {

            [JsonProperty("Foundation Invincible?")]
            public bool foundation;
            [JsonProperty("TC Owner can Damage TC and Foundation?")]
            public bool OwnerCanDoDamage;
            [JsonProperty("Team can Damage TC and Foundation?")]
            public bool teamCanDoDamage;

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile()
                {
                    foundation = true, OwnerCanDoDamage = false, teamCanDoDamage = false                   

                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Configuration = Config.ReadObject<ConfigFile>();
            if (Config == null)
            {
                LoadDefaultConfig();
            }
        }
       

        protected override void LoadDefaultConfig()
        {
            Configuration = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");

        }

        protected override void SaveConfig()
        {
            Config.WriteObject(Configuration);
        }
        #endregion
    }
}

// --- End of file: CupboardProtection.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/chat-notice ---
// --- Original File Path: C/ChatNotice/ChatNotice.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Chat Notice", "Tricky", "0.0.3")]
    [Description("Plays a sound effect for the receiver on player chat")]
    public class ChatNotice : CovalencePlugin
    {
        #region Plugin References
        [PluginReference]
        private Plugin PrivateMessages, Clans;
        #endregion

        #region Config
        Configuration config;

        class Configuration
        {
            [JsonProperty(PropertyName = "Require Permission")]
            public bool RequirePermission = false;

            [JsonProperty(PropertyName = "Sound Prefab")]
            public string SoundPrefab = "assets/bundled/prefabs/fx/invite_notice.prefab";

            [JsonProperty(PropertyName = "Use Cooldown")]
            public bool UseCooldown = true;

            [JsonProperty(PropertyName = "Cooldown (seconds)")]
            public int Cooldown = 60;

            [JsonProperty(PropertyName = "Use PM")]
            public bool PM = true;

            [JsonProperty(PropertyName = "Use Clan Chat")]
            public bool ClanChat = true;

            [JsonProperty(PropertyName = "Use Global Chat")]
            public bool GlobalChat = false;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) throw new Exception();
            }
            catch
            {
                Config.WriteObject(config, false, $"{Interface.Oxide.ConfigDirectory}/{Name}.jsonError");
                PrintError("The configuration file contains an error and has been replaced with a default config.\n" +
                           "The error configuration file was saved in the .jsonError extension");
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Classes and Stored Data
        private const string perm = "chatnotice.use";
        private Cooldown cooldown = new Cooldown();

        private class Cooldown
        {
            public List<ulong> PM;
            public List<ulong> Clan;
            public List<ulong> Global;

            public Cooldown()
            {
                PM = new List<ulong>();
                Clan = new List<ulong>();
                Global = new List<ulong>();
            }
        }

        private enum ChatType
        {
            PM,
            Clan,
            Global
        }
        #endregion

        #region Oxide Hooks
        private void OnServerInitialized()
        {
            permission.RegisterPermission(perm, this);

            if (config.PM)
            {
                if(PrivateMessages == null)
                {
                    PrintWarning("Private Messages could not be found! Get it at https://umod.org/plugins/private-messages");
                }
                else
                {
                    if (PrivateMessages.Author != "MisterPixie")
                    {
                        PrintWarning("This version of Private Messages isn't supported! Get it at https://umod.org/plugins/private-messages");
                    }
                    else if (PrivateMessages.Version < new VersionNumber(1, 0, 2))
                    {
                        PrintWarning("Only v1.0.2 or above is supported to work with Private Messages");
                    }
                }
            }

            if (config.ClanChat)
            {
                if (Clans == null)
                {
                    PrintWarning("Clans could not be found! Get it at https://umod.org/plugins/clans");
                }
                else
                {
                    if (Clans.Author != "k1lly0u")
                    {
                        PrintWarning("This version of Clans isn't supported! Get it at https://umod.org/plugins/clans");
                    }
                    else if (Clans.Version < new VersionNumber(0, 1, 52))
                    {
                        PrintWarning("Only v0.1.52 or above is supported to work with Clans");
                    }
                }
            }
        }
        #endregion

        #region Chat Hooks
        private void OnPMProcessed(IPlayer player, IPlayer target, string message)
        {
            if (!config.PM)
                return;

            if (config.RequirePermission && !target.HasPermission(perm))
                return;

            RunEffect(target, ChatType.PM);
        }

        private void OnClanChat(IPlayer player, string message)
        {
            if (!config.ClanChat)
                return;

            var clan = GetClanOf(player);
            if (clan == null)
                return;

            var members = (JArray) clan["members"];
            if (members == null)
                return;

            members.ToList().ForEach(x => 
            {
                //var member = BasePlayer.FindByID(Convert.ToUInt64(x));
                var member = players.FindPlayerById(x.ToString());
                if (member == null) return;
                if (config.RequirePermission && !member.HasPermission(perm)) return;

                RunEffect(member, ChatType.Clan);
            });
        }

        private void OnPlayerChat(BasePlayer player, string message)
        {
            if (!config.GlobalChat)
                return;

            var activeplayers = players.Connected.ToList();
            if (activeplayers == null)
                return;

            activeplayers.ForEach(target =>
            {
                if (config.RequirePermission && !target.HasPermission(perm)) return;
                if (target.Id == player.UserIDString) return;

                RunEffect(target, ChatType.Global);
            });
        }
        #endregion

        #region Effect Management
        private void RunEffect(IPlayer iplayer, ChatType type)
        {
            var player = (BasePlayer) iplayer.Object;
            if (player == null)
                return;

            switch (type)
            {
                case ChatType.PM:
                    if (config.UseCooldown && cooldown.PM.Contains(player.userID)) return;
                    cooldown.PM.Add(player.userID);
                    timer.In(config.Cooldown, () => cooldown.PM.Remove(player.userID));
                    break;
                case ChatType.Clan:
                    if (config.UseCooldown && cooldown.Clan.Contains(player.userID)) return;
                    cooldown.Clan.Add(player.userID);
                    timer.In(config.Cooldown, () => cooldown.Clan.Remove(player.userID));
                    break;
                case ChatType.Global:
                    if (config.UseCooldown && cooldown.Global.Contains(player.userID)) return;
                    cooldown.Global.Add(player.userID);
                    timer.In(config.Cooldown, () => cooldown.Global.Remove(player.userID));
                    break;
            }

            Effect.server.Run(config.SoundPrefab, player.transform.position);
        }
        #endregion

        #region Helpers
        private JObject GetClanOf(IPlayer player)
        {
            var tag = (string) Clans?.Call("GetClanOf", player);
            if (tag == null)
                return null;

            var clan = (JObject) Clans?.Call("GetClan", tag);
        
            return clan;
        }
        #endregion
    }
}

// --- End of file: ChatNotice.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/command-rate-limiter ---
// --- Original File Path: C/CommandRateLimiter/CommandRateLimiter.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using UnityEngine;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("CommandRateLimiter", "Calytic", "0.1.2", ResourceId = 1812)]
    public class CommandRateLimiter : CovalencePlugin
    {
        private int KickAfter;
        private int CooldownMS;
        private int ClearRateCountSeconds;
        private bool LogExcessiveUsage;
        private bool SendPlayerMessage;

        Dictionary<string, DateTime> lastRun = new Dictionary<string, DateTime>();
        Dictionary<string, Timer> rateTimer = new Dictionary<string, Timer>();
        Dictionary<string, int> rateCount = new Dictionary<string, int>();
        List<object> commandWhitelist = new List<object>();

        private Dictionary<string, Dictionary<string, int>> spamLog = new Dictionary<string, Dictionary<string, int>>();

        void OnServerInitialized()
        {
            Config["CooldownMS"] = CooldownMS = GetConfig("CooldownMS", 195);
            Config["KickAfter"] = KickAfter = GetConfig("KickAfter", 10);
            Config["ClearRateCountSeconds"] = ClearRateCountSeconds = GetConfig("ClearRateCountSeconds", 5);
            Config["LogExcessiveUsage"] = LogExcessiveUsage = GetConfig("LogExcessiveUsage", false);
            Config["SendPlayerMessage"] = SendPlayerMessage = GetConfig("SendPlayerMessage", true);
            Config["CommandWhitelist"] = commandWhitelist = GetConfig("CommandWhitelist", GetDefaultWhitelist());
            Config["Version"] = Version.ToString();
            SaveConfig();
            LoadMessages();
        }

        List<object> GetDefaultWhitelist()
        {
            return new List<object>() {
                "add"
            };
        }

        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Player Message", "You are doing that too often"},
                {"Kick Message", "Spamming"},
            }, this);
        }

        void LoadDefaultConfig()
        {
            Config["CooldownMS"] = 195;
            Config["KickAfter"] = 10;
            Config["ClearRateCountSeconds"] = 5;
            Config["LogExcessiveUsage"] = false;
            Config["SendPlayerMessage"] = true;
            Config["CommandWhitelist"] = GetDefaultWhitelist();
            Config["Version"] = Version.ToString();
        }

        private T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null)
            {
                return defaultValue;
            }

            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (arg.cmd == null) return null;

            if (arg.Player() == null)
            {
                return null;
            }

            IPlayer player = null;
            player = covalence.Players.FindPlayerById(arg.Player().UserIDString);
            if (player == null) return null;

            if (player.IsConnected == false) return null;

            if (arg.IsAdmin)
                return null;

            DateTime lastTime;

            if (lastRun.TryGetValue(player.Id, out lastTime))
            {
                TimeSpan ts = DateTime.Now - lastTime;
                if (ts.TotalMilliseconds < CooldownMS)
                {
                    if (arg.cmd.Name != null)
                    {
                        if (commandWhitelist.Contains(arg.cmd.Name))
                        {
                            return null;
                        }

                        if (LogExcessiveUsage)
                        {
                            if (!spamLog.ContainsKey(player.Id))
                            {
                                spamLog.Add(player.Id, new Dictionary<string, int>());

                                timer.In(ClearRateCountSeconds, delegate()
                                {
                                    List<string> msgs = new List<string>();

                                    foreach (KeyValuePair<string, int> kvp in spamLog[player.Id])
                                    {
                                        msgs.Add(kvp.Key + " (" + kvp.Value + ")");
                                    }
                                    string cmds = string.Join(", ", msgs.ToArray());
                                    PrintWarning(player.Name + " (" + player.Id + ") spamming commands: " + cmds);
                                    spamLog.Remove(player.Id);
                                });
                            }

                            if (!spamLog[player.Id].ContainsKey(arg.cmd.Name))
                            {
                                spamLog[player.Id].Add(arg.cmd.Name, 1);
                            }
                            else
                            {
                                spamLog[player.Id][arg.cmd.Name]++;
                            }
                        }
                    }

                    int c = 0;
                    bool kicked = false;
                    if (rateCount.TryGetValue(player.Id, out c))
                    {
                        rateCount[player.Id]++;
                        if (KickAfter > 0 && (c + 1) >= KickAfter)
                        {
                            player.Kick(GetMsg("Kick Message"));
                            kicked = true;
                        }
                    }
                    else
                    {
                        rateCount.Add(player.Id, 1);
                    }

                    if (ClearRateCountSeconds > 0)
                    {
                        Timer rtimer;
                        if (rateTimer.TryGetValue(player.Id, out rtimer))
                        {
                            if (!rtimer.Destroyed)
                            {
                                rtimer.Destroy();
                            }

                            rateTimer.Remove(player.Id);
                        }

                        timer.In(ClearRateCountSeconds, delegate()
                        {
                            if (rateCount.TryGetValue(player.Id, out c))
                            {
                                rateCount[player.Id] = 0;
                            }
                        });
                    }
                    if (player != null && SendPlayerMessage && !kicked)
                    {
                        player.Reply(GetMsg("Player Message"));
                    }
                }
                else
                {
                    lastRun[player.Id] = DateTime.Now;
                }
            }
            else
            {
                lastRun.Add(player.Id, DateTime.Now);
            }

            return null;
        }

        void OnUserDisconnected(IPlayer player)
        {
            int c = 0;
            if (rateCount.TryGetValue(player.Id, out c))
            {
                rateCount.Remove(player.Id);
            }
        }

        string GetMsg(string key, object userID = null)
        {
            return lang.GetMessage(key, this, userID == null ? null : userID.ToString());
        }
    }
}

// --- End of file: CommandRateLimiter.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/console-welcome ---
// --- Original File Path: C/ConsoleWelcome/ConsoleWelcome.cs ---

using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Console Welcome", "Ryz0r", "1.0.0"), Description("Sends a welcome message to the console when a player connects.")]
    public class ConsoleWelcome : RustPlugin
    {
        private static string consolePerm = "consolewelcome.receive";
        private void Init()
        {
            permission.RegisterPermission(consolePerm, this);
        }
        
        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null)
                return;
            if (!permission.UserHasPermission(player.UserIDString, consolePerm))
                return;
            
            player.ConsoleMessage(lang.GetMessage("WelcomeMsg", this, player.UserIDString));
        }
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["WelcomeMsg"] = "<size=60><color=white>Your</color><color=blue> Server</color></size>\n<size=15>Welcome to the server! Have fun!</size>\n\n"
            }, this); 
        }
    }
}

// --- End of file: ConsoleWelcome.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/cargo-wetness-fix ---
// --- Original File Path: C/CargoWetnessFix/CargoWetnessFix.cs ---

using Oxide.Core.Plugins;
using Oxide.Core;
using Oxide.Plugins;
using Rust;
using System;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins {
	[Info("Cargo Wetness Fix", "yetzt", "1.0.2")]
	[Description("Prevents players from getting wet on the Cargo Ship")]

	public class CargoWetnessFix : RustPlugin {

		private List<BasePlayer> onboard = new List<BasePlayer>();
		Timer checker;
		int numships = 0;
			
		void OnServerInitialized() {

			// get current amount of cargoships (sorry for the huge call, but runs only once)
			numships = GameObject.FindObjectsOfType<CargoShip>().Length;
			
			if (numships == 0) {
			
				// unsubscribe some hooks when no cargo is present
				Unsubscribe(nameof(OnRunPlayerMetabolism));
				Unsubscribe(nameof(OnEntityEnter));
				Unsubscribe(nameof(OnEntityLeave));
				Unsubscribe(nameof(OnPlayerDisconnected));
				Unsubscribe(nameof(OnPlayerSleepEnded));
			
			} else {
				
				// check all online players triggers for cargo
				foreach (BasePlayer player in BasePlayer.activePlayerList) {
					CheckPlayer(player);
				}

				// sometimes do sanity checks
				checker = timer.Every(60f, () => {
					RunChecker();
				});
				
			}

		}
		
		void Unload(){
			
			for (int i = onboard.Count - 1; i >= 0; i--) {
				Disembark(onboard[i]);
			}

			// destroy checking timer
			checker?.Destroy();
		}

		void OnEntitySpawned(CargoShip entity) {
			if (entity == null) return;

			numships++;
			
			if (numships == 1) {

				Subscribe(nameof(OnRunPlayerMetabolism));
				Subscribe(nameof(OnEntityEnter));
				Subscribe(nameof(OnEntityLeave));
				Subscribe(nameof(OnPlayerDisconnected));
				Subscribe(nameof(OnPlayerSleepEnded));
			
				// destroy old checker if present, run checker
				checker?.Destroy();
				checker = timer.Every(60f, () => {
					RunChecker();
				});
				
			}

		}
		
		private void OnEntityKill(CargoShip entity) {
			if (entity == null) return;
			
			numships--;
			
			// check if another cargoship is present
			// multiple cargoships might be possible
			if (numships == 0) {

				// unsubscribe to all the hooks when no cargo is present
				Unsubscribe(nameof(OnRunPlayerMetabolism));
				Unsubscribe(nameof(OnEntityEnter));
				Unsubscribe(nameof(OnEntityLeave));
				Unsubscribe(nameof(OnPlayerDisconnected));
				Unsubscribe(nameof(OnPlayerSleepEnded));
			
				// destroy checking timer
				checker?.Destroy();

				// JIC remove remaining players instantly
				for (int i = onboard.Count - 1; i >= 0; i--) {
					Disembark(onboard[i]);
				}

			}

		}
		
		private void OnRunPlayerMetabolism(PlayerMetabolism metabolism, BasePlayer player, float delta) {
			if (!IsEmbarked(player)) return;
			// cap wetness at current wetness level
			// so player stays wet when they are wet, but you can't get wetter than they are
			player.metabolism.wetness.max = player.metabolism.wetness.value;
		}

		void OnEntityEnter(TriggerParent trigger, BasePlayer player) {
			if (trigger == null || player == null || player.userID < 76560000000000000L || trigger.GetComponentInParent<CargoShip>() == null) return;
			Embark(player);
		}

		void OnEntityLeave(TriggerParent trigger, BasePlayer player) {
			if (trigger == null || player == null || player.userID < 76560000000000000L || trigger.GetComponentInParent<CargoShip>() == null) return;
			Disembark(player);
		}
		
		void OnPlayerDisconnected(BasePlayer player, string reason) {
			Disembark(player);
		}
		
		void OnPlayerSleepEnded(BasePlayer player) {
			CheckPlayer(player);
		}
		
		void RunChecker() {
			for (int i = onboard.Count - 1; i >= 0; i--) {
				CheckPlayer(onboard[i]);
			}
		}
		
		void CheckPlayer(BasePlayer player) {
			if (player == null || player.triggers == null) return;
			foreach (TriggerBase trigger in player.triggers) {
				if (trigger != null && trigger.GetComponentInParent<CargoShip>() != null) {
					Embark(player);
					return;
				}
			}
			Disembark(player);
		}
		
		bool IsEmbarked(BasePlayer player) {
			return (player != null) ? onboard.Contains(player) : false;
		}
		
		void Embark(BasePlayer player) {
			if (IsEmbarked(player)) return;
			onboard.Add(player);
			player.metabolism.wetness.max = player.metabolism.wetness.value;
			player.metabolism.SendChangesToClient();
		}

		void Disembark(BasePlayer player) {
			if (!IsEmbarked(player)) return;
			onboard.Remove(player);
			player.metabolism.wetness.max = 1;
			player.metabolism.SendChangesToClient();
		}
		
	}
}

// --- End of file: CargoWetnessFix.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/craft-ui ---
// --- Original File Path: C/CraftUI/CraftUI.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("CraftUI", "EinTime/Orange/Black_demon6", "1.2.92", ResourceId = 2273)]
    [Description("A fully customizable custom crafting UI, which allows admins to change item ingredients.")]
    public class CraftUI : RustPlugin
    {
        const string ItemInfoListName = "Item List";
        const float refreshTime = 0.25f;

        [PluginReference] private Plugin ImageLibrary;

        public static CraftUI S;

        HashSet<int> customItemCrafts = new HashSet<int>();
        static readonly Dictionary<string, string> displaynameToShortname = new Dictionary<string, string>();
        const string transparentSprite = "assets/content/textures/generic/fulltransparent.tga";

        #region Player Responses
        const string Invalid = "Invalid";
        const string FormatHelp = "FormatHelp";
        const string InvalidFormat = "InvalidFormat";

        const string AlreadyBlocked = "AlreadyBlocked";

        const string UnknownError = "UnknownError";

        const string ItemRateChange = "ItemRateChange";
        const string ItemBlocked = "ItemBlocked";
        const string ItemNotBlocked = "ItemNotBlocked";
        const string AllItemsBlocked = "AllItemsBlocked";
        const string AllItemsUnblocked = "AllItemsUnblocked";

        const string IngredientsCleared = "IngredientsCleared";
        const string IngredientsReset = "IngredientsReset";
        const string AddedIngredient = "AddedIngredient";
        const string RemovedIngredient = "RemovedIngredient";
        const string RemovedAllIngredient = "RemovedAllIngredient";
        const string DoesNotContainIngredient = "DoesNotContainIngredient";
        const string HasNoIngredients = "HasNoIngredients";
        const string IngredientsList = "IngredientsList";

        const string ItemRenamed = "ItemRenamed";
        const string DescriptionChanged = "DescriptionChanged";
        const string IconUrlChanged = "IconURLChanged";
        const string CategoryChanged = "CategoryChanged";

        const string NotAdmin = "NotAdmin";

        const string FacepunchGUIDisabled = "FacepunchGUIDisabled";

        const string ItemListLoaded = "ItemListLoaded";
        const string ItemListSaved = "ItemListSaved";

        const string AddRemoveFormat = "AddRemoveFormat";
        const string IngredientsFormat = "IngredientsFormat";
        const string CraftrateFormat = "CraftrateFormat";
        const string RenameFormat = "RenameFormat";
        const string ChangeDescriptionFormat = "ChangeDescriptionFormat";
        const string IconFormat = "IconFormat";
        const string CategoryFormat = "CategoryFormat";


        static readonly Dictionary<string, string> responseDic = new Dictionary<string, string>()
        {
            [Invalid] = "{0} is an invalid {1}.",
            [FormatHelp] = "Format is: /{0} {1}.",
            [InvalidFormat] = "Invalid format for /{0}. Correct format is: /{0} {1}",

            [AlreadyBlocked] = "'{0}' blocked value is already {1}",

            [UnknownError] = "An unknown error has occured.",

            [ItemRateChange] = "Item '{0}' crafting rate is now '{1}'.",
            [ItemBlocked] = "Item '{0}' is now blocked from crafting.",
            [ItemNotBlocked] = "Item '{0}' is no longer blocked from crafting.",
            [AllItemsBlocked] = "All items are blocked from crafting.",
            [AllItemsUnblocked] = "All items are no longer blocked from crafting",

            [IngredientsCleared] = "Item '{0}' is now free to craft.",
            [IngredientsReset] = "Item '{0}' ingredients have been reset to default values.",
            [AddedIngredient] = "Added {0} {1} to {2} crafting cost.",
            [RemovedIngredient] = "Removed {0} {1} from {2} crafting cost.",
            [RemovedAllIngredient] = "Removed all {0} from {1} crafting cost.",
            [DoesNotContainIngredient] = "Item {0} does not contain the ingredient {1}; cannot remove.",
            [HasNoIngredients] = "Item {0} has no crafting ingredients",
            [IngredientsList] = "Item {0} crafting ingredients are:",

            [ItemRenamed] = "'{0}' name is now '{1}'",
            [DescriptionChanged] = "'{0}' description is now '{1}'",
            [IconUrlChanged] = "'{0}' icon URL is now {1}",
            [CategoryChanged] = "'{0}' category is now '{1}'",

            [NotAdmin] = "Only admins may use this command.",

            [FacepunchGUIDisabled] = "Crafting from the FacePunch Crafting GUI is disabled. Please press {0} to open the correct crafting gui.",

            [ItemListLoaded] = "Item List was loaded successfully",
            [ItemListSaved] = "Item List was saved successfully",

            [AddRemoveFormat] = "\"amount\" \"Ingredient Name\" \"Item Name\"",
            [IngredientsFormat] = "\"Item Name\"",
            [CraftrateFormat] = "\"Item Name\" rate",
            [RenameFormat] = "\"Item Name\" \"New Name\"",
            [ChangeDescriptionFormat] = "\"Item Name\" \"New Description\"",
            [IconFormat] = "\"Item Name\" \"http://url.com\"",
            [CategoryFormat] = "\"Item Name\" \"Category Name\"",

            ["HelpLine1"] = "Welcome to <size=25><b>CraftUI</b></size>! Commands are:",
            ["HelpLine2"] = "<size=16><b>/craftui.add</b></size> - adds ingredients to an item.",
            ["HelpLine3"] = "<size=16><b>/craftui.remove</b></size> - removes ingredients from an item",
            ["HelpLine4"] = "<size=16><b>/craftui.ingredients</b></size> - prints a list of all current ingredients for an item.",
            ["HelpLine5"] = "<size=16><b>/craftui.clearingredients</b></size> - clears ALL ingredients from an item (free to craft)",
            ["HelpLine6"] = "<size=16><b>/craftui.resetingredients</b></size> - resets an item's ingredients to their default values.",
            ["HelpLine7"] = "<size=16><b>/craftui.craftrate</b></size> - sets the craft rate of an item. 0 is instant craft, 2 is double craft time.",
            ["HelpLine8"] = "<size=16><b>/craftui.block</b></size> - blocks an item from being crafted. It will not be displayed in the UI",
            ["HelpLine9"] = "<size=16><b>/craftui.unblock</b></size> - allows an item to be crafted.",
            ["HelpLine10"] = "<size=16><b>/craftui.blockall</b></size> - blocks all items from crafting.",
            ["HelpLine11"] = "<size=16><b>/craftui.unblockall</b></size> - unblocks all items from crafting.",
            ["HelpLine10"] = "<size=16><b>/craftui.rename</b></size> - renames an item (in the CraftUI only - does not affect inventory)",
            ["HelpLine11"] = "<size=16><b>/craftui.seticon</b></size> - sets the icon of an item to a given URL address (in CraftUI only)",
            ["HelpLine12"] = "<size=16><b>/craftui.save</b></size> - saves any changes made to items.",
            ["HelpLine13"] = "<size=16><b>/craftui.load</b></size> - loads saved item's. NOTE: this will erase any unsaved changes.",
            ["HelpLine14"] = "Type any command followed by help (ex: /craftui.add help) to see detailed information about their use.",
        };
        #endregion

        #region Config Values
        bool AllowOldCrafting = true;
        string OpenCraftUIBinding = "q";
        List<string> CategoryNames = new List<string>()
        {
            ItemCategory.Construction.ToString(),
            ItemCategory.Items.ToString(),
            ItemCategory.Resources.ToString(),
            ItemCategory.Attire.ToString(),
            ItemCategory.Tool.ToString(),
            ItemCategory.Medical.ToString(),
            ItemCategory.Weapon.ToString(),
            ItemCategory.Ammunition.ToString(),
            ItemCategory.Traps.ToString(),
            ItemCategory.Misc.ToString()
        };
        bool IncludeUncraftableItems = false;
        int ItemIconSize = 150;
        #endregion

        #region Oxide Hooks
        void OnServerInitialized()
        {
            LoadDefaultMessages();

            CloseCraftUI_AllPlayers();
            CloseOverlay_AllPlayers();
            S = this;

            itemInfoDic = new Dictionary<int, ItemInfo>();
            customItemCrafts = new HashSet<int>();
            playerDic = new Dictionary<ulong, PlayerInfo>();

            CreateMissingBlueprints();

            displaynameToShortname.Clear();
            originalCraftTimes.Clear();
            originalIngredients.Clear();
            foreach (var itemdef in ItemManager.itemList)
            {
                if (itemdef)
                {
                    if(!displaynameToShortname.ContainsKey(itemdef.displayName.english.ToLower()))
                        displaynameToShortname.Add(itemdef.displayName.english.ToLower(), itemdef.shortname);
                    if (itemdef.Blueprint)
                    {
                        originalCraftTimes.Add(itemdef.itemid, itemdef.Blueprint.time);
                        List<ItemIngredient> ingredients = new List<ItemIngredient>();
                        foreach (var ingredient in itemdef.Blueprint.ingredients)
                        {
                            ingredients.Add(new ItemIngredient(ingredient.itemid, ingredient.amount));
                        }
                        originalIngredients.Add(itemdef.itemid, ingredients);
                    }
                }
            }


            LoadItemInfoDic();

            timer.Repeat(1f, 0, () =>
            {
                RefreshCraftQueue();
            });

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                AddPlayer(player);
            }
        }
        void Loaded()
        {
        }
        void Unload()
        {
            CloseCraftUI_AllPlayers();
            CloseOverlay_AllPlayers();
            SaveItemInfoDic();
        }

        void OnPlayerConnected(BasePlayer player)
        {
            AddPlayer(player);

            PlayerInfo playerInfo = GetPlayer(player);
            if (playerInfo.uiOpen)
                CloseCraftUI(playerInfo);
        }

        object OnItemCraft(ItemCraftTask task, BasePlayer crafter)
        {
            PlayerInfo playerInfo = GetPlayer(crafter);

            if (AllowOldCrafting)
            {
                RenderHudPanelDelayed(refreshTime, CraftQueueName, playerInfo);
                RenderHudPanelDelayed(refreshTime, CraftQueueTimerName, playerInfo);
                return null;
            }
            if (!customItemCrafts.Contains(task.taskUID))
            {
                foreach (var ingredient in task.blueprint.ingredients)
                {
                    crafter.inventory.GiveItem(ItemManager.CreateByItemID(ingredient.itemid, (int)ingredient.amount * task.amount, 0));
                }
                PlayerChat(crafter, FacepunchGUIDisabled, "'" + OpenCraftUIBinding + "'");
                return false;
            }
            RenderHudPanelDelayed(refreshTime, CraftQueueName, playerInfo);
            RenderHudPanelDelayed(refreshTime, CraftQueueTimerName, playerInfo);
            return null;
        }
        void OnItemCraftFinished(ItemCraftTask task, Item item)
        {
            PlayerInfo playerInfo = GetPlayer(task.owner);

            RenderHudPanelDelayed(refreshTime, CraftQueueName, playerInfo);
            RenderHudPanelDelayed(refreshTime, CraftQueueTimerName, playerInfo);
        }
        void OnItemCraftCancelled(ItemCraftTask task)
        {

            if (task.owner == null) return;
            PlayerInfo playerInfo = GetPlayer(task.owner);
            if (playerInfo == null) return;
            if (!playerInfo.uiOpen) return;

            RenderHudPanelDelayed(refreshTime, CraftQueueName, playerInfo);
            RenderHudPanelDelayed(refreshTime, CraftQueueTimerName, playerInfo);
            RenderHudPanelDelayed(refreshTime, ResourceCostName, playerInfo);
        }

        void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            PlayerInfo playerInfo = GetPlayer(player);
            StorageContainer storage = entity as StorageContainer;
            if (storage == null) return;
            float columns = Mathf.Max(1, Mathf.CeilToInt((float)storage.inventorySlots / 6f));
            if (storage is BaseOven)
                columns += 1.5f;
            else if (storage is RepairBench)
                columns += 1;
            else if (storage is LiquidContainer)
                columns += 3.5f;
            else if (storage is SupplyDrop)
                columns += 2f;
            else if (storage is LootContainer)
                columns += 2f;

            //RenderOverlay(playerInfo, true, columns);
        }

        void RefreshCraftQueue()
        {
            foreach (var kvp in playerDic)
            {
                if (kvp.Value.uiOpen)
                {
                    RenderHudPanel(CraftQueueTimerName, kvp.Value);
                }
            }
        }

        protected override void LoadDefaultConfig() => PrintWarning("New configuration file created.");
        protected override void LoadConfig()
        {
            base.LoadConfig();

            AllowOldCrafting = GetConfigValue("_Settings", "Allow Old Crafting", AllowOldCrafting);
            var tempBinding = GetConfigValue("_Settings", "Open CraftUI Binding", OpenCraftUIBinding);
            if (defaultBinds.ContainsKey(tempBinding))
                OpenCraftUIBinding = tempBinding;
            CategoryNames = GetConfigValue("_Settings", "Category Names", CategoryNames);
            IncludeUncraftableItems = GetConfigValue("_Settings", "Include Uncraftable Items", IncludeUncraftableItems);
            ItemIconSize = GetConfigValue("_Settings", "Item Icon Size", ItemIconSize);
        }

        T GetConfigValue<T>(string category, string name, T defaultValue)
        {
            var catDic = GetConfigCategory(category);
            if (!catDic.ContainsKey(name))
            {
                catDic.Add(name, defaultValue);
                SaveConfig();
            }

            return (T)Convert.ChangeType(catDic[name], typeof(T));
        }
        List<T> GetConfigValue<T>(string category, string name, List<T> defaultValue)
        {
            var catDic = GetConfigCategory(category);
            object value = null;
            if (!catDic.TryGetValue(name, out value))
            {
                catDic[name] = defaultValue;
                Config[category] = catDic;
                SaveConfig();
                return defaultValue;
            }
            List<object> objectList = value as List<object>;
            List<T> ret = new List<T>();
            foreach (object o in objectList)
            {
                ret.Add((T)o);
            }
            return ret;
        }
        Dictionary<string, object> GetConfigCategory(string category)
        {
            var catDic = Config[category] as Dictionary<string, object>;
            if (catDic == null)
            {
                catDic = new Dictionary<string, object>();
                Config[category] = catDic;
                SaveConfig();
            }
            return catDic;
        }

        void LoadDefaultMessages()
        {
            lang.RegisterMessages(responseDic, this);
        }
        #endregion

        #region Players
        class PlayerInfo
        {
            public readonly BasePlayer basePlayer;
            public bool uiOpen;
            public bool overlayOpen;
            public bool overlayLooting;
            public float overlayLootingColumns;
            public string selectedCategory;
            public ItemInfo selectedItem;
            public int currentCraftAmount;

            public PlayerInfo(BasePlayer player)
            {
                basePlayer = player;
                uiOpen = false;
                selectedCategory = string.Empty;
                selectedItem = null;
                currentCraftAmount = 1;
            }

            public class CraftInfo
            {
                public List<string> amounts, itemTypes, totals, haves;
                public bool canCraft;

                public CraftInfo()
                {
                    amounts = new List<string>();
                    itemTypes = new List<string>();
                    totals = new List<string>();
                    haves = new List<string>();
                    canCraft = true;
                }
            }
            public CraftInfo GetCraftInfo()
            {
                CraftInfo info = new CraftInfo();

                if (selectedItem == null || selectedItem.itemID == 0)
                {
                    info.canCraft = false;
                    return info;
                }

                foreach (ItemIngredient ingredient in selectedItem.ingredients)
                {
                    float amountValue = ingredient.amount;
                    float haveValue = basePlayer.inventory.GetAmount(ingredient.ingredientID);
                    float totalValue = ingredient.amount * currentCraftAmount;
                    if (haveValue < totalValue)
                        info.canCraft = false;


                    info.amounts.Add(amountValue.ToString());
                    info.itemTypes.Add(ingredient.realName);
                    info.totals.Add(totalValue.ToString());
                    info.haves.Add(haveValue.ToString());
                }

                return info;
            }
        }

        static Dictionary<ulong, PlayerInfo> playerDic = new Dictionary<ulong, PlayerInfo>();

        /// <summary>
        /// Returns true if the player was successfully added.
        /// </summary>
        bool AddPlayer(BasePlayer player)
        {
            if (!playerDic.ContainsKey(player.userID))
            {
                PlayerInfo playerInfo = new PlayerInfo(player);
                playerDic.Add(player.userID, playerInfo);
                return true;
            }
            return false;
        }
        PlayerInfo GetPlayer(BasePlayer player)
        {
            PlayerInfo playerInfo = null;
            if (!playerDic.TryGetValue(player.userID, out playerInfo))
            {
                playerInfo = new PlayerInfo(player);
                playerDic.Add(player.userID, playerInfo);
            }
            return playerInfo;
        }
        #endregion

        #region Item Customization
        class ItemInfo
        {
            public int itemID;
            public string realName;
            public string customName;
            public string customDescription;
            public bool blocked;
            public float craftRate;
            public List<ItemIngredient> ingredients;
            public string iconURL;
            public string category;

            public ItemInfo()
            {
                ingredients = new List<ItemIngredient>();
            }
            public ItemInfo(ItemDefinition itemDef)
            {
                itemID = itemDef.itemid;
                realName = itemDef.displayName.english;
                customName = itemDef.displayName.english;
                customDescription = itemDef.displayDescription.english;
                blocked = false;
                craftRate = 1;
                ingredients = new List<ItemIngredient>();
                if (itemDef.Blueprint != null && itemDef.Blueprint.ingredients != null)
                {
                    foreach (var ingredient in itemDef.Blueprint.ingredients)
                    {
                        ingredients.Add(new ItemIngredient(ingredient.itemid, ingredient.amount));
                    }
                }

                iconURL = S.GetItemIconURL(itemDef.shortname);
                category = itemDef.category.ToString();
            }

            public ItemDefinition GetItemDef()
            {
                return ItemManager.FindItemDefinition(itemID);
            }
            public bool GetCraftable(PlayerInfo playerInfo)
            {
                if (playerInfo == null)
                    return false;

                foreach (var ingredient in ingredients)
                {
                    if (playerInfo.basePlayer.inventory.GetAmount(ingredient.ingredientID) < ingredient.amount)
                        return false;
                }

                return true;
            }
            public int GetCraftCount(PlayerInfo playerInfo)
            {
                if (playerInfo == null)
                    return -1;

                int num = -1;
                foreach (var ingredient in ingredients)
                {
                    num = Mathf.FloorToInt((float)playerInfo.basePlayer.inventory.GetAmount(ingredient.ingredientID) / ingredient.amount);
                    if (num <= 0)
                        return -1;
                }
                return num;
            }
            public string GetFormattedURL()
            {
                return string.Format(iconURL, S.ItemIconSize.ToString());
            }

            public static ItemInfo FromObject(object obj)
            {
                Dictionary<string, object> dic = obj as Dictionary<string, object>;
                if (dic == null)
                    return null;

                ItemInfo itemInfo = new ItemInfo();
                itemInfo.itemID = (int)dic[nameof(itemID)];
                itemInfo.realName = (string)dic[nameof(realName)];
                itemInfo.customName = (string)dic[nameof(customName)];
                itemInfo.customDescription = (string)dic[nameof(customDescription)];
                itemInfo.blocked = (bool)dic[nameof(blocked)];
                itemInfo.craftRate = (float)(double)dic[nameof(craftRate)];
                itemInfo.iconURL = (string)dic[nameof(iconURL)];
                itemInfo.category = (string)dic[nameof(category)];

                itemInfo.ingredients = new List<ItemIngredient>();
                List<object> ingredientList = dic[nameof(ingredients)] as List<object>;
                foreach (var iObj in ingredientList)
                {
                    ItemIngredient ingredient = ItemIngredient.FromObject(iObj);
                    if (ingredient != null)
                        itemInfo.ingredients.Add(ingredient);
                }

                return itemInfo;
            }
        }
        class ItemIngredient
        {
            public int ingredientID;
            public string realName;
            public float amount;

            public ItemIngredient()
            {
                ingredientID = 0;
                realName = "";
                amount = 0;
            }
            public ItemIngredient(int ingredientID, float amount)
            {
                this.ingredientID = ingredientID;
                realName = GetItemDef().displayName.english;
                this.amount = amount;
            }

            public ItemDefinition GetItemDef()
            {
                return ItemManager.FindItemDefinition(ingredientID);
            }
            public ItemAmount GetItemAmount()
            {
                return new ItemAmount(GetItemDef(), amount);
            }

            public static ItemIngredient FromObject(object obj)
            {
                Dictionary<string, object> dic = obj as Dictionary<string, object>;
                if (dic == null)
                    return null;

                ItemIngredient ingredient = new ItemIngredient();
                ingredient.ingredientID = (int)dic[nameof(ingredientID)];
                ingredient.realName = (string)dic[nameof(realName)];
                ingredient.amount = (float)(double)dic[nameof(amount)];

                return ingredient;
            }
        }

        static Dictionary<int, ItemInfo> itemInfoDic = new Dictionary<int, ItemInfo>();
        static Dictionary<int, float> originalCraftTimes = new Dictionary<int, float>();
        static Dictionary<int, List<ItemIngredient>> originalIngredients = new Dictionary<int, List<ItemIngredient>>();
        static HashSet<int> nullBlueprintSet = new HashSet<int>();

        bool CanAddItemInfo(ItemDefinition itemDef)
        {
            if (itemDef == null || itemDef.displayName == null)
                return false;
            if (itemInfoDic.ContainsKey(itemDef.itemid))
                return false;

            return true;
        }
        void AddItemInfo(ItemDefinition itemDef, bool forceAdd = false)
        {
            if (forceAdd || CanAddItemInfo(itemDef))
                itemInfoDic.Add(itemDef.itemid, new ItemInfo(itemDef));
        }
        void SaveItemInfoDic()
        {
            Config[ItemInfoListName] = itemInfoDic.Values;
            SaveConfig();
        }
        void LoadItemInfoDic()
        {
            var objList = Config[ItemInfoListName] as List<object>;
            if (objList == null)
            {
                objList = new List<object>();
                Config[ItemInfoListName] = objList;
                SaveConfig();
            }
            itemInfoDic = new Dictionary<int, ItemInfo>();
            foreach (var obj in objList)
            {
                ItemInfo itemInfo = ItemInfo.FromObject(obj);
                if (itemInfo == null) continue;

                itemInfoDic.Add(itemInfo.itemID, itemInfo);
            }

            VerifyItemInfoDic();
        }
        void VerifyItemInfoDic()
        {
            if (ItemManager.itemList == null)
            {
                //PrintError("ItemManager item list is null at a crucial stage of initilization. Cannot populate ItemInfoDic");
                return;
            }
            if (itemInfoDic == null)
                //PrintError("Item Info Dic is Null");
            {}
            bool changeMade = false;

            List<ItemInfo> values = new List<ItemInfo>(itemInfoDic.Values);
            List<int> toRemove = new List<int>();
            foreach (ItemInfo value in values)
            {
                ItemDefinition itemDef = ItemManager.FindItemDefinition(value.itemID);
                if (itemDef == null)
                {
                    toRemove.Add(value.itemID);
                    continue;
                }

                if (value.realName != itemDef.displayName.english)
                {
                    value.realName = itemDef.displayName.english;
                    changeMade = true;
                }
                if (value.category == null)
                {
                    value.category = itemDef.category.ToString();
                    changeMade = true;
                }
                if (value.iconURL == "")
                {
                    value.iconURL = GetItemIconURL(itemDef.shortname);
                    changeMade = true;
                }

                if (value.ingredients == null)
                    value.ingredients = new List<ItemIngredient>();
                List<int> ingredientIndicesToRemove = new List<int>();
                for (int i = 0; i < value.ingredients.Count; i++)
                {
                    ItemDefinition ingredientDef = ItemManager.FindItemDefinition(value.ingredients[i].ingredientID);
                    if (ingredientDef == null)
                        ingredientIndicesToRemove.Add(i);
                    else if (value.ingredients[i].realName != ingredientDef.displayName.english)
                    {
                        value.ingredients[i].realName = ingredientDef.displayName.english;
                        changeMade = true;
                    }
                }

                foreach (int index in ingredientIndicesToRemove)
                {
                    value.ingredients.RemoveAt(index);
                    changeMade = true;
                }
            }

            foreach (int id in toRemove)
            {
                itemInfoDic.Remove(id);
                changeMade = true;
            }

            foreach (var item in ItemManager.bpList)
            {
                if (CanAddItemInfo(item.targetItem))
                {
                    AddItemInfo(item.targetItem, true);
                    changeMade = true;
                }
            }
            foreach (var item in ItemManager.itemList)
            {
                if (CanAddItemInfo(item))
                {
                    AddItemInfo(item, true);
                    changeMade = true;
                }
            }

            if (changeMade)
                SaveItemInfoDic();
        }
        void CreateMissingBlueprints()
        {
            foreach (ItemDefinition itemDef in ItemManager.itemList)
            {
                if (itemDef == null || itemDef.Blueprint != null)
                    continue;

                CreateMissingBlueprint(itemDef);
            }
        }
        ItemBlueprint CreateMissingBlueprint(ItemDefinition itemDef)
        {
            if (itemDef.Blueprint != null)
                return itemDef.Blueprint;

            ItemBlueprint bp = itemDef.gameObject.AddComponent<ItemBlueprint>();
            bp.ingredients = new List<ItemAmount>();
            bp.userCraftable = false;
            bp.isResearchable = false;
            bp.rarity = Rarity.None;
            bp.NeedsSteamItem = false;
            bp.amountToCreate = 1;
            bp.time = 30f;

            nullBlueprintSet.Add(itemDef.itemid);

            return bp;
        }

        ItemInfo FindItemInfo(ItemDefinition itemDef)
        {
            return FindItemInfo(itemDef.itemid);
        }
        ItemInfo FindItemInfo(int itemID)
        {
            ItemInfo info = null;
            itemInfoDic.TryGetValue(itemID, out info);
            return info;
        }
        #endregion

        #region Chat Commands
        [ChatCommand("craftui.add")]
        void AddIngredient_ChatCommands(BasePlayer player, string command, string[] args)
        {
            if (!AdminCheck(player)) return;
            if (!ArgsCheck(player, args, 3, command, AddRemoveFormat)) return;

            int ingredientAmount;
            if (!int.TryParse(args[0], out ingredientAmount))
            {
                PlayerChat(player, Invalid, args[0], "ingredient amount");
                return;
            }

            ItemDefinition ingredientDef = DisplayNameToItemDef(player, args[1]);
            if (ingredientDef == null) return;
            ItemDefinition itemDef = DisplayNameToItemDef(player, args[2]);
            if (itemDef == null) return;
            ItemInfo itemInfo = FindItemInfo(itemDef);
            if (itemInfo == null) return;

            if (itemInfo.ingredients.Any(x => x.ingredientID == ingredientDef.itemid))
            {
                itemInfo.ingredients.First(x => x.ingredientID == ingredientDef.itemid).amount += ingredientAmount;
            }
            else
                itemInfo.ingredients.Add(new ItemIngredient(ingredientDef.itemid, ingredientAmount));

            PlayerChat(player, AddedIngredient, ingredientAmount, ingredientDef.displayName.english, itemDef.displayName.english);
            Puts("Player '" + player.displayName + "' added " + ingredientAmount + " " + ingredientDef.displayName.english + " to " + itemDef.displayName.english);
        }
        [ChatCommand("craftui.remove")]
        void RemoveIngredient_ChatCommands(BasePlayer player, string command, string[] args)
        {
            if (!AdminCheck(player)) return;
            if (!ArgsCheck(player, args, 3, command, AddRemoveFormat)) return;

            int ingredientAmount;
            if (!int.TryParse(args[0], out ingredientAmount))
            {
                PlayerChat(player, Invalid, args[0], "ingredient amount");
                return;
            }

            ItemDefinition ingredientDef = DisplayNameToItemDef(player, args[1]);
            if (ingredientDef == null) return;
            ItemDefinition itemDef = DisplayNameToItemDef(player, args[2]);
            if (itemDef == null) return;
            ItemInfo itemInfo = FindItemInfo(itemDef);
            if (itemInfo == null) return;

            if (!itemInfo.ingredients.Any(x => x.ingredientID == ingredientDef.itemid))
            {
                PlayerChat(player, DoesNotContainIngredient, itemDef.displayName.english, ingredientDef.displayName.english);
                return;
            }

            ItemIngredient ingredient = itemInfo.ingredients.First(x => x.ingredientID == ingredientDef.itemid);
            if (ingredientAmount < ingredient.amount)
            {
                ingredient.amount -= ingredientAmount;
                PlayerChat(player, RemovedIngredient, ingredientAmount, ingredientDef.displayName.english, itemDef.displayName.english);
                Puts("Player '" + player.displayName + "' removed " + ingredientAmount + " " + ingredientDef.displayName.english + " from " + itemDef.displayName.english);
            }
            else
            {
                itemInfo.ingredients.Remove(ingredient);
                PlayerChat(player, RemovedAllIngredient, ingredientDef.displayName.english, itemDef.displayName.english);
                Puts("Player '" + player.displayName + "' removed all " + ingredientDef.displayName.english + " from " + itemDef.displayName.english);
            }
        }
        [ChatCommand("craftui.ingredients")]
        void IngredientsList_ChatCommand(BasePlayer player, string command, string[] args)
        {
            if (!AdminCheck(player)) return;
            if (!ArgsCheck(player, args, 1, command, IngredientsFormat)) return;

            ItemDefinition itemDef = DisplayNameToItemDef(player, args[0]);
            if (itemDef == null) return;
            ItemInfo info = FindItemInfo(itemDef);
            if (info == null) return;

            if (info.ingredients.Count == 0)
            {
                PlayerChat(player, HasNoIngredients, itemDef.displayName.english);
            }
            else
            {
                PlayerChat(player, IngredientsList, itemDef.displayName.english);
                foreach (ItemIngredient ingredient in info.ingredients)
                {
                    SendReply(player, ingredient.amount + " " + ingredient.GetItemDef().displayName.english);
                }
            }
        }
        [ChatCommand("craftui.clearingredients")]
        void ClearIngredients_ChatCommands(BasePlayer player, string command, string[] args)
        {
            if (!AdminCheck(player)) return;
            if (!ArgsCheck(player, args, 1, command, IngredientsFormat)) return;

            ItemDefinition itemDef = DisplayNameToItemDef(player, args[0]);
            if (itemDef == null) return;
            ItemInfo itemInfo = FindItemInfo(itemDef);
            if (itemInfo == null) return;

            itemInfo.ingredients.Clear();

            PlayerChat(player, IngredientsCleared, itemDef.displayName.english);
            Puts("Player '" + player.displayName + "' cleared " + itemDef.displayName.english + " crafting ingredients");
        }
        [ChatCommand("craftui.resetingredients")]
        void ResetIngredients_ChatCommands(BasePlayer player, string command, string[] args)
        {
            if (!AdminCheck(player)) return;
            if (!ArgsCheck(player, args, 1, command, IngredientsFormat)) return;

            ItemDefinition itemDef = DisplayNameToItemDef(player, args[0]);
            if (itemDef == null) return;
            ItemBlueprint bp = itemDef.Blueprint;
            if (bp == null) return;
            ItemInfo itemInfo = FindItemInfo(itemDef);
            if (itemInfo == null) return;

            itemInfo.ingredients = new List<ItemIngredient>(originalIngredients[itemInfo.itemID]);

            PlayerChat(player, IngredientsReset, itemDef.displayName.english);
            Puts("Player '" + player.displayName + "' reset " + itemDef.displayName.english + " crafting ingredients");
        }
        [ChatCommand("craftui.craftrate")]
        void CraftRate_ChatCommands(BasePlayer player, string command, string[] args)
        {
            if (!AdminCheck(player)) return;
            if (!ArgsCheck(player, args, 2, command, CraftrateFormat)) return;

            ItemDefinition itemDef = DisplayNameToItemDef(player, args[0]);
            if (itemDef == null) return;
            ItemInfo itemInfo = FindItemInfo(itemDef);
            if (itemInfo == null) return;

            float rate = 0;
            if (!float.TryParse(args[1], out rate))
            {
                PlayerChat(player, Invalid, args[1], "crafting rate");
                return;
            }

            itemInfo.craftRate = rate;

            PlayerChat(player, ItemRateChange, itemDef.displayName.english, rate);
            Puts("Player '" + player.displayName + "' changed " + itemDef.displayName.english + " craft rate to " + rate);
        }
        [ChatCommand("craftui.block")]
        void Block_ChatCommands(BasePlayer player, string command, string[] args)
        {
            BlockItem(player, command, args, true);
        }
        [ChatCommand("craftui.unblock")]
        void UnBlock_ChatCommands(BasePlayer player, string command, string[] args)
        {
            BlockItem(player, command, args, false);
        }
        void BlockItem(BasePlayer player, string command, string[] args, bool block)
        {
            if (!AdminCheck(player)) return;
            if (!ArgsCheck(player, args, 1, command, IngredientsFormat)) return;

            ItemDefinition itemDef = DisplayNameToItemDef(player, args[0]);
            if (itemDef == null) return;
            ItemInfo info = FindItemInfo(itemDef);
            if (info == null) return;

            info.blocked = block;

            if (block)
            {
                PlayerChat(player, ItemBlocked, itemDef.displayName.english);
                Puts("Player '" + player.displayName + "' blocked item " + itemDef.displayName.english);
            }
            else
            {
                PlayerChat(player, ItemNotBlocked, itemDef.displayName.english);
                Puts("Player '" + player.displayName + "' unblocked item " + itemDef.displayName.english);
            }
        }
        [ChatCommand("craftui.blockall")]
        void BlockAll(BasePlayer player, string command, string[] args)
        {
            if (!AdminCheck(player)) return;

            foreach (var kvp in itemInfoDic)
            {
                kvp.Value.blocked = true;
            }

            PlayerChat(player, AllItemsBlocked);
            Puts("Player '" + player.displayName + "' blocked all items.");
        }
        [ChatCommand("craftui.unblockall")]
        void UnblockAll(BasePlayer player, string command, string[] args)
        {
            if (!AdminCheck(player)) return;

            foreach (var kvp in itemInfoDic)
            {
                kvp.Value.blocked = false;
            }

            PlayerChat(player, AllItemsUnblocked);
            Puts("Player '" + player.displayName + "' unblocked all items.");
        }
        [ChatCommand("craftui.rename")]
        void Rename_ChatCommand(BasePlayer player, string command, string[] args)
        {
            if (!AdminCheck(player)) return;
            if (!ArgsCheck(player, args, 2, command, RenameFormat)) return;

            ItemDefinition itemDef = DisplayNameToItemDef(player, args[0]);
            if (itemDef == null) return;
            ItemInfo itemInfo = FindItemInfo(itemDef);
            if (itemInfo == null) return;

            itemInfo.customName = args[1];

            PlayerChat(player, ItemRenamed, itemInfo.realName, itemInfo.customName);
            Puts("Player '" + player.displayName + "' changed item " + itemInfo.realName + " name to " + itemInfo.customName);
        }
        [ChatCommand("craftui.description")]
        void ChangeDrescription_ChatCommand(BasePlayer player, string command, string[] args)
        {
            if (!AdminCheck(player)) return;
            if (!ArgsCheck(player, args, 2, command, ChangeDescriptionFormat)) return;

            ItemDefinition itemDef = DisplayNameToItemDef(player, args[0]);
            if (itemDef == null) return;
            ItemInfo itemInfo = FindItemInfo(itemDef);
            if (itemInfo == null) return;

            itemInfo.customDescription = args[1];

            PlayerChat(player, DescriptionChanged, itemInfo.realName, itemInfo.customDescription);
            Puts("Player '" + player.displayName + "' changed item " + itemInfo.realName + " description to " + itemInfo.customName);
        }
        [ChatCommand("craftui.category")]
        void Category_ChatCommand(BasePlayer player, string command, string[] args)
        {
            if (!AdminCheck(player)) return;
            if (!ArgsCheck(player, args, 2, command, CategoryFormat)) return;

            ItemDefinition itemDef = DisplayNameToItemDef(player, args[0]);
            if (itemDef == null) return;
            ItemInfo itemInfo = FindItemInfo(itemDef);
            if (itemInfo == null) return;
            string category = "";
            foreach (var cat in CategoryNames)
            {
                if (cat.ToLower() == args[1].ToLower())
                {
                    category = cat;
                    break;
                }
            }
            if (category == "")
            {
                PlayerChat(player, Invalid, "Category Name");
                return;
            }

            itemInfo.category = category;
            PlayerChat(player, CategoryChanged, itemDef.displayName.english, itemInfo.category);
        }
        [ChatCommand("craftui.seticon")]
        void SetIcon_ChatCommand(BasePlayer player, string command, string[] args)
        {
            if (!AdminCheck(player)) return;
            if (!ArgsCheck(player, args, 2, command, IconFormat)) return;

            ItemDefinition itemDef = DisplayNameToItemDef(player, args[0]);
            if (itemDef == null) return;
            ItemInfo itemInfo = FindItemInfo(itemDef);
            if (itemInfo == null) return;

            itemInfo.iconURL = args[1];
            PlayerChat(player, itemInfo.realName, itemInfo.iconURL);
            Puts("Player '" + player.displayName + "' set " + itemInfo.realName + " icon URL to " + itemInfo.iconURL);
        }
        [ChatCommand("craftui.load")]
        void Load_ChatCommand(BasePlayer player, string command, string[] args)
        {
            if (!AdminCheck(player)) return;

            LoadItemInfoDic();
            PlayerChat(player, ItemListLoaded);
        }
        [ChatCommand("craftui.save")]
        void Save_ChatCommand(BasePlayer player, string command, string[] args)
        {
            if (!AdminCheck(player)) return;

            SaveItemInfoDic();
            PlayerChat(player, ItemListSaved);
        }
        [ChatCommand("craftui")]
        void CraftUI_ChatCommand(BasePlayer player, string command, string[] args)
        {
            if (!AdminCheck(player)) return;
            ShowHelpMessage(player);
        }
        void ShowHelpMessage(BasePlayer player)
        {
            if (!AdminCheck(player)) return;

            for (int i = 0; i < 14; i++)
            {
                PlayerChat(player, "HelpLine" + (i + 1).ToString());
            }
        }
        bool AdminCheck(BasePlayer player)
        {
            if (!player.IsAdmin)
            {
                PlayerChat(player, NotAdmin);
                return false;
            }
            return true;
        }
        bool ArgsCheck(BasePlayer player, string[] args, int minLength, string command, string formatKey)
        {
            if (args == null || args.Length == 0 || args[0].ToLower() == "help")
            {
                PlayerChat(player, FormatHelp, command, Lang(formatKey, player.UserIDString));
                return false;
            }
            if (args.Length < minLength)
            {
                PlayerChat(player, InvalidFormat, command, Lang(formatKey, player.UserIDString));
                return false;
            }
            return true;
        }
        #endregion

        #region UIRendering
        class PanelRect
        {
            public float left, bottom, right, top;
            public PanelRect()
            {
                left = 0f;
                bottom = 0f;
                right = 1f;
                top = 1f;
            }
            public PanelRect(float left, float bottom, float right, float top)
            {
                this.left = left;
                this.bottom = bottom;
                this.right = right;
                this.top = top;
            }

            public string AnchorMin
            {
                get { return left + " " + bottom; }
            }
            public string AnchorMax
            {
                get { return right + " " + top; }
            }

            public PanelRect RelativeTo(PanelRect other)
            {
                left = other.left + (other.right - other.left) * left;
                right = other.left + (other.right - other.left) * right;
                top = other.bottom + (other.top - other.bottom) * top;
                bottom = other.bottom + (other.top - other.bottom) * bottom;
                return this;
            }

            public PanelRect Copy()
            {
                return new PanelRect(left, bottom, right, top);
            }
        }
        class PanelInfo
        {
            public PanelRect rect;
            public string backgroundColor;

            public PanelInfo(PanelRect rect, string color)
            {
                this.rect = rect;
                this.backgroundColor = color;
            }
        }

        const string CraftUIName = "CraftUI";
        const string CategoriesName = "Categories";
        const string ItemListName = "ItemList";
        const string ItemInfoName = "ItemInfo";
        const string ResourceCostName = "ResourceCost";
        const string CraftAmountName = "CraftAmount";
        const string CraftCountName = "CraftCount";
        const string CraftButtonName = "CraftButton";
        const string CraftQueueName = "CraftQueue";
        const string CraftQueueTimerName = "CraftQueueTimer";

        const string CraftingButtonOverlayName = "CraftingButtonOverlay";
        const string QuickCraftOverlayName = "QuickCraftOverlay";
        const string QuickCraftOverlayLootingName = "QuicKCraftOverlayLooting";

        static readonly Dictionary<string, PanelInfo> panelAnchors = new Dictionary<string, PanelInfo>()
        {
            { CraftUIName, new PanelInfo(new PanelRect(0, 0, 1, 1), "0.1 0.1 0.1 0.9") },
            { CategoriesName, new PanelInfo(new PanelRect(0.06f, 0.25f, 0.16f, 0.9f), "0.4 0.4 0.4 0.4") },
            { ItemListName, new PanelInfo(new PanelRect(0.1625f, 0.25f, 0.55f, 0.9f), "0.4 0.4 0.4 0.4") },
            { ItemInfoName, new PanelInfo(new PanelRect(0.5525f, 0.25f, 0.94f, 0.9f), "0.4 0.4 0.4 0.4") },
            { ResourceCostName, new PanelInfo(new PanelRect(0.5525f, 0.25f, 0.94f, 0.5f), "0.4 0.4 0.4 0.4") },
            { CraftCountName, new PanelInfo(new PanelRect(0.5525f, 0.2f, 0.8526f, 0.246f), "0.4 0.4 0.4 0.4") },
            { CraftAmountName, new PanelInfo(new PanelRect(0.5525f, 0.15f, 0.8526f, 0.196f), "0.4 0.4 0.4 0.4") },
            { CraftButtonName, new PanelInfo(new PanelRect(0.855f, 0.15f, 0.94f, 0.246f), "0.4 0.4 0.4 0.4") },
            { CraftQueueName, new PanelInfo(new PanelRect(0.06f, 0.15f, 0.55f, 0.246f), "0.4 0.4 0.4 0.4") },
            { CraftQueueTimerName, new PanelInfo(new PanelRect(0, 0, 0, 0), "0 0 0 0") }
        };
        static readonly Dictionary<string, PanelInfo> overlayAnchors = new Dictionary<string, PanelInfo>()
        {
            { CraftingButtonOverlayName, new PanelInfo( new PanelRect(0.2f, 0.9f, 0.8f, 1f), "0 0 0 0") },
            { QuickCraftOverlayName, new PanelInfo( new PanelRect(0.65f, 0.125f, 0.95f, 0.45f), "0.3 0.3 0.3 1") },
            { QuickCraftOverlayLootingName, new PanelInfo( new PanelRect(0.65f, 0.475f, 0.95f, 0.8f), "0.3 0.3 0.3 1") }
        };

        //This dictionary is used for the positiopn of the quick craft overlay. It's position needs to be shifted based on the number of columns on a lootable item.
        static readonly Dictionary<float, PanelRect> lootableOverlayAnchors = new Dictionary<float, PanelRect>()
        {
            { 1, new PanelRect(0.65f, 0.325f, 0.95f, 0.65f) },
            { 2, new PanelRect(0.65f, 0.4f, 0.95f, 0.725f) },
            { 2.5f, new PanelRect(0.65f, 0.45f, 0.95f, 0.775f) },
            { 3, new PanelRect(0.65f, 0.5f, 0.95f, 0.825f) },
            { 4, new PanelRect(0.65f, 0.475f, 0.95f, 0.8f) },
            { 4.5f, new PanelRect(0.65f, 0.55f, 0.95f, 0.875f) },
            { 5, new PanelRect(0.65f, 0.65f, 0.95f, 0.975f) },
        };

        void ToggleCraftUI(PlayerInfo playerInfo)
        {
            if (playerInfo == null)
                return;

            if (playerInfo.uiOpen)
                CloseCraftUI(playerInfo);
            else
                RenderCraftUI(playerInfo);
        }
        void RenderCraftUI(PlayerInfo playerInfo)
        {
            if (playerInfo == null)
                return;

            playerInfo.uiOpen = true;

            foreach (var panel in panelAnchors)
            {
                RenderHudPanel(panel.Key, playerInfo);
            }
        }
        void CloseCraftUI(PlayerInfo playerInfo)
        {
            if (playerInfo == null)
                return;

            foreach (var kvp in panelAnchors)
            {
                CuiHelper.DestroyUi(playerInfo.basePlayer, kvp.Key);
            }
            playerInfo.uiOpen = false;
        }
        void CloseCraftUI_AllPlayers()
        {
            if (BasePlayer.activePlayerList == null || BasePlayer.activePlayerList.Count == 0)
                return;

            foreach (var p in BasePlayer.activePlayerList)
            {
                PlayerInfo playerInfo = GetPlayer(p);
                if (playerInfo != null)
                    CloseCraftUI(playerInfo);
            }
        }

        void RenderHudPanel(string panelName, PlayerInfo playerInfo)
        {
            if (playerInfo == null || playerInfo.basePlayer == null)
            {
                //PrintError("Render Panel called with a null PlayerInfo");
                return;
            }

            if (!panelAnchors.ContainsKey(panelName))
            {
                //PrintError("Cannot render panel '" + panelName + "' for player '" + playerInfo.basePlayer.displayName + "'. It does not exist");
                PlayerChat(playerInfo.basePlayer, UnknownError);
                return;
            }

            if (!playerInfo.uiOpen)
                return;

            PanelRect panelRect = panelAnchors[panelName].rect;
            CuiHelper.DestroyUi(playerInfo.basePlayer, panelName);
            CuiElementContainer elements = new CuiElementContainer();

            elements.Add(new CuiPanel
            {
                Image = { Color = panelAnchors[panelName].backgroundColor },
                RectTransform = { AnchorMin = panelRect.AnchorMin, AnchorMax = panelRect.AnchorMax },
                CursorEnabled = true
            }, "Hud", panelName);

            switch (panelName)
            {
                case CategoriesName:
                    RenderCategories(elements, playerInfo);
                    break;

                case ItemListName:
                    RenderItemList(elements, playerInfo);
                    break;

                case ItemInfoName:
                    RenderItemInfo(elements, playerInfo);
                    break;

                case ResourceCostName:
                    RenderResourceCosts(elements, playerInfo);
                    break;

                case CraftButtonName:
                    RenderCraftButton(elements, playerInfo);
                    break;

                case CraftAmountName:
                    RenderCraftAmount(elements, playerInfo);
                    break;

                case CraftCountName:
                    RenderCraftCount(elements, playerInfo);
                    break;

                case CraftQueueName:
                    RenderCraftQueue(elements, playerInfo);
                    break;

                case CraftQueueTimerName:
                    RenderCraftQueueTimer(elements, playerInfo);
                    break;
            }

            string backgroundColor = "0.5 0.0 0.0 0.8";
	    string name = "CLOSE";
            PanelRect rect = new PanelRect(0.76f, 0.90f, 0.998f, 0.998f);
            elements.Add(new CuiButton
            {
                Button = { Command = $"craftui.toggle", Color = backgroundColor },
                RectTransform =
                {
                    AnchorMin = rect.AnchorMin,
                    AnchorMax = rect.AnchorMax
                },
                Text = { Text = name, FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "0.8 0.8 0.8 1" }
            }, ItemInfoName);

            CuiHelper.AddUi(playerInfo.basePlayer, elements);
        }
        void RenderHudPanelDelayed(float delay, string panelName, PlayerInfo playerInfo)
        {
            NextTick(() => RenderHudPanel(panelName, playerInfo));
            timer.Once(delay, () => RenderHudPanel(panelName, playerInfo));
        }
        void RenderCategories(CuiElementContainer elements, PlayerInfo playerInfo)
        {

            List<string> itemCategories = new List<string>(CategoryNames);
            itemCategories.Reverse();

            for (int i = 0; i < itemCategories.Count; i++)
            {
                bool selected = playerInfo.selectedCategory == itemCategories[i];
                AddCategory(elements, itemCategories.Count, i, itemCategories[i], selected);
            }
        }
        void AddCategory(CuiElementContainer elements, float numElements, float index, string name, bool selected)
        {
            var bottom = (index / numElements);
            var top = ((index + 1) / numElements);
            top -= 0.0025f;
            bottom += 0.0025f;

            string backgroundColor = selected ? "0 0.5 0.9 0.8" : "0.35 0.35 0.35 0.8";

            string cName = name;
            if (CategoryShortNames.ContainsKey(cName))
                cName = CategoryShortNames[cName];

            PanelRect rect = new PanelRect(0, bottom, 1, top);
            elements.Add(new CuiButton
            {
                Button = { Command = $"category.select { name }", Color = backgroundColor },
                RectTransform =
                {
                    AnchorMin = rect.AnchorMin,
                    AnchorMax = rect.AnchorMax
                },
                Text = { Text = cName.ToUpper(), FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "0.8 0.8 0.8 1" }
            }, CategoriesName);
        }

        void RenderItemList(CuiElementContainer elements, PlayerInfo playerInfo)
        {
            if (playerInfo == null || itemInfoDic == null)
                return;

            List<ItemInfo> craftableItems = new List<ItemInfo>();
            List<ItemInfo> uncraftableItems = new List<ItemInfo>();
            foreach (var itemInfo in itemInfoDic.Values)
            {
                if (itemInfo == null) continue;
                if (itemInfo.category != playerInfo.selectedCategory) continue;
                if (itemInfo.blocked) continue;
                ItemDefinition itemDef = itemInfo.GetItemDef();
                if (itemDef == null) continue;
                if (!IncludeUncraftableItems && !itemDef.Blueprint.userCraftable)
                    continue;
                if (itemInfo.GetCraftable(playerInfo))
                    craftableItems.Add(itemInfo);
                else
                    uncraftableItems.Add(itemInfo);
            }


            float lowestBottom = 1f;
            for (int i = 0; i < craftableItems.Count; i++)
            {
                if (craftableItems[i] == null)
                    continue;

                float bottom = AddItem(elements, i, craftableItems[i], playerInfo, true);
                if (bottom < lowestBottom)
                    lowestBottom = bottom;
            }
            for (int i = 0; i < uncraftableItems.Count; i++)
            {
                if (uncraftableItems[i] == null)
                    continue;

                AddItem(elements, i, uncraftableItems[i], playerInfo, false, lowestBottom);
            }
        }
        float AddItem(CuiElementContainer elements, float index, ItemInfo itemInfo, PlayerInfo playerInfo, bool craftable, float startTop = 1)
        {
            const int maxRows = 8;
            const int maxColumns = 9;

            int row = (int)(index / maxColumns);
            int column = (int)index - (row * maxColumns);

            float left = (float)column / maxColumns;
            float right = (float)(column + 1) / maxColumns;
            float top = startTop - ((float)row / maxRows);
            float bottom = startTop - ((float)(row + 1) / maxRows);
            left += 0.0025f;
            right -= 0.0025f;
            top -= 0.0025f;
            bottom += 0.0025f;

            PanelRect rect = new PanelRect(left, bottom, right, top);
            bool selected = playerInfo.selectedItem == itemInfo;
            string buttonColor = selected ? "0 0.4 0.7 0.7" : "0 0 0 0";

            CuiRawImageComponent rawImage = new CuiRawImageComponent();
            //rawImage.Url = itemInfo.GetFormattedURL();
            rawImage.Png = ImageLibrary.Call<string>("GetImage", itemInfo.GetItemDef().shortname);
            rawImage.Sprite = transparentSprite;
            rawImage.Color = craftable ? "1 1 1 1" : "1 1 1 0.4";

            elements.Add(new CuiElement
            {
                Parent = ItemListName,
                Components =
                    {
                        rawImage,
                        new CuiRectTransformComponent {AnchorMin = rect.AnchorMin, AnchorMax = rect.AnchorMax },
                    }
            });

            if (selected)
            {
                float characterSize = 0.04f;
                float width = 0.3f + itemInfo.customName.Length * characterSize;
                PanelRect textRect = new PanelRect(-width / 2f, 1.05f, 1 + width / 2f, 1.35f).RelativeTo(rect);
                elements.Add(new CuiButton
                {
                    Button = { Color = "0 0.6 1 0" },
                    RectTransform = { AnchorMin = textRect.AnchorMin, AnchorMax = textRect.AnchorMax },
                    Text = { Text = itemInfo.customName, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", FontSize = 16 }
                }, ItemListName);
            }

            elements.Add(new CuiButton
            {
                Button = { Command = $"item.select { itemInfo.itemID }", Color = buttonColor },//, Sprite = transparentSprite },//, Color = backgroundColor },
                RectTransform =
                {
                    AnchorMin = rect.AnchorMin,
                    AnchorMax = rect.AnchorMax
                },
                Text = { Text = "", FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "0 0 0 0" },//, Color = "0.8 0.8 0.8 1" }
            }, ItemListName);

            return bottom;
        }

        void RenderItemInfo(CuiElementContainer elements, PlayerInfo playerInfo)
        {
            if (playerInfo.selectedItem == null)
                return;

            PanelRect itemInfoRect = panelAnchors[ItemInfoName].rect;

            PanelRect textRect = new PanelRect(0, 0.825f, 1, 0.975f);
            elements.Add(new CuiElement
            {
                Parent = ItemInfoName,
                Components =
                {
                    new CuiTextComponent { Text = playerInfo.selectedItem.customName, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", FontSize = 24 },
                    new CuiRectTransformComponent { AnchorMin = textRect.AnchorMin, AnchorMax = textRect.AnchorMax }
                }
            });

            PanelRect descriptionRect = new PanelRect(0.1f, 0.4f, 0.9f, 0.7f);
            elements.Add(new CuiElement
            {
                Parent = ItemInfoName,
                Components =
                {
                    new CuiTextComponent { Text = playerInfo.selectedItem.customDescription, Align = TextAnchor.UpperLeft, Color = "1 1 1 1", FontSize = 14 },
                    new CuiRectTransformComponent { AnchorMin = descriptionRect.AnchorMin, AnchorMax = descriptionRect.AnchorMax }
                }
            });

            PanelRect iconRect = new PanelRect(0.05f, 0.8f, 0.2f, 0.975f);
            CuiRawImageComponent rawImage = new CuiRawImageComponent();
            //rawImage.Url = playerInfo.selectedItem.GetFormattedURL(); // TODO: Testing
            rawImage.Png = ImageLibrary.Call<string>("GetImage", playerInfo.selectedItem.GetItemDef().shortname);
            rawImage.Sprite = transparentSprite;
            elements.Add(new CuiElement
            {
                Parent = ItemInfoName,
                Components =
                    {
                        rawImage,
                        new CuiRectTransformComponent {AnchorMin = iconRect.AnchorMin, AnchorMax = iconRect.AnchorMax },
                    }
            });

	    //AGA
            float craftTime = 1;
            originalCraftTimes.TryGetValue(playerInfo.selectedItem.itemID, out craftTime);
            PanelRect craftTimeRect = new PanelRect(0.76f, 0.825f, 0.875f, 0.89f);
            elements.Add(new CuiButton
            {
                Button = { Color = "0.2 0.2 0.2 0.8" },
                Text = { Text = (craftTime * playerInfo.selectedItem.craftRate).ToString("F0") + "s", Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", FontSize = 16 },
                RectTransform = { AnchorMin = craftTimeRect.AnchorMin, AnchorMax = craftTimeRect.AnchorMax }
            }, ItemInfoName);

            PanelRect amounterPerCraftRect = new PanelRect(0.885f, 0.825f, 1.00f, 0.89f);
            elements.Add(new CuiButton
            {
                Button = { Color = "0.2 0.2 0.2 0.8" },
                Text = { Text = playerInfo.selectedItem.GetItemDef().Blueprint.amountToCreate.ToString(), Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", FontSize = 16 },
                RectTransform = { AnchorMin = amounterPerCraftRect.AnchorMin, AnchorMax = amounterPerCraftRect.AnchorMax }
            }, ItemInfoName);
        }

        void RenderResourceCosts(CuiElementContainer elements, PlayerInfo playerInfo)
        {
            if (playerInfo.selectedItem == null)
                return;

            PanelRect itemCostRect = panelAnchors[ResourceCostName].rect;

            var craftInfo = playerInfo.GetCraftInfo();

            AddResourceCostColumn(elements, craftInfo.canCraft, "Amount", craftInfo.amounts, new PanelRect(0.005f, 0.005f, 0.255f, 0.995f));
            AddResourceCostColumn(elements, craftInfo.canCraft, "Item Type", craftInfo.itemTypes, new PanelRect(0.265f, 0.005f, 0.7f, 0.995f));
            AddResourceCostColumn(elements, craftInfo.canCraft, "Total", craftInfo.totals, new PanelRect(0.71f, 0.005f, 0.85f, 0.995f));
            AddResourceCostColumn(elements, craftInfo.canCraft, "Have", craftInfo.haves, new PanelRect(0.86f, 0.005f, 0.995f, 0.995f));
        }
        void AddResourceCostColumn(CuiElementContainer elements, bool canCraft, string labelName, List<string> values, PanelRect rect)
        {
            PanelRect labelRect = new PanelRect(0, 0.85f, 1f, 1).RelativeTo(rect);
            elements.Add(new CuiLabel
            {
                Text = { Text = labelName, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", FontSize = 12 },
                RectTransform = { AnchorMin = labelRect.AnchorMin, AnchorMax = labelRect.AnchorMax }
            }, ResourceCostName);

            string textColor = canCraft ? "1 1 1 1" : "0.9 0.8 0.3 1";

            for (int i = 0; i < values.Count; i++)
            {
                string textValue = "";
                string buttonColor = "0.2 0.2 0.2 0.2";
                if (values.Count - 1 >= i)
                {
                    textValue = values[i];
                    buttonColor = "0.2 0.2 0.2 0.8";
                }

                float top = 1 - ((float)i / values.Count);
                float bottom = 1 - ((float)(i + 1) / values.Count);
                top -= 0.01f;
                bottom += 0.01f;
                PanelRect tRect = rect.Copy();
                tRect.top *= 0.85f;
                tRect.bottom += 0.005f;
                PanelRect costTotalValueRect = new PanelRect(0, bottom, 1, top).RelativeTo(tRect);
                elements.Add(new CuiButton
                {
                    Button = { Color = buttonColor },
                    RectTransform = { AnchorMin = costTotalValueRect.AnchorMin, AnchorMax = costTotalValueRect.AnchorMax },
                    Text = { Text = textValue, FontSize = 12, Align = TextAnchor.MiddleCenter, Color = textColor }
                }, ResourceCostName);
            }
        }

        void RenderCraftAmount(CuiElementContainer elements, PlayerInfo playerInfo)
        {
            if (playerInfo.selectedItem == null)
                return;

            PanelRect tenRect = new PanelRect(0.00f, 0, 0.196f, 0.96f);
            elements.Add(new CuiButton
            {
                Button = { Command = $"craftamount.set { 10 }", Color = "0.6 0.6 0.6 0.85" },
                RectTransform = { AnchorMin = tenRect.AnchorMin, AnchorMax = tenRect.AnchorMax },
                Text = { Text = "10", FontSize = 28, Align = TextAnchor.MiddleCenter, Color = "1, 1, 1, 1" }
            }, CraftAmountName);

            PanelRect hundredRect = new PanelRect(0.204f, 0, 0.396f, 0.96f);
            elements.Add(new CuiButton
            {
                Button = { Command = $"craftamount.set { 100 }", Color = "0.6 0.6 0.6 0.85" },
                RectTransform = { AnchorMin = hundredRect.AnchorMin, AnchorMax = hundredRect.AnchorMax },
                Text = { Text = "100", FontSize = 28, Align = TextAnchor.MiddleCenter, Color = "1, 1, 1, 1" }
            }, CraftAmountName);

            PanelRect thousandRect = new PanelRect(0.404f, 0, 0.596f, 0.96f);
            elements.Add(new CuiButton
            {
                Button = { Command = $"craftamount.set { 1000 }", Color = "0.6 0.6 0.6 0.85" },
                RectTransform = { AnchorMin = thousandRect.AnchorMin, AnchorMax = thousandRect.AnchorMax },
                Text = { Text = "1k", FontSize = 28, Align = TextAnchor.MiddleCenter, Color = "1, 1, 1, 1" }
            }, CraftAmountName);

            PanelRect tenThousandRect = new PanelRect(0.604f, 0, 0.796f, 0.96f);
            elements.Add(new CuiButton
            {
                Button = { Command = $"craftamount.set { 10000 }", Color = "0.6 0.6 0.6 0.85" },
                RectTransform = { AnchorMin = tenThousandRect.AnchorMin, AnchorMax = tenThousandRect.AnchorMax },
                Text = { Text = "10k", FontSize = 28, Align = TextAnchor.MiddleCenter, Color = "1, 1, 1, 1" }
            }, CraftAmountName);

            PanelRect hundredThousandRect = new PanelRect(0.804f, 0, 0.996f, 0.96f);
            elements.Add(new CuiButton
            {
                Button = { Command = $"craftamount.set { 100000 }", Color = "0.6 0.6 0.6 0.85" },
                RectTransform = { AnchorMin = hundredThousandRect.AnchorMin, AnchorMax = hundredThousandRect.AnchorMax },
                Text = { Text = "100k", FontSize = 28, Align = TextAnchor.MiddleCenter, Color = "1, 1, 1, 1" }
            }, CraftAmountName);
        }

        void RenderCraftButton(CuiElementContainer elements, PlayerInfo playerInfo)
        {
            if (playerInfo.selectedItem == null)
                return;

            PanelRect craftButtonRect = new PanelRect(0, 0, 0.986f, 0.986f);
            elements.Add(new CuiButton
            {
                Button = { Command = $"craft.begin { playerInfo.selectedItem.itemID }", Color = playerInfo.GetCraftInfo().canCraft ? "0.0 0.5 0.0 0.85" : "0.2 0.2 0.2 0.8" },
                RectTransform = { AnchorMin = craftButtonRect.AnchorMin, AnchorMax = craftButtonRect.AnchorMax },
                Text = { Text = "Craft", FontSize = 28, Align = TextAnchor.MiddleCenter, Color = "1, 1, 1, 1" }
            }, CraftButtonName);
        }

        void RenderCraftCount(CuiElementContainer elements, PlayerInfo playerInfo)
        {
            if (playerInfo.selectedItem == null)
                return;

            PanelRect minusRect = new PanelRect(0.00f, 0, 0.10f, 0.96f);
            elements.Add(new CuiButton
            {
                Button = { Command = $"craftamount.change { -1 }", Color = "0.6 0.6 0.6 0.85" },
                RectTransform = { AnchorMin = minusRect.AnchorMin, AnchorMax = minusRect.AnchorMax },
                Text = { Text = "-", FontSize = 28, Align = TextAnchor.MiddleCenter, Color = "1, 1, 1, 1" }
            }, CraftCountName);

            PanelRect amountRect = new PanelRect(0.11f, 0, 0.31f, 0.96f);
            elements.Add(new CuiButton
            {
                Button = { Color = "0.2 0.2 0.2 0.8" },
                RectTransform = { AnchorMin = amountRect.AnchorMin, AnchorMax = amountRect.AnchorMax },
                Text = { Text = playerInfo.currentCraftAmount.ToString(), FontSize = 18, Align = TextAnchor.MiddleCenter, Color = "1, 1, 1, 1" }
            }, CraftCountName);

            PanelRect plusRect = new PanelRect(0.32f, 0, 0.42f, 0.96f);
            elements.Add(new CuiButton
            {
                Button = { Command = $"craftamount.change { 1 }", Color = "0.6 0.6 0.6 0.85" },
                RectTransform = { AnchorMin = plusRect.AnchorMin, AnchorMax = plusRect.AnchorMax },
                Text = { Text = "+", FontSize = 28, Align = TextAnchor.MiddleCenter, Color = "1, 1, 1, 1" }
            }, CraftCountName);

            PanelRect maxPossibleRect = new PanelRect(0.43f, 0, 0.53f, 0.96f);
            elements.Add(new CuiButton
            {
                Button = { Command = $"craftamount.max { playerInfo.selectedItem.itemID }", Color = "0.6 0.6 0.6 0.85" },
                RectTransform = { AnchorMin = maxPossibleRect.AnchorMin, AnchorMax = maxPossibleRect.AnchorMax },
                Text = { Text = ">", FontSize = 28, Align = TextAnchor.MiddleCenter, Color = "1, 1, 1, 1" }
            }, CraftCountName);
        }

        void RenderCraftQueue(CuiElementContainer elements, PlayerInfo playerInfo)
        {
            PanelRect textRect = new PanelRect(0, 0, 1, 1);
            elements.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = textRect.AnchorMin, AnchorMax = textRect.AnchorMax },
                Text = { Text = "CRAFTING QUEUE", FontSize = 58, Align = TextAnchor.MiddleLeft, Color = "1, 1, 1, 0.1" }
            }, CraftQueueName);

            BasePlayer player = playerInfo.basePlayer;
            List<ItemCraftTask> tasks = player.inventory.crafting.queue.Where(x => x.cancelled == false).ToList();
            for (int i = 0; i < tasks.Count; i++)
            {
                AddQueuedItem(elements, playerInfo, tasks[i], i, tasks.Count);
            }
        }
        void AddQueuedItem(CuiElementContainer elements, PlayerInfo player, ItemCraftTask task, int index, int taskCount)
        {
            PanelRect queueRect = panelAnchors[CraftQueueName].rect;
            float maxWidth = (queueRect.top * 1.1f - queueRect.bottom * 0.9f) * 0.8f;

            float bottom = 0.1f;
            float top = 0.9f;
            float right = 1 - ((float)index / (float)taskCount);
            float left = 1 - ((float)(index + 1) / (float)taskCount);
            float diff = right - left;
            if (diff > maxWidth)
            {
                right = 1 - ((float)index * maxWidth);
                left = right - maxWidth;
            }

            PanelRect rect = new PanelRect(left, bottom, right, top);
            ItemInfo itemInfo = FindItemInfo(task.blueprint.targetItem);
            if (itemInfo == null)
                return;

            CuiRawImageComponent rawImage = new CuiRawImageComponent();
            //rawImage.Url = itemInfo.GetFormattedURL(); // TODO: Testing
            rawImage.Png = ImageLibrary.Call<string>("GetImage", itemInfo.GetItemDef().shortname);
            rawImage.Sprite = transparentSprite;

            elements.Add(new CuiElement
            {
                Parent = CraftQueueName,
                Components =
                    {
                        rawImage,
                        new CuiRectTransformComponent {AnchorMin = rect.AnchorMin, AnchorMax = rect.AnchorMax },
                    }
            });

            elements.Add(new CuiButton
            {
                Button = { Command = $"craft.end { task.taskUID }", Color = "0 0 0 0" },
                RectTransform = { AnchorMin = rect.AnchorMin, AnchorMax = rect.AnchorMax },
                Text = { Text = "", Color = "0 0 0 0" }

            }, CraftQueueName);

            if (task.amount > 1)
            {
                PanelRect amountRect = new PanelRect(0.7f, 0f, 1f, 0.3f).RelativeTo(rect);
                elements.Add(new CuiButton
                {
                    Button = { Color = "0.8 0.8 0.8 0.8" },
                    RectTransform = { AnchorMin = amountRect.AnchorMin, AnchorMax = amountRect.AnchorMax },
                    Text = { Text = "x" + task.amount, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", FontSize = 10 }
                }, CraftQueueName);
            }
        }
        void RenderCraftQueueTimer(CuiElementContainer elements, PlayerInfo playerInfo)
        {
            if (playerInfo == null || playerInfo.basePlayer.inventory.crafting.queue.Count == 0)
                return;

            ItemCraftTask task = playerInfo.basePlayer.inventory.crafting.queue.FirstOrDefault();
            PanelRect textRect = new PanelRect(0.9f, 0.7f, 0.99f, 0.9f);//.RelativeTo(panelAnchors[CraftQueueName]);
            float timeRemaining = (task.endTime - 1f) - Time.realtimeSinceStartup;
            if (timeRemaining < 0)
                timeRemaining = 0;
            elements.Add(new CuiButton
            {
                Button = { Color = "0 1 0.3 1" },
                RectTransform = { AnchorMin = textRect.AnchorMin, AnchorMax = textRect.AnchorMax },
                Text = { Text = timeRemaining.ToString("F0") + "s", Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", FontSize = 12 }
            }, CraftQueueName);
        }

        void RenderOverlay(PlayerInfo playerInfo, bool looting, float lootColumns = 3)
        {
            if (playerInfo == null)
                return;

            playerInfo.overlayOpen = true;
            playerInfo.overlayLooting = looting;
            playerInfo.overlayLootingColumns = lootColumns;

            foreach (var panel in overlayAnchors)
            {
                if ((looting && panel.Key == QuickCraftOverlayName) || (!looting && panel.Key == QuickCraftOverlayLootingName))
                    continue;
                RenderOverlayPanel(panel.Key, playerInfo);
            }
        }
        void CloseOverlay(PlayerInfo playerInfo)
        {
            if (playerInfo == null)
                return;

            foreach (var kvp in overlayAnchors)
            {
                CuiHelper.DestroyUi(playerInfo.basePlayer, kvp.Key);
            }
            playerInfo.overlayOpen = false;
        }
        void CloseOverlay_AllPlayers()
        {
            if (BasePlayer.activePlayerList == null || BasePlayer.activePlayerList.Count == 0)
                return;

            foreach (var p in BasePlayer.activePlayerList)
            {
                PlayerInfo playerInfo = GetPlayer(p);
                if (playerInfo != null)
                    CloseOverlay(playerInfo);
            }
        }

        void RenderOverlayPanel(string panelName, PlayerInfo playerInfo)
        {
            if (playerInfo == null || playerInfo.basePlayer == null)
            {
                //PrintError("Render Overlay Panel called with a null PlayerInfo");
                return;
            }

            if (!overlayAnchors.ContainsKey(panelName))
            {
                //PrintError("Cannot render overlay panel '" + panelName + "' for player '" + playerInfo.basePlayer.displayName + "'. It does not exist");
                PlayerChat(playerInfo.basePlayer, UnknownError);
                return;
            }

            if (!playerInfo.overlayOpen)
                return;


            PanelRect panelRect = overlayAnchors[panelName].rect;
            if (panelName == QuickCraftOverlayLootingName)
                panelRect = lootableOverlayAnchors[playerInfo.overlayLootingColumns];

            CuiHelper.DestroyUi(playerInfo.basePlayer, panelName);
            CuiElementContainer elements = new CuiElementContainer();

            elements.Add(new CuiPanel
            {
                Image = { Color = overlayAnchors[panelName].backgroundColor },
                RectTransform = { AnchorMin = panelRect.AnchorMin, AnchorMax = panelRect.AnchorMax }
            }, "Overlay", panelName);

            switch (panelName)
            {
                case CraftingButtonOverlayName:
                    RenderCraftingButtonBlocker(elements, playerInfo);
                    break;
                case QuickCraftOverlayName:
                case QuickCraftOverlayLootingName:
                    RenderQuickCraft(elements, playerInfo);
                    break;
            }

            CuiHelper.AddUi(playerInfo.basePlayer, elements);
        }
        void RenderCraftingButtonBlocker(CuiElementContainer elements, PlayerInfo playerInfo)
        {
            if (playerInfo == null)
                return;

            elements.Add(new CuiButton
            {
                Button = { Command = "craftui.closeoverlayopencraftui", Color = "0 0 0 0" },
                Text = { Text = "" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
            }, CraftingButtonOverlayName);
        }
        void RenderQuickCraft(CuiElementContainer elements, PlayerInfo playerInfo)
        {
            if (playerInfo == null || itemInfoDic == null)
                return;

            List<ItemInfo> craftableItems = new List<ItemInfo>();
            foreach (var itemInfo in itemInfoDic.Values)
            {
                if (itemInfo == null) continue;
                if (!CategoryNames.Contains(itemInfo.category)) continue;
                if (itemInfo.blocked) continue;
                ItemDefinition itemDef = itemInfo.GetItemDef();
                if (itemDef == null) continue;
                if (!IncludeUncraftableItems && !itemDef.Blueprint.userCraftable)
                    continue;

                if (itemInfo.GetCraftable(playerInfo))
                    craftableItems.Add(itemInfo);
            }

            craftableItems = craftableItems.OrderByDescending(x => x.GetCraftCount(playerInfo)).Take(18).ToList();

            string parentName = playerInfo.overlayLooting ? QuickCraftOverlayLootingName : QuickCraftOverlayName;

            for (int i = 0; i < craftableItems.Count; i++)
            {
                AddQuickCraftItem(elements, i, craftableItems[i], playerInfo, parentName);
            }

            elements.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.8", AnchorMax = "1 0.97" },
                Text = { Text = "QUICK CRAFT", Align = TextAnchor.MiddleLeft, Color = "1 1 1 1", FontSize = 20 }
            }, parentName);
        }
        float AddQuickCraftItem(CuiElementContainer elements, float index, ItemInfo itemInfo, PlayerInfo playerInfo, string parentName)
        {
            const int maxRows = 4;
            const int maxColumns = 6;

            int row = (int)(index / maxColumns);
            int column = (int)index - (row * maxColumns);

            float left = (float)column / maxColumns;
            float right = (float)(column + 1) / maxColumns;
            float top = 1 - ((float)row / maxRows);
            float bottom = 1 - ((float)(row + 1) / maxRows);
            left += 0.0025f;
            right -= 0.0025f;
            top -= 0.0025f;
            bottom += 0.0025f;

            top -= 0.2f;
            bottom -= 0.2f;

            PanelRect rect = new PanelRect(left, bottom, right, top);
            string buttonColor = "0 0 0 0";

            CuiRawImageComponent rawImage = new CuiRawImageComponent();
            //rawImage.Url = itemInfo.GetFormattedURL(); // TODO: Testing
            rawImage.Png = ImageLibrary.Call<string>("GetImage", itemInfo.GetItemDef().shortname);
            rawImage.Sprite = transparentSprite;
            rawImage.Color = "1 1 1 1";

            elements.Add(new CuiElement
            {
                Parent = parentName,
                Components =
                    {
                        rawImage,
                        new CuiRectTransformComponent {AnchorMin = rect.AnchorMin, AnchorMax = rect.AnchorMax },
                    }
            });

            elements.Add(new CuiButton
            {
                Button = { Command = $"craft.begin { itemInfo.itemID }", Color = buttonColor },//, Sprite = transparentSprite },//, Color = backgroundColor },
                RectTransform =
                {
                    AnchorMin = rect.AnchorMin,
                    AnchorMax = rect.AnchorMax
                },
                Text = { Text = "", FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "0 0 0 0" },//, Color = "0.8 0.8 0.8 1" }
            }, parentName);


            return bottom;
        }
        #endregion

        #region Console Commands
        //[ConsoleCommand("craftui.toggleoverlay")]
        void ccmdOverlayToggle(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            PlayerInfo playerInfo = GetPlayer(player);

            if (!playerInfo.overlayOpen)
                RenderOverlay(playerInfo, false);
            else
                CloseOverlay(playerInfo);
        }
        [ConsoleCommand("craftui.closeoverlay")]
        void ccmdOverlayClose(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            PlayerInfo playerInfo = GetPlayer(player);

            CloseOverlay(playerInfo);
        }
        [ConsoleCommand("craftui.closeoverlayopencraftui")]
        void ccmdCloseOverlayOpenCraftUI(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            PlayerInfo playerInfo = GetPlayer(player);

            CloseOverlay(playerInfo);
            //rust.RunClientCommand(player, "inventory.toggle");
            RenderCraftUI(playerInfo);
        }
        [ConsoleCommand("craftui.toggle")]
        void ccmdCraftUIToggle(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            PlayerInfo playerInfo = GetPlayer(player);
            if (!playerInfo.uiOpen)
                RenderCraftUI(playerInfo);
            else
                CloseCraftUI(playerInfo);
        }
        [ChatCommand("craft")]
        void chatCmdCraftUIToggle(BasePlayer player)
        {
            PlayerInfo playerInfo = GetPlayer(player);
            if (!playerInfo.uiOpen)
                RenderCraftUI(playerInfo);
            else
                CloseCraftUI(playerInfo);
        }
        [ConsoleCommand("craftui.close")]
        void ccmdCraftUIClose(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            PlayerInfo playerInfo = GetPlayer(player);
            CloseCraftUI(playerInfo);
        }

        [ConsoleCommand("category.select")]
        void ccmdCategorySelect(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            PlayerInfo playerInfo = GetPlayer(player);
            if (playerInfo == null) return;

            var categoryName = arg.FullString;

            playerInfo.selectedCategory = categoryName;

            RenderHudPanel(CategoriesName, playerInfo);
            RenderHudPanel(ItemListName, playerInfo);
        }

        [ConsoleCommand("item.select")]
        void ccmdItemSelect(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            PlayerInfo playerInfo = GetPlayer(player);
            if (playerInfo == null) return;

            int itemID = arg.GetInt(0);

            ItemInfo itemInfo = FindItemInfo(itemID);
            if (itemInfo == null) return;

            playerInfo.selectedItem = itemInfo;

            RenderHudPanel(ItemListName, playerInfo);
            RenderHudPanel(ItemInfoName, playerInfo);
            RenderHudPanel(ResourceCostName, playerInfo);
            RenderHudPanel(CraftCountName, playerInfo);
            RenderHudPanel(CraftAmountName, playerInfo);
            RenderHudPanel(CraftButtonName, playerInfo);
        }

        [ConsoleCommand("craftamount.change")]
        void ccmdCraftAmountChange(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            PlayerInfo playerInfo = GetPlayer(player);
            if (playerInfo == null) return;

            int amount = arg.GetInt(0);

            playerInfo.currentCraftAmount += amount;
            if (playerInfo.currentCraftAmount < 1)
                playerInfo.currentCraftAmount = 1;

            RenderHudPanel(ResourceCostName, playerInfo);
	    RenderHudPanel(CraftAmountName, playerInfo);
            RenderHudPanel(CraftCountName, playerInfo);
            RenderHudPanel(CraftButtonName, playerInfo);
        }
        [ConsoleCommand("craftamount.set")]
        void ccmdCraftAmountSet(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            PlayerInfo playerInfo = GetPlayer(player);
            if (playerInfo == null) return;

            int amount = arg.GetInt(0);

            playerInfo.currentCraftAmount = amount;
            if (playerInfo.currentCraftAmount < 1)
                playerInfo.currentCraftAmount = 1;

            RenderHudPanel(ResourceCostName, playerInfo);
	    RenderHudPanel(CraftAmountName, playerInfo);
            RenderHudPanel(CraftCountName, playerInfo);
            RenderHudPanel(CraftButtonName, playerInfo);
        }
        [ConsoleCommand("craftamount.max")]
        void ccmdCraftAmountMax(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            PlayerInfo playerInfo = GetPlayer(player);
            if (playerInfo == null) return;

            int itemID = arg.GetInt(0);
            ItemInfo itemInfo = FindItemInfo(itemID);
            if (itemInfo == null) return;

            int curMax = int.MaxValue;
            foreach (var ingredient in itemInfo.ingredients)
            {
                float haveValue = player.inventory.GetAmount(ingredient.ingredientID);
                int possibleMax = ingredient.amount == 0 ? 999 : Mathf.FloorToInt(haveValue / ingredient.amount);
                curMax = Mathf.Min(curMax, possibleMax);
            }
            if (curMax == int.MaxValue)
                curMax = 1;

            playerInfo.currentCraftAmount = curMax;

            RenderHudPanel(ResourceCostName, playerInfo);
            RenderHudPanel(CraftAmountName, playerInfo);
            RenderHudPanel(CraftCountName, playerInfo);
            RenderHudPanel(CraftButtonName, playerInfo);
        }
        [ConsoleCommand("craft.begin")]
        void ccmdCraft(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            PlayerInfo playerInfo = GetPlayer(player);
            if (playerInfo == null) return;

            int itemID = arg.GetInt(0);
            ItemInfo itemInfo = FindItemInfo(itemID);
            if (itemInfo == null) return;
            ItemDefinition itemDef = itemInfo.GetItemDef();
            if (itemDef == null) return;
            ItemBlueprint bp = itemDef.Blueprint;
            if (bp == null) return;

            if (!itemInfo.GetCraftable(playerInfo))
                return;

	    if (!playerInfo.GetCraftInfo().canCraft)
                return;

            bp.ingredients.Clear();
            foreach (var ingredient in itemInfo.ingredients)
            {
                if (player.inventory.GetAmount(ingredient.ingredientID) < ingredient.amount)
                    return;
                bp.ingredients.Add(ingredient.GetItemAmount());
            }

            bp.time = originalCraftTimes[itemDef.itemid] * itemInfo.craftRate;

            CraftItem(bp, player, playerInfo.currentCraftAmount, 0);

            playerInfo.currentCraftAmount = 1;

            RenderHudPanel(ResourceCostName, playerInfo);
            RenderHudPanel(CraftAmountName, playerInfo);
            RenderHudPanel(CraftCountName, playerInfo);
            RenderHudPanel(CraftButtonName, playerInfo);
            RenderHudPanel(CraftQueueName, playerInfo);
            RenderHudPanel(CraftQueueTimerName, playerInfo);
            RenderOverlayPanel(playerInfo.overlayLooting ? QuickCraftOverlayLootingName : QuickCraftOverlayName, playerInfo);
            //RenderOverlayPanel(QuickCraftOverlayLootingName, playerInfo);
        }
        [ConsoleCommand("craft.end")]
        void ccmdCraftEnd(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            PlayerInfo playerInfo = GetPlayer(player);
            if (playerInfo == null) return;

            int taskID = arg.GetInt(0);
            ItemCraftTask task = null;
            foreach (var t in player.inventory.crafting.queue)
            {
                if (t.taskUID == taskID)
                {
                    task = t;
                    break;
                }
            }
            if (task == null || task.blueprint == null || task.blueprint.targetItem == null)
            {
                PrintWarning("Player '" + player.displayName + "' is attempting to cancel an invalid task.");
                RenderHudPanelDelayed(refreshTime, CraftQueueName, playerInfo);
                RenderHudPanelDelayed(refreshTime, CraftQueueTimerName, playerInfo);
                return;
            }
            ItemInfo itemInfo = FindItemInfo(task.blueprint.targetItem);
            foreach (var ingredient in itemInfo.ingredients)
            {
                player.inventory.GiveItem(ItemManager.CreateByItemID(ingredient.ingredientID, (int)ingredient.amount * task.amount, 0));
            }

            player.inventory.crafting.CancelTask(taskID, false);
            RenderHudPanelDelayed(refreshTime, CraftQueueName, playerInfo);
            RenderHudPanelDelayed(refreshTime, CraftQueueTimerName, playerInfo);
        }
        #endregion

        #region Helper Functions
        Item BuildItem(int itemid, int amount, ulong skin)
        {

            if (amount < 1) amount = 1;
            Item item = ItemManager.CreateByItemID(itemid, amount, skin);
            return item;
        }
        bool CraftItem(ItemBlueprint bp, BasePlayer owner, int amount = 1, int skinID = 0)
        {
            ItemCrafter itemCrafter = owner.inventory.crafting;
            itemCrafter.taskUID = itemCrafter.taskUID + 1;
            ItemCraftTask itemCraftTask = Facepunch.Pool.Get<ItemCraftTask>();
            itemCraftTask.blueprint = bp;
            CollectIngredients(itemCrafter, bp, itemCraftTask, amount, owner);
            itemCraftTask.endTime = 0f;
            itemCraftTask.taskUID = owner.inventory.crafting.taskUID;
            itemCraftTask.owner = owner;
            itemCraftTask.instanceData = null;
            itemCraftTask.amount = amount;
            itemCraftTask.skinID = skinID;
            customItemCrafts.Add(itemCraftTask.taskUID);

            object[] objArray = new object[] { itemCraftTask, owner, null };
            object obj = Interface.CallHook("OnItemCraft", objArray);
            if (obj is bool)
            {
                return (bool)obj;
            }

            PlayerInfo playerInfo = GetPlayer(owner);
            RenderHudPanelDelayed(refreshTime, CraftQueueName, playerInfo);
            RenderHudPanelDelayed(refreshTime, CraftQueueTimerName, playerInfo);
            RenderHudPanelDelayed(refreshTime, ResourceCostName, playerInfo);

            owner.inventory.crafting.queue.AddLast(itemCraftTask);
            if (itemCraftTask.owner != null)
            {
                if (!nullBlueprintSet.Contains(itemCraftTask.blueprint.targetItem.itemid))
                    itemCraftTask.owner.Command("note.craft_add", new object[] { itemCraftTask.taskUID, itemCraftTask.blueprint.targetItem.itemid, amount });
            }
            return true;
        }
        void CollectIngredient(ItemCrafter crafter, int item, int amount, List<Item> collect)
        {
            foreach (ItemContainer container in crafter.containers)
            {
                amount = amount - container.Take(collect, item, amount);
                if (amount > 0)
                {
                    continue;
                }
                break;
            }
        }
        void CollectIngredients(ItemCrafter crafter, ItemBlueprint bp, ItemCraftTask task, int amount = 1, BasePlayer player = null)
        {
            List<Item> items = new List<Item>();
            foreach (ItemAmount ingredient in bp.ingredients)
            {
                this.CollectIngredient(crafter, ingredient.itemid, (int)ingredient.amount * amount, items);
            }
            task.potentialOwners = new List<ulong>();
            foreach (Item item in items)
            {
                item.CollectedForCrafting(player);
                if (task.potentialOwners.Contains(player.userID))
                {
                    continue;
                }
                task.potentialOwners.Add(player.userID);
            }
            task.takenItems = items;
        }

        ItemDefinition DisplayNameToItemDef(BasePlayer player, string displayName)
        {
            string shortName = string.Empty;
            if (!displaynameToShortname.TryGetValue(displayName.ToLower(), out shortName))
            {
                PlayerChat(player, Invalid, displayName, "Item Name");
                return null;
            }

            ItemDefinition itemDef = ItemManager.FindItemDefinition(shortName);

            if (itemDef == null)
            {
                PlayerChat(player, UnknownError);
                return null;
            }

            return itemDef;
        }

        void PlayerChat(BasePlayer player, string key, params object[] args)
        {
            SendReply(player, Lang(key, player.UserIDString, args));
        }
        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        class UStopWatch
        {
            float startTime;
            int startFrame;
            float stopTime;
            int stopFrame;

            bool _isRunning;
            public bool isRunning { get { return _isRunning; } private set { _isRunning = value; } }

            public float elapsedSeconds { get { return (isRunning ? Time.realtimeSinceStartup : stopTime) - startTime; } }
            public int elapsedMilliseconds { get { return Mathf.RoundToInt(elapsedSeconds / 1000f); } }
            public int elapsedFrames { get { return (isRunning ? Time.frameCount : stopFrame) - startFrame; } }

            public UStopWatch(bool startNow = true)
            {
                if (startNow)
                    Start();
            }

            public void Start()
            {
                Reset();
                _isRunning = true;
            }
            public void Stop()
            {
                stopTime = Time.realtimeSinceStartup;
                stopFrame = Time.frameCount;

                _isRunning = false;
            }
            public void Reset()
            {
                startTime = Time.realtimeSinceStartup;
                startFrame = Time.frameCount;
                stopTime = Time.realtimeSinceStartup;
                stopFrame = Time.frameCount;
            }
        }
        #endregion

        #region ItemidToURL
        string GetItemIconURL(ItemDefinition itemDef)
        {
            return GetItemIconURL(itemDef.shortname);
        }
        string GetItemIconURL(string itemID)
        {
            string url = string.Empty;
            url = ImageLibrary.Call<string>("GetImageURL", itemID, 0);
            if (url == "null" || url == null){url = "";}
            return url;
        }
        readonly Dictionary<int, string> idToURL = new Dictionary<int, string>()
        {
            { 2033918259, "http://vignette2.wikia.nocookie.net/play-rust/images/d/d4/Python_Revolver_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 3655341, "http://vignette4.wikia.nocookie.net/play-rust/images/f/f2/Wood_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 547302405, "http://vignette3.wikia.nocookie.net/play-rust/images/f/f2/Water_Jug_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 112903447, "http://vignette3.wikia.nocookie.net/play-rust/images/7/7f/Water_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 889398893, "http://vignette3.wikia.nocookie.net/play-rust/images/2/22/Sulfur_Ore_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -891243783, "http://vignette4.wikia.nocookie.net/play-rust/images/3/32/Sulfur_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -892070738, "http://vignette4.wikia.nocookie.net/play-rust/images/8/85/Stones_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1616524891, "http://vignette2.wikia.nocookie.net/play-rust/images/9/97/Small_Stocking_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1623330855, "http://vignette1.wikia.nocookie.net/play-rust/images/6/6a/SUPER_Stocking_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 865679437, "http://vignette3.wikia.nocookie.net/play-rust/images/7/70/Small_Trout_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1001265731, "http://vignette1.wikia.nocookie.net/play-rust/images/f/fa/Wolf_Skull_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 960793436, "http://vignette3.wikia.nocookie.net/play-rust/images/2/24/Human_Skull_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 2007564590, "http://vignette4.wikia.nocookie.net/play-rust/images/4/4f/Santa_Hat_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1916127949, "http://vignette2.wikia.nocookie.net/play-rust/images/c/ce/Salt_Water_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 540154065, "http://vignette3.wikia.nocookie.net/play-rust/images/a/ac/Research_Paper_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 466113771, "http://vignette2.wikia.nocookie.net/play-rust/images/6/66/Pumpkin_Seed_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -225085592, "http://vignette3.wikia.nocookie.net/play-rust/images/4/4c/Pumpkin_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1725510067, "http://vignette2.wikia.nocookie.net/play-rust/images/d/da/Small_Present_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -2130280721, "http://vignette3.wikia.nocookie.net/play-rust/images/6/6b/Medium_Present_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1732316031, "http://vignette1.wikia.nocookie.net/play-rust/images/9/99/Large_Present_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 640562379, "http://vignette1.wikia.nocookie.net/play-rust/images/6/61/Pookie_Bear_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 843418712, "http://vignette3.wikia.nocookie.net/play-rust/images/a/a8/Mushroom_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 88869913, "http://vignette1.wikia.nocookie.net/play-rust/images/7/70/Minnows_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -758925787, "http://vignette2.wikia.nocookie.net/play-rust/images/c/c9/Pump_Jack_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 374890416, "http://vignette4.wikia.nocookie.net/play-rust/images/a/a1/High_Quality_Metal_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1059362949, "http://vignette1.wikia.nocookie.net/play-rust/images/0/0a/Metal_Ore_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 688032252, "http://vignette4.wikia.nocookie.net/play-rust/images/7/74/Metal_Fragments_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 431617507, "http://vignette3.wikia.nocookie.net/play-rust/images/f/f2/Spoiled_Wolf_Meat_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 179448791, "http://vignette2.wikia.nocookie.net/play-rust/images/5/5c/Raw_Wolf_Meat_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1691991080, "http://vignette3.wikia.nocookie.net/play-rust/images/1/16/Cooked_Wolf_Meat_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1714986849, "http://vignette4.wikia.nocookie.net/play-rust/images/b/b6/Burned_Wolf_Meat_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -253819519, "http://vignette4.wikia.nocookie.net/play-rust/images/7/78/Pork_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 991728250, "http://vignette2.wikia.nocookie.net/play-rust/images/d/dc/Cooked_Pork_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 968732481, "http://vignette2.wikia.nocookie.net/play-rust/images/6/61/Burned_Pork_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1325935999, "http://vignette4.wikia.nocookie.net/play-rust/images/c/c8/Bear_Meat_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -2043730634, "http://vignette3.wikia.nocookie.net/play-rust/images/1/17/Bear_Meat_Cooked_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -2066726403, "http://vignette2.wikia.nocookie.net/play-rust/images/c/c2/Burnt_Bear_Meat_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 50834473, "http://vignette2.wikia.nocookie.net/play-rust/images/9/9a/Leather_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 661790782, "http://vignette3.wikia.nocookie.net/play-rust/images/b/b7/Spoiled_Human_Meat_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -642008142, "http://vignette1.wikia.nocookie.net/play-rust/images/2/26/Raw_Human_Meat_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -991829475, "http://vignette4.wikia.nocookie.net/play-rust/images/d/d2/Cooked_Human_Meat_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1014825244, "http://vignette3.wikia.nocookie.net/play-rust/images/f/f0/Burned_Human_Meat_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 2133577942, "http://vignette1.wikia.nocookie.net/play-rust/images/8/80/High_Quality_Metal_Ore_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 583506109, "http://vignette1.wikia.nocookie.net/play-rust/images/1/1c/Hemp_Seed_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 3175989, "http://vignette3.wikia.nocookie.net/play-rust/images/6/66/Glue_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 97513422, "http://vignette4.wikia.nocookie.net/play-rust/images/5/57/Flare_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -533484654, "http://vignette1.wikia.nocookie.net/play-rust/images/1/1a/Raw_Fish_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -2078972355, "http://vignette3.wikia.nocookie.net/play-rust/images/8/8b/Cooked_Fish_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1034048911, "http://vignette1.wikia.nocookie.net/play-rust/images/d/d5/Animal_Fat_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1983936587, "http://vignette1.wikia.nocookie.net/play-rust/images/3/3c/Crude_Oil_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 583366917, "http://vignette1.wikia.nocookie.net/play-rust/images/2/29/Corn_Seed_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 3059624, "http://vignette1.wikia.nocookie.net/play-rust/images/0/0a/Corn_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 94756378, "http://vignette1.wikia.nocookie.net/play-rust/images/f/f7/Cloth_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -341443994, "http://vignette1.wikia.nocookie.net/play-rust/images/4/45/Chocolate_Bar_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -726947205, "http://vignette2.wikia.nocookie.net/play-rust/images/7/7d/Spoiled_Chicken_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1658459025, "http://vignette3.wikia.nocookie.net/play-rust/images/8/81/Raw_Chicken_Breast_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1734319168, "http://vignette3.wikia.nocookie.net/play-rust/images/6/6f/Cooked_Chicken_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1711323399, "http://vignette4.wikia.nocookie.net/play-rust/images/b/bb/Burned_Chicken_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1436001773, "http://vignette2.wikia.nocookie.net/play-rust/images/a/ad/Charcoal_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 523409530, "http://vignette1.wikia.nocookie.net/play-rust/images/2/2c/Candy_Cane_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1050986417, "http://vignette3.wikia.nocookie.net/play-rust/images/f/f2/Empty_Tuna_Can_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 2080339268, "http://vignette1.wikia.nocookie.net/play-rust/images/8/88/Empty_Can_Of_Beans_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -2079677721, "http://vignette4.wikia.nocookie.net/play-rust/images/f/fe/Cactus_Flesh_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -365801095, "http://vignette2.wikia.nocookie.net/play-rust/images/0/01/Bone_Fragments_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1887162396, "http://vignette3.wikia.nocookie.net/play-rust/images/8/83/Blueprint_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1386464949, "http://vignette3.wikia.nocookie.net/play-rust/images/a/ac/Bleach_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 2021568998, "http://vignette1.wikia.nocookie.net/play-rust/images/8/8c/Battery_-_Small_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1565095136, "http://vignette2.wikia.nocookie.net/play-rust/images/b/bf/Rotten_Apple_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1471284746, "http://vignette2.wikia.nocookie.net/play-rust/images/e/eb/Tech_Trash_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 3552619, "http://vignette4.wikia.nocookie.net/play-rust/images/1/12/Tarp_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1490499512, "http://vignette3.wikia.nocookie.net/play-rust/images/0/07/Targeting_Computer_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -892259869, "http://vignette1.wikia.nocookie.net/play-rust/images/d/d5/Sticks_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1835797460, "http://vignette2.wikia.nocookie.net/play-rust/images/3/3d/Metal_Spring_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -2092529553, "http://vignette3.wikia.nocookie.net/play-rust/images/d/d8/SMG_Body_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1617374968, "http://vignette3.wikia.nocookie.net/play-rust/images/3/39/Sheet_Metal_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -419069863, "http://vignette1.wikia.nocookie.net/play-rust/images/2/29/Sewing_Kit_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1223860752, "http://vignette2.wikia.nocookie.net/play-rust/images/a/ac/Semi_Automatic_Body_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 3506418, "http://vignette1.wikia.nocookie.net/play-rust/images/1/15/Rope_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -847065290, "http://vignette3.wikia.nocookie.net/play-rust/images/a/a5/Road_Signs_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1939428458, "http://vignette2.wikia.nocookie.net/play-rust/images/0/08/Rifle_Body_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1974032895, "http://vignette4.wikia.nocookie.net/play-rust/images/a/a8/Empty_Propane_Tank_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1057402571, "http://vignette2.wikia.nocookie.net/play-rust/images/4/4a/Metal_Pipe_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1567404401, "http://vignette4.wikia.nocookie.net/play-rust/images/9/9b/Metal_Blade_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 193190034, "http://vignette1.wikia.nocookie.net/play-rust/images/c/c6/M249_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1066276787, "http://vignette2.wikia.nocookie.net/play-rust/images/6/6a/Hazmat_Pants_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1133046397, "http://vignette3.wikia.nocookie.net/play-rust/images/2/23/Hazmat_Jacket_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1079752220, "http://vignette2.wikia.nocookie.net/play-rust/images/5/53/Hazmat_Helmet_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1057685737, "http://vignette3.wikia.nocookie.net/play-rust/images/a/aa/Hazmat_Gloves_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1078788046, "http://vignette4.wikia.nocookie.net/play-rust/images/8/8a/Hazmat_Boots_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 277631078, "http://vignette2.wikia.nocookie.net/play-rust/images/f/f2/Wind_Turbine_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 98228420, "http://vignette2.wikia.nocookie.net/play-rust/images/7/72/Gears_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1891056868, "http://vignette1.wikia.nocookie.net/play-rust/images/f/f8/Duct_Tape_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1200628767, "http://vignette2.wikia.nocookie.net/play-rust/images/8/84/Door_Key_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 3059095, "http://vignette3.wikia.nocookie.net/play-rust/images/f/ff/Coal_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1300054961, "http://vignette2.wikia.nocookie.net/play-rust/images/2/24/CCTV_Camera_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1594947829, "http://vignette4.wikia.nocookie.net/play-rust/images/8/80/Smoke_Rocket_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 110547964, "http://vignette1.wikia.nocookie.net/play-rust/images/4/48/Torch_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 3506021, "http://vignette2.wikia.nocookie.net/play-rust/images/f/ff/Rock_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1192532973, "http://vignette4.wikia.nocookie.net/play-rust/images/b/bc/Water_Bucket_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 3387378, "http://vignette3.wikia.nocookie.net/play-rust/images/d/d5/Note_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -217113639, "http://vignette4.wikia.nocookie.net/play-rust/images/b/bb/Acoustic_Guitar_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 191795897, "http://vignette4.wikia.nocookie.net/play-rust/images/3/3f/Double_Barrel_Shotgun_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1745053053, "http://vignette3.wikia.nocookie.net/play-rust/images/8/8d/Semi-Automatic_Rifle_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -141135377, "http://vignette4.wikia.nocookie.net/play-rust/images/9/9c/4x_Zoom_Scope_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -388967316, "http://vignette3.wikia.nocookie.net/play-rust/images/7/77/Salvaged_Sword_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1775234707, "http://vignette1.wikia.nocookie.net/play-rust/images/7/7e/Salvaged_Cleaver_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1379225193, "http://vignette2.wikia.nocookie.net/play-rust/images/b/b5/Eoka_Pistol_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1569280852, "http://vignette2.wikia.nocookie.net/play-rust/images/3/38/Muzzle_Brake_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1569356508, "http://vignette2.wikia.nocookie.net/play-rust/images/7/7d/Muzzle_Boost_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -2094080303, "http://vignette3.wikia.nocookie.net/play-rust/images/c/c0/MP5A4_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 825308669, "http://vignette3.wikia.nocookie.net/play-rust/images/3/34/Machete_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 146685185, "http://vignette4.wikia.nocookie.net/play-rust/images/3/34/Longsword_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 776005741, "http://vignette3.wikia.nocookie.net/play-rust/images/c/c7/Bone_Knife_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1229879204, "http://vignette3.wikia.nocookie.net/play-rust/images/0/0d/Weapon_Flashlight_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1045869440, "http://vignette3.wikia.nocookie.net/play-rust/images/5/55/Flame_Thrower_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -853695669, "http://vignette2.wikia.nocookie.net/play-rust/images/2/25/Hunting_Bow_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1556671423, "http://vignette4.wikia.nocookie.net/play-rust/images/2/27/Wooden_Window_Bars_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -402507101, "http://vignette1.wikia.nocookie.net/play-rust/images/e/eb/Reinforced_Window_Bars_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1021702157, "http://vignette2.wikia.nocookie.net/play-rust/images/f/fe/Metal_Window_Bars_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1175970190, "http://vignette4.wikia.nocookie.net/play-rust/images/c/c1/Shop_Front_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -378017204, "http://vignette3.wikia.nocookie.net/play-rust/images/2/2a/Chainlink_Fence_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 995306285, "http://vignette3.wikia.nocookie.net/play-rust/images/7/7a/Chainlink_Fence_Gate_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -427925529, "http://vignette4.wikia.nocookie.net/play-rust/images/f/f6/Prison_Cell_Wall_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 562888306, "http://vignette4.wikia.nocookie.net/play-rust/images/3/30/Prison_Cell_Gate_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 486166145, "http://vignette3.wikia.nocookie.net/play-rust/images/2/2b/Wood_Shutters_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -529054134, "http://vignette1.wikia.nocookie.net/play-rust/images/8/88/Metal_Vertical_embrasure_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -529054135, "http://vignette3.wikia.nocookie.net/play-rust/images/5/5d/Metal_horizontal_embrasure_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1908195100, "http://vignette1.wikia.nocookie.net/play-rust/images/9/9e/Lock_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1849912854, "http://vignette1.wikia.nocookie.net/play-rust/images/7/7c/Ladder_Hatch_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1722829188, "http://vignette4.wikia.nocookie.net/play-rust/images/4/48/Floor_Grill_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1456441506, "http://vignette1.wikia.nocookie.net/play-rust/images/7/7e/Wooden_Door_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1571725662, "http://vignette2.wikia.nocookie.net/play-rust/images/b/bc/Armored_Door_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -2104481870, "http://vignette3.wikia.nocookie.net/play-rust/images/8/83/Sheet_Metal_Door_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1575287163, "http://vignette2.wikia.nocookie.net/play-rust/images/4/41/Wood_Double_Door_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -933236257, "http://vignette3.wikia.nocookie.net/play-rust/images/c/c1/Armored_Double_Door_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1598790097, "http://vignette3.wikia.nocookie.net/play-rust/images/1/14/Sheet_Metal_Double_Door_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1257201758, "http://vignette2.wikia.nocookie.net/play-rust/images/5/57/Tool_Cupboard_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -307490664, "http://vignette2.wikia.nocookie.net/play-rust/images/b/ba/Building_Plan_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1840561315, "http://vignette3.wikia.nocookie.net/play-rust/images/6/6e/Water_Purifier_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1628526499, "http://vignette4.wikia.nocookie.net/play-rust/images/e/e2/Water_Barrel_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1369769822, "http://vignette2.wikia.nocookie.net/play-rust/images/9/9d/Survival_Fish_Trap_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -698499648, "http://vignette1.wikia.nocookie.net/play-rust/images/7/70/Small_Wooden_Sign_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -357728804, "http://vignette2.wikia.nocookie.net/play-rust/images/c/c3/Wooden_Sign_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -705305612, "http://vignette4.wikia.nocookie.net/play-rust/images/b/bc/Large_Wooden_Sign_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1962514734, "http://vignette3.wikia.nocookie.net/play-rust/images/6/6e/Huge_Wooden_Sign_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 644359987, "http://vignette1.wikia.nocookie.net/play-rust/images/f/fa/Two_Sided_Town_Sign_Post_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1224714193, "http://vignette1.wikia.nocookie.net/play-rust/images/6/62/One_Sided_Town_Sign_Post_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -163742043, "http://vignette1.wikia.nocookie.net/play-rust/images/1/11/Single_Sign_Post_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -587434450, "http://vignette2.wikia.nocookie.net/play-rust/images/5/5e/Double_Sign_Post_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1579245182, "http://vignette2.wikia.nocookie.net/play-rust/images/1/16/Large_Banner_on_pole_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1455694274, "http://vignette2.wikia.nocookie.net/play-rust/images/9/95/XXL_Picture_Frame_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1338515426, "http://vignette2.wikia.nocookie.net/play-rust/images/b/bf/XL_Picture_Frame_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 2117976603, "http://vignette1.wikia.nocookie.net/play-rust/images/6/65/Tall_Picture_Frame_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 385802761, "http://vignette1.wikia.nocookie.net/play-rust/images/5/50/Portrait_Picture_Frame_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -626812403, "http://vignette3.wikia.nocookie.net/play-rust/images/8/87/Landscape_Picture_Frame_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -632459882, "http://vignette3.wikia.nocookie.net/play-rust/images/4/4f/Two_Sided_Ornate_Hanging_Sign_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1498516223, "http://vignette4.wikia.nocookie.net/play-rust/images/d/df/Two_Sided_Hanging_Sign_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1628490888, "http://vignette3.wikia.nocookie.net/play-rust/images/2/29/Large_Banner_Hanging_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 2057749608, "http://vignette2.wikia.nocookie.net/play-rust/images/a/a5/Salvaged_Shelves_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1987447227, "http://vignette2.wikia.nocookie.net/play-rust/images/2/21/Research_Table_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 2069925558, "http://vignette1.wikia.nocookie.net/play-rust/images/6/60/Reactive_Target_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 148953073, "http://vignette3.wikia.nocookie.net/play-rust/images/a/a7/Small_Planter_Box_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 142147109, "http://vignette1.wikia.nocookie.net/play-rust/images/3/35/Large_Planter_Box_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 107868, "http://vignette4.wikia.nocookie.net/play-rust/images/c/c8/Paper_Map_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1278649848, "http://vignette1.wikia.nocookie.net/play-rust/images/9/92/Jack_O_Lantern_Happy_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1284735799, "http://vignette4.wikia.nocookie.net/play-rust/images/9/96/Jack_O_Lantern_Angry_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1598149413, "http://vignette3.wikia.nocookie.net/play-rust/images/e/ee/Large_Furnace_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -2095387015, "http://vignette3.wikia.nocookie.net/play-rust/images/4/43/Ceiling_Light_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 106434956, "http://vignette3.wikia.nocookie.net/play-rust/images/9/96/Paper_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1580059655, "http://vignette3.wikia.nocookie.net/play-rust/images/1/17/Gun_Powder_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 28178745, "http://vignette4.wikia.nocookie.net/play-rust/images/2/26/Low_Grade_Fuel_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1755466030, "http://vignette2.wikia.nocookie.net/play-rust/images/4/47/Explosives_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1660607208, "http://vignette1.wikia.nocookie.net/play-rust/images/5/57/Longsleeve_T-Shirt_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -864578046, "http://vignette2.wikia.nocookie.net/play-rust/images/6/62/T-Shirt_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1659202509, "http://vignette4.wikia.nocookie.net/play-rust/images/1/1e/Tank_Top_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 24576628, "http://vignette1.wikia.nocookie.net/play-rust/images/8/8c/Shirt_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 102672084, "http://vignette4.wikia.nocookie.net/play-rust/images/7/7f/Hide_Poncho_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -459156023, "http://vignette4.wikia.nocookie.net/play-rust/images/4/46/Shorts_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -135651869, "http://vignette2.wikia.nocookie.net/play-rust/images/e/e4/Hide_Pants_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 106433500, "http://vignette1.wikia.nocookie.net/play-rust/images/3/3f/Pants_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1767561705, "http://vignette4.wikia.nocookie.net/play-rust/images/e/e5/Burlap_Trousers_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 569119686, "http://vignette1.wikia.nocookie.net/play-rust/images/1/14/Bone_Armor_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1211618504, "http://vignette1.wikia.nocookie.net/play-rust/images/b/b5/Hoodie_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1666761111, "http://vignette3.wikia.nocookie.net/play-rust/images/c/c0/Hide_Vest_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -132588262, "http://vignette1.wikia.nocookie.net/play-rust/images/9/91/Hide_Skirt_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -148163128, "http://vignette1.wikia.nocookie.net/play-rust/images/5/57/Hide_Boots_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1178289187, "http://vignette2.wikia.nocookie.net/play-rust/images/c/ca/Bone_Helmet_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1035315940, "http://vignette2.wikia.nocookie.net/play-rust/images/c/c4/Burlap_Headwrap_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1397343301, "http://vignette2.wikia.nocookie.net/play-rust/images/8/88/Boonie_Hat_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 936777834, "http://vignette2.wikia.nocookie.net/play-rust/images/2/25/Hide_Halterneck_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 707432758, "http://vignette4.wikia.nocookie.net/play-rust/images/1/10/Burlap_Shoes_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 707427396, "http://vignette2.wikia.nocookie.net/play-rust/images/d/d7/Burlap_Shirt_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1289478934, "http://vignette2.wikia.nocookie.net/play-rust/images/9/9b/Stone_Hatchet_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 789892804, "http://vignette2.wikia.nocookie.net/play-rust/images/7/77/Stone_Pick_Axe_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1224598842, "http://vignette4.wikia.nocookie.net/play-rust/images/5/57/Hammer_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 498591726, "http://vignette1.wikia.nocookie.net/play-rust/images/6/6c/Timed_Explosive_Charge_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1295154089, "http://vignette2.wikia.nocookie.net/play-rust/images/0/0b/Satchel_Charge_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1035059994, "http://vignette1.wikia.nocookie.net/play-rust/images/2/2f/12_Gauge_Buckshot_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1819281075, "http://vignette3.wikia.nocookie.net/play-rust/images/1/1a/12_Gauge_Slug_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -533875561, "http://vignette2.wikia.nocookie.net/play-rust/images/9/9b/Pistol_Bullet_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 815896488, "http://vignette1.wikia.nocookie.net/play-rust/images/4/49/5.56_Rifle_Ammo_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 523855532, "http://vignette2.wikia.nocookie.net/play-rust/images/3/36/Hazmat_Suit_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1685058759, "http://vignette2.wikia.nocookie.net/play-rust/images/0/0e/Anti-Radiation_Pills_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 93029210, "http://vignette2.wikia.nocookie.net/play-rust/images/d/dc/Apple_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1461508848, "http://vignette3.wikia.nocookie.net/play-rust/images/d/d1/Assault_Rifle_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 563023711, "http://vignette2.wikia.nocookie.net/play-rust/images/f/f9/Auto_Turret_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -337261910, "http://vignette3.wikia.nocookie.net/play-rust/images/f/f8/Bandage_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -46188931, "http://vignette3.wikia.nocookie.net/play-rust/images/9/9f/Bandana_Mask_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1024486167, "http://vignette1.wikia.nocookie.net/play-rust/images/7/7b/Barbed_Wooden_Barricade_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 696727039, "http://vignette2.wikia.nocookie.net/play-rust/images/7/77/Baseball_Cap_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 384204160, "http://vignette1.wikia.nocookie.net/play-rust/images/b/be/Beancan_Grenade_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 97409, "http://vignette3.wikia.nocookie.net/play-rust/images/f/fe/Bed_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1406876421, "http://vignette1.wikia.nocookie.net/play-rust/images/4/43/Blue_Beenie_Hat_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1611480185, "http://vignette4.wikia.nocookie.net/play-rust/images/6/6f/Black_Raspberries_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 93832698, "http://vignette3.wikia.nocookie.net/play-rust/images/a/a3/Blood_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1063412582, "http://vignette1.wikia.nocookie.net/play-rust/images/f/f8/Blueberries_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -55660037, "http://vignette1.wikia.nocookie.net/play-rust/images/5/55/Bolt_Action_Rifle_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 919780768, "http://vignette4.wikia.nocookie.net/play-rust/images/1/19/Bone_Club_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 2107229499, "http://vignette1.wikia.nocookie.net/play-rust/images/b/b3/Boots_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 68998734, "http://vignette2.wikia.nocookie.net/play-rust/images/f/f5/Bota_Bag_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1260209393, "http://vignette1.wikia.nocookie.net/play-rust/images/a/a5/Bucket_Helmet_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1342405573, "http://vignette3.wikia.nocookie.net/play-rust/images/0/0e/Camera_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -139769801, "http://vignette4.wikia.nocookie.net/play-rust/images/3/35/Camp_Fire_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1043746011, "http://vignette2.wikia.nocookie.net/play-rust/images/e/e5/Can_of_Beans_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -171664558, "http://vignette4.wikia.nocookie.net/play-rust/images/2/2d/Can_of_Tuna_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1381682752, "http://vignette1.wikia.nocookie.net/play-rust/images/a/ad/Candle_Hat_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -975723312, "http://vignette2.wikia.nocookie.net/play-rust/images/0/0c/Code_Lock_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -2128719593, "http://vignette4.wikia.nocookie.net/play-rust/images/4/44/Coffee_Can_Helmet_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 498312426, "http://vignette2.wikia.nocookie.net/play-rust/images/b/b3/Concrete_Barricade_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 2123300234, "http://vignette3.wikia.nocookie.net/play-rust/images/2/23/Crossbow_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 109552593, "http://vignette1.wikia.nocookie.net/play-rust/images/9/95/Custom_SMG_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 805088543, "http://vignette3.wikia.nocookie.net/play-rust/images/3/31/Explosive_5.56_Rifle_Ammo_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1308622549, "http://vignette3.wikia.nocookie.net/play-rust/images/5/52/F1_Grenade_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -505639592, "http://vignette4.wikia.nocookie.net/play-rust/images/e/e3/Furnace_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 718197703, "http://vignette3.wikia.nocookie.net/play-rust/images/6/6c/Granola_Bar_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 2115555558, "http://vignette2.wikia.nocookie.net/play-rust/images/0/0d/Handmade_Shell_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 698310895, "http://vignette1.wikia.nocookie.net/play-rust/images/0/06/Hatchet_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -496055048, "http://vignette1.wikia.nocookie.net/play-rust/images/b/b6/High_External_Stone_Wall_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -57285700, "http://vignette2.wikia.nocookie.net/play-rust/images/5/53/High_External_Wooden_Gate_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1792066367, "http://vignette3.wikia.nocookie.net/play-rust/images/9/96/High_External_Wooden_Wall_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1280058093, "http://vignette3.wikia.nocookie.net/play-rust/images/e/e5/High_Velocity_Arrow_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 542276424, "http://vignette3.wikia.nocookie.net/play-rust/images/f/f4/High_Velocity_Rocket_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -465236267, "http://vignette4.wikia.nocookie.net/play-rust/images/4/45/Holosight_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1152393492, "http://vignette2.wikia.nocookie.net/play-rust/images/d/df/HV_5.56_Rifle_Ammo_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -422893115, "http://vignette4.wikia.nocookie.net/play-rust/images/e/e5/HV_Pistol_Ammo_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 997973965, "http://vignette1.wikia.nocookie.net/play-rust/images/5/52/Improvised_Balaclava_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 449771810, "http://vignette2.wikia.nocookie.net/play-rust/images/e/e1/Incendiary_5.56_Rifle_Ammo_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1621541165, "http://vignette4.wikia.nocookie.net/play-rust/images/3/31/Incendiary_Pistol_Bullet_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1436532208, "http://vignette1.wikia.nocookie.net/play-rust/images/f/f9/Incendiary_Rocket_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1167640370, "http://vignette2.wikia.nocookie.net/play-rust/images/8/8b/Jacket_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 255101535, "http://vignette3.wikia.nocookie.net/play-rust/images/8/83/Land_Mine_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -51678842, "http://vignette4.wikia.nocookie.net/play-rust/images/4/46/Lantern_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -789202811, "http://vignette3.wikia.nocookie.net/play-rust/images/9/99/Large_Medkit_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1817873886, "http://vignette2.wikia.nocookie.net/play-rust/images/3/35/Large_Water_Catcher_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 271534758, "http://vignette1.wikia.nocookie.net/play-rust/images/b/b2/Large_Wood_Box_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 115739308, "http://vignette2.wikia.nocookie.net/play-rust/images/a/a1/Leather_Gloves_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1716193401, "http://vignette1.wikia.nocookie.net/play-rust/images/d/d9/LR-300_Assault_Rifle_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 371156815, "http://vignette2.wikia.nocookie.net/play-rust/images/4/43/M92_Pistol_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 3343606, "http://vignette3.wikia.nocookie.net/play-rust/images/4/4d/Mace_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 516382256, "http://vignette1.wikia.nocookie.net/play-rust/images/8/8e/Weapon_Lasersight_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 586484018, "http://vignette3.wikia.nocookie.net/play-rust/images/9/99/Medical_Syringe_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 504904386, "http://vignette3.wikia.nocookie.net/play-rust/images/b/bb/Metal_Barricade_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1265861812, "http://vignette3.wikia.nocookie.net/play-rust/images/9/9d/Metal_Chest_Plate_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -46848560, "http://vignette1.wikia.nocookie.net/play-rust/images/1/1f/Metal_Facemask_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -450738836, "http://vignette1.wikia.nocookie.net/play-rust/images/1/1b/Miners_Hat_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1411620422, "http://vignette1.wikia.nocookie.net/play-rust/images/b/b8/Mining_Quarry_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -578028723, "http://vignette4.wikia.nocookie.net/play-rust/images/8/86/Pick_Axe_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1009492144, "http://vignette3.wikia.nocookie.net/play-rust/images/6/60/Pump_Shotgun_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1026117678, "http://vignette1.wikia.nocookie.net/play-rust/images/3/3b/Repair_Bench_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -930579334, "http://vignette1.wikia.nocookie.net/play-rust/images/5/58/Revolver_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 340009023, "http://vignette4.wikia.nocookie.net/play-rust/images/4/4e/Riot_Helmet_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -288010497, "http://vignette1.wikia.nocookie.net/play-rust/images/8/84/Road_Sign_Jacket_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1595790889, "http://vignette3.wikia.nocookie.net/play-rust/images/3/31/Road_Sign_Kilt_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1578894260, "http://vignette1.wikia.nocookie.net/play-rust/images/9/95/Rocket_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 649603450, "http://vignette3.wikia.nocookie.net/play-rust/images/0/06/Rocket_Launcher_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 790921853, "http://vignette1.wikia.nocookie.net/play-rust/images/c/c9/Salvaged_Axe_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1976561211, "http://vignette2.wikia.nocookie.net/play-rust/images/f/f8/Salvaged_Hammer_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1440143841, "http://vignette1.wikia.nocookie.net/play-rust/images/e/e1/Salvaged_Icepick_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1221200300, "http://vignette4.wikia.nocookie.net/play-rust/images/a/a7/Sandbag_Barricade_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 548699316, "http://vignette2.wikia.nocookie.net/play-rust/images/6/6b/Semi-Automatic_Pistol_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1213686767, "http://vignette3.wikia.nocookie.net/play-rust/images/9/9f/Silencer_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1253290621, "http://vignette2.wikia.nocookie.net/play-rust/images/b/be/Sleeping_Bag_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 470729623, "http://vignette2.wikia.nocookie.net/play-rust/images/a/ac/Small_Oil_Refinery_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1051155022, "http://vignette2.wikia.nocookie.net/play-rust/images/5/53/Small_Stash_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 927253046, "http://vignette2.wikia.nocookie.net/play-rust/images/f/fc/Small_Water_Bottle_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1824679850, "http://vignette2.wikia.nocookie.net/play-rust/images/0/04/Small_Water_Catcher_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1046072789, "http://vignette1.wikia.nocookie.net/play-rust/images/b/b0/Snap_Trap_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1616887133, "http://vignette3.wikia.nocookie.net/play-rust/images/0/04/Snow_Jacket_-_Red_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 510887968, "http://vignette2.wikia.nocookie.net/play-rust/images/c/cc/Stone_Barricade_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -2118132208, "http://vignette1.wikia.nocookie.net/play-rust/images/0/0a/Stone_Spear_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1625468793, "http://vignette3.wikia.nocookie.net/play-rust/images/2/24/Supply_Signal_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1293049486, "http://vignette2.wikia.nocookie.net/play-rust/images/9/9a/Survey_Charge_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 456448245, "http://vignette3.wikia.nocookie.net/play-rust/images/4/4e/Thompson_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 2077983581, "http://vignette3.wikia.nocookie.net/play-rust/images/1/1b/Waterpipe_Shotgun_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 124310981, "http://vignette2.wikia.nocookie.net/play-rust/images/0/00/Wolf_Headdress_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1883959124, "http://vignette2.wikia.nocookie.net/play-rust/images/6/68/Wood_Armor_Pants_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 1554697726, "http://vignette2.wikia.nocookie.net/play-rust/images/4/4f/Wood_Chestplate_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -770311783, "http://vignette2.wikia.nocookie.net/play-rust/images/f/ff/Wood_Storage_Box_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -420273765, "http://vignette3.wikia.nocookie.net/play-rust/images/3/3d/Wooden_Arrow_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -814689390, "http://vignette2.wikia.nocookie.net/play-rust/images/e/e5/Wooden_Barricade_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -685265909, "http://vignette4.wikia.nocookie.net/play-rust/images/f/f7/Wooden_Floor_Spikes_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1779401418, "http://vignette2.wikia.nocookie.net/play-rust/images/8/85/High_External_Stone_Gate_icon.png/revision/latest/scale-to-width-down/{0}" },
            { 108061910, "http://vignette3.wikia.nocookie.net/play-rust/images/c/c8/Wooden_Ladder_icon.png/revision/latest/scale-to-width-down/{0}" },
            { -1127699509, "http://vignette2.wikia.nocookie.net/play-rust/images/f/f2/Wooden_Spear_icon.png/revision/latest/scale-to-width-down/{0}" },
        };

        #endregion

        #region Default Binds
        static readonly Dictionary<string, string> defaultBinds = new Dictionary<string, string>()
        {
            { "f1", "consoletoggle" },
            { "f7", "bugreporter" },
            { "w", "+forward" },
            { "s", "+backward" },
            { "a", "+left" },
            { "d", "+right" },
            { "mouse0", "+attack" },
            { "mouse1", "+attack2" },
            { "mouse2", "+attack3" },
            { "1", "+slot1" },
            { "2", "+slot2" },
            { "3", "+slot3" },
            { "4", "+slot4" },
            { "5", "+slot5" },
            { "6", "+slot6" },
            { "7", "+slot7" },
            { "8", "+slot8" },
            { "leftshift", "+sprint" },
            { "rightshift", "+sprint" },
            { "leftalt", "+altlook" },
            { "r", "+reload" },
            { "space", "+jump" },
            { "leftcontrol", "+duck" },
            { "e", "+use" },
            { "v", "+voice" },
            { "g", "+map" },
            { "t", "chat.open" },
            { "return", "chat.open" },
            { "mousewheeldown", "+invnext" },
            { "mousewheelup", "+invprev" },
            { "tab", "inventory.toggle" },
            { "q", "inventory.togglecrafting" },
            { "f", "lighttoggle" }
        };
        #endregion

        #region CategoryShortnameLookup
        Dictionary<string, string> CategoryShortNames = new Dictionary<string, string>()
        {
            { ItemCategory.Construction.ToString(), "Build" },
            { ItemCategory.Items.ToString(), "Items" },
            { ItemCategory.Resources.ToString(), "Resources" },
            { ItemCategory.Attire.ToString(), "Clothing" },
            { ItemCategory.Tool.ToString(), "Tools" },
            { ItemCategory.Medical.ToString(), "Medical" },
            { ItemCategory.Weapon.ToString(), "Weapons" },
            { ItemCategory.Ammunition.ToString(), "Ammo" },
            { ItemCategory.Traps.ToString(), "Traps" },
            { ItemCategory.Misc.ToString(), "Misc" },
            { ItemCategory.Common.ToString(), "Common" },
            { ItemCategory.Component.ToString(), "Component" },
            { ItemCategory.Food.ToString(), "Food" },
        };
        #endregion
    }
}

// --- End of file: CraftUI.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/combat-log-db ---
// --- Original File Path: C/CombatLogDb/CombatLogDb.cs ---

using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Combat Log DB", "mvrb", "1.1.1")]
    [Description("Translate CombatLog IDs into playernames and lookup players' combat logs.")]
    class CombatLogDb : RustPlugin
    {
        private StoredData storedData;

        private string permissionUse = "combatlogdb.use";

        private void Init()
        {
            LoadData();

            permission.RegisterPermission(permissionUse, this);
        }

        private void OnServerInitialized()
        {
            foreach (var player in BasePlayer.activePlayerList) OnPlayerConnected(player);
        }

        new private void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPlayersFound"] = "No players found with the name {0}",
                ["MultiplePlayersFound"] = "Multiple players found with the name {0}",
                ["NoDataFound"] = "No data found for {0}",
                ["CombatLogIdBelongsTo"] = "The CombatLogID '{0}' belongs to {1}",
                ["CheckConsoleForData"] = "Check your console for CombatLog data on {0}",
                ["CheckingCombatLogFor"] = "---------- CHECKING COMBATLOG FOR {0} ----------",
                ["EndCombatLogOutput"] = "------------------------------------------------------------",
                ["ErrorNameRequired"] = "You must enter a PlayName or SteamID.",
                ["ErrorIdRequired"] = "You must enter an ID found in a Combat Log.",
                ["ErrorInvalidId"] = "You must enter a valid CombatLogID (Numbers only)",
                ["ErrorNoPermission"] = "You do not have permission to use this command."
            }, this);
        }

        [ChatCommand("cid")]
        private void CmdCombatLogId(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionUse))
            {
                player.ChatMessage(Lang("ErrorNoPermission", player.UserIDString));
                return;
            }

            if (args.Length == 0)
            {
                player.ChatMessage(Lang("ErrorIdRequired", player.UserIDString));
                return;
            }

            uint input;

            if (!uint.TryParse(args[0], out input))
            {
                player.ChatMessage(Lang("ErrorInvalidId", player.UserIDString));
                return;
            }

            if (!storedData.Players.ContainsKey(input))
            {
                player.ChatMessage(Lang("NoDataFound", player.UserIDString, input));
                return;
            }

            player.ChatMessage(Lang("CombatLogIdBelongsTo", player.UserIDString, input, GetNameFromId(storedData.Players[input].ToString())));

        }

        [ConsoleCommand("combatlogdb.get")]
        private void ConsoleCmdCombatLog(ConsoleSystem.Arg conArgs)
        {
            if (conArgs?.Connection != null && !permission.UserHasPermission(conArgs?.Player()?.UserIDString, permissionUse)) return;

            var args = conArgs.Args;

            ulong steamID;
            if (!ulong.TryParse(args[0], out steamID))
            {
                SendReply(conArgs, $"{steamID} isn't a valid SteamID64.");
                return;
            }

            int rows = args.Length > 1 ? int.Parse(args[1]) : 20;

            string combatLog = GetCombatLog(steamID, rows);

            SendReply(conArgs, "\n" + combatLog);
        }

        [ChatCommand("combatlog")]
        private void ChatCmdCombatLog(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionUse))
            {
                player.ChatMessage(Lang("ErrorNoPermission", player.UserIDString));
                return;
            }

            if (args.Length == 0)
            {
                player.ChatMessage(Lang("ErrorNameRequired", player.UserIDString));
                return;
            }

            var input = args[0].ToLower();

            var found = new List<BasePlayer>();
            foreach (var t in BasePlayer.activePlayerList)
            {
                if (t.UserIDString == input)
                {
                    found.Clear();
                    found.Add(t);
                    break;
                }
                else if (t.displayName.ToLower() == input)
                {
                    found.Clear();
                    found.Add(t);
                    break;
                }
                if (t.displayName.ToLower().Contains(input))
                {
                    found.Add(t);
                }
            }

            if (found.Count == 0)
            {
                player.ChatMessage(Lang("NoPlayersFound", player.UserIDString, input));
                return;
            }
            else if (found.Count > 1)
            {
                string msg = Lang("MultiplePlayersFound", player.UserIDString, input) + ": \n";
                foreach (var p in found) msg += $"- {p.displayName} \n";
                player.ChatMessage(msg);
                return;
            }

            var target = found[0];

            int rows = args.Length > 1 ? int.Parse(args[1]) : 20;

            player.ConsoleMessage(Lang("CheckingCombatLogFor", player.UserIDString, target.displayName));
            player.ConsoleMessage("\n");
            player.ConsoleMessage(GetCombatLog(target.userID, rows));
            player.ConsoleMessage("\n");
            player.ConsoleMessage(Lang("EndCombatLogOutput", player.UserIDString));

            player.ChatMessage(Lang("CheckConsoleForData", player.UserIDString, target.displayName));
        }

        private string GetCombatLog(ulong steamid, int count)
        {
            var storage = CombatLog.Get(steamid);

            TextTable textTable = new TextTable();
            textTable.AddColumn("time");
            textTable.AddColumn("attacker");
            textTable.AddColumn("id");
            textTable.AddColumn("target");
            textTable.AddColumn("id");
            textTable.AddColumn("weapon");
            textTable.AddColumn("ammo");
            textTable.AddColumn("area");
            textTable.AddColumn("distance");
            textTable.AddColumn("old_hp");
            textTable.AddColumn("new_hp");
            textTable.AddColumn("info");

            int num = storage.Count - count;
            int num1 = ConVar.Server.combatlogdelay;
            int num2 = 0;

            foreach (CombatLog.Event evt in storage)
            {
                if (num <= 0)
                {
                    float single = Time.realtimeSinceStartup - evt.time;
                    if (single < (float)num1)
                    {
                        num2++;
                    }
                    else
                    {
                        string str = single.ToString("0.0s");
                        string str1 = evt.attacker == "you" ? GetNameFromId(steamid.ToString()) : evt.attacker;

                        string str2 = storedData.Players.ContainsKey((uint)evt.attacker_id) ? GetNameFromId(storedData.Players[(uint)evt.attacker_id].ToString()) : evt.attacker_id.ToString();

                        string str3 = evt.target == "you" ? GetNameFromId(steamid.ToString()) : evt.target;

                        string str4 = storedData.Players.ContainsKey((uint)evt.target_id) ? GetNameFromId(storedData.Players[(uint)evt.target_id].ToString()) : evt.target_id.ToString();

                        string str5 = evt.weapon;
                        string str6 = evt.ammo;
                        string lower = HitAreaUtil.Format(evt.area).ToLower();
                        string str7 = evt.distance.ToString("0.0m");
                        string str8 = evt.health_old.ToString("0.0");
                        string str9 = evt.health_new.ToString("0.0");
                        string str10 = evt.info;
                        textTable.AddRow(new string[] { str, str1, str2, str3, str4, str5, str6, lower, str7, str8, str9, str10 });
                    }
                }
                else
                {
                    num--;
                }
            }

            string str11 = textTable.ToString();
            if (num2 > 0)
            {
                string str12 = str11;
                object[] objArray = new object[] { str12, "+ ", num2, " ", null };
                objArray[4] = (num2 <= 1 ? "event" : "events");
                str11 = string.Concat(objArray);
                str12 = str11;
                object[] objArray1 = new object[] { str12, " in the last ", num1, " ", null };
                objArray1[4] = (num1 <= 1 ? "second" : "seconds");
                str11 = string.Concat(objArray1);
            }
            return str11;
        }

        private void OnNewSave(string s)
        {
            storedData.Players.Clear();
            SaveData();
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (!storedData.Players.ContainsKey(player.net.ID))
            {
                storedData.Players.Add(player.net.ID, player.userID);
            }

            SaveData();
        }

        private void LoadData() => storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(this.Name);
        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(this.Name, storedData);

        private string GetNameFromId(string id) => covalence.Players.FindPlayerById(id)?.Name;

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private class StoredData
        {
            public Dictionary<uint, ulong> Players = new Dictionary<uint, ulong>();
        }
    }
}

// --- End of file: CombatLogDb.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/chat-head ---
// --- Original File Path: C/ChatHead/ChatHead.cs ---

﻿using ConVar;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using System.Drawing;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Chat Head", "Ujiou", "1.4.2")]
    [Description("Displays chat messages above player to other players in range.")]
    class ChatHead : RustPlugin
    {
        #region Config
        ChatHeadConfig config;

        protected override void LoadDefaultConfig() => config = LoadBaseConfig();

        protected override void SaveConfig() => Config.WriteObject(config, true);

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<ChatHeadConfig>();

                if (config == null)
                    throw new JsonException();

                if (config.Version < Version || config.Version > Version)
                    LoadDefaultConfig();
                    SaveConfig();
            }
            catch
            {
                Puts("Config was created!");
                LoadDefaultConfig();
                SaveConfig();
            }
        }

        private ChatHeadConfig LoadBaseConfig()
        {
            return new ChatHeadConfig
            {
                settings = new ChatHeadConfig.Settings
                {
                    textColor = "#ffffff",
                    textHeight = 2.5f,
                    textSize = 25,
                    hideTeamChat = true,
                },
                vanishS = new ChatHeadConfig.VanishSettings
                {
                    vanishHideAdmins = true
                },
                Version = Version
            };
        }

        public class ChatHeadConfig
        {
            [JsonProperty(PropertyName = "Settings: ")]
            public Settings settings { get; set; }

            [JsonProperty(PropertyName = "Vanish Settings: ")]
            public VanishSettings vanishS { get; set; }


            public class Settings
            {
                [JsonProperty(PropertyName = "Text Color")]
                public string textColor { get; set; }

                [JsonProperty(PropertyName = "Text Height")]
                public float textHeight { get; set; }

                [JsonProperty(PropertyName = "Text Size")]
                public int textSize { get; set; }

                [JsonProperty(PropertyName = "Hide Team Chat")]
                public bool hideTeamChat { get; set; }
            }

            public class VanishSettings
            {
                [JsonProperty(PropertyName = "Hide Text")]
                public bool vanishHideAdmins { get; set; }
            }

            [JsonProperty(PropertyName = "Version: ")]
            public Core.VersionNumber Version { get; set; }
        }
        #endregion

        #region Chat Handling
        readonly Dictionary<string, string> lastMessage = new Dictionary<string, string>();

        void OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            if (lastMessage.ContainsKey(player.UserIDString))
                lastMessage[player.UserIDString] = message;
            else
                lastMessage.Add(player.UserIDString, message);

            if (channel == Chat.ChatChannel.Team && config.settings.hideTeamChat)
                return;

            if (Vanish != null)
                if (isInvisible(player) && config.vanishS.vanishHideAdmins)
                    return;

            foreach (var target in BasePlayer.activePlayerList) DrawChat(target, player);
        }

        void DrawChat(BasePlayer target, BasePlayer player)
        {
            var distance = Vector3.Distance(target.transform.position, player.transform.position);

            if (!target.IsConnected || !player.IsConnected || distance >= 20) return;

            var color = config.settings.textColor.Contains("#") ? ColorTranslator.FromHtml(config.settings.textColor) : ColorTranslator.FromHtml("#{textColor}");

            timer.Repeat(0.1f, 80, () =>
            {
                if (!target.IsConnected || !player.IsConnected || !Equals(lastMessage[player.UserIDString], lastMessage[player.UserIDString])) return;

                var format = $"<size={config.settings.textSize}>{lastMessage[player.UserIDString]}</size>";
                if (target.IsAdmin)
                    target.SendConsoleCommand("ddraw.text", 0.1f, color, player.transform.position + (Vector3.up * config.settings.textHeight), format);
                else 
                {
                    GiveFlag(target, BasePlayer.PlayerFlags.IsAdmin, true);
                    target.SendConsoleCommand("ddraw.text", 0.1f, color, player.transform.position + (Vector3.up * config.settings.textHeight), format);
                    GiveFlag(target, BasePlayer.PlayerFlags.IsAdmin, false);
                }
            });

        }
        #endregion

        #region Vanish Plugin
        [PluginReference]
        private Plugin Vanish;

        private void Loaded()
        {
            if (Vanish != null)
                Vanish.Load();
        }

        public bool isInvisible(BasePlayer player) =>
            Vanish.Call<bool>("IsInvisible", player);
        #endregion

        #region Helpers
        private void GiveFlag(BasePlayer player, BasePlayer.PlayerFlags flag, bool value)
        {
            if (player == null) 
                return;

            player.SetPlayerFlag(flag, value);
            player.SendNetworkUpdateImmediate();
        }
        #endregion
    }
}

// --- End of file: ChatHead.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/car-lock-ui ---
// --- Original File Path: C/CarLockUI/CarLockUI.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Car Lock UI", "WhiteThunder", "1.0.2")]
    [Description("Adds a UI to add code locks to modular cars.")]
    internal class CarLockUI : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private Plugin VehicleDeployedLocks;

        private static CarLockUI _pluginInstance;
        private Configuration _pluginConfig;

        private const string PermissionUseCodeLock = "carlockui.use.codelock";

        private const int CodeLockItemId = 1159991980;

        private readonly CarLiftTracker _liftTracker = new CarLiftTracker();
        private CodeLockUIManager UIManager;

        #endregion

        #region Hooks

        private void Init()
        {
            _pluginInstance = this;
            UIManager = new CodeLockUIManager(_pluginConfig.UISettings);

            permission.RegisterPermission(PermissionUseCodeLock, this);
        }

        private void OnServerInitialized()
        {
            if (VehicleDeployedLocks == null)
                LogError("VehicleDeployedLocks is not loaded, get it at https://umod.org");
        }

        private void Unload()
        {
            UIManager.DestroyAllUIs();
            _pluginInstance = null;
        }

        private void OnLootEntity(BasePlayer player, ModularCarGarage carLift)
        {
            _liftTracker.HandlePlayerLootCarLift(player, carLift);

            var car = carLift?.carOccupant;
            if (car == null)
                return;

            UIManager.UpdateCarUI(car);
        }

        private void OnPlayerLootEnd(PlayerLoot inventory)
        {
            var player = inventory.GetComponent<BasePlayer>();
            if (player == null)
                return;

            _liftTracker.HandlePlayerLootEnd(player);
            UIManager.DestroyPlayerUI(player);
        }

        // Handle the case where a cockpit is added while a player is editing the car
        private void OnEntitySpawned(VehicleModuleSeating seatingModule)
        {
            if (seatingModule == null || !seatingModule.HasADriverSeat())
                return;

            NextTick(() =>
            {
                var car = seatingModule.Vehicle as ModularCar;
                if (car == null)
                    return;

                UIManager.UpdateCarUI(car);
            });
        }

        // Handle the case where a cockpit is removed but the car remains
        private void OnEntityKill(VehicleModuleSeating seatingModule)
        {
            if (seatingModule == null || !seatingModule.HasADriverSeat())
                return;

            var car = seatingModule.Vehicle as ModularCar;
            if (car == null)
                return;

            NextTick(() =>
            {
                if (car == null)
                    return;

                UIManager.UpdateCarUI(car);
            });
        }

        // Handle the case where the code lock is removed but the car and cockpit remain
        private void OnEntityKill(CodeLock codeLock)
        {
            if (codeLock == null)
                return;

            var seatingModule = codeLock.GetParentEntity() as VehicleModuleSeating;
            if (seatingModule == null)
                return;

            var car = seatingModule.Vehicle as ModularCar;
            NextTick(() =>
            {
                if (car == null)
                    return;

                UIManager.UpdateCarUI(car);
            });
        }

        private void OnVehicleLockDeployed(ModularCar car) =>
            UIManager.UpdateCarUI(car);

        #endregion

        #region Commands

        [Command("carlockui.deploy.codelock")]
        private void UICommandDeploy(IPlayer player, string cmd, string[] args)
        {
            if (player.IsServer || !player.HasPermission(PermissionUseCodeLock) || VehicleDeployedLocks == null)
                return;

            var basePlayer = player.Object as BasePlayer;
            var car = _liftTracker.GetCarPlayerIsLooting(basePlayer);
            if (car == null || !CanPlayerDeployCodeLock(basePlayer, car))
                return;

            VehicleDeployedLocks.Call("API_DeployCodeLock", car, basePlayer, false);
        }

        [Command("carlockui.remove.codelock")]
        private void UICommandRemove(IPlayer player, string cmd, string[] args)
        {
            if (player.IsServer || !player.HasPermission(PermissionUseCodeLock) || VehicleDeployedLocks == null)
                return;

            var basePlayer = player.Object as BasePlayer;
            var car = _liftTracker.GetCarPlayerIsLooting(basePlayer);
            if (car == null)
                return;

            var codeLock = GetCarLock(car) as CodeLock;
            if (codeLock == null)
                return;

            codeLock.Kill();

            var codeLockItem = ItemManager.CreateByItemID(CodeLockItemId);
            if (codeLockItem == null)
                return;

            basePlayer.GiveItem(codeLockItem);
        }

        #endregion

        #region Helper Methods

        private bool CanCarHaveLock(ModularCar car) =>
            FindFirstDriverModule(car) != null;

        private bool CanPlayerDeployCodeLock(BasePlayer player, ModularCar car) =>
            VehicleDeployedLocks != null && (bool)VehicleDeployedLocks.Call("API_CanPlayerDeployCodeLock", player, car);

        private BaseLock GetCarLock(ModularCar car) =>
            car.GetSlot(BaseEntity.Slot.Lock) as BaseLock;

        private VehicleModuleSeating FindFirstDriverModule(ModularCar car)
        {
            for (int socketIndex = 0; socketIndex < car.TotalSockets; socketIndex++)
            {
                BaseVehicleModule module;
                if (car.TryGetModuleAt(socketIndex, out module))
                {
                    var seatingModule = module as VehicleModuleSeating;
                    if (seatingModule != null && seatingModule.HasADriverSeat())
                        return seatingModule;
                }
            }
            return null;
        }

        #endregion

        #region Helper Classes

        private class CarLiftTracker
        {
            private readonly Dictionary<ModularCar, List<BasePlayer>> LootersOfCar = new Dictionary<ModularCar, List<BasePlayer>>();
            private readonly Dictionary<BasePlayer, ModularCar> LootingCar = new Dictionary<BasePlayer, ModularCar>();

            public ModularCar GetCarPlayerIsLooting(BasePlayer player) =>
                LootingCar.ContainsKey(player) ? LootingCar[player] : null;

            public List<BasePlayer> GetPlayersLootingCar(ModularCar car) =>
                LootersOfCar.ContainsKey(car) ? LootersOfCar[car] : new List<BasePlayer>();

            public void HandlePlayerLootCarLift(BasePlayer player, ModularCarGarage carLift)
            {
                var car = carLift?.carOccupant;
                if (car == null)
                    return;

                if (LootersOfCar.ContainsKey(car))
                    LootersOfCar[car].Add(player);
                else
                    LootersOfCar.Add(car, new List<BasePlayer> { player });

                if (LootingCar.ContainsKey(player))
                    LootingCar[player] = car;
                else
                    LootingCar.Add(player, car);
            }

            public void HandlePlayerLootEnd(BasePlayer player)
            {
                if (!LootingCar.ContainsKey(player))
                    return;

                var car = LootingCar[player];
                LootingCar.Remove(player);

                if (LootersOfCar.ContainsKey(car))
                {
                    LootersOfCar[car].Remove(player);
                    if (LootersOfCar[car].Count == 0)
                        LootersOfCar.Remove(car);
                }
            }
        }

        private class CodeLockUIManager
        {
            private enum UIState { AddLock, RemoveLock, None }

            private const string CodeLockUIName = "CarLockUI.AddRemoveLock";

            private readonly UISettings Settings;
            private readonly Dictionary<BasePlayer, UIState> PlayerUIStates = new Dictionary<BasePlayer, UIState>();

            public CodeLockUIManager(UISettings settings)
            {
                Settings = settings;
            }

            public void DestroyAllUIs()
            {
                var keys = PlayerUIStates.Keys;
                if (keys.Count == 0)
                    return;

                var playerList = new BasePlayer[keys.Count];
                keys.CopyTo(playerList, 0);

                foreach (var player in playerList)
                    DestroyPlayerUI(player);
            }

            public void UpdateCarUI(ModularCar car)
            {
                var looters = _pluginInstance._liftTracker.GetPlayersLootingCar(car);

                var currentLock = _pluginInstance.GetCarLock(car);
                if (!_pluginInstance.CanCarHaveLock(car) || currentLock is KeyLock)
                {
                    foreach (var player in looters)
                        DestroyPlayerUI(player);
                    return;
                }

                var uiState = currentLock == null ? UIState.AddLock : UIState.RemoveLock;
                foreach (var player in looters)
                    UpdatePlayerCarUI(player, car, uiState);
            }

            private void UpdatePlayerCarUI(BasePlayer player, ModularCar car, UIState desiredUIState)
            {
                UIState uiState = desiredUIState;

                if (!player.IPlayer.HasPermission(PermissionUseCodeLock) || player.IsBuildingBlocked())
                    uiState = UIState.None;

                if (uiState == UIState.AddLock && !_pluginInstance.CanPlayerDeployCodeLock(player, car))
                    uiState = UIState.None;

                UIState currentUIState;
                if (PlayerUIStates.TryGetValue(player, out currentUIState) && currentUIState == uiState)
                    return;

                DestroyPlayerUI(player);

                if (uiState != UIState.None)
                    SendPlayerUI(player, uiState);
            }

            public void DestroyPlayerUI(BasePlayer player)
            {
                if (PlayerUIStates.ContainsKey(player))
                {
                    CuiHelper.DestroyUi(player, CodeLockUIName);
                    PlayerUIStates.Remove(player);
                }
            }

            private void SendPlayerUI(BasePlayer player, UIState uiState)
            {
                var cuiElements = new CuiElementContainer
                {
                    {
                        new CuiButton
                        {
                            Text = {
                                Text = _pluginInstance.GetMessage(player.IPlayer, uiState == UIState.AddLock ? "UI.AddCodeLock" : "UI.RemoveCodeLock"),
                                Color = Settings.ButtonTextColor,
                                Align = TextAnchor.MiddleCenter,
                                FadeIn = 0.25f
                            },
                            Button =
                            {
                                Color = uiState == UIState.AddLock ? Settings.AddButtonColor : Settings.RemoveButtonColor,
                                Command = uiState == UIState.AddLock ? "carlockui.deploy.codelock" : "carlockui.remove.codelock"
                            },
                            RectTransform =
                            {
                                AnchorMin = Settings.AnchorMin,
                                AnchorMax = Settings.AnchorMax,
                                OffsetMin = Settings.OffsetMin,
                                OffsetMax = Settings.OffsetMax
                            }
                        },
                        "Hud.Menu",
                        CodeLockUIName
                    }
                };

                CuiHelper.AddUi(player, cuiElements);
                PlayerUIStates.Add(player, uiState);
            }
        }

        #endregion

        #region Configuration

        private Configuration GetDefaultConfig() => new Configuration();

        private class Configuration : SerializableConfiguration
        {
            [JsonProperty("UISettings")]
            public UISettings UISettings = new UISettings();
        }

        private class UISettings
        {
            [JsonProperty("AnchorMin")]
            public string AnchorMin = "0.5 0";

            [JsonProperty("AnchorMax")]
            public string AnchorMax = "0.5 0";

            [JsonProperty("OffsetMin")]
            public string OffsetMin = "385.5 349";

            [JsonProperty("OffsetMax")]
            public string OffsetMax = "572.5 377";

            [JsonProperty("AddButtonColor")]
            public string AddButtonColor = "0.44 0.54 0.26 1";

            [JsonProperty("RemoveButtonColor")]
            public string RemoveButtonColor = "0.7 0.3 0 1";

            [JsonProperty("ButtonTextColor")]
            public string ButtonTextColor = "0.97 0.92 0.88 1";
        }

        #endregion

        #region Configuration Boilerplate

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _pluginConfig = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _pluginConfig = Config.ReadObject<Configuration>();
                if (_pluginConfig == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_pluginConfig))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_pluginConfig, true);
        }

        #endregion

        #region Localization

        private string GetMessage(IPlayer player, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, player.Id);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["UI.AddCodeLock"] = "Add Code Lock",
                ["UI.RemoveCodeLock"] = "REMOVE Code Lock",
            }, this, "en");
        }

        #endregion
    }
}


// --- End of file: CarLockUI.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/copy-paste ---
// --- Original File Path: C/CopyPaste/CopyPaste.cs ---

//If debug is defined it will add a stopwatch to the paste and copydata which can be used to profile copying and pasting.
// #define DEBUG

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Linq;
using System.Text;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Libraries.Covalence;
using ProtoBuf;
using UnityEngine;
using Graphics = System.Drawing.Graphics;

#if DEBUG
using System.Diagnostics;
#endif

// ReSharper disable SpecifyACultureInStringConversionExplicitly

/*
 * CREDITS
 *
 * Orange - Saving ContainerIOEntity
 * UIP88 - Turrets fix
 * bsdinis - Wire fix
 * nivex - Ownership option, sign fix
 * bmgjet - Wallpapers, pattern firework, industrial
 * DezLife - CCTV fix
 * Wulf - Skipping 4.1.24 :D
 * 
 */

namespace Oxide.Plugins
{
    [Info("Copy Paste", "misticos", "4.2.0")]
    [Description("Copy and paste buildings to save them or move them")]
    public class CopyPaste : CovalencePlugin
    {
        // ReSharper disable once Unity.IncorrectMonoBehaviourInstantiation
        private readonly Item _emptyItem = new Item { info = new ItemDefinition() };
        private readonly IPlayer _consolePlayer = new RustConsolePlayer();

        private int _copyLayer =
                LayerMask.GetMask("Construction", "Prevent Building", "Construction Trigger", "Trigger", "Deployed",
                    "Default", "Ragdoll"),
            _groundLayer = LayerMask.GetMask("Terrain", "Default"),
            _rayCopy = LayerMask.GetMask("Construction", "Deployed", "Tree", "Resource", "Prevent Building"),
            _rayPaste = LayerMask.GetMask("Construction", "Deployed", "Tree", "Terrain", "World", "Water",
                "Prevent Building");

        private string _copyPermission = "copypaste.copy",
            _listPermission = "copypaste.list",
            _pastePermission = "copypaste.paste",
            _pastebackPermission = "copypaste.pasteback",
            _undoPermission = "copypaste.undo",
            _subDirectory = "copypaste/";

        private Dictionary<string, Stack<List<BaseEntity>>> _lastPastes =
            new Dictionary<string, Stack<List<BaseEntity>>>();

        private Dictionary<string, SignSize> _signSizes = new Dictionary<string, SignSize>
        {
            //{"spinner.wheel.deployed", new SignSize(512, 512)},
            { "sign.pictureframe.landscape", new SignSize(256, 192) },
            { "sign.pictureframe.tall", new SignSize(128, 512) },
            { "sign.pictureframe.portrait", new SignSize(205, 256) },
            { "sign.pictureframe.xxl", new SignSize(1024, 512) },
            { "sign.pictureframe.xl", new SignSize(512, 512) },
            { "sign.small.wood", new SignSize(256, 128) },
            { "sign.medium.wood", new SignSize(512, 256) },
            { "sign.large.wood", new SignSize(512, 256) },
            { "sign.huge.wood", new SignSize(1024, 256) },
            { "sign.hanging.banner.large", new SignSize(256, 1024) },
            { "sign.pole.banner.large", new SignSize(256, 1024) },
            { "sign.post.single", new SignSize(256, 128) },
            { "sign.post.double", new SignSize(512, 512) },
            { "sign.post.town", new SignSize(512, 256) },
            { "sign.post.town.roof", new SignSize(512, 256) },
            { "sign.hanging", new SignSize(256, 512) },
            { "sign.hanging.ornate", new SignSize(512, 256) },
            { "sign.neon.xl.animated", new SignSize(256, 256) },
            { "sign.neon.xl", new SignSize(256, 256) },
            { "sign.neon.125x215.animated", new SignSize(256, 128) },
            { "sign.neon.125x215", new SignSize(256, 128) },
            { "sign.neon.125x125", new SignSize(128, 128) },
        };

        private HashSet<Type> ItemModAssociatedEntities = new()
        {
            typeof(PaintedItemStorageEntity),
            typeof(PhotoEntity),
            typeof(SignContent),
            typeof(HeadEntity),
            typeof(PagerEntity),
            typeof(MobileInventoryEntity),
            typeof(Cassette)
        };

        private List<BaseEntity.Slot> _checkSlots = new List<BaseEntity.Slot>
        {
            BaseEntity.Slot.Lock,
            BaseEntity.Slot.UpperModifier,
            BaseEntity.Slot.MiddleModifier,
            BaseEntity.Slot.LowerModifier
        };

        public enum CopyMechanics
        {
            Building,
            Proximity
        }

        private class SignSize
        {
            public int Width;
            public int Height;

            public SignSize(int width, int height)
            {
                Width = width;
                Height = height;
            }
        }

        //Config

        private ConfigData _config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Copy Options")]
            public CopyOptions Copy { get; set; }

            [JsonProperty(PropertyName = "Paste Options")]
            public PasteOptions Paste { get; set; }

            [JsonProperty(PropertyName =
                "Amount of entities to paste per batch. Use to tweak performance impact of pasting")]
            [DefaultValue(15)]
            public int PasteBatchSize = 15;

            [JsonProperty(PropertyName =
                "Amount of entities to copy per batch. Use to tweak performance impact of copying")]
            [DefaultValue(100)]
            public int CopyBatchSize = 100;

            [JsonProperty(PropertyName =
                "Amount of entities to undo per batch. Use to tweak performance impact of undoing")]
            [DefaultValue(15)]
            public int UndoBatchSize = 15;

            [JsonProperty(PropertyName = "Enable data saving feature")]
            [DefaultValue(true)]
            public bool DataSaving = true;

            public class CopyOptions
            {
                [JsonProperty(PropertyName = "Check radius from each entity (true/false)")]
                [DefaultValue(true)]
                public bool EachToEach { get; set; } = true;

                [JsonProperty(PropertyName = "Share (true/false)")]
                [DefaultValue(false)]
                public bool Share { get; set; } = false;

                [JsonProperty(PropertyName = "Tree (true/false)")]
                [DefaultValue(false)]
                public bool Tree { get; set; } = false;

                [JsonProperty(PropertyName = "Default radius to look for entities from block")]
                [DefaultValue(3.0f)]
                public float Radius { get; set; } = 3.0f;
            }

            public class PasteOptions
            {
                [JsonProperty(PropertyName = "Auth (true/false)")]
                [DefaultValue(false)]
                public bool Auth { get; set; } = false;

                [JsonProperty(PropertyName = "Deployables (true/false)")]
                [DefaultValue(true)]
                public bool Deployables { get; set; } = true;

                [JsonProperty(PropertyName = "Inventories (true/false)")]
                [DefaultValue(true)]
                public bool Inventories { get; set; } = true;

                [JsonProperty(PropertyName = "Vending Machines (true/false)")]
                [DefaultValue(true)]
                public bool VendingMachines { get; set; } = true;

                [JsonProperty(PropertyName = "Stability (true/false)")]
                [DefaultValue(true)]
                public bool Stability { get; set; } = true;

                [JsonProperty(PropertyName = "EntityOwner (true/false)")]
                [DefaultValue(true)]
                public bool EntityOwner { get; set; } = true;
            }
        }

        private void LoadVariables()
        {
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;

            _config = Config.ReadObject<ConfigData>();

            Config.WriteObject(_config, true);
        }

        protected override void LoadDefaultConfig()
        {
            var configData = new ConfigData
            {
                Copy = new ConfigData.CopyOptions(),
                Paste = new ConfigData.PasteOptions()
            };

            Config.WriteObject(configData, true);
        }

        //Hooks

        private void Init()
        {
            permission.RegisterPermission(_copyPermission, this);
            permission.RegisterPermission(_listPermission, this);
            permission.RegisterPermission(_pastePermission, this);
            permission.RegisterPermission(_pastebackPermission, this);
            permission.RegisterPermission(_undoPermission, this);

            var compiledLangs = new Dictionary<string, Dictionary<string, string>>();

            foreach (var line in _messages)
            {
                foreach (var translate in line.Value)
                {
                    if (!compiledLangs.ContainsKey(translate.Key))
                        compiledLangs[translate.Key] = new Dictionary<string, string>();

                    compiledLangs[translate.Key][line.Key] = translate.Value;
                }
            }

            foreach (var cLangs in compiledLangs)
            {
                lang.RegisterMessages(cLangs.Value, this, cLangs.Key);
            }
        }

        private void OnServerInitialized()
        {
            LoadVariables();

            Vis.colBuffer = new Collider[8192 * 16];

            JsonConvert.DefaultSettings = () => new JsonSerializerSettings
            {
                Formatting = Formatting.Indented,
                ReferenceLoopHandling = ReferenceLoopHandling.Ignore
            };
        }

        #region API

        private object TryCopyFromSteamId(ulong userId, string filename, string[] args, Action callback = null)
        {
            var player = players.FindPlayerById(userId.ToString())?.Object as BasePlayer;
            if (player == null)
                return Lang("NOT_FOUND_PLAYER");

            RaycastHit hit;

            if (!Physics.Raycast(player.eyes.HeadRay(), out hit, 1000f, _rayCopy))
                return Lang("NO_ENTITY_RAY", player.UserIDString);

            var entity = hit.GetEntity();
            if (!entity.IsValid())
                return Lang("NO_ENTITY_RAY", player.UserIDString);

            return TryCopy(hit.point, entity.GetNetworkRotation().eulerAngles, filename,
                DegreeToRadian(player.GetNetworkRotation().eulerAngles.y), args, player.IPlayer, callback);
        }

        private object TryPasteFromSteamId(ulong userId, string filename, string[] args, Action callback = null,
            Action<BaseEntity> callbackSpawned = null)
        {
            var player = players.FindPlayerById(userId.ToString())?.Object as BasePlayer;
            if (player == null)
                return Lang("NOT_FOUND_PLAYER");

            RaycastHit hit;

            if (!Physics.Raycast(player.eyes.HeadRay(), out hit, 1000f, _rayPaste))
                return Lang("NO_ENTITY_RAY", player.UserIDString);

            return TryPaste(hit.point, filename, player.IPlayer,
                DegreeToRadian(player.GetNetworkRotation().eulerAngles.y),
                args, callback: callback, callbackSpawned: callbackSpawned).Item1;
        }

        private object TryPasteFromVector3(Vector3 pos, float rotationCorrection, string filename, string[] args,
            Action callback = null, Action<BaseEntity> callbackSpawned = null)
        {
            return TryPaste(pos, filename, _consolePlayer, rotationCorrection, args, callback: callback,
                callbackSpawned: callbackSpawned).Item1;
        }

        private ValueTuple<object, Action> TryPasteFromVector3Cancellable(Vector3 pos, float rotationCorrection,
            string filename, string[] args,
            Action callback = null, Action<BaseEntity> callbackSpawned = null)
        {
            var result = TryPaste(pos, filename, _consolePlayer, rotationCorrection, args, callback: callback,
                callbackSpawned: callbackSpawned);

            var pasteData = result.Item2;

            return new ValueTuple<object, Action>(result.Item1, () => pasteData.Cancelled = true);
        }

        #endregion

        //Other methods

        private object CheckCollision(HashSet<Dictionary<string, object>> entities, Vector3 startPos, float radius)
        {
            foreach (var entityobj in entities)
            {
                if (Physics.CheckSphere((Vector3)entityobj["position"], radius, _copyLayer))
                    return Lang("BLOCKING_PASTE");
            }

            return true;
        }

        private bool CheckPlaced(string prefabname, Vector3 pos, Quaternion rot)
        {
            const float maxDiff = 0.01f;

            var ents = Pool.Get<List<BaseEntity>>();
            try
            {
                Vis.Entities(pos, maxDiff, ents);

                foreach (var ent in ents)
                {
                    if (ent.IsDestroyed || ent.PrefabName != prefabname)
                        continue;

                    if (Vector3.Distance(ent.transform.position, pos) > maxDiff)
                    {
                        continue;
                    }

                    if (Vector3.Distance(ent.transform.rotation.eulerAngles, rot.eulerAngles) > maxDiff)
                    {
                        continue;
                    }

                    return true;
                }

                return false;
            }
            finally
            {
                Pool.FreeUnmanaged(ref ents);
            }
        }

        private void UndoLoop(HashSet<BaseEntity> entities, IPlayer player, int count = 0)
        {
            foreach (var storageContainer in entities.OfType<StorageContainer>().Where(x => !x.IsDestroyed))
            {
                storageContainer.Kill();
            }

            // Take an amount of entities from the entity list (defined in config) and kill them. Will be repeated for every tick until there are no entities left.
            entities
                .Take(_config.UndoBatchSize)
                .ToList()
                .ForEach(p =>
                {
                    entities.Remove(p);

                    // Cleanup the hotspot beloning to the node.
                    var ore = p as OreResourceEntity;
                    if (ore != null)
                    {
                        ore.CleanupBonus();
                    }

                    var io = p as IOEntity;
                    if (io != null)
                    {
                        io.ClearConnections();
                    }

                    var autoTurret = p as AutoTurret;
                    if (autoTurret != null)
                    {
                        AutoTurret.interferenceUpdateList.Remove(autoTurret);
                    }

                    if (p != null && !p.IsDestroyed)
                        p.Kill();
                });

            // If it gets stuck in infinite loop break the loop.
            if (count != 0 && entities.Count != 0 && entities.Count == count)
            {
                player?.Reply("Undo cancelled because of infinite loop.");
                return;
            }

            if (entities.Count > 0)
                NextTick(() => UndoLoop(entities, player, entities.Count));
            else if (player != null)
            {
                player.Reply(Lang("UNDO_SUCCESS", player.Id));

                if (_lastPastes.ContainsKey(player.Id) && _lastPastes[player.Id].Count == 0)
                    _lastPastes.Remove(player.Id);
            }
        }

        private void Copy(Vector3 sourcePos, Vector3 sourceRot, string filename, float rotationCorrection,
            CopyMechanics copyMechanics, float range, bool saveTree, bool saveShare, bool eachToEach, IPlayer player,
            Action callback)
        {
            var currentLayer = _copyLayer;

            if (saveTree)
                currentLayer |= LayerMask.GetMask("Tree");

            var copyData = new CopyData
            {
                Filename = filename,
                CurrentLayer = currentLayer,
                RotCor = rotationCorrection,
                Range = range,
                SaveShare = saveShare,
                SaveTree = saveTree,
                CopyMechanics = copyMechanics,
                EachToEach = eachToEach,
                SourcePos = sourcePos,
                SourceRot = sourceRot,
                Player = player,
                BasePlayer = player.Object as BasePlayer,
                Callback = callback
            };

            copyData.CheckFrom.Push(sourcePos);

            NextTick(() => CopyLoop(copyData));
        }

        // Main loop for copy, will fetch all the data needed. Is called every tick untill copy is done (can't find any entities)
        private void CopyLoop(CopyData copyData)
        {
            var checkFrom = copyData.CheckFrom;
            var houseList = copyData.HouseList;
            var buildingId = copyData.BuildingId;
            var copyMechanics = copyData.CopyMechanics;
            var batchSize = checkFrom.Count < _config.CopyBatchSize ? checkFrom.Count : _config.CopyBatchSize;

            for (var i = 0; i < batchSize; i++)
            {
                if (checkFrom.Count == 0)
                    break;

                var list = Pool.Get<List<BaseEntity>>();
                try
                {
                    Vis.Entities(checkFrom.Pop(), copyData.Range, list, copyData.CurrentLayer);

                    foreach (var entity in list)
                    {
                        // Skip entities that are already in the list
                        if (!entity.IsValid() || entity.HasParent())
                            continue;
                        
                        // Skip metal detector flags
                        if (entity.GetComponent<MetalDetectorSource>() != null)
                            continue;
                        
                        if (!houseList.Add(entity))
                            continue;

                        if (copyMechanics == CopyMechanics.Building)
                        {
                            var buildingBlock = entity.GetComponentInParent<BuildingBlock>();

                            if (buildingBlock != null)
                            {
                                if (buildingId == 0)
                                    buildingId = buildingBlock.buildingID;

                                if (buildingId != buildingBlock.buildingID)
                                    continue;
                            }
                        }

                        var transform = entity.transform;
                        if (copyData.EachToEach)
                            checkFrom.Push(transform.position);

                        if (entity.GetComponent<BaseLock>() != null)
                            continue;
                        
                        copyData.RawData.Add(EntityData(entity, transform.position,
                            transform.rotation.eulerAngles / Mathf.Rad2Deg, copyData));
                    }
                }
                finally
                {
                    Pool.FreeUnmanaged(ref list);
                }

                copyData.BuildingId = buildingId;
            }

            if (checkFrom.Count > 0)
            {
                NextTick(() => CopyLoop(copyData));
            }
            else
            {
                var path = _subDirectory + copyData.Filename;
                var datafile = Interface.Oxide.DataFileSystem.GetFile(path);

                datafile.Clear();

                var sourcePos = copyData.SourcePos;

                datafile["default"] = new Dictionary<string, object>
                {
                    {
                        "position", new Dictionary<string, object>
                        {
                            { "x", sourcePos.x.ToString() },
                            { "y", sourcePos.y.ToString() },
                            { "z", sourcePos.z.ToString() }
                        }
                    },
                    { "rotationy", copyData.SourceRot.y.ToString() },
                    { "rotationdiff", copyData.RotCor.ToString() }
                };

                datafile["entities"] = copyData.RawData;
                datafile["protocol"] = new Dictionary<string, object>
                {
                    { "items", 2 },
                    { "version", Version }
                };

                Interface.Oxide.DataFileSystem.SaveDatafile(path);

                copyData.Player.Reply(Lang("COPY_SUCCESS", copyData.Player.Id, copyData.Filename));

                copyData.Callback?.Invoke();

                Interface.CallHook("OnCopyFinished", copyData.RawData, copyData.Filename, copyData.Player, copyData.SourcePos);
            }
        }

        private float DegreeToRadian(float angle)
        {
            return (float)(Math.PI * angle / 180.0f);
        }

        private Dictionary<string, object> EntityData(BaseEntity entity, Vector3 entPos, Vector3 entRot,
            CopyData copyData)
        {
            var normalizedPos = NormalizePosition(copyData.SourcePos, entPos, copyData.RotCor);
            var isChild = entity.HasParent();

            entRot.y -= copyData.RotCor;

            var data = new Dictionary<string, object>
            {
                { "prefabname", entity.PrefabName },
                { "skinid", entity.skinID },
                { "flags", TryCopyFlags(entity) },
                {
                    "pos", new Dictionary<string, object>
                    {
                        { "x", isChild ? entity.transform.localPosition.x.ToString() : normalizedPos.x.ToString() },
                        { "y", isChild ? entity.transform.localPosition.y.ToString() : normalizedPos.y.ToString() },
                        { "z", isChild ? entity.transform.localPosition.z.ToString() : normalizedPos.z.ToString() }
                    }
                },
                {
                    "rot", new Dictionary<string, object>
                    {
                        { "x", isChild ? entity.transform.localRotation.eulerAngles.x.ToString() : entRot.x.ToString() },
                        { "y", isChild ? entity.transform.localRotation.eulerAngles.y.ToString() : entRot.y.ToString() },
                        { "z", isChild ? entity.transform.localRotation.eulerAngles.z.ToString() : entRot.z.ToString() }
                    }
                },
                { "ownerid", entity.OwnerID }
            };

            if (entity.HasParent())
            {
                if (entity.parentBone != 0)
                {
                    data.Add("parentbone", StringPool.Get(entity.parentBone));
                }

                if (GetSlot(entity.GetParentEntity(), entity, out BaseEntity.Slot? theslot) && theslot != null)
                {
                    data.Add("slot", (int)theslot);
                }
            }

            if (entity.children != null && entity.children.Count > 0)
            {
                var children = new List<object>();
                foreach (var child in entity.children)
                {
                    if (!child.IsValid())
                        continue;
                    
                    children.Add(EntityData(child, child.transform.position, child.transform.rotation.eulerAngles, copyData));
                }

                if( children.Count > 0 )
                    data.Add("children", children);
            }

            var growableEntity = entity as GrowableEntity;
            if (growableEntity != null)
            {
                var genes = GrowableGeneEncoding.EncodeGenesToInt(growableEntity.Genes);
                if (genes > 0)
                {
                    data.Add("genes", genes);
                }

                var perent = growableEntity.GetParentEntity();
                if (perent != null)
                {
                    data.Add("hasParent", true);
                }
            }

            // TryCopySlots(entity, data, copyData.SaveShare);

            var codeLock = entity.GetComponent<CodeLock>();
            if (codeLock != null)
            {
                data.Add("code", codeLock.code);

                if (copyData.SaveShare)
                    data.Add("whitelistPlayers", codeLock.whitelistPlayers);

                if (codeLock.guestCode != null && codeLock.guestCode.Length == 4)
                {
                    data.Add("guestCode", codeLock.guestCode);

                    if (copyData.SaveShare)
                        data.Add("guestPlayers", codeLock.guestPlayers);
                }
            }
            
            var keyLock = entity.GetComponent<KeyLock>();
            if (keyLock != null)
            {
                data.Add("code", keyLock.keyCode.ToString());
                data.Add("firstKeyCreated", keyLock.firstKeyCreated);
            }
            
            var buildingblock = entity as BuildingBlock;

            if (buildingblock != null)
            {
                data.Add("grade", buildingblock.grade);
                if (buildingblock.customColour != 0)
                {
                    data.Add("customColour", buildingblock.customColour);
                }
                if (buildingblock.HasWallpaper())
                {
                    data.Add("wallpaperID", buildingblock.wallpaperID);
                    data.Add("wallpaperHealth", buildingblock.wallpaperHealth);
                }
            }

            var container = entity as IItemContainerEntity;
            if (container != null && container.inventory != null)
            {
                ExtractInventory(data, container.inventory, copyData);
            }

            var iSignage = entity as ISignage;
            if (iSignage != null)
            {
                ExtractTextures(data, iSignage.GetTextureCRCs(), entity, iSignage.FileType);
            }

            var photoEntity = entity as PhotoEntity;
            if (photoEntity != null)
            {
                ExtractTextures(data, photoEntity.GetContentCRCs, entity, FileStorage.Type.jpg);
            }

            var photoFrame = entity as PhotoFrame;
            if (photoFrame != null && photoFrame._photoEntity.uid.IsValid)
            {
                data.Add("photoEntity", photoFrame._photoEntity.uid.Value);
            }

            var signContent = entity as SignContent;
            if (signContent != null)
            {
                ExtractTextures(data, signContent.GetContentCRCs, entity, signContent.FileType);
            }

            var paintedItemStorageEntity = entity as PaintedItemStorageEntity;
            if (paintedItemStorageEntity != null)
            {
                ExtractTextures(data, paintedItemStorageEntity.GetContentCRCs, entity, FileStorage.Type.png);
            }

            var lights = entity as AdvancedChristmasLights;
            if (lights != null)
            {
                var lightsPointsList = new List<Dictionary<string, object>>();
                foreach (var lightsPoint in lights.points)
                {
                    lightsPointsList.Add(new Dictionary<string, object>
                    {
                        { "normal", lightsPoint.normal },
                        { "point", NormalizePosition(copyData.SourcePos, lightsPoint.point, copyData.RotCor) },
                        { "slack", lightsPoint.slack },
                    });
                }
                data.Add("points", lightsPointsList);
                data.Add("animationStyle", lights.animationStyle);
            }

            if (copyData.SaveShare)
            {
                var sleepingBag = entity as SleepingBag;

                if (sleepingBag != null)
                {
                    data.Add("sleepingbag", new Dictionary<string, object>
                    {
                        { "niceName", sleepingBag.niceName },
                        { "deployerUserID", sleepingBag.deployerUserID },
                        { "isPublic", sleepingBag.IsPublic() }
                    });
                }

                var cupboard = entity as BuildingPrivlidge;

                if (cupboard != null)
                {
                    data.Add("cupboard", new Dictionary<string, object>
                    {
                        { "authorizedPlayers", cupboard.authorizedPlayers.Select(y => y.userid).ToList() }
                    });
                }

                var autoTurret = entity as AutoTurret;

                if (autoTurret != null)
                {
                    data.Add("autoturret", new Dictionary<string, object>
                    {
                        { "authorizedPlayers", autoTurret.authorizedPlayers.Select(p => p.userid).ToList() }
                    });
                }
            }

            var firework = entity as PatternFirework;
            if (firework != null && firework?.Design != null && firework?.Design?.stars != null)
            {
                data.Add("patternfirework", new Dictionary<string, object>
                {
                    { "editedBy", firework.Design.editedBy },
                    { "stars", SerializeStarPattern(firework.Design.stars) },
                });
            }

            var tinCanAlarm = entity as TinCanAlarm;
            if (tinCanAlarm != null)
            {
                if (tinCanAlarm.endPoint != Vector3.zero)
                {
                    data.Add("endPoint", NormalizePosition(copyData.SourcePos, tinCanAlarm.endPoint, copyData.RotCor));
                }
            }

            var cctvRc = entity as CCTV_RC;
            if (cctvRc != null)
            {
                data.Add("cctv", new Dictionary<string, object>
                {
                    { "yaw", cctvRc.yawAmount },
                    { "pitch", cctvRc.pitchAmount },
                    { "rcIdentifier", cctvRc.rcIdentifier }
                });
            }

            var headEntity = entity as HeadEntity;
            if (headEntity != null)
            {
                ExtractHeadData(data, headEntity.CurrentTrophyData);
            }

            var huntingTrophy = entity as HuntingTrophy;
            if (huntingTrophy != null)
            {
                ExtractHeadData(data, huntingTrophy.CurrentTrophyData);
            }

            // Save RF frequencies for non-IOEntity RF objects (IOEntity frequencies are handled separately)
            var rfObject = entity as IRFObject;
            if (rfObject != null && entity is not IOEntity)
            {
                var frequency = rfObject.GetFrequency();
                if (frequency > 0)
                    data.Add("frequency", frequency);
            }

            var cassette = entity as Cassette;
            if (cassette != null)
            {
                ExtractCassette(data, cassette);
            }

            var elevator = entity as Elevator;
            if (elevator != null)
            {
                data.Add("Floor", elevator.Floor);
            }

            var weaponRack = entity as WeaponRack;
            if (weaponRack != null)
            {
                var gridSlots = new List<object>();
                foreach (var weaponRackGridSlot in weaponRack.gridSlots)
                {
                    if (weaponRackGridSlot != null && weaponRackGridSlot.Used)
                    {
                        gridSlots.Add(new Dictionary<string, object>
                        {
                            { "GridSlotIndex", weaponRackGridSlot.GridSlotIndex },
                            { "InventoryIndex", weaponRackGridSlot.InventoryIndex },
                            { "Rotation", weaponRackGridSlot.Rotation },
                        });
                    }
                }

                data.Add("gridSlots", gridSlots);
            }

            var phoneController = entity.GetComponent<PhoneController>();
            if (phoneController != null && phoneController.savedVoicemail != null && phoneController.savedVoicemail.Count > 0)
            {
                var savedVoicemail = new List<object>();
                foreach (var voicemail in phoneController.savedVoicemail)
                {
                    var oggByte = FileStorage.server.Get(voicemail.audioId, FileStorage.Type.ogg, entity.net.ID);
                    if (oggByte != null)
                    {
                        savedVoicemail.Add(new Dictionary<string, object>
                        {
                            { "audio", Convert.ToBase64String(oggByte) },
                            { "userName", voicemail.userName }
                        });
                    }
                }

                data.Add("savedVoicemail", savedVoicemail);
            }

            var vendingMachine = entity as VendingMachine;

            if (vendingMachine != null)
            {
                var sellOrders = new List<object>();

                foreach (var vendItem in vendingMachine.sellOrders.sellOrders)
                {
                    sellOrders.Add(new Dictionary<string, object>
                    {
                        { "itemToSellID", vendItem.itemToSellID },
                        { "itemToSellAmount", vendItem.itemToSellAmount },
                        { "currencyID", vendItem.currencyID },
                        { "currencyAmountPerItem", vendItem.currencyAmountPerItem },
                        { "inStock", vendItem.inStock },
                        { "currencyIsBP", vendItem.currencyIsBP },
                        { "itemToSellIsBP", vendItem.itemToSellIsBP }
                    });
                }

                data.Add("vendingmachine", new Dictionary<string, object>
                {
                    { "shopName", vendingMachine.shopName },
                    { "isBroadcasting", vendingMachine.IsBroadcasting() },
                    { "sellOrders", sellOrders }
                });
            }

            var ioEntity = entity as IOEntity;

            if (ioEntity.IsValid() && !ioEntity.IsDestroyed)
            {
                var ioData = new Dictionary<string, object>();
                var inputs = ioEntity.inputs.Select(input => new Dictionary<string, object>
                    {
                        { "connectedID", input.connectedTo.entityRef.uid.Value },
                        { "connectedToSlot", input.connectedToSlot },
                        { "niceName", input.niceName },
                        { "wireColour", input.wireColour },
                        { "type", (int)input.type }
                    })
                    .Cast<object>()
                    .ToList();

                ioData.Add("inputs", inputs);

                var outputs = new List<object>();
                foreach (var output in ioEntity.outputs)
                {
                    var ioConnection = new Dictionary<string, object>
                    {
                        { "connectedID", output.connectedTo.entityRef.uid.Value },
                        { "connectedToSlot", output.connectedToSlot },
                        { "niceName", output.niceName },
                        { "wireColour", output.wireColour },
                        { "type", (int)output.type },
                        { "linePoints", output.linePoints?.ToList() ?? new List<Vector3>() },
                        { "lineAnchors", output.lineAnchors != null ? GetLineAnchors(output.lineAnchors, ioEntity) : new List<object>() },
                        { "slackLevels", output.slackLevels?.ToList() ?? new List<float>() },
                    };

                    outputs.Add(ioConnection);
                }

                ioData.Add("outputs", outputs);
                ioData.Add("oldID", ioEntity.net.ID.Value);
                var electricalBranch = ioEntity as ElectricalBranch;
                if (electricalBranch != null)
                {
                    ioData.Add("branchAmount", electricalBranch.branchAmount);
                }

                var counter = ioEntity as PowerCounter;
                if (counter != null)
                {
                    ioData.Add("targetNumber", counter.GetTarget());
                    ioData.Add("counterNumber", counter.counterNumber);
                }

                var timerSwitch = ioEntity as TimerSwitch;
                if (timerSwitch != null)
                {
                    ioData.Add("timerLength", timerSwitch.timerLength);
                }

                var rfBroadcaster = ioEntity as IRFObject;
                if (rfBroadcaster != null)
                {
                    ioData.Add("frequency", rfBroadcaster.GetFrequency());
                }

                var seismicSensor = ioEntity as SeismicSensor;
                if (seismicSensor != null)
                {
                    ioData.Add("range", seismicSensor.range);
                }

                var conveyor = ioEntity as IndustrialConveyor;
                if (conveyor != null)
                {
                    ioData.Add("industrialconveyormode", (int)conveyor.mode);
                    ioData.Add("industrialconveyorfilteritems", SerializeConveyorFilter(conveyor.filterItems));
                }

                var digitalClock = ioEntity as DigitalClock;
                if (digitalClock != null)
                {
                    var alarms = new List<object>();
                    foreach (var alarm in digitalClock.alarms)
                    {
                        alarms.Add(new Dictionary<string, object>
                        {
                            { "time", alarm.time },
                            { "active", alarm.active },
                        });
                    }

                    ioData.Add("muted", digitalClock.muted);
                    ioData.Add("alarms", alarms);
                }

                data.Add("IOEntity", ioData);
            }

            if (entity is StorageContainer || entity is Door || (isChild && entity is not IOEntity))
            {
                data.Add("oldID", entity.net.ID.Value);
            }

            return data;
        }
        
        private List<object> GetLineAnchors(IOEntity.LineAnchor[] lineAnchors, IOEntity ioEntity)
        {
            var anchors = new List<object>();
            foreach (var anchor in lineAnchors)
            {
                anchors.Add(new Dictionary<string, object>
                {
                    { "position", new Dictionary<string, object>
                        {
                            { "x", anchor.position.x.ToString() },
                            { "y", anchor.position.y.ToString() },
                            { "z", anchor.position.z.ToString() }
                        }
                    },
                    { "index", anchor.index },
                    { "boneName", anchor.boneName },
                    { "entityRefID", anchor.entityRef.uid.Value }
                });
            }

            return anchors;
        }

        private object FindBestHeight(HashSet<Dictionary<string, object>> entities, Vector3 startPos)
        {
            var maxHeight = 0f;

            foreach (var entity in entities)
            {
                var prefab = (string)entity["prefabname"];
                if (prefab.Contains("/foundation/") || prefab.Contains("/foundation.triangle/"))
                {
                    var foundHeight = GetGround((Vector3)entity["position"]);

                    if (foundHeight != null)
                    {
                        var height = (Vector3)foundHeight;

                        if (height.y > maxHeight)
                            maxHeight = height.y;
                    }
                }
            }

            maxHeight += 1f;

            return maxHeight;
        }

        private bool FindRayEntity(Vector3 sourcePos, Vector3 sourceDir, out Vector3 point, out BaseEntity entity,
            int rayLayer)
        {
            RaycastHit hitinfo;
            entity = null;
            point = Vector3.zero;

            if (!Physics.Raycast(sourcePos, sourceDir, out hitinfo, 1000f, rayLayer))
                return false;

            entity = hitinfo.GetEntity();
            point = hitinfo.point;

            return true;
        }

        private byte[] FixSignage(ISignage iSignage, byte[] imageBytes)
        {
            var sign = iSignage as Signage;

            if (sign == null || !_signSizes.ContainsKey(sign.ShortPrefabName))
                return imageBytes;

            var size = Math.Max(sign.paintableSources.Length, 1);
            if (sign.textureIDs == null || sign.textureIDs.Length != size)
            {
                Array.Resize(ref sign.textureIDs, size);
            }

            return ImageResize(imageBytes, _signSizes[sign.ShortPrefabName].Width,
                _signSizes[sign.ShortPrefabName].Height);
        }

        private object GetGround(Vector3 pos)
        {
            RaycastHit hitInfo;
            pos += new Vector3(0, 100, 0);

            if (Physics.Raycast(pos, Vector3.down, out hitInfo, 200, _groundLayer))
                return hitInfo.point;

            return null;
        }

        private int GetItemId(int itemId)
        {
            if (ReplaceItemId.ContainsKey(itemId))
                return ReplaceItemId[itemId];

            return itemId;
        }

        private bool HasAccess(IPlayer player, string permName)
        {
            return player.IsAdmin || player.HasPermission(permName);
        }

        private byte[] ImageResize(byte[] imageBytes, int width, int height)
        {
            Bitmap resizedImage = new Bitmap(width, height),
                sourceImage = new Bitmap(new MemoryStream(imageBytes));

            Graphics.FromImage(resizedImage).DrawImage(sourceImage, new Rectangle(0, 0, width, height),
                new Rectangle(0, 0, sourceImage.Width, sourceImage.Height), GraphicsUnit.Pixel);

            var ms = new MemoryStream();
            resizedImage.Save(ms, ImageFormat.Png);

            return ms.ToArray();
        }

        private string Lang(string key, string userId = null, params object[] args) =>
            string.Format(lang.GetMessage(key, this, userId), args);

        private Vector3 NormalizePosition(Vector3 initialPos, Vector3 currentPos, float diffRot)
        {
            var transformedPos = currentPos - initialPos;
            var newX = transformedPos.x * (float)Math.Cos(-diffRot) +
                       transformedPos.z * (float)Math.Sin(-diffRot);
            var newZ = transformedPos.z * (float)Math.Cos(-diffRot) -
                       transformedPos.x * (float)Math.Sin(-diffRot);

            transformedPos.x = newX;
            transformedPos.z = newZ;

            return transformedPos;
        }

        private PasteData Paste(ICollection<Dictionary<string, object>> entities, Dictionary<string, object> protocol,
            bool ownership, Vector3 startPos, IPlayer player, bool stability, float rotationCorrection,
            float heightAdj, bool auth, Action callback, Action<BaseEntity> callbackSpawned, string filename, bool checkPlaced, bool enableSaving = true)
        {
            //Settings

            var isItemReplace = !protocol.ContainsKey("items");

            var eulerRotation = new Vector3(0f, rotationCorrection * Mathf.Rad2Deg, 0f);
            var quaternionRotation = Quaternion.Euler(eulerRotation);
            
            // Parse VersionNumber
            var version = protocol.ContainsKey("version") ? protocol["version"] as Dictionary<string, object> : null;
            
            VersionNumber vNumber = default;
            if (version != null)
                vNumber = new VersionNumber((int)version["Major"], (int)version["Minor"], (int)version["Patch"]);
            
            var pasteData = new PasteData
            {
                HeightAdj = heightAdj,
                IsItemReplace = isItemReplace,
                Entities = entities,
                Player = player,
                BasePlayer = player.Object as BasePlayer,
                QuaternionRotation = quaternionRotation,
                StartPos = startPos,
                Stability = stability,
                Auth = auth,
                Ownership = ownership,
                CallbackFinished = callback,
                CallbackSpawned = callbackSpawned,
                Filename = filename,
                CheckPlaced = checkPlaced,
                Version = vNumber,
                EnableSaving = enableSaving
            };

            NextTick(() => PasteLoop(pasteData));

            return pasteData;
        }

        private void PasteLoop(PasteData pasteData)
        {
            if (pasteData.Cancelled)
            {
                UndoLoop(new HashSet<BaseEntity>(pasteData.PastedEntities), pasteData.Player,
                    pasteData.PastedEntities.Count);
                
                return;
            }

            var entities = pasteData.Entities;
            var todo = entities.Take(_config.PasteBatchSize).ToArray();

            foreach (var data in todo)
            {
                entities.Remove(data);

                PasteEntity(data, pasteData);
            }

            if (entities.Count > 0)
                NextTick(() => PasteLoop(pasteData));
            else
            {
                foreach (var ioData in pasteData.EntityLookup.Values.ToArray())
                {
                    ProgressIOEntity(ioData, pasteData);
                }

                foreach (var keyPair in pasteData.ItemsWithSubEntity)
                {
                    SetItemSubEntity(pasteData, keyPair.Value, keyPair.Key);
                }

                foreach (var entity in pasteData.StabilityEntities)
                {
                    entity.grounded = false;
                    entity.InitializeSupports();
                    entity.UpdateStability();
                }

                foreach (var adapter in pasteData.industrialStorageAdaptors)
                {
                    if (adapter == null) { continue; }
                    if (!adapter.HasParent())
                    {
                        List<BaseEntity> ents = Facepunch.Pool.Get<List<BaseEntity>>();
                        Vis.Entities(adapter.transform.position + (adapter.transform.up * -0.2f), 0.01f, ents);
                        if (ents.Count > 0)
                        {
                            adapter.SetParent(ents[0], true, true);
                        }
                        Facepunch.Pool.FreeUnmanaged(ref ents);
                    }
                    adapter.MarkDirtyForceUpdateOutputs();
                    adapter.SendNetworkUpdateImmediate(false);
                    adapter.RefreshIndustrialPreventBuilding();
                    adapter.NotifyIndustrialNetworkChanged();
                }

                pasteData.FinalProcessingActions.ForEach(action => action());

                pasteData.Player.Reply(Lang("PASTE_SUCCESS", pasteData.Player.Id));
#if DEBUG
                pasteData.Player.Reply($"Stopwatch took: {pasteData.Sw.Elapsed.TotalMilliseconds} ms");
#endif

                if (!_lastPastes.ContainsKey(pasteData.Player.Id))
                    _lastPastes[pasteData.Player.Id] = new Stack<List<BaseEntity>>();

                _lastPastes[pasteData.Player.Id].Push(pasteData.PastedEntities);

                pasteData.CallbackFinished?.Invoke();

                Interface.CallHook("OnPasteFinished", pasteData.PastedEntities, pasteData.Filename, pasteData.Player, pasteData.StartPos);
            }
        }

        private void PasteEntity(Dictionary<string, object> data, PasteData pasteData, BaseEntity parent = null)
        {
            bool isChild = parent != null;
            
            var prefabname = (string)data["prefabname"];
#if DEBUG
            Puts($"{nameof(PasteLoop)}: Entity {prefabname}");
#endif
            
            var skinid = ulong.Parse(data["skinid"].ToString());
            var pos = isChild ? Vector3.zero : (Vector3)data["position"];
            var rot = isChild ? Quaternion.identity : (Quaternion)data["rotation"];
            var localPos = isChild ? (Vector3)data["position"] : Vector3.zero;
            var localRot = isChild ? (Quaternion)data["rotation"] : Quaternion.identity;
                
            var ownerId = pasteData.BasePlayer?.userID ?? 0;
            if (data.ContainsKey("ownerid"))
            {
#if DEBUG
                Puts($"{nameof(PasteLoop)}: Convert.ToUInt64 1077");
#endif
                ownerId = Convert.ToUInt64(data["ownerid"]);
            }

            if (pasteData.CheckPlaced && CheckPlaced(prefabname, pos, rot))
                return;

            if (prefabname.Contains("pillar"))
                return;

            // Used to copy locks for no reason in previous versions (is included in the slots info so no need to copy locks) so just skipping them.
            if (prefabname.Contains("locks") && pasteData.Version < new VersionNumber(4, 2, 0))
                return;

            BaseEntity entity = null;

            // Check to see if this child is already spawned
            if (isChild && parent.children != null)
            {
                foreach (var child in parent.children)
                {
                    if (child == null || child.IsDestroyed)
                        continue;

                    // Skip associated entities that can have multiple instances and always have localPosition set to Vector3.zero
                    if (ItemModAssociatedEntities.Contains(child.GetType()) && child.transform.localPosition == Vector3.zero)
                        continue;

                    if (child.PrefabName == prefabname && (child.transform.localPosition - localPos).sqrMagnitude < 0.001f)
                    {
                        entity = child;
                        break;
                    }
                }
            }

            if (entity == null)
                entity = GameManager.server.CreateEntity(prefabname, pos, rot);

            if (entity == null)
                return;
            
            var transform = entity.transform;
            
            // If the entity is a child, set the parent and the local position and rotation.
            if (isChild)
            {
                if (!entity.isSpawned)
                {
                    entity.gameObject.Identity();
                    if (data.ContainsKey("parentbone"))
                        entity.SetParent(parent, data["parentbone"].ToString());
                    else
                        entity.SetParent(parent);

                    // Custom door controllers and auto turrets don't have null checks for deployedBy baseplayer
                    if (entity is not CustomDoorManipulator && entity is not AutoTurret)
                        entity.OnDeployed(parent, null, _emptyItem);

                    transform.localPosition = localPos;
                    transform.localRotation = localRot;
                }
            }
            // If the entity is not a child, set the position and rotation.
            else
            {
                transform.position = pos;
                transform.rotation = rot;
            }

            if (pasteData.BasePlayer != null)
                entity.SendMessage("SetDeployedBy", pasteData.BasePlayer, SendMessageOptions.DontRequireReceiver);

            if (pasteData.Ownership)
                entity.OwnerID = ownerId;

            var buildingBlock = entity as BuildingBlock;
            if (buildingBlock != null)
            {
                buildingBlock.blockDefinition = PrefabAttribute.server.Find<Construction>(buildingBlock.prefabID);
                var grade = (BuildingGrade.Enum)Convert.ToInt32(data["grade"]);
                if (skinid != 0ul && !HasGrade(buildingBlock, grade, skinid))
                    skinid = 0ul;
                buildingBlock.SetGrade(grade);
                if (!pasteData.Stability)
                    buildingBlock.grounded = true;
            }

            var decayEntity = entity as DecayEntity;
            if (decayEntity != null)
            {
                if (pasteData.BuildingId == 0)
                    pasteData.BuildingId = BuildingManager.server.NewBuildingID();

                decayEntity.AttachToBuilding(pasteData.BuildingId);
            }

            var stabilityEntity = entity as StabilityEntity;
            if (stabilityEntity != null)
            {
                if (!stabilityEntity.grounded)
                {
                    stabilityEntity.grounded = true;
                    pasteData.StabilityEntities.Add(stabilityEntity);
                }
            }

            if (data.TryGetValue("oldID", out var oldIDString))
            {
                ulong oldID = Convert.ToUInt64(oldIDString);
                if (!pasteData.EntityLookup.ContainsKey(oldID))
                {
                    pasteData.EntityLookup.Add(oldID, new Dictionary<string, object>
                    {
                        { "entity", entity }
                    });
                }
            }

            entity.skinID = skinid;

            if (!pasteData.EnableSaving)
            {
                entity.enableSaving = false;
            }

            if (entity is ModularCar modularCar && data.TryGetValue("children", out var childrenObj))
            {
                // If there are children present, disable the default spawn settings to prevent stacking modules
                // on top of each other, which could cause the vehicle to be destroyed
                var children = childrenObj as List<object>;
                if (children != null && children.Count > 0)
                    modularCar.spawnSettings.useSpawnSettings = false;
            }

            if (!entity.isSpawned)
                entity.Spawn();

            if (entity.net == null || entity.IsDestroyed)
                return;

            var baseCombat = entity as BaseCombatEntity;
            if (buildingBlock != null)
            {
                buildingBlock.SetHealthToMax();
                buildingBlock.UpdateSkin();
                buildingBlock.SendNetworkUpdate();
                buildingBlock.ResetUpkeepTime();
                object customColour;
                if (data.TryGetValue("customColour", out customColour))
                    buildingBlock.SetCustomColour(Convert.ToUInt32(customColour));

                object wallpaperHealth;
                if (data.TryGetValue("wallpaperHealth", out wallpaperHealth))
                    buildingBlock.wallpaperHealth = Convert.ToInt32(wallpaperHealth);

                object wallpaperID;
                if (data.TryGetValue("wallpaperID", out wallpaperID))
                    buildingBlock.SetWallpaper(Convert.ToUInt64(wallpaperID));
            }
            else if (baseCombat != null)
                baseCombat.SetHealth(baseCombat.MaxHealth());

            var firework = entity as PatternFirework;
            if (firework != null && data.ContainsKey("patternfirework"))
            {
                if (firework?.Design == null)
                {
                    firework.Design = new ProtoBuf.PatternFirework.Design();
                    firework.Design.stars = new List<ProtoBuf.PatternFirework.Star>();
                }
                var pattern = (Dictionary<string, object>)data["patternfirework"];
                object editedBy;
                if (data.TryGetValue("editedBy", out editedBy))
                    firework.Design.editedBy = Convert.ToUInt32(pattern["editedBy"]);

                firework.Design.stars = DeSerializeStarPattern(pattern["stars"].ToString());
                firework.SendNetworkUpdate();
            }

            // This needs to stay for the old configs to load properly but is unused because of the new 'children' system.
            pasteData.PastedEntities.AddRange(TryPasteSlots(entity, data, pasteData));

            if (isChild && data.ContainsKey( "slot" ))
            {
                var slot = (BaseEntity.Slot) Convert.ToInt32(data["slot"]);
                if (parent.HasSlot( slot ))
                {
                    parent.SetSlot( slot, entity );
                }
            }
            
            TryPasteLocks(entity, data, pasteData);
            
            var autoTurret = entity as AutoTurret;
            if (autoTurret != null)
            {
                var authorizedPlayers = new List<ulong>();

                if (data.ContainsKey("autoturret"))
                {
#if DEBUG
                    Puts($"{nameof(PasteLoop)}: Convert.ToUInt64 1305");
#endif
                    var autoTurretData = data["autoturret"] as Dictionary<string, object>;
                    authorizedPlayers = (autoTurretData["authorizedPlayers"] as List<object>)
                        .Select(Convert.ToUInt64).ToList();
                }

                if (pasteData.BasePlayer != null && !authorizedPlayers.Contains(pasteData.BasePlayer.userID) &&
                    pasteData.Auth)
                    authorizedPlayers.Add(pasteData.BasePlayer.userID);

                foreach (var userId in authorizedPlayers)
                {
                    autoTurret.authorizedPlayers.Add(new PlayerNameID
                    {
                        userid = userId,
                        username = "Player"
                    });
                }

                autoTurret.SendNetworkUpdate();
            }

            var box = entity as IItemContainerEntity;
            if (box != null)
            {
                if (box.inventory == null)
                {
                    if (entity is StorageContainer storageContainer)
                    {
                        storageContainer.CreateInventory(true);
                    }
                    else if (entity is IndustrialCrafter crafter)
                    {
                        crafter.CreateInventory(true);
                    }
                    else if (entity is ContainerIOEntity containerIo)
                    {
                        containerIo.CreateInventory(true);
                        containerIo.OnInventoryFirstCreated(containerIo.inventory);
                    }
                    else
                    {
                        Puts("WARNING: New IItemContainerEntity container '{0}' not supported", entity);
                    }
                }
                else
                {
                    box.inventory.Clear();
                }

                if (box.inventory != null)
                {
                    PopulateInventory(pasteData, data, entity, box.inventory);

                    if (autoTurret != null)
                    {
                        autoTurret.UpdateAttachedWeapon();
                    }

                    entity.SendNetworkUpdate();
                }
            }

            var iSignage = entity as ISignage;
            if (iSignage != null && data.ContainsKey("sign"))
            {
                var signData = data["sign"] as Dictionary<string, object>;

                if (signData.ContainsKey("amount") || signData.ContainsKey("texture") || signData.ContainsKey("texture0"))
                {
                    int amount = int.TryParse(signData["amount"].ToString(), out var parsedAmount) ? parsedAmount : 1;

                    uint[] newTextureIDs = new uint[amount];

                    for (var num = 0; num < amount; num++)
                    {
                        string textureKey = $"texture{num}";
                        if (amount == 1 && signData.ContainsKey("texture"))
                        {
                            textureKey = "texture";
                        }

                        if (signData.ContainsKey(textureKey))
                        {
                            var imageBytes = FixSignage(iSignage, Convert.FromBase64String(signData[textureKey].ToString()));
                            newTextureIDs[num] = FileStorage.server.Store(imageBytes, iSignage.FileType, entity.net.ID);
                        }
                        else
                        {
                            newTextureIDs[num] = 0;
                        }
                    }

                    iSignage.SetTextureCRCs(newTextureIDs);
                }

                if (iSignage is Signage sign)
                {
                    if (Convert.ToBoolean(signData["locked"]))
                        sign.SetFlag(BaseEntity.Flags.Locked, true);

                    sign.SendNetworkUpdate();
                }
            }

            var photoEntity = entity as PhotoEntity;
            if (photoEntity != null && data.ContainsKey("sign"))
            {
                var signData = data["sign"] as Dictionary<string, object>;

                if (signData.ContainsKey("amount"))
                {
                    int amount;
                    if (int.TryParse(signData["amount"].ToString(), out amount))
                    {
                        for (var num = 0; num < amount; num++)
                        {
                            string textureKey = $"texture{num}";

                            if (signData.ContainsKey(textureKey))
                            {
                                var imageBytes = Convert.FromBase64String(signData[textureKey].ToString());
                                photoEntity.SetImageData(0UL, imageBytes);
                            }
                        }
                    }
                }
            }

            var signContent = entity as SignContent;
            if (signContent != null && data.ContainsKey("sign"))
            {
                var signData = data["sign"] as Dictionary<string, object>;

                if (signData.ContainsKey("amount"))
                {
                    int amount;
                    if (int.TryParse(signData["amount"].ToString(), out amount))
                    {
                        uint[] newTextureIDs = new uint[amount];

                        for (var num = 0; num < amount; num++)
                        {
                            string textureKey = $"texture{num}";

                            if (signData.ContainsKey(textureKey))
                            {
                                var imageBytes = Convert.FromBase64String(signData[textureKey].ToString());
                                newTextureIDs[num] = FileStorage.server.Store(imageBytes, signContent.FileType, entity.net.ID);
                            }
                            else
                            {
                                newTextureIDs[num] = 0;
                            }
                        }

                        signContent.textureIDs = newTextureIDs;
                    }
                }
            }

            var paintedItemStorageEntity = entity as PaintedItemStorageEntity;
            if (paintedItemStorageEntity != null && data.ContainsKey("sign"))
            {
                var signData = data["sign"] as Dictionary<string, object>;

                if (signData.ContainsKey("amount"))
                {
                    int amount;
                    if (int.TryParse(signData["amount"].ToString(), out amount))
                    {
                        for (var num = 0; num < amount; num++)
                        {
                            if (signData.ContainsKey($"texture{num}"))
                            {
                                var imageBytes = Convert.FromBase64String(signData[$"texture{num}"].ToString());

                                if (ImageProcessing.IsValidPNG(imageBytes, 512, 512))
                                    paintedItemStorageEntity._currentImageCrc = FileStorage.server.Store(imageBytes, FileStorage.Type.png, paintedItemStorageEntity.net.ID);
                            }
                        }
                    }
                }
            }

            var lights = entity as AdvancedChristmasLights;
            if (lights != null)
            {
                if (data.ContainsKey("points"))
                {
                    var points = data["points"] as List<object>;
                    if (points != null && points.Count > 0)
                    {
                        foreach (Dictionary<string, object> pointEntry in points)
                        {
                            var normal = (Dictionary<string, object>)pointEntry["normal"];
                            var point = (Dictionary<string, object>)pointEntry["point"];

                            var adjustedPoint = pasteData.QuaternionRotation * new Vector3(Convert.ToSingle(point["x"]),
                                Convert.ToSingle(point["y"]),
                                Convert.ToSingle(point["z"])) + pasteData.StartPos;

                            adjustedPoint.y += pasteData.HeightAdj;

                            float slack = 0f;
                            if (pointEntry.TryGetValue("slack", out var rawSlack))
                                slack = Convert.ToSingle(rawSlack);

                            lights.points.Add(new AdvancedChristmasLights.pointEntry
                            {
                                normal = new Vector3(Convert.ToSingle(normal["x"]), Convert.ToSingle(normal["y"]), Convert.ToSingle(normal["z"])),
                                point = adjustedPoint,
                                slack = slack
                            });
                        }
                    }
                }

                if (data.ContainsKey("animationStyle"))
                {
                    lights.animationStyle = (AdvancedChristmasLights.AnimationType)data["animationStyle"];
                }
            }

            var sleepingBag = entity as SleepingBag;
            if (sleepingBag != null && data.ContainsKey("sleepingbag"))
            {
                var bagData = data["sleepingbag"] as Dictionary<string, object>;

                sleepingBag.niceName = bagData["niceName"].ToString();
                sleepingBag.deployerUserID = ulong.Parse(bagData["deployerUserID"].ToString());
                sleepingBag.SetPublic(Convert.ToBoolean(bagData["isPublic"]));
            }

            var cupboard = entity as BuildingPrivlidge;
            if (cupboard != null)
            {
                var authorizedPlayers = new List<ulong>();

                if (data.ContainsKey("cupboard"))
                {
#if DEBUG
                    Puts($"{nameof(PasteLoop)}: Convert.ToUInt64 1521");
#endif
                    var cupboardData = data["cupboard"] as Dictionary<string, object>;
                    authorizedPlayers = (cupboardData["authorizedPlayers"] as List<object>).Select(Convert.ToUInt64)
                        .ToList();
                }

                if (pasteData.BasePlayer != null && !authorizedPlayers.Contains(pasteData.BasePlayer.userID) &&
                    pasteData.Auth)
                    authorizedPlayers.Add(pasteData.BasePlayer.userID);

                foreach (var userId in authorizedPlayers)
                {
                    cupboard.authorizedPlayers.Add(new PlayerNameID
                    {
                        userid = userId,
                        username = "Player"
                    });
                }

                cupboard.SendNetworkUpdate();
            }

            var tinCanAlarm = entity as TinCanAlarm;
            if (tinCanAlarm != null)
            {
                if (data.ContainsKey("endPoint"))
                {
                    var endPoint = (Dictionary<string, object>)data["endPoint"];
                    var adjustedEndPoint = pasteData.QuaternionRotation * new Vector3(Convert.ToSingle(endPoint["x"]),
                        Convert.ToSingle(endPoint["y"]),
                        Convert.ToSingle(endPoint["z"])) + pasteData.StartPos;

                    adjustedEndPoint.y += pasteData.HeightAdj;

                    tinCanAlarm.endPoint = adjustedEndPoint;
                    tinCanAlarm.SendNetworkUpdate();
                }
            }

            var cctvRc = entity as CCTV_RC;
            if (cctvRc != null && data.ContainsKey("cctv"))
            {
                var cctv = (Dictionary<string, object>)data["cctv"];
                cctvRc.yawAmount = Convert.ToSingle(cctv["yaw"]);
                cctvRc.pitchAmount = Convert.ToSingle(cctv["pitch"]);
                cctvRc.rcIdentifier = cctv["rcIdentifier"].ToString();
                cctvRc.SendNetworkUpdate();
            }

            var headEntity = entity as HeadEntity;
            if (headEntity != null && data.ContainsKey("currentTrophyData"))
            {
                if (headEntity.CurrentTrophyData == null)
                    headEntity.CurrentTrophyData = Pool.Get<HeadData>();

                PopulateHeadData(data, headEntity.CurrentTrophyData);
            }

            var huntingTrophy = entity as HuntingTrophy;
            if (huntingTrophy != null && data.ContainsKey("currentTrophyData"))
            {
                if (huntingTrophy.CurrentTrophyData == null)
                    huntingTrophy.CurrentTrophyData = Pool.Get<HeadData>();

                PopulateHeadData(data, huntingTrophy.CurrentTrophyData);
            }

            var pagerEntity = entity as PagerEntity;
            if (pagerEntity != null && data.ContainsKey("frequency"))
            {
                pagerEntity.ChangeFrequency(Convert.ToInt32(data["frequency"]));
                pagerEntity.SendNetworkUpdate();
            }

            var rfTimedExplosive = entity as RFTimedExplosive;
            if (rfTimedExplosive != null && data.ContainsKey("frequency"))
            {
                rfTimedExplosive.SetFrequency(Convert.ToInt32(data["frequency"]));
                rfTimedExplosive.SetFuse(0f);
            }

            var cassette = entity as Cassette;
            if (cassette != null)
            {
                PopulateCassette(data, cassette);
            }

            var mobileInventoryEntity = entity as MobileInventoryEntity;
            if (mobileInventoryEntity != null)
            {
                mobileInventoryEntity.SetFlag(MobileInventoryEntity.Ringing, false);
            }

            var elevator = entity as Elevator;
            if (elevator != null && data.ContainsKey("Floor"))
            {
                elevator.Floor = Convert.ToInt32(data["Floor"]);
            }

            var weaponRack = entity as WeaponRack;
            if (weaponRack != null && data.ContainsKey("gridSlots"))
            {
                var gridSlots = (List<object>)data["gridSlots"];
                if (gridSlots != null)
                {
                    foreach (Dictionary<string, object> gridSlot in gridSlots)
                    {
                        if (gridSlot != null)
                        {
                            int gridSlotIndex = Convert.ToInt32(gridSlot["GridSlotIndex"]);
                            int inventoryIndex = Convert.ToInt32(gridSlot["InventoryIndex"]);
                            int rotation = Convert.ToInt32(gridSlot["Rotation"]);

                            var item = weaponRack.inventory.GetSlot(inventoryIndex);
                            if (item != null)
                            {
                                var slot = weaponRack.gridSlots[inventoryIndex];
                                if (slot != null)
                                {
                                    slot.SetItem(item, item.info, gridSlotIndex, rotation);
                                    weaponRack.SetGridCellContents(slot, false);
                                }
                            }
                        }
                    }
                }
            }

            var phoneController = entity.GetComponent<PhoneController>();
            if (phoneController != null && data.ContainsKey("savedVoicemail"))
            {
                // Requires the cassette item subentity to exist, delay processing until the very end
                pasteData.FinalProcessingActions.Add(() =>
                {
                    var savedVoicemail = (List<object>)data["savedVoicemail"];
                    if (savedVoicemail != null)
                    {
                        foreach (Dictionary<string, object> voicemail in savedVoicemail)
                        {
                            if (voicemail != null)
                            {
                                byte[] audioData = Convert.FromBase64String(voicemail["audio"].ToString());
                                phoneController.SaveVoicemail(audioData, voicemail["userName"].ToString());
                            }
                        }
                    }
                });
            }

            var vendingMachine = entity as VendingMachine;
            if (vendingMachine != null && data.ContainsKey("vendingmachine"))
            {
                var vendingData = data["vendingmachine"] as Dictionary<string, object>;

                vendingMachine.shopName = vendingData["shopName"].ToString();
                vendingMachine.SetFlag(BaseEntity.Flags.Reserved4,
                    Convert.ToBoolean(vendingData["isBroadcasting"]));

                var sellOrders = vendingData["sellOrders"] as List<object>;

                foreach (var orderPreInfo in sellOrders)
                {
                    var orderInfo = orderPreInfo as Dictionary<string, object>;

                    if (!orderInfo.ContainsKey("inStock"))
                    {
                        orderInfo["inStock"] = 0;
                        orderInfo["currencyIsBP"] = false;
                        orderInfo["itemToSellIsBP"] = false;
                    }

                    int itemToSellId = Convert.ToInt32(orderInfo["itemToSellID"]),
                        currencyId = Convert.ToInt32(orderInfo["currencyID"]);

                    if (pasteData.IsItemReplace)
                    {
                        itemToSellId = GetItemId(itemToSellId);
                        currencyId = GetItemId(currencyId);
                    }

                    vendingMachine.sellOrders.sellOrders.Add(new ProtoBuf.VendingMachine.SellOrder
                    {
                        ShouldPool = false,
                        itemToSellID = itemToSellId,
                        itemToSellAmount = Convert.ToInt32(orderInfo["itemToSellAmount"]),
                        currencyID = currencyId,
                        currencyAmountPerItem = Convert.ToInt32(orderInfo["currencyAmountPerItem"]),
                        inStock = Convert.ToInt32(orderInfo["inStock"]),
                        currencyIsBP = Convert.ToBoolean(orderInfo["currencyIsBP"]),
                        itemToSellIsBP = Convert.ToBoolean(orderInfo["itemToSellIsBP"])
                    });
                }

                vendingMachine.FullUpdate();
            }

            var ioEntity = entity as IOEntity;
            if (ioEntity.IsValid() && !ioEntity.IsDestroyed)
            {
                var ioData = new Dictionary<string, object>();

                if (data.ContainsKey("IOEntity"))
                {
                    ioData = data["IOEntity"] as Dictionary<string, object> ?? new Dictionary<string, object>();
                }

                ioData.Add("entity", ioEntity);
                ioData.Add("newId", ioEntity.net.ID.Value);

                object oldIdObject;
                if (ioData.TryGetValue("oldID", out oldIdObject))
                {
#if DEBUG
                    Puts($"{nameof(PasteLoop)}: Convert.ToUInt64 1619");
#endif
                    var oldId = Convert.ToUInt64(oldIdObject);
                    pasteData.EntityLookup.Add(oldId, ioData);
                }
            }
            
            var flagsData = new Dictionary<string, object>();

            if (data.ContainsKey("flags"))
                flagsData = data["flags"] as Dictionary<string, object>;

            var flags = new Dictionary<BaseEntity.Flags, bool>();

            foreach (var flagData in flagsData)
            {
                BaseEntity.Flags baseFlag;
                if (Enum.TryParse(flagData.Key, out baseFlag))
                    flags.Add(baseFlag, Convert.ToBoolean(flagData.Value));
            }

            foreach (var flag in flags)
            {
                entity.SetFlag(flag.Key, flag.Value);
            }
            
            var industrialCrafter = entity as IndustrialCrafter;
            if (industrialCrafter != null)
            {
                industrialCrafter.SetFlag(IndustrialCrafter.Crafting, false);
            }

            if (data.ContainsKey("children"))
            {
                var children = data["children"] as List<object>;

                if (children != null)
                {
                    foreach (var child in children)
                    {
                        var childData = child as Dictionary<string, object>;
                        if (childData == null)
                            continue;

                        PasteEntity(childData, pasteData, entity);
                    }
                }
            }
            
            var photoFrame = entity as PhotoFrame;
            if (photoFrame != null && data.ContainsKey("photoEntity"))
            {
                if (pasteData.EntityLookup.TryGetValue(Convert.ToUInt64(data["photoEntity"]), out var objData))
                {
                    if (objData["entity"] is BaseEntity baseEntity && baseEntity.IsValid() && !baseEntity.IsDestroyed && baseEntity.net.ID.IsValid)
                    {
                        photoFrame._photoEntity.uid = baseEntity.net.ID;
                    }
                }
            }

            if (entity is IndustrialStorageAdaptor)
            {
                pasteData.industrialStorageAdaptors.Add(entity as IndustrialStorageAdaptor);
            }

            pasteData.PastedEntities.Add(entity);
            pasteData.CallbackSpawned?.Invoke(entity);
        }

        private void ProgressIOEntity(Dictionary<string, object> ioData, PasteData pasteData)
        {
            if (!ioData.ContainsKey("entity"))
                return;

            var ioEntity = ioData["entity"] as IOEntity;

            if (!ioEntity.IsValid() || ioEntity.IsDestroyed)
                return;

            List<object> inputs = null;
            if (ioData.ContainsKey("inputs"))
                inputs = ioData["inputs"] as List<object>;

            var electricalBranch = ioEntity as ElectricalBranch;
            if (electricalBranch != null && ioData.ContainsKey("branchAmount"))
            {
                electricalBranch.branchAmount = Convert.ToInt32(ioData["branchAmount"]);
            }

            var counter = ioEntity as PowerCounter;
            if (counter != null)
            {
                if (ioData.ContainsKey("targetNumber"))
                    counter.targetCounterNumber = Convert.ToInt32(ioData["targetNumber"]);

                object counterNumber;
                counter.SetCounterNumber(ioData.TryGetValue("counterNumber", out counterNumber) ?
                    Convert.ToInt32(counterNumber) :
                    0);
            }

            var timerSwitch = ioEntity as TimerSwitch;
            if (timerSwitch != null && ioData.ContainsKey("timerLength"))
            {
                timerSwitch.timerLength = Convert.ToSingle(ioData["timerLength"]);
                if(timerSwitch.IsOn())
                {
                    timerSwitch.SetFlag(BaseEntity.Flags.On, false);
                    timerSwitch.SwitchPressed();
                }
            }

            var rfBroadcaster = ioEntity as RFBroadcaster;
            if (rfBroadcaster != null && ioData.ContainsKey("frequency"))
            {
                int newFrequency = Convert.ToInt32(ioData["frequency"]);
                if (ioEntity.IsPowered())
                    RFManager.AddBroadcaster(newFrequency, rfBroadcaster);
                rfBroadcaster.frequency = newFrequency;
                rfBroadcaster.MarkDirty();
            }

            var rfReceiver = ioEntity as RFReceiver;
            if (rfReceiver != null && ioData.ContainsKey("frequency"))
            {
                int newFrequency = Convert.ToInt32(ioData["frequency"]);
                RFManager.AddListener(newFrequency, rfReceiver);
                rfReceiver.frequency = newFrequency;
                rfReceiver.MarkDirty();
            }

            var seismicSensor = ioEntity as SeismicSensor;
            if (seismicSensor != null && ioData.ContainsKey("range"))
            {
                seismicSensor.SetRange(Convert.ToInt32(ioData["range"]));
            }

            var doorManipulator = ioEntity as CustomDoorManipulator;
            if (doorManipulator != null)
            {
                Door door = doorManipulator.GetParentEntity() as Door;
                if (door != null)
                {
                    doorManipulator.SetTargetDoor(door);
                }
            }

            var conveyor = ioEntity as IndustrialConveyor;
            if (conveyor != null && ioData.ContainsKey("industrialconveyormode"))
            {
                object mode;
                if (ioData.TryGetValue("industrialconveyormode", out mode))
                    conveyor.mode = (IndustrialConveyor.ConveyorMode)Convert.ToInt32(mode);

                conveyor.filterItems = DeSerializeConveyorFilter(ioData["industrialconveyorfilteritems"].ToString());
                conveyor.SendNetworkUpdate();
            }

            var digitalClock = ioEntity as DigitalClock;
            if (digitalClock != null)
            {
                if (ioData.ContainsKey("muted"))
                {
                    digitalClock.muted = Convert.ToBoolean(ioData["muted"]);
                }

                if (ioData.ContainsKey("alarms") && ioData["alarms"] is List<object> alarms)
                {
                    foreach (Dictionary<string, object> alarm in alarms)
                    {
                        if (alarm != null && alarm.ContainsKey("time") && alarm.ContainsKey("active"))
                        {
                            digitalClock.alarms.Add(new DigitalClock.Alarm(TimeSpan.Parse(alarm["time"].ToString()),
                                Convert.ToBoolean(alarm["active"])));
                        }
                    }
                }

                digitalClock.MarkDirty();
                digitalClock.SendNetworkUpdate();
            }

            if (inputs != null && inputs.Count > 0)
            {
                for (var index = 0; index < inputs.Count; index++)
                {
                    var input = inputs[index] as Dictionary<string, object>;
                    object oldIdObject;

                    if (!input.TryGetValue("connectedID", out oldIdObject))
                        continue;

#if DEBUG
                    Puts($"{nameof(PasteLoop)}: Convert.ToUInt64 1712");
#endif
                    var oldId = Convert.ToUInt64(oldIdObject);

                    if (oldId != 0 && pasteData.EntityLookup.ContainsKey(oldId))
                    {
                        if (ioEntity.inputs[index] == null)
                            ioEntity.inputs[index] = new IOEntity.IOSlot();

                        var ioConnection = pasteData.EntityLookup[oldId];
                        if (ioConnection.ContainsKey("newId"))
                        {
#if DEBUG
            Puts($"{nameof(PasteLoop)}: Convert.ToUInt64 1719");
#endif
                            ioEntity.inputs[index].connectedTo.entityRef.uid =
                                new NetworkableId(Convert.ToUInt64(ioConnection["newId"]));
                        }
                    }
                }
            }

            List<object> outputs = null;
            if (ioData.ContainsKey("outputs"))
                outputs = ioData["outputs"] as List<object>;

            if (outputs != null && outputs.Count > 0)
            {
                for (var index = 0; index < outputs.Count; index++)
                {
                    var output = outputs[index] as Dictionary<string, object>;
#if DEBUG
                    Puts($"{nameof(PasteLoop)}: Convert.ToUInt64 1744");
#endif
                    var oldId = Convert.ToUInt64(output["connectedID"]);

                    if (oldId != 0 && pasteData.EntityLookup.ContainsKey(oldId))
                    {
                        if (ioEntity.outputs[index] == null)
                            ioEntity.outputs[index] = new IOEntity.IOSlot();

                        var ioConnection = pasteData.EntityLookup[oldId];

                        if( ioConnection.ContainsKey( "newId" ) )
                        {
                            var ioOutput = ioEntity.outputs[index];
                            var ioEntity2 = ioConnection["entity"] as IOEntity;

                            if (!ioEntity2.IsValid() || ioEntity2.IsDestroyed)
                                continue;

                            var connectedToSlot = Convert.ToInt32( output["connectedToSlot"] );
                            var ioInput = ioEntity2.inputs[connectedToSlot];

                            ioOutput.connectedTo = new IOEntity.IORef();
                            ioOutput.connectedTo.Set( ioEntity2 );
                            ioOutput.connectedToSlot = connectedToSlot;
                            ioOutput.type = (IOEntity.IOType) Convert.ToInt32( output["type"] );
                            ioOutput.niceName = output["niceName"] as string;
                            ioOutput.connectedTo.Init();

                            ioInput.connectedTo = new IOEntity.IORef();
                            ioInput.connectedTo.Set( ioEntity );
                            ioInput.connectedToSlot = index;
                            ioInput.connectedTo.Init();

                            ioOutput.worldSpaceLineEndRotation =
                                ioEntity2.transform.TransformDirection( ioInput.handleDirection );
                            ioOutput.originPosition = ioEntity.transform.position;
                            ioOutput.originRotation = ioEntity.transform.rotation.eulerAngles;

                            if( output.TryGetValue( "wireColour", out var wireColour ) )
                            {
                                var color = (WireTool.WireColour) Convert.ToInt32( wireColour );
                                ioInput.wireColour = color;
                                ioOutput.wireColour = color;
                            }

                            if (output.ContainsKey( "linePoints" ) && output["linePoints"] is List<object> linePoints)
                            {
                                ioOutput.linePoints = new Vector3[linePoints.Count];
                                for( var i = 0; i < linePoints.Count; i++ )
                                {
                                    var linePoint = linePoints[i] as Dictionary<string, object>;
                                    ioOutput.linePoints[i] = new Vector3(
                                        Convert.ToSingle( linePoint["x"] ),
                                        Convert.ToSingle( linePoint["y"] ),
                                        Convert.ToSingle( linePoint["z"] ) );
                                }
                            }
                            
                            if (output.ContainsKey("slackLevels") && output["slackLevels"] is List<object> slackLevels)
                            {
                                ioOutput.slackLevels = new float[slackLevels.Count];
                                for (var i = 0; i < slackLevels.Count; i++)
                                {
                                    ioOutput.slackLevels[i] = Convert.ToSingle(slackLevels[i]);
                                }
                            }
                            else
                            {
                                ioOutput.slackLevels = new float[ioOutput.linePoints.Count()];
                                for (var i = 0; i < ioOutput.slackLevels.Count(); i++)
                                    ioOutput.slackLevels[i] = 0f;
                            }

                            if (output.ContainsKey("lineAnchors") && output["lineAnchors"] is List<object> lineAnchors)
                            {
                                ioOutput.lineAnchors = new IOEntity.LineAnchor[lineAnchors.Count];
                                for (var i = 0; i < lineAnchors.Count; i++)
                                {
                                    var lineAnchor = lineAnchors[i] as Dictionary<string, object>;
                                    var pos = (Dictionary<string, object>)lineAnchor["position"];

                                    if (pasteData.EntityLookup.TryGetValue(Convert.ToUInt64(lineAnchor["entityRefID"]), out var data))
                                    {
                                        var door = data["entity"] as Door;
                                        if (door.IsValid())
                                        {
                                            ioOutput.lineAnchors[i] = new IOEntity.LineAnchor
                                            {
                                                entityRef = new EntityRef<Door>(door.net.ID),
                                                position = new Vector3(Convert.ToSingle(pos["x"]), Convert.ToSingle(pos["y"]),
                                                    Convert.ToSingle(pos["z"])),
                                                index = Convert.ToInt32(lineAnchor["index"]),
                                                boneName = lineAnchor["boneName"] as string
                                            };                                            
                                        }
                                    }
                                }
                            }

                            ioEntity2.SendNetworkUpdate();
                        }
                    }
                }
            }

            ioEntity.MarkDirty();
            ioEntity.UpdateOutputs();
            ioEntity.SendNetworkUpdate();
            ioEntity.RefreshIndustrialPreventBuilding();
        }

        private void SetItemSubEntity(PasteData pasteData, Item item, ulong oldId)
        {
            if (item != null && oldId != 0 && pasteData.EntityLookup.TryGetValue(oldId, out var data))
            {
                if (data["entity"] is BaseEntity subEntity && subEntity.IsValid() && !subEntity.IsDestroyed && subEntity.net.ID.IsValid)
                {
                    if (item.instanceData == null)
                        item.instanceData = new ProtoBuf.Item.InstanceData();

                    item.instanceData.subEntity = subEntity.net.ID;
                }
            }
        }

        private void ExtractInventory(Dictionary<string, object> data, ItemContainer inventory, CopyData copyData)
        {
            var itemlist = new List<object>();

            foreach (var item in inventory.itemList)
            {
                var itemdata = new Dictionary<string, object>
                {
                    { "condition", item.condition.ToString() },
                    { "id", item.info.itemid },
                    { "amount", item.amount },
                    { "skinid", item.skin },
                    { "position", item.position },
                    { "blueprintTarget", item.blueprintTarget },
                    { "dataInt", item.instanceData?.dataInt ?? 0 }
                };

                if (item.instanceData != null)
                {
                    if (item.instanceData.subEntity != default(NetworkableId))
                    {
                        itemdata.Add("subEntity", item.instanceData.subEntity.Value);
                    }

                    // RF timed explosives
                    if (item.instanceData.dataInt > 0 && item.info != null && item.info.Blueprint != null &&
                        item.info.Blueprint.workbenchLevelRequired == 3)
                    {
                        itemdata.Add("IsOn", item.IsOn());
                    }
                }

                if (!string.IsNullOrEmpty(item.name))
                    itemdata["name"] = item.name;

                if (!string.IsNullOrEmpty(item.text))
                    itemdata["text"] = item.text;

                var heldEnt = item.GetHeldEntity();

                if (heldEnt != null)
                {
                    var projectiles = heldEnt.GetComponent<BaseProjectile>();

                    if (projectiles != null)
                    {
                        var magazine = projectiles.primaryMagazine;

                        if (magazine != null)
                        {
                            itemdata.Add("magazine", new Dictionary<string, object>
                        {
                            { magazine.ammoType.itemid.ToString(), magazine.contents }
                        });
                        }
                    }

                    if (heldEnt.children != null && heldEnt.children.Count > 0)
                    {
                        var children = new List<object>();
                        foreach (var child in heldEnt.children)
                        {
                            if (!child.IsValid())
                                continue;

                            children.Add(EntityData(child, child.transform.position,
                                child.transform.rotation.eulerAngles, copyData));
                        }

                        if (children.Count > 0)
                            itemdata["children"] = children;
                    }
                }

                if (item?.contents?.itemList != null && item.contents.itemList.Count > 0)
                {
                    var itemContents = new Dictionary<string, object>();
                    ExtractInventory(itemContents, item.contents, copyData);
                    if (itemContents.ContainsKey("items"))
                        itemdata["items"] = itemContents["items"];
                }

                itemlist.Add(itemdata);
            }

            data.Add("items", itemlist);
        }

        private void PopulateInventory(PasteData pasteData, Dictionary<string,object> data, BaseEntity entity, ItemContainer inventory)
        {
            var items = new List<object>();

            if (data.ContainsKey("items"))
                items = data["items"] as List<object>;

            foreach (var itemDef in items)
            {
                var item = itemDef as Dictionary<string, object>;
                var itemid = Convert.ToInt32(item["id"]);
                var itemamount = Convert.ToInt32(item["amount"]);
                var itemskin = item.ContainsKey("skinid") ? ulong.Parse(item["skinid"].ToString()) : 0;
                var dataInt = item.ContainsKey("dataInt") ? Convert.ToInt32(item["dataInt"]) : 0;

                var growableEntity = entity as GrowableEntity;
                if (growableEntity != null)
                {
                    if (data.ContainsKey("genes"))
                    {
                        var genesData = (int)data["genes"];

                        if (genesData > 0)
                        {
                            GrowableGeneEncoding.DecodeIntToGenes(genesData, growableEntity.Genes);
                        }
                    }

                    if (data.ContainsKey("hasParent"))
                    {
                        var isParented = (bool)data["hasParent"];

                        if (isParented)
                        {
                            RaycastHit hitInfo;

                            if (Physics.Raycast(growableEntity.transform.position, Vector3.down, out hitInfo,
                                    .5f, Rust.Layers.DefaultDeployVolumeCheck))
                            {
                                var parentEntity = hitInfo.GetEntity();
                                if (parentEntity != null)
                                {
                                    growableEntity.SetParent(parentEntity, true);
                                }
                            }
                        }
                    }
                }

                if (pasteData.IsItemReplace)
                    itemid = GetItemId(itemid);

                var i = ItemManager.CreateByItemID(itemid, itemamount, itemskin);

                if (i != null)
                {
                    if (item.ContainsKey("condition"))
                        i.condition = Convert.ToSingle(item["condition"]);

                    if (item.ContainsKey("text"))
                        i.text = item["text"].ToString();

                    if (item.ContainsKey("name"))
                        i.name = item["name"]?.ToString();

                    if (item.ContainsKey("blueprintTarget"))
                    {
                        var blueprintTarget = Convert.ToInt32(item["blueprintTarget"]);

                        if (pasteData.IsItemReplace)
                            blueprintTarget = GetItemId(blueprintTarget);

                        i.blueprintTarget = blueprintTarget;
                    }

                    if (dataInt > 0)
                    {
                        i.instanceData = new ProtoBuf.Item.InstanceData()
                        {
                            ShouldPool = false,
                            dataInt = dataInt
                        };
                    }

                    if (item.ContainsKey("IsOn"))
                    {
                        i.SetFlag(Item.Flag.IsOn, Convert.ToBoolean(item["IsOn"]));
                    }

                    if (item.ContainsKey("subEntity"))
                    {
                        // Needs to be processed after all of the children are spawned
                        var oldId = Convert.ToUInt64(item["subEntity"]);
                        if (oldId != 0)
                            pasteData.ItemsWithSubEntity.Add(oldId, i);
                    }

                    if (item.ContainsKey("items"))
                    {
                        PopulateInventory(pasteData, item, null, i.contents);
                    }

                    var heldent = i.GetHeldEntity();

                    if (heldent != null)
                    {
                        if (item.ContainsKey("magazine"))
                        {
                            var projectiles = heldent.GetComponent<BaseProjectile>();

                            if (projectiles != null)
                            {
                                var magazine = item["magazine"] as Dictionary<string, object>;
                                var ammotype = int.Parse(magazine.Keys.ToArray()[0]);
                                var ammoamount = int.Parse(magazine[ammotype.ToString()].ToString());

                                if (pasteData.IsItemReplace)
                                    ammotype = GetItemId(ammotype);

                                projectiles.primaryMagazine.ammoType = ItemManager.FindItemDefinition(ammotype);
                                projectiles.primaryMagazine.contents = ammoamount;
                            }
                        }

                        if (item.ContainsKey("children"))
                        {
                            PreLoadChildrenData(item);

                            var children = item["children"] as List<object>;
                            if (children != null)
                            {
                                foreach (var child in children)
                                {
                                    var childData = child as Dictionary<string, object>;
                                    if (childData == null)
                                        continue;

                                    PasteEntity(childData, pasteData, heldent);
                                }
                            }
                        }
                    }

                    var targetPos = -1;

                    if (item.ContainsKey("position"))
                        targetPos = Convert.ToInt32(item["position"]);

                    var heldEntity = i.GetHeldEntity();
                    if (heldEntity != null && heldEntity is Detonator detonator)
                    {
                        detonator.frequency = dataInt;
                        if ( detonator.IsOn() )
                            RFManager.AddBroadcaster(detonator.frequency, detonator);
                    }

                    i.position = targetPos;

                    if (entity is WaterCatcher waterCatcher)
                    {
                        waterCatcher.Invoke(() => {
                            if (waterCatcher != null && !waterCatcher.IsDestroyed)
                                waterCatcher.inventory.AddItem(i.info, i.amount);
                        }, 1f);
                    }
                    else
                    {
                        inventory.Insert(i);
                    }
                }
            }
        }

        void ExtractTextures(Dictionary<string, object> data, uint[] textureIDs, BaseEntity entity, FileStorage.Type type)
        {
            if (textureIDs != null && textureIDs.Length > 0)
            {
                var signData = new Dictionary<string, object>();

                if (entity is Signage sign && sign != null)
                    signData.Add("locked", sign.IsLocked());

                for (var num = 0; num < textureIDs.Length; num++)
                {
                    var textureId = textureIDs[num];
                    if (textureId == 0)
                        continue;

                    var imageByte = FileStorage.server.Get(textureId, type, entity.net.ID);
                    if (imageByte != null)
                    {
                        signData.Add($"texture{num}", Convert.ToBase64String(imageByte));
                    }
                }

                signData["amount"] = textureIDs.Length;
                data.Add("sign", signData);
            }
        }

        void ExtractCassette(Dictionary<string, object> data, Cassette cassette)
        {
            if (cassette.IsValid())
            {
                uint[] contentCRCs = cassette.GetContentCRCs;
                if (contentCRCs != null && contentCRCs.Length == 1)
                {
                    var oggByte = FileStorage.server.Get(contentCRCs[0], FileStorage.Type.ogg, cassette.net.ID);
                    if (oggByte != null)
                    {
                        data.Add("audio", Convert.ToBase64String(oggByte));
                    }
                }
            }
        }

        void PopulateCassette(Dictionary<string, object> data, Cassette cassette)
        {
            if (data.ContainsKey("audio"))
            {
                var contentCRC = FileStorage.server.Store(Convert.FromBase64String(data["audio"].ToString()), FileStorage.Type.ogg, cassette.net.ID);
                cassette.SetAudioId(contentCRC, 0);
            }
        }

        void ExtractHeadData(Dictionary<string, object> data, HeadData headData)
        {
            if (headData != null)
            {
                data.Add("currentTrophyData", new Dictionary<string, object>
                {
                    { "entitySource", headData.entitySource },
                    { "playerName", headData.playerName },
                    { "playerId", headData.playerId },
                    { "clothing", headData.clothing },
                    { "count", headData.count },
                    { "horseBreed", headData.horseBreed }
                });
            }
        }

        void PopulateHeadData(Dictionary<string,object> data, HeadData headData)
        {
            if (data.ContainsKey("currentTrophyData"))
            {
                var headDataData = (Dictionary<string, object>)data["currentTrophyData"];

                var clothing = Pool.Get<List<int>>();
                if (headDataData["clothing"] is List<object> clothingData)
                {
                    foreach (var clothingItem in clothingData)
                    {
                        clothing.Add(Convert.ToInt32(clothingItem));
                    }
                }
                if (clothing.Count == 0)
                    Pool.FreeUnmanaged(ref clothing);

                headData.entitySource = Convert.ToUInt32(headDataData["entitySource"]);
                headData.playerName = headDataData["playerName"] as string;
                headData.playerId = Convert.ToUInt64(headDataData["playerId"]);
                headData.clothing = clothing;
                headData.count = Convert.ToUInt32(headDataData["count"]);
                headData.horseBreed = Convert.ToInt32(headDataData["horseBreed"]);
            }
        }

        private HashSet<Dictionary<string, object>> PreLoadData(List<object> entities, Vector3 startPos,
            float rotationCorrection, bool deployables, bool inventories, bool auth, bool vending)
        {
            var eulerRotation = new Vector3(0f, rotationCorrection, 0f);
            var quaternionRotation = Quaternion.Euler(eulerRotation * Mathf.Rad2Deg);
            var preloaddata = new HashSet<Dictionary<string, object>>();

            foreach (Dictionary<string, object> entity in entities)
            {
                if (!deployables && !entity.ContainsKey("grade"))
                    continue;

                var pos = (Dictionary<string, object>)entity["pos"];
                var rot = (Dictionary<string, object>)entity["rot"];

                entity.Add("position",
                    quaternionRotation * new Vector3(Convert.ToSingle(pos["x"]), Convert.ToSingle(pos["y"]),
                        Convert.ToSingle(pos["z"])) + startPos);
                entity.Add("rotation",
                    Quaternion.Euler((eulerRotation + new Vector3(Convert.ToSingle(rot["x"]),
                        Convert.ToSingle(rot["y"]), Convert.ToSingle(rot["z"]))) * Mathf.Rad2Deg));

                if (!inventories && entity.ContainsKey("items"))
                    entity["items"] = new List<object>();

                if (!vending && entity["prefabname"].ToString().Contains("vendingmachine"))
                    entity.Remove("vendingmachine");

                PreLoadChildrenData(entity);

                preloaddata.Add(entity);
            }

            return preloaddata;
        }

        private void PreLoadChildrenData(Dictionary<string, object> entity)
        {
            if (entity.ContainsKey("children"))
            {
                var children = entity["children"] as List<object>;

                if (children == null)
                    return;

                // Set the (local) position and rotation of the children
                foreach (var child in children)
                {
                    var childData = child as Dictionary<string, object>;
                    if (childData == null)
                        continue;

                    var childPos = (Dictionary<string, object>)childData["pos"];
                    var childRot = (Dictionary<string, object>)childData["rot"];

                    childData.Add("position",
                        new Vector3(Convert.ToSingle(childPos["x"]), Convert.ToSingle(childPos["y"]),
                            Convert.ToSingle(childPos["z"])));
                    childData.Add("rotation",
                        Quaternion.Euler(new Vector3(Convert.ToSingle(childRot["x"]),
                            Convert.ToSingle(childRot["y"]), Convert.ToSingle(childRot["z"]))));

                    // Recursively process the child's children
                    PreLoadChildrenData(childData);
                }
            }
        }

        private object TryCopy(Vector3 sourcePos, Vector3 sourceRot, string filename, float rotationCorrection,
            string[] args, IPlayer player, Action callback)
        {
            bool saveShare = _config.Copy.Share, saveTree = _config.Copy.Tree, eachToEach = _config.Copy.EachToEach;
            var copyMechanics = CopyMechanics.Proximity;
            var radius = _config.Copy.Radius;

            for (var i = 0;; i += 2)
            {
                if (i >= args.Length)
                    break;

                var valueIndex = i + 1;

                if (valueIndex >= args.Length)
                    return Lang("SYNTAX_COPY");

                var param = args[i].ToLower();

                switch (param)
                {
                    case "e":
                    case "each":
                        if (!bool.TryParse(args[valueIndex], out eachToEach))
                            return Lang("SYNTAX_BOOL", null, param);

                        break;

                    case "m":
                    case "method":
                        switch (args[valueIndex].ToLower())
                        {
                            case "b":
                            case "building":
                                copyMechanics = CopyMechanics.Building;
                                break;

                            case "p":
                            case "proximity":
                                copyMechanics = CopyMechanics.Proximity;
                                break;
                        }

                        break;

                    case "r":
                    case "radius":
                        if (!float.TryParse(args[valueIndex], out radius))
                            return Lang("SYNTAX_RADIUS");

                        break;

                    case "s":
                    case "share":
                        if (!bool.TryParse(args[valueIndex], out saveShare))
                            return Lang("SYNTAX_BOOL", null, param);

                        break;

                    case "t":
                    case "tree":
                        if (!bool.TryParse(args[valueIndex], out saveTree))
                            return Lang("SYNTAX_BOOL", null, param);

                        break;

                    default:
                        return Lang("SYNTAX_COPY");
                }
            }

            Copy(sourcePos, sourceRot, filename, rotationCorrection, copyMechanics, radius, saveTree, saveShare,
                eachToEach, player, callback);

            return true;
        }

        private bool GetSlot(BaseEntity parent, BaseEntity child, out BaseEntity.Slot? slot)
        {
            slot = null;
            
            for (int s = 0; s < (int)BaseEntity.Slot.Count; s++)
            {
                var slotEnum = (BaseEntity.Slot)s;
                
                if (parent.HasSlot( slotEnum ) && parent.GetSlot( slotEnum ) == child)
                {
                    slot = slotEnum;
                    return true;
                }
            }
            
            return false;
        }
        
        // private void TryCopySlots(BaseEntity ent, IDictionary<string, object> housedata, bool saveShare)
        // {
        //     foreach (var slot in _checkSlots)
        //     {
        //         if (!ent.HasSlot(slot))
        //             continue;
        //
        //         var slotEntity = ent.GetSlot(slot);
        //
        //         if (slotEntity == null)
        //             continue;
        //
        //         var codedata = new Dictionary<string, object>
        //         {
        //             { "prefabname", slotEntity.PrefabName },
        //             { "flags", TryCopyFlags(ent) }
        //         };
        //
        //         if (slotEntity.GetComponent<CodeLock>())
        //         {
        //             var codeLock = slotEntity.GetComponent<CodeLock>();
        //
        //             codedata.Add("code", codeLock.code);
        //
        //             if (saveShare)
        //                 codedata.Add("whitelistPlayers", codeLock.whitelistPlayers);
        //
        //             if (codeLock.guestCode != null && codeLock.guestCode.Length == 4)
        //             {
        //                 codedata.Add("guestCode", codeLock.guestCode);
        //
        //                 if (saveShare)
        //                     codedata.Add("guestPlayers", codeLock.guestPlayers);
        //             }
        //         }
        //         else if (slotEntity.GetComponent<KeyLock>())
        //         {
        //             var keyLock = slotEntity.GetComponent<KeyLock>();
        //             var code = keyLock.keyCode;
        //
        //             if (keyLock.firstKeyCreated)
        //                 code |= 0x80;
        //
        //             codedata.Add("ownerId", keyLock.OwnerID.ToString());
        //             codedata.Add("code", code.ToString());
        //         }
        //
        //         var slotName = slot.ToString().ToLower();
        //
        //         housedata.Add(slotName, codedata);
        //     }
        // }

        private Dictionary<string, object> TryCopyFlags(BaseEntity entity)
        {
            var flags = new Dictionary<string, object>();

            foreach (BaseEntity.Flags flag in Enum.GetValues(typeof(BaseEntity.Flags)))
            {
                if (!_config.DataSaving || entity.HasFlag(flag))
                    flags.Add(flag.ToString(), entity.HasFlag(flag));
            }

            return flags;
        }

        private ValueTuple<object, PasteData> TryPaste(Vector3 startPos, string filename, IPlayer player,
            float rotationCorrection,
            string[] args, bool autoHeight = true, Action callback = null,
            Action<BaseEntity> callbackSpawned = null)
        {
            var userId = player?.Id;

            var path = _subDirectory + filename;

            if (!Interface.Oxide.DataFileSystem.ExistsDatafile(path))
                return new ValueTuple<object, PasteData>(Lang("FILE_NOT_EXISTS", userId), null);

            var data = Interface.Oxide.DataFileSystem.GetDatafile(path);

            if (data["default"] == null || data["entities"] == null)
                return new ValueTuple<object, PasteData>(Lang("FILE_BROKEN", userId), null);

            float heightAdj = 0f, blockCollision = 0f;
            bool auth = _config.Paste.Auth,
                inventories = _config.Paste.Inventories,
                deployables = _config.Paste.Deployables,
                vending = _config.Paste.VendingMachines,
                stability = _config.Paste.Stability,
                ownership = _config.Paste.EntityOwner,
                checkPlaced = true, enableSaving = true;

            for (var i = 0;; i += 2)
            {
                if (i >= args.Length)
                    break;

                var valueIndex = i + 1;

                if (valueIndex >= args.Length)
                    return new ValueTuple<object, PasteData>(Lang("SYNTAX_PASTE_OR_PASTEBACK", userId), null);

                var param = args[i].ToLower();

                switch (param)
                {
                    case "a":
                    case "auth":
                        if (!bool.TryParse(args[valueIndex], out auth))
                            return new ValueTuple<object, PasteData>(Lang("SYNTAX_BOOL", userId, param), null);

                        break;

                    case "b":
                    case "blockcollision":
                        if (!float.TryParse(args[valueIndex], out blockCollision))
                            return new ValueTuple<object, PasteData>(Lang("SYNTAX_BLOCKCOLLISION", userId), null);

                        break;

                    case "d":
                    case "deployables":
                        if (!bool.TryParse(args[valueIndex], out deployables))
                            return new ValueTuple<object, PasteData>(Lang("SYNTAX_BOOL", userId, param), null);

                        break;

                    case "h":
                    case "height":
                        if (!float.TryParse(args[valueIndex], out heightAdj))
                            return new ValueTuple<object, PasteData>(Lang("SYNTAX_HEIGHT", userId), null);

                        break;

                    case "i":
                    case "inventories":
                        if (!bool.TryParse(args[valueIndex], out inventories))
                            return new ValueTuple<object, PasteData>(Lang("SYNTAX_BOOL", userId, param), null);

                        break;

                    case "s":
                    case "stability":
                        if (!bool.TryParse(args[valueIndex], out stability))
                            return new ValueTuple<object, PasteData>(Lang("SYNTAX_BOOL", userId, param), null);

                        break;

                    case "v":
                    case "vending":
                        if (!bool.TryParse(args[valueIndex], out vending))
                            return new ValueTuple<object, PasteData>(Lang("SYNTAX_BOOL", userId, param), null);

                        break;

                    case "o":
                    case "entityowner":
                        if (!bool.TryParse(args[valueIndex], out ownership))
                            return new ValueTuple<object, PasteData>(Lang("SYNTAX_BOOL", userId, param), null);

                        break;

                    case "cp":
                    case "checkplaced":
                        if (!bool.TryParse(args[valueIndex], out checkPlaced))
                            return new ValueTuple<object, PasteData>(Lang("SYNTAX_BOOL", userId, param), null);

                        break;

                    case "autoheight":
                        if (!bool.TryParse(args[valueIndex], out autoHeight))
                            return new ValueTuple<object, PasteData>(Lang("SYNTAX_BOOL", userId, param), null);

                        break;

                    case "position":
                        startPos = args[valueIndex].ToVector3();
                        break;

                    case "rotation":
                        if (!float.TryParse(args[valueIndex], out rotationCorrection))
                            return new ValueTuple<object, PasteData>(Lang("SYNTAX_FLOAT", userId, param), null);

                        break;

                    case "enablesaving":
                        if (!bool.TryParse(args[valueIndex], out enableSaving))
                            return new(Lang("SYNTAX_BOOL", userId, param), null);

                        break;

                    default:
                        return new ValueTuple<object, PasteData>(Lang("SYNTAX_PASTE_OR_PASTEBACK", userId), null);
                }
            }

            startPos.y += heightAdj;

            var preloadData = PreLoadData(data["entities"] as List<object>, startPos, rotationCorrection, deployables,
                inventories, auth, vending);

            if (autoHeight)
            {
                var bestHeight = FindBestHeight(preloadData, startPos);

                if (bestHeight is string)
                    return new ValueTuple<object, PasteData>(bestHeight, null);

                heightAdj += (float)bestHeight - startPos.y;

                foreach (var entity in preloadData)
                {
                    var pos = (Vector3)entity["position"];
                    pos.y += heightAdj;

                    entity["position"] = pos;
                }
            }

            if (blockCollision > 0f)
            {
                var collision = CheckCollision(preloadData, startPos, blockCollision);

                if (collision is string)
                    return new ValueTuple<object, PasteData>(collision, null);
            }

            var protocol = new Dictionary<string, object>();

            if (data["protocol"] != null)
                protocol = data["protocol"] as Dictionary<string, object>;

            var pasteData = Paste(preloadData, protocol, ownership, startPos, player, stability, rotationCorrection,
                autoHeight ? heightAdj : 0, auth, callback, callbackSpawned, filename, checkPlaced, enableSaving);

            return new ValueTuple<object, PasteData>(true, pasteData);
        }

        private void TryPasteLocks(BaseEntity entity, Dictionary<string, object> data, PasteData pasteData)
        {
            if (entity.GetComponent<CodeLock>())
            {
                var code = (string)data["code"];

                if (!string.IsNullOrEmpty(code))
                {
                    var codeLock = entity.GetComponent<CodeLock>();
                    codeLock.code = code;
                    codeLock.hasCode = true;

                    if (pasteData.Auth && pasteData.BasePlayer != null)
                        codeLock.whitelistPlayers.Add(pasteData.BasePlayer.userID);

                    if (data.ContainsKey("whitelistPlayers"))
                    {
                        foreach (var userId in (List<object>)data["whitelistPlayers"])
                        {
#if DEBUG
                            Puts($"{nameof(PasteLoop)}: Convert.ToUInt64 2206");
#endif
                            codeLock.whitelistPlayers.Add(Convert.ToUInt64(userId));
                        }
                    }

                    if (data.ContainsKey("guestCode"))
                    {
                        var guestCode = (string)data["guestCode"];

                        codeLock.guestCode = guestCode;
                        codeLock.hasGuestCode = true;

                        if (data.ContainsKey("guestPlayers"))
                        {
                            foreach (var userId in (List<object>)data["guestPlayers"])
                            {
#if DEBUG
                                Puts($"{nameof(PasteLoop)}: Convert.ToUInt64 2224");
#endif
                                codeLock.guestPlayers.Add(Convert.ToUInt64(userId));
                            }
                        }
                    }

                    codeLock.SetFlag(BaseEntity.Flags.Locked, true);
                }
            }
            else if (entity.GetComponent<KeyLock>())
            {
                var code = Convert.ToInt32(data["code"]);
                var keyLock = entity.GetComponent<KeyLock>();

                if (data.ContainsKey("firstKeyCreated"))
                {
                    keyLock.keyCode = code;
                    keyLock.firstKeyCreated = Convert.ToBoolean(data["firstKeyCreated"]);
                }
                else
                {
                    if ((code & 0x80) != 0)
                    {
                        keyLock.keyCode = code & 0x7F;
                        keyLock.firstKeyCreated = true;
                        keyLock.SetFlag(BaseEntity.Flags.Locked, true);
                    }
                }

                if (pasteData.Ownership && data.ContainsKey("ownerId"))
                {
#if DEBUG
                    Puts($"{nameof(PasteLoop)}: Convert.ToUInt64 2249");
#endif
                    keyLock.OwnerID = Convert.ToUInt64(data["ownerId"]);
                }
            }
        }
        
        private List<BaseEntity> TryPasteSlots(BaseEntity ent, Dictionary<string, object> structure,
            PasteData pasteData)
        {
            var entitySlots = new List<BaseEntity>();

            foreach (var slot in _checkSlots)
            {
                var slotName = slot.ToString().ToLower();

                if (!ent.HasSlot(slot) || !structure.ContainsKey(slotName))
                    continue;

                var slotData = structure[slotName] as Dictionary<string, object>;
                var slotEntity = GameManager.server.CreateEntity((string)slotData?["prefabname"], Vector3.zero);
                if (slotEntity == null)
                    continue;

                slotEntity.gameObject.Identity();
                slotEntity.SetParent(ent, slotName);
                slotEntity.OnDeployed(ent, null, _emptyItem);

                if (!pasteData.EnableSaving)
                {
                    slotEntity.enableSaving = false;
                }

                slotEntity.Spawn();

                ent.SetSlot(slot, slotEntity);

                entitySlots.Add(slotEntity);

                if (slotName != "lock" || !slotData.ContainsKey("code"))
                    continue;

                TryPasteLocks(slotEntity, slotData, pasteData);

                pasteData.CallbackSpawned?.Invoke(ent);
            }

            return entitySlots;
        }

        private List<IndustrialConveyor.ItemFilter> DeSerializeConveyorFilter(string itemstring)
        {
            List<IndustrialConveyor.ItemFilter> itemFilters = new List<IndustrialConveyor.ItemFilter>();
            try
            {
                foreach (string datapoint in Encoding.ASCII.GetString(Facepunch.Utility.Compression.Uncompress(Convert.FromBase64String(itemstring))).Split('\\'))
                {
                    if (datapoint != null && !string.IsNullOrEmpty(datapoint))
                    {
                        string[] info = datapoint.Split('/');
                        if (info.Length == 6)
                        {
                            IndustrialConveyor.ItemFilter item = new IndustrialConveyor.ItemFilter();
                            if (info[0] != "-1")
                            {
                                item.TargetItem = ItemManager.FindItemDefinition(Convert.ToInt32(info[0]));
                            }
                            item.MaxAmountInOutput = Convert.ToInt32(info[1]);
                            item.BufferAmount = Convert.ToInt32(info[2]);
                            item.MinAmountInInput = Convert.ToInt32(info[3]);
                            if (info[4] != "-1")
                            {
                                item.TargetCategory = (ItemCategory)Convert.ToInt32(info[4]);
                            }
                            item.IsBlueprint = Convert.ToBoolean(info[5]);
                            itemFilters.Add(item);
                        }
                    }
                }
            }
            catch { Puts("DeSerializeConveyorFilter Failed!"); }
            return itemFilters;
        }

        private string SerializeConveyorFilter(List<IndustrialConveyor.ItemFilter> filterItems, string itemstring = "")
        {
            if (filterItems?.Count > 0)
            {
                foreach (var item in filterItems) { itemstring += (item.TargetItem ? item.TargetItem.itemid : "-1") + "/" + item.MaxAmountInOutput + "/" + item.BufferAmount + "/" + item.MinAmountInInput + "/" + (item.TargetCategory.HasValue ? (int) item.TargetCategory.Value : "-1") + "/" + item.IsBlueprint + "\\"; }
                return Convert.ToBase64String(Facepunch.Utility.Compression.Compress(Encoding.ASCII.GetBytes(itemstring)));
            }
            return itemstring;
        }

        private List<ProtoBuf.PatternFirework.Star> DeSerializeStarPattern(string stars)
        {
            List<ProtoBuf.PatternFirework.Star> starlist = new List<ProtoBuf.PatternFirework.Star>();
            try
            {
                foreach (string datapoint in Encoding.ASCII.GetString(Facepunch.Utility.Compression.Uncompress(Convert.FromBase64String(stars))).Split('\\'))
                {
                    if (datapoint != null && !string.IsNullOrEmpty(datapoint))
                    {
                        string[] info = datapoint.Split('/');
                        if (info.Length == 6)
                        {
                            ProtoBuf.PatternFirework.Star star = new ProtoBuf.PatternFirework.Star();
                            star.position = new Vector2(Convert.ToSingle(info[0]), Convert.ToSingle(info[1]));
                            star.color = new UnityEngine.Color(Convert.ToSingle(info[2]), Convert.ToSingle(info[3]), Convert.ToSingle(info[4]), Convert.ToSingle(info[5]));
                            starlist.Add(star);
                        }
                    }
                }
            }
            catch { Puts("DeSerializeStarPattern Failed!"); }
            return starlist;
        }

        private string SerializeStarPattern(List<ProtoBuf.PatternFirework.Star> stars, string starstring = "")
        {
            if (stars?.Count > 0)
            {
                foreach (var star in stars) { starstring += star.position.x + "/" + star.position.y + "/" + star.color.r + "/" + star.color.g + "/" + star.color.b + "/" + star.color.a + "\\"; }
                return Convert.ToBase64String(Facepunch.Utility.Compression.Compress(Encoding.ASCII.GetBytes(starstring)));
            }
            return starstring;
        }

        private object TryPasteBack(string filename, IPlayer player, string[] args)
        {
            var path = _subDirectory + filename;

            if (!Interface.Oxide.DataFileSystem.ExistsDatafile(path))
                return Lang("FILE_NOT_EXISTS", player?.Id);

            var data = Interface.Oxide.DataFileSystem.GetDatafile(path);

            if (data["default"] == null || data["entities"] == null)
                return Lang("FILE_BROKEN", player?.Id);

            var defaultdata = data["default"] as Dictionary<string, object>;
            var pos = defaultdata?["position"] as Dictionary<string, object>;
            var rotationCorrection = Convert.ToSingle(defaultdata?["rotationdiff"]);
            var startPos = new Vector3(Convert.ToSingle(pos?["x"]), Convert.ToSingle(pos?["y"]),
                Convert.ToSingle(pos?["z"]));

            return TryPaste(startPos, filename, player, rotationCorrection, args, false).Item1;
        }

        private static bool HasGrade(BuildingBlock block, BuildingGrade.Enum grade, ulong skin)
        {
            foreach (var constructionGrade in block.blockDefinition.grades)
            {
                var baseGrade = constructionGrade.gradeBase;
                if (baseGrade.type == grade && baseGrade.skin == skin)
                    return true;
            }

            return false;
        }
        
        [Command("copy")]
        private void CmdCopy(IPlayer player, string command, string[] args)
        {
            if (!HasAccess(player, _copyPermission))
            {
                player.Reply(Lang("NO_ACCESS", player.Id));
                return;
            }

            if (args.Length < 1)
            {
                player.Reply(Lang("SYNTAX_COPY", player.Id));
                return;
            }

            var basePlayer = player.Object as BasePlayer;
            var savename = args[0];
            var success =
                TryCopyFromSteamId(basePlayer == null ? 0ul : basePlayer.userID, savename,
                    args.Skip(1).ToArray()) as string;

            if (!string.IsNullOrEmpty(success))
                player.Reply(success);
        }

        [Command("paste")]
        private void CmdPaste(IPlayer player, string command, string[] args)
        {
            if (!HasAccess(player, _pastePermission))
            {
                player.Reply(Lang("NO_ACCESS", player.Id));
                return;
            }

            if (args.Length < 1)
            {
                player.Reply(Lang("SYNTAX_PASTE_OR_PASTEBACK", player.Id));
                return;
            }

            var basePlayer = player.Object as BasePlayer;
            var success =
                TryPasteFromSteamId(basePlayer == null ? 0ul : basePlayer.userID, args[0],
                    args.Skip(1).ToArray()) as string;

            if (!string.IsNullOrEmpty(success))
                player.Reply(success);
        }

        [Command("copylist")]
        private void CmdList(IPlayer player, string command, string[] args)
        {
            if (!HasAccess(player, _listPermission))
            {
                player.Reply(Lang("NO_ACCESS", player.Id));
                return;
            }

            var files = Interface.Oxide.DataFileSystem.GetFiles(_subDirectory);

            var fileList = new List<string>();

            foreach (var file in files)
            {
                var strFileParts = file.Split('/');
                var justfile = strFileParts[strFileParts.Length - 1].Replace(".json", "");
                fileList.Add(justfile);
            }

            player.Reply(Lang("AVAILABLE_STRUCTURES", player.Id));
            player.Reply(string.Join(", ", fileList.ToArray()));
        }

        [Command("pasteback")]
        private void CmdPasteBack(IPlayer player, string command, string[] args)
        {
            if (!HasAccess(player, _pastebackPermission))
            {
                player.Reply(Lang("NO_ACCESS", player.Id));
                return;
            }

            if (args.Length < 1)
            {
                player.Reply(Lang("SYNTAX_PASTEBACK", player.Id));
                return;
            }

            var success = TryPasteBack(args[0], player, args.Skip(1).ToArray()) as string;
            if (!string.IsNullOrEmpty(success))
                player.Reply(success);
        }

        [Command("undo")]
        private void CmdUndo(IPlayer player, string command, string[] args)
        {
            if (!HasAccess(player, _undoPermission))
            {
                player.Reply(Lang("NO_ACCESS", player.Id));
                return;
            }

            if (!_lastPastes.ContainsKey(player.Id))
            {
                player.Reply(Lang("NO_PASTED_STRUCTURE", player.Id));
                return;
            }

            var entities = new HashSet<BaseEntity>(_lastPastes[player.Id].Pop().ToList());

            UndoLoop(entities, player);
        }

        //Replace between old ItemID to new ItemID

        private static readonly Dictionary<int, int> ReplaceItemId = new Dictionary<int, int>
        {
            { -1461508848, 1545779598 },
            { 2115555558, 588596902 },
            { -533875561, 785728077 },
            { 1621541165, 51984655 },
            { -422893115, -1691396643 },
            { 815896488, -1211166256 },
            { 805088543, -1321651331 },
            { 449771810, 605467368 },
            { 1152393492, 1712070256 },
            { 1578894260, -742865266 },
            { 1436532208, 1638322904 },
            { 542276424, -1841918730 },
            { 1594947829, -17123659 },
            { -1035059994, -1685290200 },
            { 1818890814, -1036635990 },
            { 1819281075, -727717969 },
            { 1685058759, -1432674913 },
            { 93029210, 1548091822 },
            { -1565095136, 352130972 },
            { -1775362679, 215754713 },
            { -1775249157, 14241751 },
            { -1280058093, -1023065463 },
            { -420273765, -1234735557 },
            { 563023711, -2139580305 },
            { 790921853, -262590403 },
            { -337261910, -2072273936 },
            { 498312426, -1950721390 },
            { 504904386, 1655650836 },
            { -1221200300, -559599960 },
            { 510887968, 15388698 },
            { -814689390, 866889860 },
            { 1024486167, 1382263453 },
            { 2021568998, 609049394 },
            { 97329, 1099314009 },
            { 1046072789, -582782051 },
            { 97409, -1273339005 },
            { -1480119738, -1262185308 },
            { 1611480185, 1931713481 },
            { -1386464949, 1553078977 },
            { 93832698, 1776460938 },
            { -1063412582, -586342290 },
            { -1887162396, -996920608 },
            { -55660037, 1588298435 },
            { 919780768, 1711033574 },
            { -365801095, 1719978075 },
            { 68998734, 613961768 },
            { -853695669, 1443579727 },
            { 271534758, 833533164 },
            { -770311783, -180129657 },
            { -1192532973, 1424075905 },
            { -307490664, 1525520776 },
            { 707427396, 602741290 },
            { 707432758, -761829530 },
            { -2079677721, 1783512007 },
            { -1342405573, -1316706473 },
            { -139769801, 1946219319 },
            { -1043746011, -700591459 },
            { 2080339268, 1655979682 },
            { -171664558, -1941646328 },
            { 1050986417, -1557377697 },
            { -1693683664, 1789825282 },
            { 523409530, 1121925526 },
            { 1300054961, 634478325 },
            { -2095387015, 1142993169 },
            { 1428021640, 1104520648 },
            { 94623429, 1534542921 },
            { 1436001773, -1938052175 },
            { 1711323399, 1973684065 },
            { 1734319168, -1848736516 },
            { -1658459025, -1440987069 },
            { -726947205, -751151717 },
            { -341443994, 363467698 },
            { 1540879296, 2009734114 },
            { 94756378, -858312878 },
            { 3059095, 204391461 },
            { 3059624, 1367190888 },
            { 2045107609, -778875547 },
            { 583366917, 998894949 },
            { 2123300234, 1965232394 },
            { 1983936587, -321733511 },
            { 1257201758, -97956382 },
            { -1144743963, 296519935 },
            { -1144542967, -113413047 },
            { -1144334585, -2022172587 },
            { 1066729526, -1101924344 },
            { -1598790097, 1390353317 },
            { -933236257, 1221063409 },
            { -1575287163, -1336109173 },
            { -2104481870, -2067472972 },
            { -1571725662, 1353298668 },
            { 1456441506, 1729120840 },
            { 1200628767, -1112793865 },
            { -778796102, 1409529282 },
            { 1526866730, 674734128 },
            { 1925723260, -1519126340 },
            { 1891056868, 1401987718 },
            { 1295154089, -1878475007 },
            { 498591726, 1248356124 },
            { 1755466030, -592016202 },
            { 726730162, 798638114 },
            { -1034048911, -1018587433 },
            { 252529905, 274502203 },
            { 471582113, -1065444793 },
            { -1138648591, 16333305 },
            { 305916740, 649305914 },
            { 305916742, 649305916 },
            { 305916744, 649305918 },
            { 1908328648, -1535621066 },
            { -2078972355, 1668129151 },
            { -533484654, 989925924 },
            { 1571660245, 1569882109 },
            { 1045869440, -1215753368 },
            { 1985408483, 528668503 },
            { 97513422, 304481038 },
            { 1496470781, -196667575 },
            { 1229879204, 952603248 },
            { -1722829188, 936496778 },
            { 1849912854, 1948067030 },
            { -1266285051, 1413014235 },
            { -1749787215, -1000573653 },
            { 28178745, -946369541 },
            { -505639592, -1999722522 },
            { 1598149413, -1992717673 },
            { -1779401418, -691113464 },
            { -57285700, -335089230 },
            { 98228420, 479143914 },
            { 1422845239, 999690781 },
            { 277631078, -1819763926 },
            { 115739308, 1366282552 },
            { -522149009, -690276911 },
            { 3175989, -1899491405 },
            { 718197703, -746030907 },
            { 384204160, 1840822026 },
            { -1308622549, 143803535 },
            { -217113639, -2124352573 },
            { -1580059655, -265876753 },
            { -1832205789, 1070894649 },
            { 305916741, 649305917 },
            { 936777834, 3222790 },
            { -1224598842, 200773292 },
            { -1976561211, -1506397857 },
            { -1406876421, 1675639563 },
            { -1397343301, -23994173 },
            { 1260209393, 850280505 },
            { -1035315940, 1877339384 },
            { -1381682752, 1714496074 },
            { 696727039, -1022661119 },
            { -2128719593, -803263829 },
            { -1178289187, -1903165497 },
            { 1351172108, 1181207482 },
            { -450738836, -1539025626 },
            { -966287254, -324675402 },
            { 340009023, 671063303 },
            { 124310981, -1478212975 },
            { 1501403549, -2094954543 },
            { 698310895, -1252059217 },
            { 523855532, 1266491000 },
            { 2045246801, -886280491 },
            { 583506109, -237809779 },
            { -148163128, 794356786 },
            { -132588262, -1773144852 },
            { -1666761111, 196700171 },
            { -465236267, 442289265 },
            { -1211618504, 1751045826 },
            { 2133577942, -1982036270 },
            { -1014825244, -682687162 },
            { -991829475, 1536610005 },
            { -642008142, -1709878924 },
            { 661790782, 1272768630 },
            { -1440143841, -1780802565 },
            { 569119686, 1746956556 },
            { 1404466285, -1102429027 },
            { -1616887133, -48090175 },
            { -1167640370, -1163532624 },
            { -1284735799, 1242482355 },
            { -1278649848, -1824943010 },
            { 776005741, 1814288539 },
            { 108061910, -316250604 },
            { 255101535, -1663759755 },
            { -51678842, 1658229558 },
            { -789202811, 254522515 },
            { 516382256, -132516482 },
            { 50834473, 1381010055 },
            { -975723312, 1159991980 },
            { 1908195100, -850982208 },
            { -1097452776, -110921842 },
            { 146685185, -1469578201 },
            { -1716193401, -1812555177 },
            { 193190034, -2069578888 },
            { 371156815, -852563019 },
            { 3343606, -1966748496 },
            { 825308669, -1137865085 },
            { 830965940, -586784898 },
            { 1662628660, -163828118 },
            { 1662628661, -163828117 },
            { 1662628662, -163828112 },
            { -1832205788, 1070894648 },
            { -1832205786, 1070894646 },
            { 1625090418, 181590376 },
            { -1269800768, -874975042 },
            { 429648208, -1190096326 },
            { -1832205787, 1070894647 },
            { -1832205785, 1070894645 },
            { 107868, 696029452 },
            { 997973965, -2012470695 },
            { -46188931, -702051347 },
            { -46848560, -194953424 },
            { -2066726403, -989755543 },
            { -2043730634, 1873897110 },
            { 1325935999, -1520560807 },
            { -225234813, -78533081 },
            { -202239044, -1509851560 },
            { -322501005, 1422530437 },
            { -1851058636, 1917703890 },
            { -1828062867, -1162759543 },
            { -1966381470, -1130350864 },
            { 968732481, 1391703481 },
            { 991728250, -242084766 },
            { -253819519, 621915341 },
            { -1714986849, 1827479659 },
            { -1691991080, 813023040 },
            { 179448791, -395377963 },
            { 431617507, -1167031859 },
            { 688032252, 69511070 },
            { -1059362949, -4031221 },
            { 1265861812, 1110385766 },
            { 374890416, 317398316 },
            { 1567404401, 1882709339 },
            { -1057402571, 95950017 },
            { -758925787, -1130709577 },
            { -1411620422, 1052926200 },
            { 88869913, -542577259 },
            { -2094080303, 1318558775 },
            { 843418712, -1962971928 },
            { -1569356508, -1405508498 },
            { -1569280852, 1478091698 },
            { 449769971, 1953903201 },
            { 590532217, -2097376851 },
            { 3387378, 1414245162 },
            { 1767561705, 1992974553 },
            { 106433500, 237239288 },
            { -1334615971, -1778159885 },
            { -135651869, 1722154847 },
            { -1595790889, 1850456855 },
            { -459156023, -1695367501 },
            { 106434956, -1779183908 },
            { -578028723, -1302129395 },
            { -586116979, 286193827 },
            { -1379225193, -75944661 },
            { -930579334, 649912614 },
            { 548699316, 818877484 },
            { 142147109, 1581210395 },
            { 148953073, 1903654061 },
            { 102672084, 980333378 },
            { 640562379, -1651220691 },
            { -1732316031, -1622660759 },
            { -2130280721, 756517185 },
            { -1725510067, -722241321 },
            { 1974032895, -1673693549 },
            { -225085592, -567909622 },
            { 509654999, 1898094925 },
            { 466113771, -1511285251 },
            { 2033918259, 1373971859 },
            { 2069925558, -1736356576 },
            { -1026117678, 803222026 },
            { 1987447227, -1861522751 },
            { 540154065, -544317637 },
            { 1939428458, 176787552 },
            { -288010497, -2002277461 },
            { -847065290, 1199391518 },
            { 3506021, 963906841 },
            { 649603450, 442886268 },
            { 3506418, 1414245522 },
            { 569935070, -1104881824 },
            { 113284, -1985799200 },
            { 1916127949, -277057363 },
            { -1775234707, -1978999529 },
            { -388967316, 1326180354 },
            { 2007564590, -575483084 },
            { -1705696613, 177226991 },
            { 670655301, -253079493 },
            { 1148128486, -1958316066 },
            { -141135377, 567235583 },
            { 109266897, -932201673 },
            { -527558546, 2087678962 },
            { -1745053053, -904863145 },
            { 1223860752, 573926264 },
            { -419069863, 1234880403 },
            { -1617374968, -1994909036 },
            { 2057749608, 1950721418 },
            { 24576628, -2025184684 },
            { -1659202509, 1608640313 },
            { 2107229499, -1549739227 },
            { 191795897, -765183617 },
            { -1009492144, 795371088 },
            { 2077983581, -1367281941 },
            { 378365037, 352499047 },
            { -529054135, -1199897169 },
            { -529054134, -1199897172 },
            { 486166145, -1023374709 },
            { 1628490888, 23352662 },
            { 1498516223, 1205607945 },
            { -632459882, -1647846966 },
            { -626812403, -845557339 },
            { 385802761, -1370759135 },
            { 2117976603, 121049755 },
            { 1338515426, -996185386 },
            { -1455694274, 98508942 },
            { 1579245182, 2070189026 },
            { -587434450, 1521286012 },
            { -163742043, 1542290441 },
            { -1224714193, -1832422579 },
            { 644359987, 826309791 },
            { -1962514734, -143132326 },
            { -705305612, 1153652756 },
            { -357728804, -1819233322 },
            { -698499648, -1138208076 },
            { 1213686767, -1850571427 },
            { 386382445, -855748505 },
            { 1859976884, 553887414 },
            { 960793436, 996293980 },
            { 1001265731, 2048317869 },
            { 1253290621, -1754948969 },
            { 470729623, -1293296287 },
            { 1051155022, -369760990 },
            { 865679437, -1878764039 },
            { 927253046, -1039528932 },
            { 109552593, 1796682209 },
            { -2092529553, 1230323789 },
            { 691633666, -363689972 },
            { -2055888649, 1629293099 },
            { 621575320, -41440462 },
            { -2118132208, 1602646136 },
            { -1127699509, 1540934679 },
            { -685265909, -92759291 },
            { 552706886, -1100422738 },
            { 1835797460, -1021495308 },
            { -892259869, 642482233 },
            { -1623330855, -465682601 },
            { -1616524891, 1668858301 },
            { 789892804, 171931394 },
            { -1289478934, -1583967946 },
            { -892070738, -2099697608 },
            { -891243783, -1581843485 },
            { 889398893, -1157596551 },
            { -1625468793, 1397052267 },
            { 1293049486, 1975934948 },
            { 1369769822, 559147458 },
            { 586484018, 1079279582 },
            { 110115790, 593465182 },
            { 1490499512, 1523195708 },
            { 3552619, 2019042823 },
            { 1471284746, 73681876 },
            { 456448245, -1758372725 },
            { 110547964, 795236088 },
            { 1588977225, -1667224349 },
            { 918540912, -209869746 },
            { -471874147, 1686524871 },
            { 205978836, 1723747470 },
            { -1044400758, -129230242 },
            { -2073307447, -1331212963 },
            { 435230680, 2106561762 },
            { -864578046, 223891266 },
            { 1660607208, 935692442 },
            { 260214178, -1478445584 },
            { -1847536522, 198438816 },
            { -496055048, -967648160 },
            { -1792066367, 99588025 },
            { 562888306, -956706906 },
            { -427925529, -1429456799 },
            { 995306285, 1451568081 },
            { -378017204, -1117626326 },
            { 447918618, -148794216 },
            { 313836902, 1516985844 },
            { 1175970190, -796583652 },
            { 525244071, -148229307 },
            { -1021702157, -819720157 },
            { -402507101, 671706427 },
            { -1556671423, -1183726687 },
            { 61936445, -1614955425 },
            { 112903447, -1779180711 },
            { 1817873886, -1100168350 },
            { 1824679850, -132247350 },
            { -1628526499, -1863559151 },
            { 547302405, -119235651 },
            { 1840561315, 2114754781 },
            { -460592212, -1379835144 },
            { 3655341, -151838493 },
            { 1554697726, 418081930 },
            { -1883959124, 832133926 },
            { -481416622, 1524187186 },
            { -481416621, -41896755 },
            { -481416620, -1607980696 },
            { -1151126752, 1058261682 },
            { -1926458555, 794443127 }
        };

        //Languages phrases

        private readonly Dictionary<string, Dictionary<string, string>> _messages =
            new Dictionary<string, Dictionary<string, string>>
            {
                {
                    "FILE_NOT_EXISTS", new Dictionary<string, string>
                    {
                        { "en", "File does not exist" },
                        { "ru", "Файл не существует" },
                        { "nl", "Bestand bestaat niet." }
                    }
                },
                {
                    "FILE_BROKEN", new Dictionary<string, string>
                    {
                        { "en", "Something went wrong during pasting because of a error in the file." },
                        { "ru", "Файл поврежден, вставка невозможна" },
                        { "nl", "Er is iets misgegaan tijdens het plakken door een beschadigd bestand." }
                    }
                },
                {
                    "NO_ACCESS", new Dictionary<string, string>
                    {
                        { "en", "You don't have the permissions to use this command" },
                        { "ru", "У вас нет прав доступа к данной команде" },
                        { "nl", "U heeft geen toestemming/permissie om dit commando te gebruiken." }
                    }
                },
                {
                    "SYNTAX_PASTEBACK", new Dictionary<string, string>
                    {
                        {
                            "en", "Syntax: /pasteback <Target Filename> <options values>\n" +
                                  "height XX - Adjust the height\n" +
                                  "vending - Information and sellings in vending machine\n" +
                                  "stability <true/false> - Wether or not to disable stability\n" +
                                  "deployables <true/false> - Wether or not to copy deployables\n" +
                                  "auth <true/false> - Wether or not to copy lock and cupboard whitelists\n" +
                                  "position <x,y,z> - Override position\n" +
                                  "rotation <X> - Override rotation"
                        },
                        {
                            "ru", "Синтаксис: /pasteback <Название Объекта> <опция значение>\n" +
                                  "height XX - Высота от земли\n" +
                                  "vending - Информация и товары в торговом автомате"
                        },
                        {
                            "nl", "Syntax: /pasteback <Bestandsnaam> <opties waarden>\n" +
                                  "height XX - Pas de hoogte aan \n" +
                                  "vending <true/false> - Informatie en inventaris van \"vending machines\" kopiëren\n" +
                                  "stability <true/false> - of de stabiliteit van het gebouw uitgezet moet worden\n" +
                                  "deployables <true/false> - of de \"deployables\" gekopiërd moeten worden\n" +
                                  "auth <true/false> - Of authorisatie op sloten en tool cupboards gekopiërd moet worden"
                        }
                    }
                },
                {
                    "SYNTAX_PASTE_OR_PASTEBACK", new Dictionary<string, string>
                    {
                        {
                            "en", "Syntax: /paste or /pasteback <Target Filename> <options values>\n" +
                                  "height XX - Adjust the height\n" +
                                  "autoheight true/false - sets best height, carefull of the steep\n" +
                                  "blockcollision XX - blocks the entire paste if something the new building collides with something\n" +
                                  "deployables true/false - false to remove deployables\n" +
                                  "inventories true/false - false to ignore inventories\n" +
                                  "vending - Information and sellings in vending machine\n" +
                                  "stability <true/false> - Wether or not to disable stability on the building\n" +
                                  "position <x,y,z> - Override position\n" +
                                  "rotation <X> - Override rotation"
                        },
                        {
                            "ru", "Синтаксис: /paste or /pasteback <Название Объекта> <опция значение>\n" +
                                  "height XX - Высота от земли\n" +
                                  "autoheight true/false - автоматически подобрать высоту от земли\n" +
                                  "blockcollision XX - блокировать вставку, если что-то этому мешает\n" +
                                  "deployables true/false - false для удаления предметов\n" +
                                  "inventories true/false - false для игнорирования копирования инвентаря\n" +
                                  "vending - Информация и товары в торговом автомате"
                        },
                        {
                            "nl", "Syntax: /paste of /pasteback <Bestandsnaam> <opties waarden>\n" +
                                  "height XX - Pas de hoogte aan \n" +
                                  "autoheight true/false - probeert de optimale hoogte te vinden om gebouw te plaatsen. Werkt optimaal op vlakke grond.\n" +
                                  "vending true/false - Informatie en inventaris van \"vending machines\" kopiëren\n" +
                                  "stability <true/false> - of de stabiliteit van het gebouw uitgezet moet worden\n" +
                                  "deployables <true/false> - of de \"deployables\" gekopiërd moeten worden\n" +
                                  "auth <true/false> - Of authorisatie op sloten en tool cupboards gekopiërd moet worden"
                        }
                    }
                },
                {
                    "PASTEBACK_SUCCESS", new Dictionary<string, string>
                    {
                        { "en", "You've successfully placed back the structure" },
                        { "ru", "Постройка успешно вставлена на старое место" },
                        { "nl", "Het gebouw is succesvol teruggeplaatst." }
                    }
                },
                {
                    "PASTE_SUCCESS", new Dictionary<string, string>
                    {
                        { "en", "You've successfully pasted the structure" },
                        { "ru", "Постройка успешно вставлена" },
                        { "nl", "Het gebouw is succesvol geplaatst." }
                    }
                },
                {
                    "SYNTAX_COPY", new Dictionary<string, string>
                    {
                        {
                            "en", "Syntax: /copy <Target Filename> <options values>\n" +
                                  "radius XX (default 3) - The radius in which to search for the next object (performs this search from every other object)\n" +
                                  "method proximity/building (default proximity) - Building only copies objects which are part of the building, proximity copies everything (within the radius)\n" +
                                  "deployables true/false (saves deployables or not) - Wether to save deployables\n" +
                                  "inventories true/false (saves inventories or not) - Wether to save inventories of found objects with inventories."
                        },
                        {
                            "ru", "Синтаксис: /copy <Название Объекта> <опция значение>\n" +
                                  "radius XX (default 3)\n" +
                                  "method proximity/building (по умолчанию proximity)\n" +
                                  "deployables true/false (сохранять предметы или нет)\n" +
                                  "inventories true/false (сохранять инвентарь или нет)"
                        },
                        {
                            "nl", "Syntax: /copy <Bestandsnaam> <opties waarden>\n" +
                                  "radius XX (standaard 3) - De radius waarin copy paste naar het volgende object zoekt\n" +
                                  "method proximity/building (standaard proximity) - Building kopieërd alleen objecten die bij het gebouw horen, proximity kopieërd alles wat gevonden is\n" +
                                  "deployables true/false (saves deployables or not) - Of de data van gevonden \"deployables\" opgeslagen moet worden\n" +
                                  "inventories true/false (saves inventories or not) - Of inventarissen van objecten (kisten, tool cupboards, etc) opgeslagen moet worden"
                        }
                    }
                },
                {
                    "NO_ENTITY_RAY", new Dictionary<string, string>
                    {
                        { "en", "Couldn't ray something valid in front of you" },
                        { "ru", "Не удалось найти какой-либо объект перед вами" },
                        { "nl", "U kijkt niet naar een geschikt object om een kopie op te starten." }
                    }
                },
                {
                    "COPY_SUCCESS", new Dictionary<string, string>
                    {
                        { "en", "The structure was successfully copied as {0}" },
                        { "ru", "Постройка успешно скопирована под названием: {0}" },
                        { "nl", "Gebouw is succesvol gekopieërd" }
                    }
                },
                {
                    "NO_PASTED_STRUCTURE", new Dictionary<string, string>
                    {
                        { "en", "You must paste structure before undoing it" },
                        { "ru", "Вы должны вставить постройку перед тем, как отменить действие" },
                        {
                            "nl",
                            "U moet eerst een gebouw terugplaatsen alvorens deze ongedaan gemaakt kan worden (duhh)"
                        }
                    }
                },
                {
                    "UNDO_SUCCESS", new Dictionary<string, string>
                    {
                        { "en", "You've successfully undid what you pasted" },
                        { "ru", "Вы успешно снесли вставленную постройку" },
                        { "nl", "Laatse geplaatste gebouw is succesvol ongedaan gemaakt." }
                    }
                },
                {
                    "NOT_FOUND_PLAYER", new Dictionary<string, string>
                    {
                        { "en", "Couldn't find the player" },
                        { "ru", "Не удалось найти игрока" },
                        { "nl", "Speler niet gevonden." }
                    }
                },
                {
                    "SYNTAX_BOOL", new Dictionary<string, string>
                    {
                        { "en", "Option {0} must be true/false" },
                        { "ru", "Опция {0} принимает значения true/false" },
                        { "nl", "Optie {0} moet true of false zijn" }
                    }
                },
                {
                    "SYNTAX_FLOAT", new Dictionary<string, string>
                    {
                        { "en", "Option {0} must be a decimal" },
                        { "ru", "Опция {0} принимает только числовые значения с точкой" },
                        { "nl", "Optie {0} moet een decimal zijn" }
                    }
                },
                {
                    "SYNTAX_HEIGHT", new Dictionary<string, string>
                    {
                        { "en", "Option height must be a number" },
                        { "ru", "Опция height принимает только числовые значения" },
                        { "nl", "De optie height accepteert alleen nummers" }
                    }
                },
                {
                    "SYNTAX_BLOCKCOLLISION", new Dictionary<string, string>
                    {
                        { "en", "Option blockcollision must be a number, 0 will deactivate the option" },
                        {
                            "ru",
                            "Опция blockcollision принимает только числовые значения, 0 позволяет отключить проверку"
                        },
                        { "nl", "Optie blockcollision accepteert alleen nummers, 0 schakelt deze functionaliteit uit" }
                    }
                },
                {
                    "SYNTAX_RADIUS", new Dictionary<string, string>
                    {
                        { "en", "Option radius must be a number" },
                        { "ru", "Опция radius принимает только числовые значения" },
                        { "nl", "Optie height accepteert alleen nummers" }
                    }
                },
                {
                    "BLOCKING_PASTE", new Dictionary<string, string>
                    {
                        { "en", "Something is blocking the paste" },
                        { "ru", "Что-то препятствует вставке" },
                        { "nl", "Iets blokkeert het plaatsen van dit gebouw" }
                    }
                },
                {
                    "AVAILABLE_STRUCTURES", new Dictionary<string, string>
                    {
                        { "ru", "<color=orange>Доступные постройки:</color>" },
                        { "en", "<color=orange>Available structures:</color>" },
                        { "nl", "Beschikbare bestanden om te plaatsen zijn:" }
                    }
                }
            };

        public class CopyData
        {
            public IPlayer Player;
            public BasePlayer BasePlayer;
            public Stack<Vector3> CheckFrom = new Stack<Vector3>();
            public HashSet<BaseEntity> HouseList = new HashSet<BaseEntity>();
            public List<object> RawData = new List<object>();
            public Vector3 SourcePos;
            public Vector3 SourceRot;
            public Action Callback;

            public string Filename;
            public int CurrentLayer;
            public float RotCor;
            public float Range;
            public bool SaveTree;
            public bool SaveShare;
            public CopyMechanics CopyMechanics;
            public bool EachToEach;
            public uint BuildingId = 0;

#if DEBUG
            public Stopwatch Sw = new Stopwatch();
#endif
        }

        public class PasteData
        {
            public ICollection<Dictionary<string, object>> Entities;
            public List<BaseEntity> PastedEntities = new List<BaseEntity>();
            public string Filename;

            public Dictionary<ulong, Dictionary<string, object>> EntityLookup =
                new Dictionary<ulong, Dictionary<string, object>>();

            public Dictionary<ulong, Item> ItemsWithSubEntity = new Dictionary<ulong, Item>();
            public List<Action> FinalProcessingActions = new List<Action>();
            public IPlayer Player;
            public BasePlayer BasePlayer;
            public List<StabilityEntity> StabilityEntities = new List<StabilityEntity>();
            public List<IndustrialStorageAdaptor> industrialStorageAdaptors = new List<IndustrialStorageAdaptor>();
            public Quaternion QuaternionRotation;
            public Action CallbackFinished;
            public Action<BaseEntity> CallbackSpawned;

            public bool Auth;
            public Vector3 StartPos;
            public float HeightAdj;
            public bool Stability;
            public bool IsItemReplace;
            public bool Ownership;
            public bool CheckPlaced = true;
            public bool EnableSaving = true;

            public bool Cancelled = false;

            public uint BuildingId = 0;
            
            public VersionNumber Version { get; set; }

#if DEBUG
            public Stopwatch Sw = new Stopwatch();
#endif
        }
        
        private VersionNumber ParseVersionNumber(string versionString)
        {
            string[] array = versionString.Split(new char[1] { '.' }, StringSplitOptions.RemoveEmptyEntries);
            int major = int.Parse(array[0]);
            int minor = int.Parse(array[1]);
            int patch = int.Parse(array[2]);
            return new VersionNumber(major, minor, patch);
        }
    }
}

// --- End of file: CopyPaste.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ch47-and-mini-copter-spawner ---
// --- Original File Path: C/CH47AndMiniCopterSpawner/CH47AndMiniCopterSpawner.cs ---

using UnityEngine;
using System.Collections.Generic;
using Oxide.Core;
using Convert = System.Convert;
using System.Linq;
using Oxide.Game.Rust.Cui;
using System;
using System.Text.RegularExpressions;
using Oxide.Core.Plugins;
using Newtonsoft.Json.Linq;

namespace Oxide.Plugins
{
    [Info("CH47 And MiniCopter Spawner", "BuzZ[PHOQUE]", "1.0.4")]
    [Description("Spawn CH47 and/or MiniCopter at saved point(s)")]

/*=======================================================================================================================
*   THANKS TO THE OXIDE/UMOD TEAM for coding quality, ideas, and time spent for the community
*
*   10 february 2019
*
*
*   1.0.0   20190210        creation
*   1.0.1                   code
*   1.0.2                   code
*   1.0.3                   Patch for 2023 May 4th
*=======================================================================================================================*/

    public class CH47AndMiniCopterSpawner : RustPlugin
    {
        bool debug = false;
        bool loaded;
        string Prefix = "[Spawner] :";
        ulong SteamIDIcon = 76561198332562475;
        const string chprefab = "assets/prefabs/npc/ch47/ch47.entity.prefab";
        const string miniprefab = "assets/content/vehicles/minicopter/minicopter.entity.prefab";
        const string SpawnerAdmin = "ch47andminicopterspawner.admin";

//////////////////////////////////////////////////////////////////////////////////////////////////////////

    class StoredData
    {
        public Dictionary<string, Vector3> SpawnSpots = new Dictionary<string, Vector3>();
        public List<ulong> SpawnerCH47 = new List<ulong>();
        public List<ulong> SpawnerMinicopters = new List<ulong>();

        public StoredData()
        {
        }
    }
        private StoredData storedData;

////////////////////////////////////////////////////////////////////////////////
        void Init()
        {
            permission.RegisterPermission(SpawnerAdmin, this);
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
        }

        void Loaded()
        {
            loaded = true;
        }

        void Unload()
        {
            	foreach (var entity in UnityEngine.Object.FindObjectsOfType<BaseEntity>())
				{
					if (entity.OwnerID == 998877665544)
					{
						if (debug) Puts ("REMOVING ONE COPTER from spawner");
						entity.Kill();
					}
				}
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
        }
/////////////////////////////////////////
#region MESSAGES

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"NoDataMsg", "No spawn point data found."},
                {"WipeMsg", "Datas have been wiped. {0} spots were in datas."},
                {"AlreadySpotNameMsg", "Spot name already taken."},
                {"NotFoundSpotMsg", "Spot name not found."},
                {"RemovedOneSpotMsg", "Spot has been removed."},
                {"HelpMsg", "Commands are :\n/cms_add\n/cms_list\n/cms_allch\n/cms_ch\n/cms_allmini\n/cms_mini\n/cms_del\n/cms_wipe"},
                {"SetSpotNameDeleteMsg", "Please set a spot name to delete"},
                {"SetSpotNameMsg", "Please set a name for this spot.\nexample : /copterspawn_add airport"},
                {"SpotAddedMsg", "Spot {0} added to datas."},
                {"SpawnedMsg", "{0} Helicopter has spawned on {1} spot !."},
                {"KilledMsg", "A {0} Helicopter has been removed/killed."},
                {"NoPermMsg", "You are not allowed to do this."},

            }, this, "en");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"NoDataMsg", "Aucun point trouvé dans les données."},
                {"WipeMsg", "Données effacées. Il y avait {0} points enregistrés."},
                {"AlreadySpotNameMsg", "Ce nom est déjà pris."},
                {"NotFoundSpotMsg", "Le nom du spot n'a pas été trouvé."},
                {"RemovedOneSpotMsg", "Ces coordonnées ont été effacées."},
                {"HelpMsg", "Les commandes sont :\n/cms_add\n/cms_list\n/cms_allch\n/cms_ch\n/cms_allmini\n/cms_mini\n/cms_del\n/cms_wipe"},
                {"SetSpotNameDeleteMsg", "Veuillez préciser le nom d'un spot à effacer."},
                {"SetSpotNameMsg", "Veuillez saisir un nom pour ces coordonnées.\nexemple : /copterspawn_add chezmoi"},
                {"SpotAddedMsg", "Coordonnées pour {0} enregistrées dans les données."},
                {"SpawnedMsg", "{0} Helicoptère arrivé au point : {1}!"},
                {"KilledMsg", "Un Hélicoptère {0} a disparu du monde."},
                {"NoPermMsg", "Vous n'êtes pas autorisé."},

            }, this, "fr");
        }

#endregion
////////////////////////////////////////////////////
///////////////////
// CHAT /SPAWN
///////////
        [ChatCommand("cms")]
        private void CH47AndMiniCopterSpawnerNoUnderscore(BasePlayer player, string command, string[] args)
        {
            bool spawner = DoesThisPlayerHasPermission(player);
            if (!spawner) return;
            if (args.Length == 0 )
            {
                if (debug) Puts($"... command copterspawn... lonely");
                Player.Message(player, $"{lang.GetMessage("HelpMsg", this, player.UserIDString)}", Prefix, SteamIDIcon);
                return;
            }

            switch (args[0].ToLower())
            {
                case "add" :
                {
                    if (debug) Puts($"cms_add");
                    if (args.Length == 1 )
                    {
                        Player.Message(player, $"{lang.GetMessage("SetSpotNameMsg", this, player.UserIDString)}", Prefix, SteamIDIcon);
                        return;
                    }
                    string spotname = string.Empty;
                    int array = 1;
                    int Round = 1;
                    for (Round = 1; array <= args.Length - 1; Round++)
                    {
                        if (array == 1) spotname = args[array];
                        else spotname = spotname + " " + args[array];
                        array = array + 1;
                    }
                    if (storedData.SpawnSpots.ContainsKey(spotname))
                    {
                        Player.Message(player, $"{lang.GetMessage("AlreadySpotNameMsg", this, player.UserIDString)}", Prefix, SteamIDIcon);
                        return;
                    }
                    storedData.SpawnSpots.Add(spotname, player.transform.position + new Vector3(0f,1f,0f));
                    Player.Message(player, String.Format(lang.GetMessage("SpotAddedMsg", this, player.UserIDString), spotname), Prefix, SteamIDIcon);
                    break;
                }
                case "list" :
                {
                    if (debug) Puts($"cms_list");
                    string listinline = string.Empty;
                    if (storedData.SpawnSpots.Count() >= 1)
                    {
                        int array = 1;
                        foreach (var paire in storedData.SpawnSpots)
                        {
                            player.SendConsoleCommand("ddraw.box", 20f, Color.green, paire.Value, 1f);
                            player.SendConsoleCommand("ddraw.text", 20f, Color.green, paire.Value + new Vector3(0, 1f, 0), $"{paire.Key}");
                            listinline = listinline + $" <color=orange>[{array}]</color> " + paire.Key + " - " + paire.Value + " | ";
                            array = array + 1;
                        }
                        Player.Message(player, listinline, Prefix, SteamIDIcon);
                        return;
                    }
                    else
                    {
                        Player.Message(player, $"{lang.GetMessage("NoDataMsg", this, player.UserIDString)}", Prefix, SteamIDIcon);
                        return;
                    }
                    break;
                }
                case "allch" :
                {
                    if (debug) Puts($"cms_allch");
                    foreach (var paire in storedData.SpawnSpots)
                    {
                        SpawnOneHelicopterThere(paire.Value, "ch47");
                        Player.Message(player, String.Format(lang.GetMessage("SpawnedMsg", this, player.UserIDString), "CH47", paire.Key), Prefix, SteamIDIcon);
                    }
                    break;
                }
                case "ch" :
                {
                    if (debug) Puts($"cms_ch");
                    if (storedData.SpawnSpots == null)
                    {
                        Player.Message(player, $"{lang.GetMessage("NoDataMsg", this, player.UserIDString)}", Prefix, SteamIDIcon);
                        return;
                    }
                    if (args.Length == 1 )
                    {
                        Player.Message(player, $"{lang.GetMessage("SetSpotNameMsg", this, player.UserIDString)}", Prefix, SteamIDIcon);
                        return;
                    }
                    string spotname = string.Empty;
                    int array = 1;
                    int Round = 1;
                    for (Round = 1; array <= args.Length - 1; Round++)
                    {
                        if (array == 1) spotname = args[array];
                        else spotname = spotname + " " + args[array];
                        array = array + 1;
                    }
                    Vector3 there = new Vector3();
                    storedData.SpawnSpots.TryGetValue(spotname, out there);
                    if (there != null)
                    {
                        SpawnOneHelicopterThere(there, "ch47");
                        Player.Message(player, String.Format(lang.GetMessage("SpawnedMsg", this, player.UserIDString), "CH47", spotname), Prefix, SteamIDIcon);
                    }
                    break;
                }
                case "allmini" :
                {
                    if (debug) Puts($"cms_allmini");
                    foreach (var paire in storedData.SpawnSpots)
                    {
                        SpawnOneHelicopterThere(paire.Value, "mini");
                        Player.Message(player, String.Format(lang.GetMessage("SpawnedMsg", this, player.UserIDString), "Mini", paire.Key), Prefix, SteamIDIcon);
                    }
                    break;
                }
                case "mini" :
                {
                    if (debug) Puts($"cms_mini");
                    if (storedData.SpawnSpots == null)
                    {
                        Player.Message(player, $"{lang.GetMessage("NoDataMsg", this, player.UserIDString)}", Prefix, SteamIDIcon);
                        return;
                    }
                    if (args.Length == 1 )
                    {
                        Player.Message(player, $"{lang.GetMessage("SetSpotNameMsg", this, player.UserIDString)}", Prefix, SteamIDIcon);
                        return;
                    }
                    string spotname = string.Empty;
                    int array = 1;
                    int Round = 1;
                    for (Round = 1; array <= args.Length - 1; Round++)
                    {
                        if (array == 1) spotname = args[array];
                        else spotname = spotname + " " + args[array];
                        array = array + 1;
                    }
                    Vector3 there = new Vector3();
                    storedData.SpawnSpots.TryGetValue(spotname, out there);
                    if (there != null)
                    {
                        SpawnOneHelicopterThere(there, "mini");
                        Player.Message(player, String.Format(lang.GetMessage("SpawnedMsg", this, player.UserIDString), "Mini", spotname), Prefix, SteamIDIcon);
                    }
                    break;
                }
                case "del" :
                {
                    if (debug) Puts($"cms_del");
                    if (args.Length == 1 )
                    {
                        Player.Message(player, $"{lang.GetMessage("SetSpotNameDeleteMsg", this, player.UserIDString)}", Prefix, SteamIDIcon);
                        return;
                    }
                    bool found = false;
                    string spotname = string.Empty;
                    int array = 1;
                    int Round = 1;
                    for (Round = 1; array <= args.Length - 1; Round++)
                    {
                        if (array == 1) spotname = args[array];
                        else spotname = spotname + " " + args[array];
                        array = array + 1;
                    }
                    if (storedData.SpawnSpots.ContainsKey(spotname))
                    {
                            found = true;
                            Player.Message(player, $"{lang.GetMessage("RemovedOneSpotMsg", this, player.UserIDString)} - {spotname}", Prefix, SteamIDIcon);
                    }
                    if (found == false) Player.Message(player, $"{lang.GetMessage("NotFoundSpotMsg", this, player.UserIDString)}", Prefix, SteamIDIcon);
                    else storedData.SpawnSpots.Remove(spotname);
                    break;
                }
                case "wipe" :
                {
                    if (debug) Puts($"cms_wipe");
                    int count = storedData.SpawnSpots.Count();
                    storedData.SpawnSpots.Clear();
                    Player.Message(player, String.Format(lang.GetMessage("WipeMsg", this, player.UserIDString), count), Prefix, SteamIDIcon);

                    break;
                }
            }
        }

// code duplica on bool.perm
// onload check uint, remove non existing
// cms_chalive = list ch47 uint in world
// cms_minialive

// chat command spawn_random X

// chat command wipe

// config remove default rust CH47 on map (ownerid =0 ?)

// true/false ch47 mmapmarker

// timer auto kill/spawn = respawn timer
//console commands all in one
// kill heliz alive
///////////////////////////////////
// BOOL PERM ADMIN
/////////////////////////
        bool DoesThisPlayerHasPermission(BasePlayer player)
        {
            bool admin = permission.UserHasPermission(player.UserIDString, SpawnerAdmin);
            if (!admin)
            {
                Player.Message(player, $"{lang.GetMessage("NoPermMsg", this, player.UserIDString)}", Prefix, SteamIDIcon);
                return false;
            }
            else return true;
        }

/////////////////////////////
// SPAWN ON VECTOR3
///////////////////

        void SpawnOneHelicopterThere(Vector3 spot, string what)
        {
            if (spot == null) return;
            string prefab = chprefab;
            if (what == "mini") prefab = miniprefab;
            BaseVehicle vehicle = (BaseVehicle)GameManager.server.CreateEntity(prefab, spot, new Quaternion());
            if (vehicle == null) return;
            BaseEntity entity = vehicle as BaseEntity;
            entity.OwnerID = 998877665544;//for FUTURE
            vehicle.Spawn();
            NetworkableId copteruint = entity.net.ID;
            storedData.SpawnerCH47.Add(copteruint.Value);
            if (debug) Puts($"SPAWNED MINICOPTER {copteruint.ToString()} - OWNER {entity.OwnerID}");
        }

//////////////////////////
// KILL ONE ID CH47 - FUTURE
///////////////
        /*void KillThisSpawnerCH47HelicopterPlease(uint deluint)
        {
            if (debug) Puts($"KillThisSpawnerCH47HelicopterPlease");
            var tokill = BaseNetworkable.serverEntities.Find(deluint);
            if (tokill != null) tokill.Kill();
            storedData.SpawnerCH47.Remove(deluint);
        }*/
////////////////////////////////
// ENTITY KILL
//////////////////

        void OnEntityKill(BaseNetworkable entity)
        {
            if (!loaded) return;
            if (entity == null) return;
            if (entity.net.ID == default) return;
            if (storedData.SpawnerCH47 == null && storedData.SpawnerMinicopters == null) return;
            if (storedData.SpawnerCH47.Contains(entity.net.ID.Value) == false && storedData.SpawnerMinicopters.Contains(entity.net.ID.Value) == false)
            {
                if (debug) Puts($"KILLED HELICOPTER not from Spawner plugin");
                return;
            }
            NetworkableId todelete = default;
            CH47Helicopter chcheck = entity as CH47Helicopter;
            if (chcheck != null)
            {
                if (storedData.SpawnerCH47.Contains(entity.net.ID.Value)) todelete = entity.net.ID;
                if (todelete != null)
                {
                    storedData.SpawnerCH47.Remove(todelete.Value);
                    if (debug) Puts($"KILLED CH47 - removed from list");
                }
                return;
            }
            Minicopter minicheck = entity as Minicopter;
            if (minicheck != null)
            {
                if (storedData.SpawnerMinicopters.Contains(entity.net.ID.Value)) todelete = entity.net.ID;
                if (todelete != null)
                {
                    storedData.SpawnerMinicopters.Remove(todelete.Value);
                    if (debug) Puts($"KILLED MINI - removed from list");
                }
            }
        }
    }
}


// --- End of file: CH47AndMiniCopterSpawner.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/custom-icon ---
// --- Original File Path: C/CustomIcon/CustomIcon.cs ---

﻿using System.Collections.Generic;
using Network;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Custom Icon", "collect_vood", "1.0.4")]
    [Description("Set a customizable icon for all non user messages")]

    class CustomIcon : CovalencePlugin
    {
        #region Config
        
        private Configuration _configuration;
        
        private class Configuration
        {
            [JsonProperty(PropertyName = "Steam Avatar User ID")]
            public ulong SteamAvatarUserID = 0;
        }
        
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            _configuration = new Configuration();
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            _configuration = Config.ReadObject<Configuration>();
            SaveConfig();
        }
        
        protected override void SaveConfig() => Config.WriteObject(_configuration);
        
        #endregion

        #region Hooks 
        
        private void OnBroadcastCommand(string command, object[] args)
        {
            TryApplySteamAvatarUserID(command, args);
        }
        
        private void OnSendCommand(Connection cn, string command, object[] args)
        {
            TryApplySteamAvatarUserID(command, args);
        }
        
        private void OnSendCommand(List<Connection> cn, string command, object[] args)
        {
            TryApplySteamAvatarUserID(command, args);
        }

        #endregion

        #region Helpers

        private void TryApplySteamAvatarUserID(string command, object[] args)
        {
            if (args == null || _configuration == null) 
                return;
            
            if (args.Length < 2 || (command != "chat.add" && command != "chat.add2")) 
                return;

            ulong providedID;
            if (ulong.TryParse(args[1].ToString(), out providedID) && providedID == 0)
                args[1] = _configuration.SteamAvatarUserID;
        }

        #endregion
    }
}

// --- End of file: CustomIcon.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/custom-chat-commands ---
// --- Original File Path: C/CustomChatCommands/CustomChatCommands.cs ---

﻿﻿using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("CustomChatCommands", "PsychoTea", "2.1.2")]
    [Description("Allows you to set up custom commands.")]

    class CustomChatCommands : CovalencePlugin
    {
        class ChatCommand
        {
            public string Command;
            public List<string> Messages;
            public string Permission;
            public List<string> ConsoleCmd;
            public ulong UserID;
            public bool Broadcast;
            public List<string> RconCmd;
            public float Cooldown;
            public int MaxUses;

            public ChatCommand(string Command, List<string> Messages, string Permission = "", List<string> ConsoleCmd = null, ulong UserID = 0, bool Broadcast = false, List<string> RconCmd = null, float Cooldown = 0f, int MaxUses = 0)
            {
                this.Command = Command;
                this.Messages = Messages;
                this.Permission = Permission;
                this.ConsoleCmd = ConsoleCmd;
                this.UserID = UserID;
                this.Broadcast = Broadcast;
                this.RconCmd = RconCmd;
                this.Cooldown = Cooldown;
                this.MaxUses = MaxUses;
            }
        }

        class Cooldown
        {
            public string CommandName;
            public double ExpiryPoint;

            public Cooldown(string CommandName, double ExpiryPoint)
            {
                this.CommandName = CommandName;
                this.ExpiryPoint = ExpiryPoint;
            }
        }

        class MaxUses
        {
            public string CommandName;
            public int Uses;

            public MaxUses(string CommandName, int Uses)
            {
                this.CommandName = CommandName;
                this.Uses = Uses;
            }
        }

        #region Config

        ConfigFile config;

        class ConfigFile
        {
            [JsonProperty(PropertyName = "Reset Cooldowns On New Map")]
            public bool ResetCooldownsOnNewMap;

            [JsonProperty(PropertyName = "Reset Max Uses On New Map")]
            public bool ResetMaxUsesOnNewMap;

            [JsonProperty(PropertyName = "Reset Max Uses At Midnight")]
            public bool ResetMaxUsesAtMidnight;

            public List<ChatCommand> Commands;

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    ResetCooldownsOnNewMap = true,
                    ResetMaxUsesOnNewMap = true,
                    ResetMaxUsesAtMidnight = true,
                    Commands = new List<ChatCommand>()
                    {
                        new ChatCommand("sinfo", new List<string>() { "<color=lime>Insert your server info here!</color>" }),
                        new ChatCommand("website", new List<string>() { "Insert your server website here! This is broadcasted to all users!" }, "customchatcommands.admin", null, 0, true, null, 30f, 3),
                        new ChatCommand("adminhelp", new List<string>() { "Password for TeamSpeak channel: xyz", "Discord invite: website.com/discord" }, "customchatcommands.admin"),
                        new ChatCommand("noclip", new List<string>() { "NoClip toggled." }, "customchatcommands.admin", new List<string> { "noclip" }, 0, false, new List<string>() { "say {player.name} / {player.id} has used the /noclip command!" })
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<ConfigFile>();
        }

        protected override void LoadDefaultConfig() => config = ConfigFile.DefaultConfig();

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Data

        class StoredData
        {
            public Dictionary<ulong, List<Cooldown>> Cooldowns = new Dictionary<ulong, List<Cooldown>>();
            public Dictionary<ulong, List<MaxUses>> MaxUses = new Dictionary<ulong, List<MaxUses>>();
        }
        StoredData storedData;

        void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(this.Title, storedData);

        void ReadData() => storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(this.Title);

        #endregion

        #region Oxide Hooks

        void Init()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                { "Command On Cooldown - Minutes", "This command is on cooldown for another {0} minutes." },
                { "Command On Cooldown - Hours", "This command is on cooldwon for another {0} hours." },
                { "Max Uses Reached", "You have reached the maximum of {0} uses for this command." }
            }, this);

            foreach (var command in config.Commands)
            {
                AddCovalenceCommand(command.Command, "CustomCommand", command.Permission);
            }

            ReadData();

            if (config.ResetMaxUsesAtMidnight)
            {
                timer.Every(60f, () =>
                {
                    if (DateTime.Now.Hour == 0 && DateTime.Now.Minute == 0)
                    {
                        ResetMaxUses();
                    }
                });
            }
        }

        void Unload() => SaveData();

        void OnNewSave()
        {
            if (config.ResetCooldownsOnNewMap)
            {
                ResetCooldowns();
            }

            if (config.ResetMaxUsesOnNewMap)
            {
                ResetMaxUses();
            }
        }

        void OnServerSave() => SaveData();

        #endregion

        #region Commands

        void CustomCommand(IPlayer player, string command, string[] args)
        {
            ulong userID = ulong.Parse(player.Id);

            var cmd = config.Commands.SingleOrDefault(x => x.Command.ToLower() == command.ToLower());
            if (cmd == null) return;

            if (!CanUseCommand(userID, cmd.Command))
            {
                player.Message(GetMessage("Max Uses Reached", player.Id, cmd.MaxUses.ToString()));
                return;
            }

            if (IsOnCooldown(userID, cmd.Command))
            {
                double timeRemaining = CooldownRemaining(userID, cmd.Command);

                double hours;
                if (IsHours(timeRemaining, out hours))
                {
                    Puts(hours.ToString());
                    player.Message(GetMessage("Command On Cooldown - Hours", player.Id, hours.ToString("N1")));
                    return;
                }

                double minutes = timeRemaining / 60;
                player.Message(GetMessage("Command On Cooldown - Minutes", player.Id, minutes.ToString("N1")));
                
                return;
            }

            if (cmd.Broadcast) BroadcastMessages(cmd.Messages, cmd.UserID);
            else SendMessages(player, cmd.Messages, cmd.UserID);

            if (cmd.ConsoleCmd != null && cmd.ConsoleCmd.Count > 0)
                foreach (var consoleCmd in cmd.ConsoleCmd)
                    player.Command(consoleCmd);

            if (cmd.RconCmd != null && cmd.RconCmd.Count > 0)
            {
                foreach (var rconCmd in cmd.RconCmd)
                {
                    var newCmd = rconCmd.Replace("{player.name}", player.Name)
                                        .Replace("{player.id}", player.Id);
                    server.Command(newCmd);
                }
            }

            if (cmd.Cooldown > 0f) AddCooldown(userID, cmd.Command, cmd.Cooldown);
            if (cmd.MaxUses > 0) AddUse(userID, cmd.Command);
        }

        [Command("ccc.resetcooldowns")]
        void CCCResetCooldowns(IPlayer player, string command, string[] args)
        {
            if (player.Id != "server_console") return;

            ResetCooldowns();
            player.Message($"[{this.Title}] Reset all cooldowns.");
        }

        [Command("ccc.resetmaxuses")]
        void CCCResetMaxUses(IPlayer player, string command, string[] args)
        {
            if (player.Id != "server_console") return;

            ResetMaxUses();
            player.Message($"[{this.Title}] Reset all max uses.");
        }

        #endregion

        #region Functions

        void SendMessages(IPlayer player, List<string> messages, ulong userID = 0)
        {
            foreach (var message in messages)
            {
                #if RUST
                var basePlayer = player.Object as BasePlayer;
                basePlayer?.SendConsoleCommand("chat.add", 2, userID, message);
                #else
                player.Message(message);
                #endif
            }
        }

        void BroadcastMessages(List<string> messages, ulong userID = 0) => players.Connected.ToList().ForEach(x => SendMessages(x, messages, userID));

        void AddCooldown(ulong userID, string commandName, float time)
        {
            if (!storedData.Cooldowns.ContainsKey(userID))
            {
                storedData.Cooldowns.Add(userID, new List<Cooldown>());
            }

            var search = storedData.Cooldowns[userID].Where(x => x.CommandName.ToLower() == commandName.ToLower());
            if (search.Any()) search.ToList().ForEach(x => storedData.Cooldowns[userID].Remove(x));

            var cooldown = new Cooldown(commandName, TimeSinceEpoch() + time);
            storedData.Cooldowns[userID].Add(cooldown);
            SaveData();
        }

        bool IsOnCooldown(ulong userID, string commandName)
        {
            if (!storedData.Cooldowns.ContainsKey(userID)) return false;

            var cooldown = storedData.Cooldowns[userID].SingleOrDefault(x => x.CommandName.ToLower() == commandName.ToLower());
            if (cooldown == null) return false;

            return cooldown.ExpiryPoint > TimeSinceEpoch();
        }

        double CooldownRemaining(ulong userID, string commandName)
        {
            if (!storedData.Cooldowns.ContainsKey(userID)) return -1f;

            var cooldown = storedData.Cooldowns[userID].SingleOrDefault(x => x.CommandName.ToLower() == commandName.ToLower());
            return cooldown.ExpiryPoint - TimeSinceEpoch();
        }

        void ResetCooldowns()
        {
            storedData.Cooldowns.Clear();
            SaveData();
        }

        void AddUse(ulong userID, string commandName)
        {
            if (!storedData.MaxUses.ContainsKey(userID))
            {
                storedData.MaxUses.Add(userID, new List<MaxUses>());
            }

            var foundUses = storedData.MaxUses[userID].SingleOrDefault(x => x.CommandName.ToLower() == commandName.ToLower());
            if (foundUses != null)
            {
                foundUses.Uses++;
                return;
            }

            var maxUses = new MaxUses(commandName, 1);
            storedData.MaxUses[userID].Add(maxUses);
            SaveData();
        }

        bool CanUseCommand(ulong userID, string commandName)
        {
            var configMax = config.Commands.Where(x => x.Command.ToLower() == commandName.ToLower()).FirstOrDefault()?.MaxUses;
            if (configMax == null || configMax < 1) return true;

            if (!storedData.MaxUses.ContainsKey(userID)) return true;

            var playerMax = storedData.MaxUses[userID].SingleOrDefault(x => x.CommandName.ToLower() == commandName.ToLower());
            if (playerMax == null) return true;

            return playerMax.Uses < configMax;
        }

        void ResetMaxUses()
        {
            storedData.MaxUses.Clear();
            SaveData();
        }

        double TimeSinceEpoch() => (DateTime.UtcNow - DateTime.MinValue).TotalSeconds;

        #endregion

        #region Helpers

        bool IsHours(double seconds, out double hours)
        {
            hours = seconds / (60d * 60d);

            return hours >= 1;
        }
        
        string GetMessage(string key, string userID, params string[] args) => string.Format(lang.GetMessage(key, this, userID), args);

        #endregion
    }
}

// --- End of file: CustomChatCommands.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/clothing-slots ---
// --- Original File Path: C/ClothingSlots/ClothingSlots.cs ---

﻿using System;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("ClothingSlots", "Jake_Rich", "1.1.4")]
    [Description("Available Inventory Slots Depends On Clothing Worn")]

    public partial class ClothingSlots : RustPlugin
    {
        public static ClothingSlots _plugin;
        public static JSONFile<ConfigData> _settingsFile; //I know static stuff persists, it's handled in this case :)
        public static ConfigData Settings { get { return _settingsFile.Instance; } }
        public PlayerDataController<SlotPlayerData> PlayerData;

        void Init()
        {
            _plugin = this;
        }

        void Loaded()
        {
            _settingsFile = new JSONFile<ConfigData>($"{Name}", ConfigLocation.Config, extension: ".json");
            PlayerData = new PlayerDataController<SlotPlayerData>();

            if (lang_en.Count > 0)
            {
                lang.RegisterMessages(lang_en, this); //Setup lang now by default in case it is needed
            }
        }

        void OnServerInitialized()
        {
            Settings.Setup();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
        }

        void Unload()
        {
            foreach (var data in PlayerData.All) data.SetSlots(30); //Reset slot limit when unloading plugin

            PlayerData.Unload();
        }

        void OnPlayerConnected(BasePlayer player) => PlayerData.Get(player).UpdateSlots();

        void OnPlayerDisconnected(BasePlayer player) => PlayerData.Get(player).UpdateSlots();

        void OnPlayerRespawned(BasePlayer player) => PlayerData.Get(player).UpdateSlots();

        void OnPlayerDeath(BasePlayer player) => PlayerData.Get(player).UpdateSlots();

        object CanMoveItem(Item item, PlayerInventory playerLoot, ItemContainerId targetContainer, int targetSlot, int amount)
        {
            if (item == null || playerLoot == null)
            {
                return null;
            }

            BasePlayer _BasePlayer = playerLoot.baseEntity;
            if (!_BasePlayer.IsValid())
            {
                return null;
            }

            BasePlayer player = playerLoot.GetComponent<BasePlayer>();
            if (player == null)
            {
                return null;
            }

            ItemContainer _targetContainer = playerLoot.FindContainer(targetContainer);
            if (_targetContainer == null)
            {
                return null;
            }

            if (targetSlot != -1)
            {
                return null;
            }

            if (item.parent != playerLoot.containerBelt)
            {
                return null;
            }

            if (item.info.GetComponent<ItemModWearable>() != null)
            {
                if (item.MoveToContainer(playerLoot.containerWear))
                {
                    return false;
                }
            }

            return null;
        }

        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if (container == null || item == null)
            {
                return;
            }

            BasePlayer player = container.GetOwnerPlayer();

            if (player == null || !player.userID.IsSteamId())
            {
                return;
            }

            if (container != player.inventory.containerWear || player.inventory.containerWear.uid != container.uid)
            {
                return;
            }

            PlayerData.Get(player).UpdateSlots();
        }

        void OnItemRemovedFromContainer(ItemContainer container, Item item)
        {
            if (container == null || item == null)
            {
                return;
            }

            BasePlayer player = container.GetOwnerPlayer();

            if (player == null || !player.userID.IsSteamId())
            {
                return;
            }

            if (container != player.inventory.containerWear || player.inventory.containerWear.uid != container.uid)
            {
                return;
            }

            NextFrame(() =>
            {
                //NextFrame it, so when clothing is put into the inventory it will move when capacity decreases
                if (player == null || !player.userID.IsSteamId() || player.IsDead())
                {
                    return;
                }

                PlayerData.Get(player).UpdateSlots();
            });
        }

        public class ClothingSetting
        {
            [JsonProperty(PropertyName = "Available inventory slots (Main)")]
            public int Slots = 0;

            public ClothingSetting()
            {

            }

            public ClothingSetting(ItemDefinition clothing)
            {

            }
        }

        public class ConfigData
        {
            [JsonProperty(PropertyName = "Available inventory slots (Belt)")]
            public int DefaultSlots = 6;

            [JsonProperty(PropertyName = "Clothing settings (item shortname) and (available inventory slots)")]
            public Dictionary<string, ClothingSetting> Clothing = new Dictionary<string, ClothingSetting>() //Default values are as follows
            {
                {"hazmatsuit", new ClothingSetting() { Slots = 12, } },
                {"hazmatsuit.arcticsuit", new ClothingSetting() { Slots = 12, } },
                {"hazmatsuit.spacesuit", new ClothingSetting() { Slots = 12, } },
                {"hazmatsuit.lumberjack", new ClothingSetting() { Slots = 12, } },
                {"mask.balaclava", new ClothingSetting() { Slots = 1, } },
                {"diving.tank", new ClothingSetting() { Slots = 5, } },
                {"mask.bandana", new ClothingSetting() { Slots = 1, } },
                {"shoes.boots", new ClothingSetting() { Slots = 4, } },
                {"scientistsuit_heavy", new ClothingSetting() { Slots = 24, } },
                {"roadsign.jacket", new ClothingSetting() { Slots = 1, } },
                {"tshirt.long", new ClothingSetting() { Slots = 1, } },
                {"hat.beenie", new ClothingSetting() { Slots = 1, } },
                {"diving.wetsuit", new ClothingSetting() { Slots = 4, } },
                {"wood.armor.pants", new ClothingSetting() { Slots = 1, } },
                {"wood.armor.jacket", new ClothingSetting() { Slots = 1, } },
                {"wood.armor.helmet", new ClothingSetting() { Slots = 1, } },
                {"metal.facemask", new ClothingSetting() { Slots = 1, } },
                {"metal.facemask.hockey", new ClothingSetting() { Slots = 1, } },
                {"attire.hide.vest", new ClothingSetting() { Slots = 1, } },
                {"jacket.snow", new ClothingSetting() { Slots = 16, } },
                {"hat.cap", new ClothingSetting() { Slots = 1, } },
                {"roadsign.kilt", new ClothingSetting() { Slots = 1, } },
                {"burlap.gloves", new ClothingSetting() { Slots = 1, } },
                {"jumpsuit.suit", new ClothingSetting() { Slots = 8, } },
                {"attire.ninja.suit", new ClothingSetting() { Slots = 6, } },
                {"hazmatsuit_scientist_arctic", new ClothingSetting() { Slots = 24, } },
                {"hazmatsuit.nomadsuit", new ClothingSetting() { Slots = 12, } },
                {"attire.bunny.onesie", new ClothingSetting() { Slots = 8, } },
                {"halloween.mummysuit", new ClothingSetting() { Slots = 5, } },
                {"ghostsheet", new ClothingSetting() { Slots = 1, } },
                {"hazmatsuit_scientist", new ClothingSetting() { Slots = 24, } },
                {"hazmatsuit_scientist_peacekeeper", new ClothingSetting() { Slots = 24, } },
                {"halloween.surgeonsuit", new ClothingSetting() { Slots = 5, } },
                {"scarecrow.suit", new ClothingSetting() { Slots = 5, } },
                {"barrelcostume", new ClothingSetting() { Slots = 24, } },
                {"attire.egg.suit", new ClothingSetting() { Slots = 4, } },
                {"bone.armor.suit", new ClothingSetting() { Slots = 4, } },
                {"deer.skull.mask", new ClothingSetting() { Slots = 1, } },
                {"attire.bunnyears", new ClothingSetting() { Slots = 1, } },
                {"jacket", new ClothingSetting() { Slots = 8, } },
                {"diving.fins", new ClothingSetting() { Slots = 1, } },
                {"shirt.tanktop", new ClothingSetting() { Slots = 1, } },
                {"hat.oxmask", new ClothingSetting() { Slots = 1, } },
                {"hat.dragonmask", new ClothingSetting() { Slots = 1, } },
                {"hat.ratmask", new ClothingSetting() { Slots = 1, } },
                {"hat.tigermask", new ClothingSetting() { Slots = 1, } },
                {"metal.plate.torso", new ClothingSetting() { Slots = 1, } },
                {"attire.hide.helterneck", new ClothingSetting() { Slots = 1, } },
                {"twitch.headset", new ClothingSetting() { Slots = 1, } },
                {"burlap.shoes", new ClothingSetting() { Slots = 1, } },
                {"attire.banditguard", new ClothingSetting() { Slots = 24, } },
                {"attire.reindeer.headband", new ClothingSetting() { Slots = 1, } },
                {"nightvisiongoggles", new ClothingSetting() { Slots = 1, } },
                {"hat.boonie", new ClothingSetting() { Slots = 1, } },
                {"roadsign.gloves", new ClothingSetting() { Slots = 1, } },
                {"burlap.gloves.new", new ClothingSetting() { Slots = 1, } },
                {"burlap.headwrap", new ClothingSetting() { Slots = 1, } },
                {"scarecrowhead", new ClothingSetting() { Slots = 1, } },
                {"diving.mask", new ClothingSetting() { Slots = 1, } },
                {"attire.hide.poncho", new ClothingSetting() { Slots = 1, } },
                {"partyhat", new ClothingSetting() { Slots = 1, } },
                {"hat.gas.mask", new ClothingSetting() { Slots = 1, } },
                {"shirt.collared", new ClothingSetting() { Slots = 4, } },
                {"burlap.shirt", new ClothingSetting() { Slots = 1, } },
                {"attire.hide.boots", new ClothingSetting() { Slots = 3, } },
                {"boots.frog", new ClothingSetting() { Slots = 2, } },
                {"gloweyes", new ClothingSetting() { Slots = 1, } },
                {"pumpkin", new ClothingSetting() { Slots = 1, } },
                {"jumpsuit.suit.blue", new ClothingSetting() { Slots = 8, } },
                {"sunglasses", new ClothingSetting() { Slots = 1, } },
                {"tactical.gloves", new ClothingSetting() { Slots = 1, } },
                {"lumberjack hoodie", new ClothingSetting() { Slots = 12, } },
                {"hoodie", new ClothingSetting() { Slots = 12, } },
                {"heavy.plate.pants", new ClothingSetting() { Slots = 1, } },
                {"heavy.plate.jacket", new ClothingSetting() { Slots = 1, } },
                {"heavy.plate.helmet", new ClothingSetting() { Slots = 1, } },
                {"twitchsunglasses", new ClothingSetting() { Slots = 1, } },
                {"hat.miner", new ClothingSetting() { Slots = 1, } },
                {"tshirt", new ClothingSetting() { Slots = 1, } },
                {"hat.wolf", new ClothingSetting() { Slots = 1, } },
                {"hat.bunnyhat", new ClothingSetting() { Slots = 1, } },
                {"santahat", new ClothingSetting() { Slots = 1, } },
                {"clatter.helmet", new ClothingSetting() { Slots = 1, } },
                {"riot.helmet", new ClothingSetting() { Slots = 1, } },
                {"bucket.helmet", new ClothingSetting() { Slots = 1, } },
                {"coffeecan.helmet", new ClothingSetting() { Slots = 1, } },
                {"attire.snowman.helmet", new ClothingSetting() { Slots = 1, } },
                {"hat.candle", new ClothingSetting() { Slots = 1, } },
                {"attire.nesthat", new ClothingSetting() { Slots = 1, } },
                {"pants.shorts", new ClothingSetting() { Slots = 2, } },
                {"pants", new ClothingSetting() { Slots = 4, } },
                {"burlap.trousers", new ClothingSetting() { Slots = 1, } },
                {"attire.hide.pants", new ClothingSetting() { Slots = 2, } },
                {"attire.hide.skirt", new ClothingSetting() { Slots = 1, } },
                {"cratecostume", new ClothingSetting() { Slots = 24, } },
            };

            public void Setup()
            {
                var clothing = ItemManager.itemList.Where(x => x.GetComponent<ItemModWearable>());
                bool modified = false;
                foreach (var attire in clothing)
                {
                    if (_plugin.ItemNotClothing(attire.shortname))
                    {
                        //_plugin.Puts($"Item Not Clothing (shortname - {attire.shortname})");
                        continue;
                    }

                    if (!Clothing.ContainsKey(attire.shortname))
                    {
                        Clothing.Add(attire.shortname, new ClothingSetting(attire));
                        modified = true;
                    }
                }

                if (modified)
                {
                    _settingsFile.Save();
                }

                //Outputs default values I put above
                //_plugin.Puts(string.Join("\n", Clothing.Select(x=>$"{{\"{x.Key}\", new ClothingSetting() {{ Slots = {x.Value.Slots}, }} }},").ToArray()));
            }
        }

        bool ItemNotClothing(string shortname)
        {
            switch (shortname)
            {
                case "movembermoustache":
                    return true;
                case "santabeard":
                    return true;
                case "movembermoustachecard":
                    return true;
                case "frankensteins.monster.01.head":
                    return true;
                case "frankensteins.monster.01.legs":
                    return true;
                case "frankensteins.monster.01.torso":
                    return true;
                case "frankensteins.monster.02.head":
                    return true;
                case "frankensteins.monster.02.legs":
                    return true;                
                case "frankensteins.monster.02.torso":
                    return true;
                case "frankensteins.monster.03.head":
                    return true;
                case "frankensteins.monster.03.legs":
                    return true;
                case "frankensteins.monster.03.torso":
                    return true;
                case "sunglasses02black":
                    return true;
                case "sunglasses02camo":
                    return true;
                case "sunglasses02red":
                    return true;
                case "sunglasses03black":
                    return true;
                case "sunglasses03chrome":
                    return true;
                case "sunglasses03gold":
                    return true;
                default:
                    return false;
            }
        }

        public class SlotPlayerData : BasePlayerData
        {
            public void SetSlots(int slots)
            {
                if (Player == null || !Player.userID.IsSteamId() || !Player.IsConnected)
                {
                    return;
                }

                Player.inventory.containerBelt.MarkDirty();
                Player.inventory.containerMain.MarkDirty();

                if (slots <= 6)
                {
                    Player.inventory.containerBelt.capacity = slots;
                    Player.inventory.containerMain.capacity = 0;
                    UpdateInventories();
                    return;
                }

                Player.inventory.containerBelt.capacity = 6;

                if (slots >= 30)
                {
                    Player.inventory.containerMain.capacity = 24;
                }
                else
                {
                    Player.inventory.containerMain.capacity = slots - 6;
                }

                UpdateInventories();
            }

            private void UpdateInventory(ItemContainer container)
            {
                foreach (var invalidItem in container.itemList.ToList())
                {
                    if (invalidItem.position >= container.capacity)
                    {
                        bool hasMovedItem = false;
                        for (int slot = 0; slot < Player.inventory.containerMain.capacity; slot++)
                        {
                            var slotItem = container.GetSlot(slot);
                            if (slotItem != null && invalidItem != null)
                            {
                                if (slotItem.CanStack(invalidItem))
                                {
                                    int maxStack = slotItem.MaxStackable();
                                    if (slotItem.amount < maxStack)
                                    {
                                        slotItem.amount += invalidItem.amount;
                                        if (slotItem.amount > maxStack)
                                        {
                                            invalidItem.amount = slotItem.amount - maxStack;
                                            slotItem.amount = maxStack;
                                        }
                                        else
                                        {
                                            //Combined item
                                            hasMovedItem = true;
                                            invalidItem.Remove();
                                            ItemManager.DoRemoves();
                                            break;
                                        }
                                    }
                                }

                                continue;
                            }

                            invalidItem.position = slot;
                            hasMovedItem = true;
                            break;
                        }

                        if (hasMovedItem == false)
                        {
                            invalidItem.Drop(Player.GetDropPosition(), Player.GetDropVelocity());
                        }
                    }
                }
            }

            private void UpdateInventories()
            {
                if (Player.inventory.containerBelt.capacity < 6)
                {
                    UpdateInventory(Player.inventory.containerBelt);
                }

                if (Player.inventory.containerMain.capacity < 24)
                {
                    UpdateInventory(Player.inventory.containerMain);
                }
            }

            public void UpdateSlots()
            {
                int targetSlots = Settings.DefaultSlots;
                foreach (var clothing in Player.inventory.containerWear.itemList.ToList())
                {
                    targetSlots += Settings.Clothing[clothing.info.shortname].Slots;
                }

                SetSlots(targetSlots);
            }
        }

        #region Lang API

        public Dictionary<string, string> lang_en = new Dictionary<string, string>()
        {

        };

        public static string GetLangMessage(string key, BasePlayer player)
        {
            return _plugin.lang.GetMessage(key, _plugin, player.UserIDString);
        }

        public static string GetLangMessage(string key, ulong player)
        {
            return _plugin.lang.GetMessage(key, _plugin, player.ToString());
        }

        public static string GetLangMessage(string key, string player)
        {
            return _plugin.lang.GetMessage(key, _plugin, player);
        }

        #endregion

        #region PlayerData

        public class BasePlayerData
        {
            [JsonIgnore]
            public BasePlayer Player { get; set; }

            public string userID { get; set; } = "";

            public BasePlayerData()
            {

            }
            public BasePlayerData(BasePlayer player) : base()
            {
                userID = player.UserIDString;
                Player = player;
            }
        }

        public class PlayerDataController<T> where T : BasePlayerData
        {
            [JsonPropertyAttribute(Required = Required.Always)]
            private Dictionary<string, T> playerData { get; set; } = new Dictionary<string, T>();
            private JSONFile<Dictionary<string, T>> _file;
            private Timer _timer;
            public IEnumerable<T> All { get { return playerData.Values; } }

            public PlayerDataController()
            {

            }

            public PlayerDataController(string filename = null)
            {
                if (filename == null)
                {
                    return;
                }

                _file = new JSONFile<Dictionary<string, T>>(filename);
                _timer = _plugin.timer.Every(60.0f, () =>
                {
                    _file.Save();
                });
            }

            public void Unload()
            {
                if (_file == null)
                {
                    return;
                }

                _file.Save();
            }

            public T Get(string identifer)
            {
                T data;
                if (!playerData.TryGetValue(identifer, out data))
                {
                    data = Activator.CreateInstance<T>();
                    playerData[identifer] = data;
                }

                return data;
            }

            public T Get(ulong userID)
            {
                return Get(userID.ToString());
            }

            public T Get(BasePlayer player)
            {
                var data = Get(player.UserIDString);
                data.Player = player;
                return data;
            }

            public bool Has(ulong userID)
            {
                return playerData.ContainsKey(userID.ToString());
            }

            public void Set(string userID, T data)
            {
                playerData[userID] = data;
            }

            public bool Remove(string userID)
            {
                return playerData.Remove(userID);
            }

            public void Update(T data)
            {
                playerData[data.userID] = data;
            }
        }

        #endregion

        #region Configuration Files

        public enum ConfigLocation
        {
            Data = 0,
            Config = 1,
            Logs = 2,
            Plugins = 3,
            Lang = 4,
            Custom = 5,
        }

        public class JSONFile<Type> where Type : class
        {
            private DynamicConfigFile _file;
            public string _name { get; set; }
            public Type Instance { get; set; }
            private ConfigLocation _location { get; set; }
            private string _path { get; set; }

            public JSONFile(string name, ConfigLocation location = ConfigLocation.Data, string path = null, string extension = ".json")
            {
                _name = name.Replace(".json", "");
                _location = location;

                switch (location)
                {
                    case ConfigLocation.Data:
                        {
                            _path = $"{Oxide.Core.Interface.Oxide.DataDirectory}/{name}{extension}";
                            break;
                        }
                    case ConfigLocation.Config:
                        {
                            _path = $"{Oxide.Core.Interface.Oxide.ConfigDirectory}/{name}{extension}";
                            break;
                        }
                    case ConfigLocation.Logs:
                        {
                            _path = $"{Oxide.Core.Interface.Oxide.LogDirectory}/{name}{extension}";
                            break;
                        }
                    case ConfigLocation.Lang:
                        {
                            _path = $"{Oxide.Core.Interface.Oxide.LangDirectory}/{name}{extension}";
                            break;
                        }
                    case ConfigLocation.Custom:
                        {
                            _path = $"{path}/{name}{extension}";
                            break;
                        }
                }

                _file = new DynamicConfigFile(_path);
                _file.Settings = new JsonSerializerSettings() { ReferenceLoopHandling = ReferenceLoopHandling.Ignore };

                Init();
            }

            public virtual void Init()
            {
                Load();
                Save();
                Load();
            }

            public virtual void Load()
            {

                if (!_file.Exists())
                {
                    Save();
                }

                Instance = _file.ReadObject<Type>();

                if (Instance == null)
                {
                    Instance = Activator.CreateInstance<Type>();
                    Save();
                }
                return;
            }

            public virtual void Save()
            {
                _file.WriteObject(Instance);
                return;
            }

            public virtual void Reload()
            {
                Load();
            }

            private void Unload(Plugin sender, PluginManager manager)
            {

            }
        }

        #endregion
    }
}

// --- End of file: ClothingSlots.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/custom-item-gambling ---
// --- Original File Path: C/CustomItemGambling/CustomItemGambling.cs ---

using System.Collections.Generic;
using System;

namespace Oxide.Plugins
{
    [Info("Custom Item Gambling", "Pro Noob (patched by chrome)", "1.0.2")]
    [Description("Allows putting items other than scrap into the scrap wheel at Bandit Camp")]
    class CustomItemGambling : CovalencePlugin
    {
        #region Fields
        private const string usePermission = "customitemgambling.use";

        private ConfigData configData;
        private Dictionary<ItemContainer, ItemDefinition[]> originalAllowedItems = new Dictionary<ItemContainer, ItemDefinition[]>();
        private List<string> itemWhitelist;
        private bool allowAnyItem;
        #endregion

        #region Config
        private class ConfigData
        {
            public List<string> ItemWhitelist = new List<string>();
            public bool AllowAnyItem;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                ItemWhitelist = new List<string> { "scrap" },
                AllowAnyItem = false
            };
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Config not found or unreadable, generating new config file");
            Config.WriteObject(GetDefaultConfig(), true);
        }
        #endregion

        #region Oxide Hooks
        private void Init()
        {
            permission.RegisterPermission(usePermission, this);
            configData = Config.ReadObject<ConfigData>();
            itemWhitelist = configData.ItemWhitelist;
            allowAnyItem = configData.AllowAnyItem;
        }

        // Resetting allowed items lists back to their original values
        void Unload() => ResetContainer();

        private object CanMoveItem(Item item, PlayerInventory playerLoot, ItemContainerId targetContainerID, int targetSlot, int amount)
        {
            var basePlayer = item?.GetOwnerPlayer();

            if (basePlayer != null)
            {
                if (!basePlayer.IsNpc)
                {
                    ItemContainer targetContainer = playerLoot.FindContainer(targetContainerID);
                    BigWheelBettingTerminal bigWheelBettingTerminal;

                    try
                    {
                        bigWheelBettingTerminal = (BigWheelBettingTerminal)targetContainer?.entityOwner;
                    }
                    catch (Exception)
                    {
                        return null;
                    }

                    if (bigWheelBettingTerminal != null)
                    {
                        // Reset container allowed items and let the game handle the rest
                        if (!basePlayer.IPlayer.HasPermission(usePermission))
                        {
                            ResetContainer(targetContainer);
                            return null;
                        }

                        if (!itemWhitelist.Contains(item.info.shortname) && !allowAnyItem)
                            return false;

                        // Prevent mixing items since weird stuff happens if you do
                        if (targetContainer.itemList.Count > 0)
                        {
                            foreach (Item containerItem in targetContainer.itemList)
                            {
                                if (containerItem.info.shortname != item.info.shortname)
                                {
                                    return false;
                                }
                            }
                        }

                        if (!targetContainer.onlyAllowedItems.Contains(item.info))
                        {
                            if (!originalAllowedItems.ContainsKey(targetContainer))
                            {
                                originalAllowedItems.Add(targetContainer, targetContainer.onlyAllowedItems);
                            }

                            ItemDefinition[] allowedItems = new ItemDefinition[targetContainer.onlyAllowedItems.Length + 1];

                            // Add current item to allowed items list
                            for (int i = 0; i < allowedItems.Length - 1; i++)
                            {
                                allowedItems[i] = targetContainer.onlyAllowedItems[i];
                            }

                            allowedItems[allowedItems.Length - 1] = item.info;
                            targetContainer.SetOnlyAllowedItems(allowedItems);
                        }
                    }
                }
            }

            return null;
        }
        #endregion

        #region Methods
        private void ResetContainer(ItemContainer itemContainer = null)
        {
            if (itemContainer == null)
            {
                foreach (var keyValuePair in originalAllowedItems)
                {
                    keyValuePair.Key.SetOnlyAllowedItems(keyValuePair.Value);
                }
            }
            else
            {
                ItemDefinition[] itemDefinitions;
                originalAllowedItems.TryGetValue(itemContainer, out itemDefinitions);
                if (itemDefinitions != null)
                {
                    itemContainer.SetOnlyAllowedItems(itemDefinitions);
                }
            }
        }
        #endregion
    }
}

// --- End of file: CustomItemGambling.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/cupboard-info-logs ---
// --- Original File Path: C/CupboardInfoLogs/CupboardInfoLogs.cs ---

﻿using System;
using UnityEngine;

namespace Oxide.Plugins
{
	[Info("CupboardInfoLogs", "NubbbZ", "1.1.1")]
	[Description("Logs info about TC when placed!")]
	class CupboardInfoLogs : CovalencePlugin
	{
		#region Hooks
		void OnEntityBuilt(Planner plan, GameObject go)
		{
			BasePlayer Player = plan.GetOwnerPlayer();
			BaseEntity Entity = go.ToBaseEntity();

			if (Entity.ShortPrefabName.Contains("cupboard.tool"))
			{
				Make_Log(Player, Entity);
			}
		}
		#endregion

		#region Functions
		private void Make_Log(BasePlayer Player, BaseEntity TC)
		{
			string Filename = TC.net.ID.ToString();
			string Content = "Owner: " + Player.displayName;

			Content += "Owner: " + Player.displayName + "\n";
			Content += "\n" + "Location: " + TC.ServerPosition.ToString() + "\n";
			Content += "\n" + "Creation Date: " + DateTime.Now.ToString();

			LogToFile(Filename, Content, this, true);
		}
		#endregion
	}
}


// --- End of file: CupboardInfoLogs.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/connection-limiter ---
// --- Original File Path: C/ConnectionLimiter/ConnectionLimiter.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("ConnectionLimiter", "Exel80", "1.0.1", ResourceId = 2649)]
    [Description("Help server admins block spam re-connecting")]
    class ConnectionLimiter : CovalencePlugin
    {
        public Dictionary<string, DateTime> ConnectedPlayers = new Dictionary<string, DateTime>();

        #region Configuration
        private Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Enable Connection Limit (true/false)")]
            public bool limitEnabled;

            [JsonProperty(PropertyName = "Kick message show current waiting time (true/false)")]
            public bool limitCurrenttime;

            [JsonProperty(PropertyName = "Connection cooldown (in Seconds)")]
            public int limitCooldown;

            public static Configuration DefaultConfig()
            {
                return new Configuration
                {
                    limitEnabled = true,
                    limitCurrenttime = true,
                    limitCooldown = 30,
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
            }
            catch
            {
                LogWarning($"Could not read oxide/config/{Name}.json, creating new config file");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => config = Configuration.DefaultConfig();

        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Initialization
        private void Init()
        {
            if (!config.limitEnabled)
            {
                Unsubscribe("CanUserLogin");
                Unsubscribe("OnUserDisconnected");
            }
        }
        #endregion

        #region Lang
        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["WaitConnection"] = "Wait connection: {0} second"
            }, this);
        }
        #endregion

        #region Oxide Hooks
        object CanUserLogin(string name, string id, string ip)
        {
            if (!ConnectedPlayers.ContainsKey(id))
                return null;

            if (ConnectedPlayers[id] > DateTime.Now)
            {
                //Puts($"Kicked from server {DateTime.Now.AddSeconds(config.limitCooldown)}");
                if (config.limitCurrenttime)
                    return Lang("WaitConnection", id, Math.Round((ConnectedPlayers[id] - DateTime.Now).TotalSeconds));
                else
                    return Lang("WaitConnection", id, config.limitCooldown);
            }
            else
            {
                //Puts($"Removed from DB");
                ConnectedPlayers.Remove(id);
            }
            return null;
        }

        private void OnUserDisconnected(IPlayer player)
        {
            if (!ConnectedPlayers.ContainsKey(player.Id))
            {
                //Puts($"Disconnected, added to DB {DateTime.Now.AddSeconds(config.limitCooldown)}");
                ConnectedPlayers.Add(player.Id, DateTime.Now.AddSeconds(config.limitCooldown));
            }
        }
        #endregion
    }
}

// --- End of file: ConnectionLimiter.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/code-sync ---
// --- Original File Path: C/CodeSync/CodeSync.cs ---

/***********************************************************************************************************************/
/*** DO NOT edit this file! Edit the files under `oxide/config` and/or `oxide/lang`, created once plugin has loaded. ***/
/*** Please note, support cannot be provided if the plugin has been modified. Please use a fresh copy if modified.   ***/
/***********************************************************************************************************************/

using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Code Sync", "Wulf", "2.0.4")]
    [Description("Automatically allows players access to code locks based on tool cupboard authorization")]
    public class CodeSync : CovalencePlugin
    {
        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                ["CodeSynced"] = "Code will be the same code as the tool cupboard lock"
            }, this);
        }

        #endregion Localization

        #region Lock Handling

        private BuildingManager.Building GetBuilding(BaseEntity entity)
        {
            var parent = entity.GetParentEntity();

            if (parent == null)
            {
                return null;
            }

            BuildingManager.Building building;
            if (parent.prefabID == 4211374971 || parent.prefabID == 95147612)
            {
                building = parent.GetBuildingPrivilege()?.GetBuilding();
            }
            else building = (parent as DecayEntity)?.GetBuilding();

            if (building == null || building.buildingPrivileges == null || building.buildingPrivileges.Count == 0)
            {
                //Log($"Could not find building for {codeLock.GetParentEntity()?.PrefabName}");
                return null;
            }

            return building;
        }

        private CodeLock GetCupboardLock(BuildingManager.Building building)
        {
            return building.buildingPrivileges[0].GetSlot(BaseEntity.Slot.Lock) as CodeLock;
        }

        private void CanChangeCode(BasePlayer basePlayer, CodeLock codeLock)
        {
            // TODO: Support changing code on any code lock, for all building code locks
            Message(basePlayer, "CodeSynced");
        }

        private object CanUseLockedEntity(BasePlayer basePlayer, CodeLock codeLock)
        {
            // Check if entity is already unlocked
            if (!codeLock.IsLocked())
            {
                return null;
            }

            // Check for valid building entity
            BuildingManager.Building building = GetBuilding(codeLock);
            if (building == null)
            {
                return null;
            }

            // Check if code matches tool cupboard lock code
            CodeLock tcLock = GetCupboardLock(building);
            if (tcLock == null || tcLock.code != codeLock.code && tcLock.guestCode != codeLock.code)
            {
                return null;
            }

            // Check for and allow player if whitelisted
            if (tcLock.whitelistPlayers.Contains(basePlayer.userID) || tcLock.guestPlayers.Contains(basePlayer.userID))
            {
                return true;
            }

            return null;
        }

        private void OnCodeEntered(CodeLock codeLock, BasePlayer basePlayer, string code)
        {
            // Notify of sync if codelock code matches code provided
            if (GetBuilding(codeLock) != null && codeLock.code == code)
            {
                Message(basePlayer, "CodeSynced");
            }
        }

        #endregion Lock Handling

        #region Helpers

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void Message(BasePlayer basePlayer, string langKey, params object[] args)
        {
            if (basePlayer.IsConnected)
            {
                basePlayer.IPlayer.Message(GetLang(langKey, basePlayer.UserIDString, args));
            }
        }

        #endregion Helpers
    }
}

// --- End of file: CodeSync.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/crafting-store ---
// --- Original File Path: C/CraftingStore/CraftingStore.cs ---

using System;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using UnityEngine;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Crafting Store", "CraftingStore", "0.1.5")]
    [Description("Checks the CraftingStore donation platform for new payments and executes the commands that have been set.")]

    class CraftingStore : CovalencePlugin
    {
        private string baseUrl = "https://api.craftingstore.net/v4/";
        private string baseUrlAlternative = "https://api-fallback.craftingstore.net/v4/";
		private bool useAlternativeBaseUrl = false;

        private string apiToken = "";

        void OnServerInitialized()
        {
            // Set config
            this.apiToken = Config["token"].ToString();
            int fetchFrequencyMinutes = Int32.Parse(Config["frequencyMinutes"].ToString());

            if (this.apiToken == "Enter your API token") 
			{
                PrintError("Your API token is not yet set, please set the API token in the config and reload the CraftingStore plugin.");
                return;
            }

            if (fetchFrequencyMinutes < 4) 
			{
                // Set to 5 minutes when the frequency is to 4 or lower.
                PrintError("The fetch frequency was set below the minimum (5 minutes). Please change this value in the config, CraftingStore will still work and fetch the commands every 5 minutes.");
                fetchFrequencyMinutes = 5;
            }
			
            // Request commands on load
            RequestCommands();

            // Create timer that will execute the commands
            timer.Repeat(fetchFrequencyMinutes * 60, 0, () => 
			{
                RequestCommands();
            });
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Creating CraftingStore Config");
	    
            Config["token"] = "Enter your API token";
            Config["frequencyMinutes"] = 5;
        }

        private ApiResponse ParseResponse(string response)
        {
            ApiResponse commands = JsonConvert.DeserializeObject<ApiResponse>(response);
            return commands;
        }

        private void GetRequest(string uri, string action)
        {
            // Set the authentication header
            Dictionary<string, string> headers = new Dictionary<string, string> { { "token", this.apiToken } };

            webrequest.Enqueue(getBaseUrl() + uri, null, (code, response) =>
                GetCallback(code, response, action), this, Core.Libraries.RequestMethod.GET, headers);
        }

        private void GetCallback(int code, string response, string action)
        {
            if (response == null || code != 200) 
			{
                if (this.useAlternativeBaseUrl == false) {
                    // Some installations cannot work with our TLS/SSL certificate, use our alternative endpoint.
                    this.useAlternativeBaseUrl = true;
                    RequestCommands();
                    return;
                }
                PrintError("Invalid response returned, please contact us if this error persists.");
				PrintError(response);
                return;
            }

            // Create model from the JSON response.
            ApiResponse parsedResponse = ParseResponse(response);

            // Validate that the request got a success response back, if not, return the message.
            if (!parsedResponse.success) 
			{
                PrintError("Did not receive success status: " + parsedResponse.message);
                return;
            }

            if (action == "queue") 
			{
                this.ProcessQueuedCommands(parsedResponse);
				return;
            }
        }

        private void PostRequest(string uri, string action, string payload)
        {
            // Set the authentication header
            Dictionary<string, string> headers = new Dictionary<string, string> { { "token", this.apiToken } };

            webrequest.Enqueue(getBaseUrl() + uri, payload, (code, response) =>
                PostCallback(code, response, action), this, Core.Libraries.RequestMethod.POST, headers);
        }

        private void PostCallback(int code, string response, string action)
        {
            if (response == null || code != 200) 
			{
                PrintError("Got error: Invalid response returned, please contact us if this error persists.");
                return;
            }

            // Create model from the JSON response.
            ApiResponse parsedResponse = ParseResponse(response);

            // Validate that the request got a success response back, if not, return the message.
            if (!parsedResponse.success) 
			{
                PrintError("Did not receive success status: " + parsedResponse.message);
                return;
            }
        }

        private void ProcessQueuedCommands(ApiResponse parsedResponse)
        {
            QueueResponse[] donations = parsedResponse.result;

            List<int> ids = new List<int>();

            foreach (QueueResponse donation in donations)
            {
                // Add donation to executed list.
                ids.Add(donation.id);

                // Execute commands
                Puts("Executing Command: " + donation.command);
				server.Command(donation.command);
            }

            if (ids.Count > 0) 
			{
                // Mark as complete if there are commands processed
                string serializedIds = JsonConvert.SerializeObject(ids);

                string payload = "removeIds=" + serializedIds;

                PostRequest("queue/markComplete", "markComplete", payload);
            }
        }

        private string getBaseUrl()
        {
            return this.useAlternativeBaseUrl ? this.baseUrlAlternative : this.baseUrl;
        }

        private void RequestCommands()
        {
            GetRequest("queue", "queue");
        }
        
        public class QueueResponse 
		{
            public int id;
            public string command;
            public string packageName;
        }

        public class ApiResponse 
		{
            public int id;
            public bool success;
            public string error;
            public string message;
            public QueueResponse[] result;
        }
    }
}


// --- End of file: CraftingStore.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/chill-diving ---
// --- Original File Path: C/ChillDiving/ChillDiving.cs ---

﻿using Oxide.Game.Rust.Cui;
using UnityEngine;
using System;
using Rust;
using System.Collections.Generic;
using Oxide.Core;
using Newtonsoft.Json;
using System.Globalization;
using System.Linq;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("Chill Diving", "Thisha", "1.4.0")]
    [Description("Audiovisual support for divers")]

    public class ChillDiving : RustPlugin
    {
        private const string inviteNoticeMsg = "assets/bundled/prefabs/fx/invite_notice.prefab";
        private const string divingTankShortName = "diving.tank";
        private const string defaultPictureURL = "https://i.imgur.com/z8JqhRB.png";
        private float pictureOffset = 0.022f;
        public DateTime lastCleanUp;

        public enum ShowValues { All, Bar, Value };

        public enum DivingColor
        {
            AliceBlue = 28,
            AntiqueWhite = 29,
            Aqua = 30,
            Aquamarine = 31,
            Azure = 32,
            Beige = 33,
            Bisque = 34,
            Black = 35,
            BlanchedAlmond = 36,
            Blue = 37,
            BlueViolet = 38,
            Brown = 39,
            BurlyWood = 40,
            CadetBlue = 41,
            Chartreuse = 42,
            Chocolate = 43,
            Coral = 44,
            CornflowerBlue = 45,
            Cornsilk = 46,
            Crimson = 47,
            Cyan = 48,
            DarkBlue = 49,
            DarkCyan = 50,
            DarkGoldenrod = 51,
            DarkGray = 52,
            DarkGreen = 53,
            DarkKhaki = 54,
            DarkMagenta = 55,
            DarkOliveGreen = 56,
            DarkOrange = 57,
            DarkOrchid = 58,
            DarkRed = 59,
            DarkSalmon = 60,
            DarkSeaGreen = 61,
            DarkSlateBlue = 62,
            DarkSlateGray = 63,
            DarkTurquoise = 64,
            DarkViolet = 65,
            DeepPink = 66,
            DeepSkyBlue = 67,
            DimGray = 68,
            DodgerBlue = 69,
            Firebrick = 70,
            FloralWhite = 71,
            ForestGreen = 72,
            Fuchsia = 73,
            Gainsboro = 74,
            GhostWhite = 75,
            Gold = 76,
            Goldenrod = 77,
            Gray = 78,
            Green = 79,
            GreenYellow = 80,
            Honeydew = 81,
            HotPink = 82,
            IndianRed = 83,
            Indigo = 84,
            Ivory = 85,
            Khaki = 86,
            Lavender = 87,
            LavenderBlush = 88,
            LawnGreen = 89,
            LemonChiffon = 90,
            LightBlue = 91,
            LightCoral = 92,
            LightCyan = 93,
            LightGoldenrodYellow = 94,
            LightGray = 95,
            LightGreen = 96,
            LightPink = 97,
            LightSalmon = 98,
            LightSeaGreen = 99,
            LightSkyBlue = 100,
            LightSlateGray = 101,
            LightSteelBlue = 102,
            LightYellow = 103,
            Lime = 104,
            LimeGreen = 105,
            Linen = 106,
            Magenta = 107,
            Maroon = 108,
            MediumAquamarine = 109,
            MediumBlue = 110,
            MediumOrchid = 111,
            MediumPurple = 112,
            MediumSeaGreen = 113,
            MediumSlateBlue = 114,
            MediumSpringGreen = 115,
            MediumTurquoise = 116,
            MediumVioletRed = 117,
            MidnightBlue = 118,
            MintCream = 119,
            MistyRose = 120,
            Moccasin = 121,
            NavajoWhite = 122,
            Navy = 123,
            OldLace = 124,
            Olive = 125,
            OliveDrab = 126,
            Orange = 127,
            OrangeRed = 128,
            Orchid = 129,
            PaleGoldenrod = 130,
            PaleGreen = 131,
            PaleTurquoise = 132,
            PaleVioletRed = 133,
            PapayaWhip = 134,
            PeachPuff = 135,
            Peru = 136,
            Pink = 137,
            Plum = 138,
            PowderBlue = 139,
            Purple = 140,
            Red = 141,
            RosyBrown = 142,
            RoyalBlue = 143,
            SaddleBrown = 144,
            Salmon = 145,
            SandyBrown = 146,
            SeaGreen = 147,
            SeaShell = 148,
            Sienna = 149,
            Silver = 150,
            SkyBlue = 151,
            SlateBlue = 152,
            SlateGray = 153,
            Snow = 154,
            SpringGreen = 155,
            SteelBlue = 156,
            Tan = 157,
            Teal = 158,
            Thistle = 159,
            Tomato = 160,
            Turquoise = 161,
            Violet = 162,
            Wheat = 163,
            White = 164,
            WhiteSmoke = 165,
            Yellow = 166,
            YellowGreen = 167,
        }

        #region localization
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["HelpInfo"] = "Use \"/diving <on|off>\" to show hide the diving panel.",
                ["HelpShow"] = "Use \"/diving show <alerts|ranges>\" to see your active alerts/colors.",
                ["HelpView"] = "Use \"/diving view <bar|value|all>\" to switch view.",
                ["HelpColor"] = "Use \"/diving colors help\" to show more info about color usage.",
                ["HelpColorList"] = "Use \"/diving colors list\" to see a list of the available color names.",
                ["HelpAlertAdd"] = "Use \"/diving add alert <number>\" to add or update a normal alert, add * for a continuous one (eg. 20*)",
                ["HelpRangeAdd"] = "Use \"/diving add range <number> <barcolor> <fontcolor>\" to add or update a color range.",
                ["HelpDelete"] = "Use \"/diving remove <alert|range> <number>\" to delete a certain alert or range",
                ["HelpReset"] = "Use \"/diving reset\" to reset your settings to defaults.",
                ["NoUsePermission"] = "You do not have permission to use the diving information.",
                ["NoModifyPermission"] = "You do not have permission to modify diving settings.",
                ["InvalidAlert"] = "Invalid alert value.",
                ["InvalidColor"] = "Invalid color value.",
                ["InvalidRGB"] = "Invalid RGB value.",
                ["InvalidNumberValue"] = "Invalid number value",
                ["NoAlerts"] = "You don't have any active alerts.",
                ["AlertAdded"] = "The alert has been added.",
                ["AlertUpdated"] = "The alert has been updated.",
                ["AlertRemoved"] = "The alert has been removed.",
                ["AlertDoesNotExists"] = "The alert does not exist.",
                ["NoRanges"] = "You don't have any color ranges.",
                ["RangeAdded"] = "The color range has been added.",
                ["RangeUpdated"] = "The color range has been updated.",
                ["RangeRemoved"] = "The color range has been removed.",
                ["RangeDoesNotExists"] = "The color range does not exist.",
                ["MaxAlerts"] = "You have reached the maximum number of alerts.",
                ["DataReset"] = "Your data has been reset to defaults.",
                ["ColorUsage"] = "Colors can be defined by a hexadecimal value, for example #FC03F0.\nTransparancy from FF (none) to 00 (full) can be added, for example FC03F0FF.\nColors can be defined by name too (case-sensitive), use \"/diving colors list\" to view them.\nWhen using color names, the transparancy will be default.",
                ["ServerDefaults"] = "Server defaults",
                ["NoServerAlerts"] = "No alerts",
            }, this);
        }
        #endregion localization

        #region data
        private Dictionary<ulong, PlayerData> playerData = new Dictionary<ulong, PlayerData>();

        private class PlayerData
        {
            public bool Enabled;
            public string ShowInfo = string.Empty;
            public DateTime LastChange = DateTime.Today;
            public DateTime LastOnline = DateTime.Today;

            public Dictionary<uint, SimpleRangeData> ColorRanges = new Dictionary<uint, SimpleRangeData>();
            public Dictionary<uint, bool> Alerts = new Dictionary<uint, bool>();

            public PlayerData()
            {

            }
        }
        #endregion data

        #region config
        private ConfigData config;

        class ConfigData
        {
            [JsonProperty(PropertyName = "Lower Range Color Value")]
            public SimpleRangeData LowerRange = new SimpleRangeData
            {
                BarColorValue = "#996633",
                FontColorValue = "#FFFFFFFF"
            };

            [JsonProperty(PropertyName = "Middle Range")]
            public FullRangeData MiddleRange = new FullRangeData
            {
                BarColorValue = "#FFFF00E4",
                StartValue = 100,
                FontColorValue = "#FFFFFFFF"
            };

            [JsonProperty(PropertyName = "Higher Range")]
            public FullRangeData HigherRange = new FullRangeData
            {
                BarColorValue = "#669933E4",
                StartValue = 300,
                FontColorValue = "#FFFFFFFF"
            };

            [JsonProperty(PropertyName = "Alert 1")]
            public uint Alert1 = 100;

            [JsonProperty(PropertyName = "Alert 2")]
            public uint Alert2 = 0;

            [JsonProperty(PropertyName = "Continous alert")]
            public uint ContAlert = 15;

            [JsonProperty(PropertyName = "Show picture")]
            public bool ShowPicture = false;

            [JsonProperty(PropertyName = "Picture URL")]
            public string PictureURL = "https://i.imgur.com/z8JqhRB.png";

            [JsonProperty(PropertyName = "Show info (All, Bar, Value)")]
            public string ShowInfo = ShowValues.All.ToString();

            [JsonProperty(PropertyName = "Postition")]
            public AnchorPosition Position = new AnchorPosition
            {
                XAxis = 0.035f,
                YAxis = 0.007f
            };

            [JsonProperty(PropertyName = "Maximum Player Alerts")]
            public uint MaxAlerts = 6;

            [JsonProperty(PropertyName = "Remove after offline days")]
            public uint OffDays = 0;
        }

        private class FullRangeData
        {
            [JsonProperty(PropertyName = "Starting Value")]
            public uint StartValue = 0;

            [JsonProperty(PropertyName = "Bar Color")]
            public string BarColorValue = "#00000000";

            [JsonProperty(PropertyName = "Font Color")]
            public string FontColorValue = "#00000000";
        }

        private class AnchorPosition
        {
            [JsonProperty(PropertyName = "X-axis")]
            public float XAxis = 0;

            [JsonProperty(PropertyName = "Y-axis")]
            public float YAxis = 0;
        }

        private class SimpleRangeData
        {
            [JsonProperty(PropertyName = "Bar Color")]
            public string BarColorValue = "#00000000";

            [JsonProperty(PropertyName = "Font Color")]
            public string FontColorValue = "#00000000";

            public SimpleRangeData()
            {

            }

            public SimpleRangeData(string barcolor, string fontcolor)
            {
                BarColorValue = barcolor;
                FontColorValue = fontcolor;
            }
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                    throw new Exception();

                SaveConfig();
            }
            catch
            {
                LoadDefaultConfig();
            }

        }
        #endregion config

        #region commands
        [ChatCommand("Diving")]
        void HandleChatcommand(BasePlayer player, string command, string[] args)
        {
            bool doUpdate = false;

            if (!permission.UserHasPermission(player.UserIDString, "chilldiving.use"))
            {
                PrintToChat(player, Lang("NoUsePermission", player.UserIDString));
                return;
            }

            switch (args.Length)
            {
                case 1:
                    {
                        switch (args[0].ToLower())
                        {
                            case "on":
                                {
                                    ShowOxygen(player);
                                    break;
                                }

                            case "off":
                                {
                                    HideOxygen(player);
                                    break;
                                }

                            case "reset":
                                {
                                    if (!permission.UserHasPermission(player.UserIDString, "chilldiving.modify"))
                                    {
                                        PrintToChat(player, Lang("NoModifyPermission", player.UserIDString));
                                        return;
                                    }
                                    InitPlayer(player.userID, true);
                                    player.ChatMessage(Lang("DataReset", player.UserIDString));

                                    Item item;
                                    if (IsWearingdivingTank(player, out item))
                                        UpdatePanels(player, item.condition, item.maxCondition, true);

                                    break;
                                }

                            default:
                                {
                                    ShowCommandHelp(player);
                                    break;
                                }
                        }
                        break;
                    }

                case 2:
                    {
                        switch (args[0].ToLower())
                        {
                            case "show":
                                {
                                    switch (args[1].ToLower())
                                    {
                                        case "alerts":
                                            { }
                                            player.ChatMessage(GetAlerts(player.userID));
                                            break;

                                        case "ranges":
                                            {
                                                player.ChatMessage(GetRanges(player.userID));
                                                break;
                                            }

                                        default:
                                            {
                                                PrintToChat(player, Lang("HelpShow", player.UserIDString));
                                                break;
                                            }
                                    }
                                    break;
                                }

                            case "view":
                                {
                                    if (!permission.UserHasPermission(player.UserIDString, "chilldiving.modify"))
                                    {
                                        PrintToChat(player, Lang("NoModifyPermission", player.UserIDString));
                                        return;
                                    }

                                    switch (args[1].ToLower())
                                    {
                                        case "bar":
                                            {
                                                ChangeView(player.userID, args[1], out doUpdate);
                                                break;
                                            }

                                        case "value":
                                            {
                                                ChangeView(player.userID, args[1], out doUpdate);
                                                break;
                                            }

                                        case "all":
                                            {
                                                ChangeView(player.userID, args[1], out doUpdate);
                                                break;
                                            }

                                        default:
                                            {
                                                PrintToChat(player, Lang("HelpView", player.UserIDString));
                                                break;
                                            }
                                    }
                                    break;
                                }

                            case "colors":
                                {
                                    switch (args[1].ToLower())
                                    {
                                        case "help":
                                            {
                                                PrintToChat(player, Lang("ColorUsage", player.UserIDString));
                                                break;
                                            }

                                        case "list":
                                            {
                                                PrintToChat(player, ColorList());
                                                break;
                                            }

                                        default:
                                            {
                                                PrintToChat(player, Lang("HelpColor", player.UserIDString));
                                                break;
                                            }
                                    }
                                    break;
                                }


                            default:
                                ShowCommandHelp(player);
                                break;
                        }
                        break;
                    }

                case 3:
                    {
                        if (!permission.UserHasPermission(player.UserIDString, "chilldiving.modify"))
                        {
                            PrintToChat(player, Lang("NoModifyPermission", player.UserIDString));
                            return;
                        }

                        switch (args[0].ToLower())
                        {
                            case "add":
                                {
                                    switch (args[1].ToLower())
                                    {
                                        case "alert":
                                            {
                                                player.ChatMessage(Lang(AddAlert(player.userID, args[2])));
                                                break;
                                            }

                                        default:
                                            {
                                                ShowCommandHelp(player);
                                                break;
                                            }
                                    }
                                    break;
                                }

                            case "remove":
                                {
                                    switch (args[1].ToLower())
                                    {
                                        case "alert":
                                            {
                                                player.ChatMessage(Lang(RemoveAlert(player.userID, args[2])));
                                                break;
                                            }

                                        case "range":
                                            {
                                                player.ChatMessage(Lang(RemoveRange(player.userID, args[2], out doUpdate)));
                                                break;
                                            }

                                        default:
                                            {
                                                ShowCommandHelp(player);
                                                break;
                                            }
                                    }
                                    break;
                                }

                            default:
                                ShowCommandHelp(player);
                                break;
                        }
                        break;
                    }

                case 5:
                    {
                        if (!permission.UserHasPermission(player.UserIDString, "chilldiving.modify"))
                        {
                            PrintToChat(player, Lang("NoModifyPermission", player.UserIDString));
                            return;
                        }

                        switch (args[0].ToLower())
                        {
                            case "add":
                                {
                                    switch (args[1].ToLower())
                                    {
                                        case "range":
                                            {
                                                string[] pars = new string[3] { args[2], args[3], args[4] };
                                                player.ChatMessage(Lang(AddRange(player.userID, pars, out doUpdate)));
                                                break;
                                            }

                                        default:
                                            {
                                                ShowCommandHelp(player);
                                                break;
                                            }
                                    }
                                    break;
                                }

                            default:
                                {
                                    ShowCommandHelp(player);
                                    break;
                                }

                        }
                        break;
                    }

                default:
                    {
                        ShowCommandHelp(player);
                        break;
                    }
            };

            if (doUpdate)
            {
                Item item;
                if (PlayerSignedUp(player))
                    if (IsWearingdivingTank(player, out item))
                        UpdatePanels(player, item.condition, item.maxCondition, true);
            }

        }
        #endregion commands

        #region hooks
        private void Init()
        {
            permission.RegisterPermission("chilldiving.use", this);
            permission.RegisterPermission("chilldiving.modify", this);
            LoadData();
        }

        void OnServerInitialized()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (!PlayerSignedUp(player))
                    continue;

                if (!player.IsAlive())
                    continue;

                Item item;
                if (IsWearingdivingTank(player, out item))
                {
                    UpdatePanels(player, item.condition, item.maxCondition, true);
                }
            }
        }

        void OnServerSave()
        {
            RemoveOldData();
        }

        private void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (PlayerSignedUp(player))
                    DestroyUI(player, true);
            }
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (playerData.ContainsKey(player.userID))
            {
                playerData[player.userID].LastOnline = DateTime.Today;
                SaveData();
            }
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            if (!PlayerSignedUp(player))
                return;

            Item item;
            if (IsWearingdivingTank(player, out item))
                UpdatePanels(player, item.condition, item.maxCondition, true);
        }

        void OnPlayerDeath(BasePlayer player, ref HitInfo info)
        {
            if (!PlayerSignedUp(player))
                return;

            Item item2;
            if (IsWearingdivingTank(player, out item2))
                DestroyUI(player, true);
        }

        void OnItemAddedToContainer(ItemContainer cont, Item item)
        {
            if (ShouldHandleUI(cont, item))
                UpdatePanels(cont.playerOwner, item.condition, item.maxCondition, true);
        }

        void OnItemRemovedFromContainer(ItemContainer cont, Item item)
        {
            if (ShouldHandleUI(cont, item))
                DestroyUI(cont.GetOwnerPlayer(), true);
        }

        void OnEntityTakeDamage(BasePlayer player, ref HitInfo info)
        {
            if (info.damageTypes.Get(DamageType.Drowned) <= 0f)
                return;

            if (!PlayerSignedUp(player))
                return;

            if (!player.IsAlive())
                return;

            Item item;
            if (IsWearingdivingTank(player, out item))
            {
                UpdatePanels(player, item.condition, item.maxCondition, true);
            }
        }

        void OnLoseCondition(Item item, ref float amount)
        {
            if (!item.info.shortname.Equals(divingTankShortName))
                return;

            BasePlayer player = item.GetOwnerPlayer();

            if (!PlayerSignedUp(player))
                return;

            UpdatePanels(player, item.condition - 3f, item.maxCondition, false);
        }

        void OnItemAction(Item item, string action, BasePlayer player)
        {
            if (!action.ToUpper().Contains("REFILL"))
                return;

            Item item2;
            if ((item.info.shortname.Equals(divingTankShortName)) && (IsWearingdivingTank(player, out item2)))
            {
                float maxLossFraction = 0.05f;
                float tempMax = 0;
                float single = 1f - item.condition / item.maxCondition;
                maxLossFraction = Mathf.Clamp(maxLossFraction, 0f, item.maxCondition);
                tempMax = (float)Math.Floor(item.maxCondition * (1f - maxLossFraction * single));

                UpdatePanels(player, tempMax, tempMax, false);
            }
        }

        #endregion hooks

        #region functions
        #region general
        void RemoveOldData()
        {
            if (lastCleanUp >= DateTime.Today)
                return;

            if (config.OffDays <= 0)
                return;

            List<ulong> ToDelete = new List<ulong>();

            for (int i = 0; i < playerData.Count; i++)
            {
                if ((DateTime.Today - playerData.ElementAt(i).Value.LastOnline).TotalDays > config.OffDays)
                {
                    ToDelete.Add(playerData.ElementAt(i).Key);
                }
            }

            if (ToDelete.Count > 0)
            {
                for (int i = 0; i < ToDelete.Count; i++)
                    playerData.Remove(ToDelete[i]);

            }

            SaveData(); //catch save of new player data lastonline

            lastCleanUp = DateTime.Today;
        }

        void InitPlayer(ulong userID, bool reset)
        {
            if (reset)
            {
                playerData.Remove(userID);
                SaveData();
                return;
            }

            PlayerData data = new PlayerData();
            data.Enabled = true;
            data.ShowInfo = config.ShowInfo;

            data.ColorRanges.Add(0, config.LowerRange);
            data.ColorRanges.Add(config.MiddleRange.StartValue, new SimpleRangeData(config.MiddleRange.BarColorValue, config.MiddleRange.FontColorValue));
            data.ColorRanges.Add(config.HigherRange.StartValue, new SimpleRangeData(config.HigherRange.BarColorValue, config.HigherRange.FontColorValue));

            if (config.ContAlert > 0)
                data.Alerts.Add(config.ContAlert, true);

            if (config.Alert1 > 0)
                data.Alerts.Add(config.Alert1, false);

            if (config.Alert2 > 0)
                data.Alerts.Add(config.Alert2, false);

            playerData[userID] = data;
            SaveData();
        }

        void HideOxygen(BasePlayer player)
        {
            if (!playerData.ContainsKey(player.userID))
                InitPlayer(player.userID, false);

            playerData[player.userID].Enabled = false;
            playerData[player.userID].LastChange = DateTime.Today;
            SaveData();

            DestroyUI(player, true);
        }

        void ShowOxygen(BasePlayer player)
        {
            PlayerData info;
            if (!playerData.TryGetValue(player.userID, out info))
            {
                InitPlayer(player.userID, false);
            }
            else
            {
                info.Enabled = true;
                playerData[player.userID].LastChange = DateTime.Today;
                SaveData();

                Item item;
                if (IsWearingdivingTank(player, out item))
                    UpdatePanels(player, item.condition, item.maxCondition, true);
            }
        }
        #endregion general

        #region alerts
        string GetAlerts(ulong userID)
        {
            string alerts = string.Empty;

            if (playerData.ContainsKey(userID))
            {
                if (playerData[userID].Alerts.Count > 0)
                {
                    foreach (var alert in playerData[userID].Alerts.OrderBy(x => x.Key))
                    {
                        if (alerts.Length > 0)
                            alerts = alerts + ", " + alert.Key.ToString();
                        else
                            alerts = alert.Key.ToString();

                        if (alert.Value == true)
                            alerts = alerts + "*";
                    }
                }

                if (alerts.Length == 0)
                {
                    alerts = Lang("NoAlerts", userID.ToString());
                }
            }
            else
            {
                alerts = Lang("NoAlerts", userID.ToString()) + '\n' + GetDefaultAlerts();
            }

            return alerts;
        }

        string GetDefaultAlerts()
        {
            string alerts = string.Empty;

            if (config.ContAlert > 0)
                alerts = config.ContAlert.ToString() + "*";

            if (config.Alert1 > 0)
                alerts = (alerts + ", " + config.Alert1.ToString()).TrimStart(' ', ',');

            if (config.Alert2 > 0)
                alerts = (alerts + ", " + config.Alert2.ToString()).TrimStart(' ', ',');

            if (alerts.Length > 0)
                return (Lang("ServerDefaults") + ": " + alerts);
            else
                return (Lang("ServerDefaults") + ": " + Lang("NoServerAlerts"));
        }

        string AddAlert(ulong userID, string args)
        {
            string result = String.Empty;

            bool continuous = args.Substring(args.Length - 1) == "*";

            if (continuous)
            {
                args = args.Remove(args.Length - 1);
            }

            uint condition;
            if (uint.TryParse(args, out condition))
            {
                bool oldContinuous;

                if (!playerData.ContainsKey(userID))
                    InitPlayer(userID, false);

                if (!playerData[userID].Alerts.TryGetValue(condition, out oldContinuous))
                {
                    if ((playerData[userID].Alerts.Count < config.MaxAlerts) || (config.MaxAlerts == 0))
                    {
                        playerData[userID].Alerts.Add(condition, continuous);
                        playerData[userID].LastChange = DateTime.Today;
                        SaveData();
                        result = "AlertAdded";
                    }
                    else
                    {
                        result = "MaxAlerts";
                    }
                }
                else
                {
                    playerData[userID].Alerts[condition] = continuous;
                    playerData[userID].LastChange = DateTime.Today;
                    SaveData();
                    result = "AlertUpdated";
                }
            }
            else
            {
                result = "InvalidAlert";
            }

            return (result);
        }

        string RemoveAlert(ulong userID, string args)
        {
            string result = string.Empty;
            uint condition;

            if (uint.TryParse(args, out condition))
            {
                if (playerData[userID].Alerts.Remove(condition))
                {
                    playerData[userID].LastChange = DateTime.Today;
                    SaveData();
                    result = "AlertRemoved";
                }
                else
                {
                    result = "AlertDoesNotExists";
                }
            }
            else
            {
                result = "InvalidAlert";
            };

            return result;
        }

        bool MustDoEffect(float condition, ulong userID)
        {
            uint alert = 0;

            if (playerData.ContainsKey(userID))
            {
                alert = playerData[userID].Alerts.Where(x => x.Key >= condition).OrderBy(x => x.Key).FirstOrDefault().Key;

                if (alert > 0)
                {
                    if (playerData[userID].Alerts[alert] == false)
                        return (condition >= alert - 3) && (condition <= alert);
                    else
                        return true;
                }
                else
                {
                    return false;
                }
            }
            else
            {
                return (((config.Alert1 > 0) && (condition >= config.Alert1 - 3) && (condition <= config.Alert1)) ||
                       ((config.Alert2 > 0) && (condition >= config.Alert2 - 3) && (condition <= config.Alert2)) ||
                       ((config.ContAlert > 0) && (condition <= config.ContAlert)));
            }

        }
        #endregion alerts

        #region ranges
        string GetRanges(ulong userID)
        {
            string ranges = string.Empty;

            if (playerData.ContainsKey(userID))
            {
                if (playerData[userID].ColorRanges.Count > 0)
                {
                    foreach (var range in playerData[userID].ColorRanges.OrderBy(x => x.Key))
                    {
                        if (ranges.Length > 0)
                            ranges = ranges + "\n" + range.Key.ToString() + " B: " + range.Value.BarColorValue + " F: " + range.Value.FontColorValue;
                        else
                            ranges = range.Key.ToString() + " B: " + range.Value.BarColorValue + " F: " + range.Value.FontColorValue;
                    }
                }
            }

            if (ranges.Length == 0)
            {
                ranges = Lang("NoRanges", userID.ToString()) + '\n' + Lang("ServerDefaults") + ": " + '\n' + GetDefaultRanges();
            }


            return ranges;
        }

        string GetDefaultRanges()
        {
            return ("0 " + "B: " + config.LowerRange.BarColorValue + " F: " + config.LowerRange.FontColorValue +
                '\n' + config.MiddleRange.StartValue.ToString() + " B: " + config.MiddleRange.BarColorValue + " F: " + config.LowerRange.FontColorValue +
                '\n' + config.HigherRange.StartValue.ToString() + " B: " + config.HigherRange.BarColorValue + " F: " + config.HigherRange.FontColorValue);
        }

        string AddRange(ulong userID, string[] args, out bool doUpdate)
        {
            string result = string.Empty;
            string barRGB = string.Empty;
            string fontRGB = string.Empty;
            uint startCond = 0;
            doUpdate = false;

            if (IsValidColor(args[1], out barRGB))
            {
                if (IsValidColor(args[2], out fontRGB))
                {
                    if (uint.TryParse(args[0], out startCond))
                    {
                        if (!playerData.ContainsKey(userID))
                            InitPlayer(userID, false);

                        SimpleRangeData range;
                        if (!playerData[userID].ColorRanges.TryGetValue(startCond, out range))
                        {
                            playerData[userID].ColorRanges.Add(startCond, new SimpleRangeData(args[1], args[2]));
                            playerData[userID].LastChange = DateTime.Today;
                            SaveData();
                            result = "RangeAdded";
                        }
                        else
                        {
                            playerData[userID].ColorRanges[startCond].BarColorValue = args[1];
                            playerData[userID].ColorRanges[startCond].FontColorValue = args[2];
                            playerData[userID].LastChange = DateTime.Today;
                            SaveData();
                            result = "RangeUpdated";
                        }
                        doUpdate = true;
                    }
                    else
                        result = "InvalidNumberValue";
                }
                else
                    result = "InvalidColor";
            }
            else
                result = "InvalidColor";

            return result;
        }

        string RemoveRange(ulong userID, string args, out bool doUpdate)
        {
            string result = string.Empty;
            uint condition;
            doUpdate = false;

            if (uint.TryParse(args, out condition))
            {
                if (playerData[userID].ColorRanges.Remove(condition))
                {
                    playerData[userID].LastChange = DateTime.Today;
                    SaveData();
                    result = "RangeRemoved";
                    doUpdate = true;
                }
                else
                {
                    result = "RangeDoesNotExists";
                }
            }
            else
            {
                result = "InvalidNumberValue";
            };

            return result;
        }

        void GetRGBValues(ulong userID, uint condition, out string barRGB, out string fontRGB)
        {
            barRGB = string.Empty;
            fontRGB = string.Empty;

            bool getFromconfig = true;
            uint startCond = 0;
            SimpleRangeData range;

            if (playerData.ContainsKey(userID))
            {
                startCond = playerData[userID].ColorRanges.Where(x => x.Key <= condition).OrderBy(x => x.Key).LastOrDefault().Key;

                if (playerData[userID].ColorRanges.TryGetValue(startCond, out range))
                {
                    barRGB = range.BarColorValue;
                    fontRGB = range.FontColorValue;
                    getFromconfig = false;
                }
            }

            if (getFromconfig)
            {
                if (condition < config.MiddleRange.StartValue)
                {
                    barRGB = config.LowerRange.BarColorValue;
                    fontRGB = config.LowerRange.FontColorValue;
                }
                else if ((condition >= config.MiddleRange.StartValue) && (condition < config.HigherRange.StartValue))
                {
                    barRGB = config.MiddleRange.BarColorValue;
                    fontRGB = config.MiddleRange.FontColorValue;
                }
                else
                {
                    barRGB = config.HigherRange.BarColorValue;
                    fontRGB = config.HigherRange.FontColorValue;
                }
            }

            if (barRGB[0] != '#')
                barRGB = ColorToRGB(barRGB);
            if (fontRGB[0] != '#')
                fontRGB = ColorToRGB(fontRGB);
        }
        #endregion ranges

        #region UI
        void ChangeView(ulong userID, string show, out bool doUpdate)
        {
            doUpdate = false;

            if (!playerData.ContainsKey(userID))
                InitPlayer(userID, false);

            if (playerData[userID].ShowInfo != show)
            {
                playerData[userID].ShowInfo = show;
                playerData[userID].LastChange = DateTime.Today;
                SaveData();
                doUpdate = true;
            }
        }

        bool ShouldHandleUI(ItemContainer cont, Item item)
        {
            if (!item.info.shortname.Equals(divingTankShortName))
                return false;

            if (cont.playerOwner == null)
                return false;

            if (!cont.playerOwner.IsAlive())
                return false;

            if (!PlayerSignedUp(cont.playerOwner))
                return false;

            if (IsWearablesContainer(cont))
                return true;

            return false;
        }

        void UpdatePanels(BasePlayer player, float condition, float maxCondition, bool doPicture)
        {
            if (!permission.UserHasPermission(player.UserIDString, "chilldiving.use"))
                return;

            string barColor;
            string fontColor;
            string valueText;
            string barText;

            if (condition < 0)
                condition = 0;

            GetRGBValues(player.userID, (uint)Math.Floor(condition), out barColor, out fontColor);

            double lifepct = condition / maxCondition * 1000;

            if (MustDoEffect(condition, player.userID))
                Effect.server.Run(inviteNoticeMsg, player.transform.position);

            int counter = 0;
            int numberofchars = (int)Math.Round(lifepct);

            counter = Convert.ToInt32(config.Position.XAxis * 10000);

            if (condition != 0)
                counter = counter + numberofchars;

            if (MustShowValue(player.userID))
                counter = counter + 150;

            if (config.ShowPicture)
                counter = counter + 220; 

            barText = "0." + counter.ToString("".PadLeft(4, '0')) + " " + (config.Position.YAxis + 0.023f).ToString();
            valueText = ((int)Math.Round(condition, 0)).ToString();

            DestroyUI(player, doPicture);
            DrawUI(player, ColorFromHex(barColor, 228), valueText, barText, ColorFromHex(fontColor, 255), doPicture);
        }

        void DestroyUI(BasePlayer player, bool updatePicture)
        {
            if (player == null)
                return;

            CuiHelper.DestroyUi(player, "divingPanel");
            CuiHelper.DestroyUi(player, "divingBar");

            if (updatePicture)
                CuiHelper.DestroyUi(player, "divingPicture");
        }

        void DrawUI(BasePlayer player, string color, string valueText, string barText, string fontColor, bool updatePicture)
        {
            CuiHelper.AddUi(player, Generate_Menu(player, color, valueText, barText, fontColor, updatePicture));
        }

        private bool MustShowBar(ulong userID)
        {
            if (playerData.ContainsKey(userID))
                return (playerData[userID].ShowInfo.ToLower() == ShowValues.All.ToString().ToLower()) || (playerData[userID].ShowInfo.ToLower() == ShowValues.Bar.ToString().ToLower());
            else
                return (config.ShowInfo.ToLower() == ShowValues.All.ToString().ToLower()) || (config.ShowInfo.ToLower() == ShowValues.Bar.ToString().ToLower());
        }

        private bool MustShowValue(ulong userID)
        {
            if (playerData.ContainsKey(userID))
                return (playerData[userID].ShowInfo.ToLower() == ShowValues.All.ToString().ToLower()) || (playerData[userID].ShowInfo.ToLower() == ShowValues.Value.ToString().ToLower());
            else
                return (config.ShowInfo.ToLower() == ShowValues.All.ToString().ToLower()) || (config.ShowInfo.ToLower() == ShowValues.Value.ToString().ToLower());
        }

        private string GetAnchorMax(ulong userID)
        {
            float X = config.Position.XAxis;
            if (config.ShowPicture)
                X = X + pictureOffset;

            float Y = config.Position.YAxis;

            if (MustShowBar(userID))
                X = X + 0.116f; 
            else
                X = X + 0.013f;

            if (!MustShowValue(userID))
                X = X - 0.015f;

            Y = Y + 0.025f;

            return X.ToString() + " " + Y.ToString();
        }

        CuiElementContainer Generate_Menu(BasePlayer player, string barColor, string valueText, string barText, string fontColor, bool updatePicture)
        {
            var elements = new CuiElementContainer();

            string contMin = config.Position.XAxis.ToString() + " " + config.Position.YAxis.ToString();
            if (config.ShowPicture)
                contMin = (config.Position.XAxis + pictureOffset).ToString() + " " + config.Position.YAxis.ToString();

            var panel = elements.Add(new CuiPanel
            {
                Image = {
                    Color = "0.60 0.60 0.60 0.27"
                },

                RectTransform = {
                    AnchorMin = contMin,
                    AnchorMax = GetAnchorMax(player.userID)
                },

                CursorEnabled = false
            }, "Hud", "divingPanel");

            if (updatePicture)
            {
                if (config.ShowPicture)
                {
                    var logo = new CuiElementContainer();
                    logo.Add(new CuiElement
                    {
                        Name = "divingPicture",
                        Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = "1 1 1 1",
                            Url = (config.PictureURL != "") ? config.PictureURL : "https://i.imgur.com/z8JqhRB.png"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = config.Position.XAxis.ToString() + " " + (config.Position.YAxis + 0.004f).ToString(),
                            AnchorMax = (config.Position.XAxis + 0.019f).ToString() + " " + (config.Position.YAxis + 0.027f).ToString()
                        }
                    }
                    });

                    CuiHelper.AddUi(player, logo);
                }
            }

            if (MustShowValue(player.userID))
            {
                var message01 = elements.Add(new CuiLabel
                {
                    Text =
                    {
                    Text = valueText,
                    Color = fontColor,
                    FontSize = 12,
                    Align = TextAnchor.MiddleLeft
                    },

                    RectTransform = {
                    AnchorMin = "0.02 0",
                    AnchorMax = "0.8 1"
                    },
                }, panel);
            }

            if ((MustShowBar(player.userID)) && (valueText != "0"))
            {
                float anchorMin = config.Position.XAxis;
                if (config.ShowPicture)
                    anchorMin = anchorMin + pictureOffset;

                if (MustShowValue(player.userID))
                    anchorMin = anchorMin + 0.015f;

                var panel2 = elements.Add(new CuiPanel
                {
                    Image = {
                    Color = barColor
                },

                    RectTransform = {
                    AnchorMin = anchorMin.ToString() + " " + (config.Position.YAxis + 0.002f).ToString(),
                    AnchorMax = barText
                },

                    CursorEnabled = false
                }, "Hud", "divingBar");
            }

            return elements;
        }
        #endregion UI

        void LoadData()
        {
            try
            {
                playerData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, PlayerData>>("ChillDiving");
            }
            catch
            {
                playerData = new Dictionary<ulong, PlayerData>();
            }
        }

        void SaveData() => Interface.Oxide.DataFileSystem.WriteObject("ChillDiving", playerData);

        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion functions    

        #region helpers
        private static string ColorFromHex(string hexColor, int alpha)
        {
            hexColor = hexColor.TrimStart('#');
            if (hexColor.Length != 6 && hexColor.Length != 8)
            {
                hexColor = "000000";
            }
            int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
            int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
            int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);

            if (hexColor.Length == 8)
            {
                alpha = int.Parse(hexColor.Substring(6, 2), NumberStyles.AllowHexSpecifier);
            }

            return $"{red / 255.0} {green / 255.0} {blue / 255.0} {alpha / 255.0}";
        }

        private string Lang(string key, string userId = null, params object[] args) => string.Format(lang.GetMessage(key, this, userId), args);

        private bool IsWearablesContainer(ItemContainer cont)
        {
            return (cont.HasFlag(ItemContainer.Flag.Clothing) && (cont.HasFlag(ItemContainer.Flag.IsPlayer)));
        }

        private bool IsWearingdivingTank(BasePlayer player, out Item item)
        {
            foreach (Item contItem in player.inventory.containerWear.itemList)
            {
                if (contItem.info.shortname.Equals(divingTankShortName))
                {
                    item = contItem;
                    return true;
                }
            }

            item = null;
            return false;
        }

        private bool PlayerSignedUp(BasePlayer player)
        {
            PlayerData info;
            if (playerData.TryGetValue(player.userID, out info))
                return info.Enabled;
            else
                return true;
        }

        private bool IsValidColor(string value, out string RGB)
        {
            RGB = string.Empty;

            if (value[0] == '#')
            {
                if (IsValidRGBValue(value))
                {
                    RGB = value;
                    return true;
                }
                else
                    return false;
            }
            else
            {
                if (Enum.IsDefined(typeof(DivingColor), value))
                {
                    RGB = ColorToRGB(value);
                    return true;
                }
                else
                    return false;

            }
        }

        private bool IsValidRGBValue(string value)
        {
            if (value.Length <= 7)
                return Regex.IsMatch(value, "^#([A-Fa-f0-9]{6})$");
            else
                return Regex.IsMatch(value, "^#([A-Fa-f0-9]{8})$");
        }

        void ShowCommandHelp(BasePlayer player)
        {
            player.ChatMessage(Lang("HelpInfo", player.UserIDString) + "\n\n" + Lang("HelpView", player.userID.ToString()) + "\n" + Lang("HelpShow", player.userID.ToString()) +
                "\n\n" + Lang("HelpAlertAdd", player.userID.ToString()) + "\n" + Lang("HelpRangeAdd", player.userID.ToString()) + "\n" + Lang("HelpDelete", player.userID.ToString()) +
                "\n\n" + Lang("HelpView", player.userID.ToString()) + "\n\n" + Lang("HelpColor", player.userID.ToString()));
        }

        string ColorList()
        {
            string colors = string.Empty;
            foreach (string value in Enum.GetNames(typeof(DivingColor)))
            {
                colors = colors + ", " + value;
            }

            colors = colors.TrimStart(',', ' ');
            return (colors);
        }

        string ColorToRGB(string namedColor)
        {
            System.Drawing.Color color = System.Drawing.Color.FromName(namedColor);
            return ("#" + color.R.ToString("X2") + color.G.ToString("X2") + color.B.ToString("X2"));
        }

        #endregion helpers
    }
}

// --- End of file: ChillDiving.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/command-splitter ---
// --- Original File Path: C/CommandSplitter/CommandSplitter.cs ---

﻿using System;
using Network;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Command Splitter", "birthdates", "1.0.1")]
    [Description("Split one client command into multiple")]
    public class CommandSplitter : CovalencePlugin
    {
        #region Variables

        private const string UsePermission = "commandsplitter.use";

        #endregion

        #region Helpers

        /// <summary>
        ///     Send console reply to <paramref name="connection" />
        /// </summary>
        /// <param name="connection">Target connection</param>
        /// <param name="reply">String reply</param>
        private static void SendReply(Connection connection, string reply)
        {
            if (string.IsNullOrEmpty(reply) || !Net.sv.IsConnected()) return;

            using (NetWrite write = Net.sv.StartWrite())
            {
                write.PacketID(Message.Type.ConsoleMessage);
                write.String(reply);
                write.Send(new SendInfo(connection));
            }
        }

        #endregion

        #region Hooks

        /// <summary>
        ///     On client command, split it into multiple
        /// </summary>
        /// <param name="connection">Target connection</param>
        /// <param name="command">Target command(s)</param>
        /// <returns>True, if we should cancel. Null, if we shouldn't</returns>
        private object OnClientCommand(Connection connection, string command)
        {
            var player = connection.player as BasePlayer;
            if (player == null || !player.IPlayer.HasPermission(UsePermission)) return null;
            var commands = command.Split(_config.Separator.ToCharArray());
            foreach (var cmd in commands)
            {
                var trim = cmd.Trim();
                if (string.IsNullOrEmpty(trim)) continue;
                var reply = ConsoleSystem.Run(ConsoleSystem.Option.Server.FromConnection(connection).Quiet(), trim,
                    Array.Empty<object>());
                SendReply(connection, reply);
            }

            return true;
        }

        private void Init()
        {
            permission.RegisterPermission(UsePermission, this);
        }

        #endregion

        #region Configuration

        private ConfigFile _config;

        public class ConfigFile
        {
            [JsonProperty("Command Separator")] public string Separator { get; set; }

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    Separator = ";"
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if (_config == null) LoadDefaultConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        #endregion
    }
}

// --- End of file: CommandSplitter.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/craft-queue-saver ---
// --- Original File Path: C/CraftQueueSaver/CraftQueueSaver.cs ---

﻿namespace Oxide.Plugins
{
    [Info("Craft Queue Saver", "Jake_Rich", "1.1.6")]
    [Description("Saves player crafting queues on disconnect and on server shutdown")]
    class CraftQueueSaver : RustPlugin
    {
        private void Init()
        {
            Puts("This plugins functionality is part of the game.");
            Puts("The game saves the crafting queue when a player disconnects or when the server restarts.");
            Puts("The game puts the crafting materials back into the inventory of the player when they die.");
            Puts("There is no need for this plugin anymore. Delete it.");
        }
    }
}


// --- End of file: CraftQueueSaver.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ctf-events ---
// --- Original File Path: C/CTFEvents/CTFEvents.cs ---

// #define DEBUG
// #define UNITY_ASSERTIONS

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;

using Facepunch;

using Network;

using Newtonsoft.Json;

using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

using UnityEngine;
using UnityEngine.Assertions;

using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("CTF Events", "2CHEVSKII", "1.0.0")]
    [Description("Adds 'capture the flag' type events to your server")]
    class CTFEvents : CovalencePlugin
    {
        const string PERMISSION_MANAGE     = "ctfevents.manage";
        const string PREFAB_MARKER_GENERIC = "assets/prefabs/tools/map/genericradiusmarker.prefab";

        const string M_PREFIX                  = "Chat prefix",
                     M_NO_PERMISSION           = "No permission",
                     M_WRONG_USAGE             = "Wrong usage",
                     M_HELP                    = "Help",
                     M_EVENT_INFO              = "Event info",
                     M_EVENT_NOT_FOUND         = "Event not found",
                     M_NO_EVENTS               = "No events running",
                     M_EVENT_STARTED           = "Event started",
                     M_EVENT_STARTED_BY        = "Event started by player/plugin",
                     M_EVENT_FINISHED_TIME     = "Event time expired",
                     M_EVENT_FINISHED_FORCE    = "Event finished forcefully",
                     M_EVENT_FINISHED_CAPTURED = "Event finished by capturing flag",
                     M_INVALID_POS             = "Invalid position for event",
                     M_EVENT_EXISTS            = "Event already exists",
                     M_EVENT_LIMIT             = "Event limit reached",
                     M_EVENT_TICK_CAPTURING    = "Event tick capture",
                     M_EVENT_TICK_CONTESTED    = "Event tick contested",
                     M_PLAYER_CAPTURE_ENTER    = "Player entered capture zone",
                     M_PLAYER_CAPTURE_LEAVE    = "Player left capture zone";

        const string COLOR_CLOSE   = "</color>",
                     COLOR_DEFOCUS = "#a2ad9c",
                     COLOR_SUCCESS = "#72c93c",
                     COLOR_INFO    = "#309bd9",
                     COLOR_WARN    = "#f5cd2c",
                     COLOR_DANGER  = "#ff5526";

        static readonly int EventSpawnMask = LayerMask.GetMask(
            "Water",
            "Deployed",
            "Vehicle_World",
            "World",
            "Construction",
            "Construction_Socket",
            "Terrain",
            "Clutter",
            "Debris"
        );

        static CTFEvents Instance;

        PluginSettings    settings;
        int               maxEventsPerMap;
        List<Vector3>     eventSpawnPoints;
        readonly string[] hereSynonyms = { "here", "there", "sight", "place", "point", "atme", "spot", "on-this-spot", "within-reach", "hereabouts" };
        readonly string[] allSynonyms  = { "all", "every", "entier", "everything", "total", "whole", "allpresent" };

        [Conditional("DEBUG")]
        static void LogDebug(string format, params object[] args)
        {
            Interface.Oxide.LogDebug("[CTFEvents] " + format, args);
        }

        #region Command handlers

        void CommandHandler(IPlayer player, string _, string[] args)
        {
            if (args.Length == 0)
            {
                InfoCommand(player, null);
            }
            else
            {
                string arg = args.Skip(1).FirstOrDefault();

                switch (args[0])
                {
                    case "info":
                        InfoCommand(player, arg);
                        break;

                    case "start":
                        StartCommand(player, arg);
                        break;

                    case "end":
                        EndCommand(player, arg);
                        break;

                    case "help":
                        Message(player, M_HELP);
                        break;

                    default:
                        Message(player, M_WRONG_USAGE);
                        break;
                }
            }
        }

        void StartCommand(IPlayer player, string arg)
        {
            if (!player.HasPermission(PERMISSION_MANAGE))
            {
                Message(player, M_NO_PERMISSION);
            }
            else if (Flag.IsEventLimitReached)
            {
                Message(player, M_EVENT_LIMIT);
            }
            else if (arg == null)
            {
                Vector3 pos = GetRandomSpawnPoint();

                Flag.CreateNewEvent(pos, player);

                //if (pos == Vector3.zero)
                //{
                //    Message(player, M_EVENT_LIMIT);
                //}
                //else
                //{

                //}
            }
            else if (hereSynonyms.Contains(arg.ToLower()))
            {
                //if (Flag.IsEventLimitReached)
                //{
                //    Message(player, M_EVENT_LIMIT);
                //}
                //else
                //{

                //}

                Vector3 pos = GetViewPos(player);
                Vector3 pos2 = GetClosestSpawnPoint(pos);

                if (pos == Vector3.zero || !CanSpawnEvent(pos, pos2))
                {
                    Message(player, M_INVALID_POS);
                }
                else if (Flag.FindByGridCell(PhoneController.PositionToGridCoord(pos2)) != null)
                {
                    Message(player, M_EVENT_EXISTS);
                }
                else
                {
                    Flag.CreateNewEvent(pos2, player);
                }
            }
            else
            {
                Message(player, M_WRONG_USAGE);
            }
        }

        void EndCommand(IPlayer player, string arg)
        {
            if (!player.HasPermission(PERMISSION_MANAGE))
            {
                Message(player, M_NO_PERMISSION);
            }
            else if (Flag.EventCount == 0)
            {
                Message(player, M_NO_EVENTS);
            }
            else if (arg == null)
            {
                if (Flag.EventCount == 1)
                {
                    Flag.FindById(1).ForceFinish(player);
                }
                else
                {
                    Message(player, M_WRONG_USAGE);
                }
            }
            else if (allSynonyms.Contains(arg.ToLower()))
            {
                Flag[] flags = Flag.GetAll();

                for (int i = 0; i < flags.Length; i++)
                {
                    flags[i].ForceFinish(player);
                }
            }
            else
            {
                int id;
                Flag flag;
                if (int.TryParse(arg, out id))
                {
                    flag = Flag.FindById(id);
                }
                else
                {
                    flag = Flag.FindByGridCell(arg);
                }

                if (!flag)
                {
                    Message(player, M_EVENT_NOT_FOUND);
                }
                else
                {
                    flag.ForceFinish(player);
                }
            }
        }

        void InfoCommand(IPlayer player, string arg)
        {
            int id;
            if (arg == null)
            {
                Flag[] allFlags = Flag.GetAll();

                if (allFlags.Length == 0)
                {
                    Message(player, M_NO_EVENTS);
                }
                else
                {
                    StringBuilder builder = Pool.Get<StringBuilder>();

                    for (int i = 0; i < allFlags.Length; i++)
                    {
                        Flag flag = allFlags[i];

                        string info = GetFlagInfo(player, flag);

                        builder.AppendLine(info);
                    }

                    MessageRaw(player, builder.ToString(), true);

                    builder.Clear();
                    Pool.Free(ref builder);
                }
            }
            else if (int.TryParse(arg, out id))
            {
                Flag flag = Flag.FindById(id);

                if (!flag)
                {
                    Message(player, M_EVENT_NOT_FOUND);
                }
                else
                {
                    MessageRaw(player, GetFlagInfo(player, flag));
                }
            }
            else
            {
                Flag flag = Flag.FindByGridCell(arg);

                if (!flag)
                {
                    Message(player, M_EVENT_NOT_FOUND);
                }
                else
                {
                    MessageRaw(player, GetFlagInfo(player, flag));
                }
            }
        }

        #endregion

        #region Utility

        Vector3 GetClosestSpawnPoint(Vector3 pos)
        {
            return eventSpawnPoints.Except(Flag.GetOccupiedSpawnPoints())
                                   .OrderBy(sp => Vector3.Distance(sp, pos))
                                   .First();
        }

        Vector3 GetRandomSpawnPoint()
        {
            List<Vector3> occupied = Flag.GetOccupiedSpawnPoints();

            return eventSpawnPoints.FindAll(sp => !occupied.Contains(sp)).GetRandom();
        }

        bool CanSpawnEvent(Vector3 origPos, Vector3 closestSp)
        {
            return Vector3.Distance(origPos, closestSp) <= 75f;
        }

        Vector3 GetViewPos(IPlayer player)
        {
            var basePlayer = (BasePlayer)player.Object;

            RaycastHit hit;

            if (!Physics.Raycast(basePlayer.eyes.HeadRay(), out hit, 100f, EventSpawnMask))
            {
                return Vector3.zero;
            }

            return hit.point;
        }

        List<Vector3> ScanTerrain()
        {
            Vector3 pos = new Vector3(-(TerrainMeta.Size.x / 2) + 75f, 0, TerrainMeta.Size.z / 2 - 75f);
            const float GRID_SIZE = 150f;

            List<Vector3> spawnPoints = new List<Vector3>();

            while (pos.z > -(TerrainMeta.Size.z / 2 ))
            {
                Vector3 point;
                if (ScanCell(pos, out point))
                {
                    spawnPoints.Add(point);
                }

                pos.x += GRID_SIZE;

                if (pos.x > TerrainMeta.Size.x)
                {
                    pos.x = -(TerrainMeta.Size.x / 2) + 75f;
                    pos.z -= GRID_SIZE;
                }
            }

            return spawnPoints;
        }

        bool ScanCell(Vector3 pos, out Vector3 point)
        {
            LogDebug("Scanning grid cell {0}", PhoneController.PositionToGridCoord(pos));

            const int SAMPLE_COUNT = 150;

            for (int i = 0; i < SAMPLE_COUNT; i++)
            {
                Vector2 rand = Random.insideUnitCircle * 75f;
                Vector3 sample = pos + new Vector3(rand.x, 0, rand.y);

                RaycastHit hit;
                sample.y = 300f;

                Physics.Raycast(
                    sample,
                    Vector3.down,
                    out hit,
                    500f,
                    EventSpawnMask
                );

                float height = hit.point.y;
                float height2 = TerrainMeta.WaterMap.GetHeight(sample);

                if (height > height2)
                {
                    point = sample;
                    point.y = height;
                    return true;
                }
            }

            point = Vector3.zero;
            return false;
        }

        #endregion

        #region Oxide hooks

        void Init()
        {
            Instance = this;

            permission.RegisterPermission(PERMISSION_MANAGE, this);
            AddCovalenceCommand("ctf", nameof(CommandHandler));

            LogDebug("Debug messages enabled");
        }

        void OnServerInitialized()
        {
            var points = ScanTerrain();

            maxEventsPerMap = points.Count;
            eventSpawnPoints = points;

            LogDebug("Max events per map: {0}", maxEventsPerMap);

            if (settings.EventLimit > maxEventsPerMap)
            {
                LogWarning(
                    "Configured event limit exceeds maximum event count dictated by the map size. The latter will be used instead"
                );
            }

            Flag.Initialize();

            if (settings.EventAutoCreateFrequency > 0f)
            {
                timer.Every(
                    settings.EventAutoCreateFrequency,
                    () => {
                        int c = Flag.EventCount;

                        if (c != 0 && !settings.AutoCreateIfAnyExists)
                        {
                            return;
                        }

                        if (Flag.IsEventLimitReached)
                        {
                            return;
                        }

                        Flag.CreateNewEvent(GetRandomSpawnPoint());
                    }
                );
            }
        }

        void OnUserConnected(IPlayer player)
        {
            Flag.OnPlayerConnected((BasePlayer)player.Object);
        }

        void Unload()
        {
            Flag.Unload();

            Instance = null;
        }

        #endregion

        #region External API calls

        void OnEventStarted(Flag flag)
        {
            if (Interface.Oxide.CallHook("OnCtfEventStarted", flag.GridCell) == null)
            {
                Announce(M_EVENT_STARTED, flag.GridCell);
            }
        }

        void OnEventStarted(Flag flag, IPlayer manager)
        {
            if (Interface.Oxide.CallHook("OnCtfEventStarted", flag.GridCell, manager) == null)
            {
                Announce(M_EVENT_STARTED_BY, flag.GridCell, manager.Name);
            }
        }

        void OnEventStarted(Flag flag, Plugin caller)
        {
            if (Interface.Oxide.CallHook("OnCtfEventStarted", flag.GridCell, caller) == null)
            {
                Announce(M_EVENT_STARTED_BY, flag.GridCell, caller.Name);
            }
        }

        void OnEventFinished(Flag flag)
        {
            if (Interface.Oxide.CallHook("OnCtfEventFinished", flag.GridCell) == null)
            {
                Announce(M_EVENT_FINISHED_TIME, flag.GridCell);
            }
        }

        void OnEventFinished(Flag flag, BasePlayer winner)
        {
            if (Interface.Oxide.CallHook("OnCtfEventFinished", flag.GridCell, winner.displayName) == null)
            {
                Announce(M_EVENT_FINISHED_CAPTURED, flag.GridCell, WrapInColor(winner.displayName, COLOR_INFO));
            }
        }

        void OnEventFinished(Flag flag, List<BasePlayer> winners)
        {
            if (Interface.Oxide.CallHook("OnCtfEventFinished", flag.GridCell, winners) == null)
            {
                Announce(
                    M_EVENT_FINISHED_CAPTURED,
                    flag.GridCell,
                    string.Join(", ", winners.Select(w => WrapInColor(w.displayName, COLOR_INFO)))
                );
            }
        }

        void OnEventFinished(Flag flag, IPlayer manager)
        {
            if (Interface.Oxide.CallHook("OnCtfEventFinished", flag.GridCell, manager) == null)
            {
                Announce(M_EVENT_FINISHED_FORCE, flag.GridCell, manager.Name);
                LogDebug("Event {0} finished by player {1}", flag.GridCell, manager);
            }
        }

        void OnEventFinished(Flag flag, Plugin caller)
        {
            if (Interface.Oxide.CallHook("OnCtfEventFinished", flag.GridCell, caller) == null)
            {
                Announce(M_EVENT_FINISHED_FORCE, flag.GridCell, caller.Name);
            }

            LogDebug("Event {0} finished by plugin {1}", flag.GridCell, caller.Name);
        }

        void OnEventTick(Flag flag)
        {
            Interface.Oxide.CallHook(
                "OnCtfEventTick",
                flag.GridCell,
                flag.State,
                flag.TimeLeft,
                flag.CaptureProgress
            );

            if (flag.State == Flag.EventState.Stale)
            {
                return;
            }

            List<BasePlayer> list = Pool.GetList<BasePlayer>();

            flag.GetAlivePlayers(list);

            for (int i = 0; i < list.Count; i++)
            {
                BasePlayer player = list[i];

                if (!flag.ShouldNotify(player.IPlayer))
                {
                    continue;
                }

                if (flag.State == Flag.EventState.Capturing)
                {
                    Message(player.IPlayer, M_EVENT_TICK_CAPTURING, flag.GridCell, flag.CaptureTimeLeft);
                }
                else
                {
                    Message(player.IPlayer, M_EVENT_TICK_CONTESTED, flag.GridCell, list.Count - flag.CapturerCount);
                }
            }

            Pool.FreeList(ref list);
        }

        void OnEventStateChange(Flag flag, Flag.EventState prevState, Flag.EventState newState)
        {
            Interface.Oxide.CallHook("OnCtfEventStateChange", flag.GridCell, prevState, newState);
        }

        void OnPlayerEnterCaptureZone(Flag flag, BasePlayer player)
        {
            if (Interface.Oxide.CallHook("OnCtfPlayerEnterZone", flag.GridCell, player) == null)
            {
                Message(player.IPlayer, M_PLAYER_CAPTURE_ENTER, flag.GridCell);
            }
        }

        void OnPlayerLeaveCaptureZone(Flag flag, BasePlayer player)
        {
            if (Interface.Oxide.CallHook("OnCtfPlayerLeaveZone", flag.GridCell, player) == null)
            {
                Message(player.IPlayer, M_PLAYER_CAPTURE_LEAVE, flag.GridCell);
            }
        }

        #endregion

        #region Public API

        [HookMethod("CTFEvents::GetInGridCell")]
        public Flag GetEventInGridCell(string gridCell)
        {
            return Flag.FindByGridCell(gridCell);
        }

        #endregion

        #region LangAPI

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(
                new Dictionary<string, string> {
                    [M_PREFIX] = "[CTF] ",
                    [M_NO_PERMISSION] = WrapInColor("You have no access to this command", COLOR_DANGER),
                    [M_WRONG_USAGE] = WrapInColor(
                        $"Syntax error. Use {WrapInColor("/ctf help", COLOR_INFO)} to get help",
                        COLOR_WARN
                    ),
                    [M_HELP] =
                        $"Usage: {WrapInColor("/ctf", COLOR_INFO)} [{WrapInColor("command", COLOR_SUCCESS)}] <{WrapInColor("arguments", COLOR_DEFOCUS)}>\n" +
                        "Commands:\n" +
                        $"no command | {WrapInColor("info", COLOR_SUCCESS)} - Shows info about all current events. Can be provided with an id or grid cell name to get info about specific event\n" +
                        $"{WrapInColor("start", COLOR_SUCCESS)} - Starts event at random position. Additional argument - {WrapInColor("here", COLOR_DEFOCUS)} might be specified to create event on the point you are currently looking at\n" +
                        $"{WrapInColor("end", COLOR_SUCCESS)} - Stops an event, needs to be provided with either id or grid cell as an argument",
                    [M_EVENT_INFO] =
                        $"#{WrapInColor("{0}", COLOR_INFO)}: [ {WrapInColor("{1}", COLOR_WARN)} ], Time left: {WrapInColor("{2}", COLOR_DEFOCUS)}",
                    [M_EVENT_NOT_FOUND] = WrapInColor("Event not found", COLOR_DANGER),
                    [M_NO_EVENTS] = WrapInColor("No events currently in process", COLOR_WARN),
                    [M_EVENT_STARTED] =
                        $"Capture the flag event started at [ {WrapInColor("{0}", COLOR_WARN)} ], check your map!",
                    [M_EVENT_STARTED_BY] =
                        $"Capture the flag event started by {WrapInColor("{1}", COLOR_INFO)} at [ {WrapInColor("{0}", COLOR_WARN)} ], check your map!",
                    [M_EVENT_FINISHED_TIME] = WrapInColor(
                        $"Capture the flag event at [ {WrapInColor("{0}", COLOR_WARN)} ] has ran out of time, no winner chosen",
                        COLOR_DEFOCUS
                    ),
                    [M_EVENT_FINISHED_FORCE] =
                        $"Capture the flag event at [ {WrapInColor("{0}", COLOR_DEFOCUS)} ] was stopped by {WrapInColor("{1}", COLOR_WARN)}",
                    [M_EVENT_FINISHED_CAPTURED] =
                        $"Capture the flag event at [ {WrapInColor("{0}", COLOR_SUCCESS)} ] was won by {{1}}",
                    [M_INVALID_POS] = WrapInColor("Event cannot be spawned here", COLOR_DANGER),
                    [M_EVENT_EXISTS] = WrapInColor(
                        "Event already exists near that position, try choosing another place",
                        COLOR_WARN
                    ),
                    [M_EVENT_LIMIT] = WrapInColor(
                        "Event limit reached, wait for other event to end, or stop it manually",
                        COLOR_DANGER
                    ),
                    [M_EVENT_TICK_CAPTURING] =
                        $"You are capturing flag at [ {WrapInColor("{0}", COLOR_SUCCESS)} ], stay in the zone for {WrapInColor("{1}", COLOR_INFO)} more seconds",
                    [M_EVENT_TICK_CONTESTED] =
                        $"The objective at [ {WrapInColor("{0}", COLOR_WARN)} ] is being contested, make other {WrapInColor("{1}", COLOR_DANGER)} players leave the zone or put a bullet in their heads!",
                    [M_PLAYER_CAPTURE_ENTER] = $"You've entered event zone [ {WrapInColor("{0}", COLOR_SUCCESS)} ]",
                    [M_PLAYER_CAPTURE_LEAVE] = $"You've left event zone [ {WrapInColor("{0}", COLOR_DANGER)} ]"
                },
                this
            );
        }

        void Message(IPlayer player, string langKey, params object[] args)
        {
            string prefix = GetMessage(player, M_PREFIX);
            string format = GetMessage(player, langKey);
            string message = string.Format(format, args);

            player.Message(prefix + message);
        }

        void MessageRaw(IPlayer player, string message, bool newLine = false)
        {
            string prefix = GetMessage(player, M_PREFIX);

            if (newLine)
            {
                player.Message(prefix + '\n' + message);
            }
            else
            {
                player.Message(prefix + message);
            }
        }

        void Announce(string langKey, params object[] args)
        {
            foreach (IPlayer player in players.Connected)
            {
                Message(player, langKey, args);
            }
        }

        void AnnounceRaw(string message, bool newLine = false)
        {
            foreach (IPlayer player in players.Connected)
            {
                MessageRaw(player, message, newLine);
            }
        }

        string GetMessage(IPlayer player, string langKey)
        {
            return lang.GetMessage(langKey, this, player.Id);
        }

        string WrapInColor(string str, string color)
        {
            return "<color=" + color + ">" + str + COLOR_CLOSE;
        }

        string GetFlagInfo(IPlayer player, Flag flag)
        {
            string format = GetMessage(player, M_EVENT_INFO);

            string info = string.Format(format, flag.Id, flag.GridCell, flag.TimeLeft);

            return info;
        }

        #endregion

        #region Configuration

        protected override void LoadDefaultConfig()
        {
            settings = PluginSettings.Default;
            SaveConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                settings = Config.ReadObject<PluginSettings>();

                if (settings == null)
                {
                    throw new Exception();
                }
            }
            catch (Exception e)
            {
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(settings);
        }

        #endregion

        #region Nested types

        #region Flag

        public class Flag : MonoBehaviour
        {
            static List<Flag>     allEvents;
            static ItemDefinition captureItemDef;

            PluginSettings             settings;
            DroppedItem                bindObject;
            float                      startTime;
            float                      endTime;
            float                      capturePercentage;
            float                      lastCaptureTickTime;
            List<BasePlayer>           currentCapturers;
            List<BasePlayer>           allPlayersInZone;
            List<BasePlayer>           alivePlayersInZone;
            string                     gridCell;
            MapMarkerGenericRadius     mapMarker;
            EventState                 state;
            object                     initiator;
            Dictionary<IPlayer, float> lastNotificationTime;

            public static int EventCount => allEvents.Count;

            public static bool IsEventLimitReached => EventCount == Instance.maxEventsPerMap ||
                                                      Instance.settings.EventLimit > -1 &&
                                                      EventCount == Instance.settings.EventLimit;

            public string GridCell => gridCell;
            public int Id => allEvents.IndexOf(this) + 1;
            public int TimeLeft => Mathf.FloorToInt(endTime - Time.realtimeSinceStartup);
            public float CaptureProgress => capturePercentage;

            public int CaptureTimeLeft =>
                Mathf.FloorToInt(settings.CaptureTime - settings.CaptureTime * capturePercentage);

            public int CapturerCount => currentCapturers.Count;

            public EventState State
            {
                get { return state; }

                private set
                {
                    Assert.IsFalse(state == value, "Updating state with the same value!");

                    Instance.OnEventStateChange(this, state, value);
                    state = value;
                    UpdateMarkerColors();
                    UpdateMarkerForAll();
                }
            }

            public static void Initialize()
            {
                captureItemDef = ItemManager.FindItemDefinition(Instance.settings.CaptureItemShortName);

                if (!captureItemDef)
                {
                    throw new ArgumentException(
                        $"Could not find item definition for shortname '{Instance.settings.CaptureItemShortName}'"
                    );
                }

                allEvents = new List<Flag>();
            }

            public static void Unload()
            {
                if (allEvents == null)
                {
                    return; // Plugin was unloaded before server fully initialized
                }

                foreach (Flag allEvent in allEvents)
                {
                    allEvent.TimedDispose();
                }

                captureItemDef = null;
                allEvents = null;
            }

            public static List<Vector3> GetOccupiedSpawnPoints()
            {
                return Instance.eventSpawnPoints.FindAll(
                    sp => allEvents.Any(e => e.bindObject.transform.position == sp)
                );
            }

            public static Flag FindByGridCell(string gridCell)
            {
                return allEvents.Find(e => e.gridCell == gridCell.ToUpper());
            }

            public static Flag FindById(int id)
            {
                if (id < 1 || id > allEvents.Count)
                {
                    return null;
                }

                return allEvents[id - 1];
            }

            public static Flag[] GetAll()
            {
                return allEvents.ToArray();
            }

            public static void OnPlayerConnected(BasePlayer player)
            {
                for (int i = 0; i < allEvents.Count; i++)
                {
                    Flag flag = allEvents[i];
                    flag.SendMarkerUpdate(player);
                }
            }

            public static void CreateNewEvent(Vector3 pos)
            {
                CreateEvent(pos);

                LogDebug("Created new event at {0}", pos);
            }

            public static void CreateNewEvent(Vector3 pos, object initiator)
            {
                Flag flag = CreateEvent(pos);
                flag.SetInitiator(initiator);

                LogDebug("Created new event at {0} with initiator {1}", pos, initiator);
            }

            static Flag CreateEvent(Vector3 pos)
            {
                Item item = ItemManager.Create(captureItemDef, skin: Instance.settings.CaptureItemSkinId);

                Assert.IsNotNull(item, "Item is null in CreateEvent");

                BaseEntity bindObject = item.CreateWorldObject(pos);

                Assert.IsNotNull(bindObject, "Bind object is null in CreateEvent");

                Flag flag = bindObject.gameObject.AddComponent<Flag>();

                return flag;
            }

            public Dictionary<string, object> ToSerializable()
            {
                var dictionary = new Dictionary<string, object>();

                dictionary["id"] = Id;
                dictionary["gridcell"] = gridCell;
                dictionary["starttime"] = startTime;
                dictionary["endtime"] = endTime;
                dictionary["bindobj"] = bindObject;
                dictionary["capturepercent"] = capturePercentage;
                dictionary["capturers"] = currentCapturers.ToArray();
                dictionary["state"] = (int)state;

                return dictionary;
            }

            public void ForceFinish(IPlayer manager)
            {
                ForceDispose(manager);
            }

            public void ForceFinish(Plugin caller)
            {
                ForceDispose(caller);
            }

            public void SetInitiator(object initiator)
            {
                Assert.IsTrue(initiator is IPlayer || initiator is Plugin, "Initiator is not a player nor a plugin!");

                this.initiator = initiator;
            }

            public bool ShouldNotify(IPlayer player)
            {
                if (player == null)
                {
                    return false;
                }

                bool b = false;
                if (!lastNotificationTime.ContainsKey(player))
                {
                    b = true;
                }
                else if (Time.realtimeSinceStartup - lastNotificationTime[player] >
                         settings.EventTickNotificationFrequency)
                {
                    b = true;
                }

                if (b)
                {
                    lastNotificationTime[player] = Time.realtimeSinceStartup;
                }

                return b;
            }

            public void GetAlivePlayers(List<BasePlayer> list)
            {
                list.AddRange(alivePlayersInZone);
            }

            #region Unity Messages

            void Awake()
            {
                settings = Instance.settings;
                bindObject = GetComponent<DroppedItem>();

                currentCapturers = new List<BasePlayer>();
                allPlayersInZone = new List<BasePlayer>();
                alivePlayersInZone = new List<BasePlayer>();
                lastNotificationTime = new Dictionary<IPlayer, float>();

                Assert.IsNotNull(bindObject, "Bind object is null in Awake!");

                SetupCollider();
                SetupRotation();

                startTime = Time.realtimeSinceStartup;
                endTime = startTime + settings.TotalEventTime;

                gridCell = PhoneController.PositionToGridCoord(bindObject.transform.position);

                allEvents.Add(this);

                bindObject.allowPickup = false;

                InvokeRepeating(nameof(EventTick), 1f, 1f);

                if (settings.EnableMapMarkers)
                {
                    SetupMarker();
                    UpdateMarkerColors();
                    UpdateMarkerForAll();
                }

                bindObject.SendNetworkUpdate();
            }

            void Start()
            {
                if (initiator == null)
                {
                    OnEventStart();
                }
                else if (initiator is IPlayer)
                {
                    OnEventStart((IPlayer)initiator);
                }
                else
                {
                    OnEventStart((Plugin)initiator);
                }
            }

            void OnTriggerEnter(Collider other)
            {
                if (other.gameObject.layer != 17)
                {
                    return;
                }

                var player = other.GetComponentInParent<BasePlayer>();

                Assert.IsNotNull(player, "Player is null in OnTriggerEnter");
                LogDebug("OnTriggerEnter: {0}", player.displayName);

                allPlayersInZone.Add(player);

                if (!player.IsDead() && !player.IsSleeping())
                {
                    OnPlayerEnterCaptureZone(player);
                }
            }

            void OnTriggerExit(Collider other)
            {
                if (other.gameObject.layer != 17)
                {
                    return;
                }

                var player = other.GetComponentInParent<BasePlayer>();

                Assert.IsNotNull(player, "Player is null on OnTriggerExit");
                LogDebug("OnTriggerExit: {0}", player.displayName);

                allPlayersInZone.Remove(player);

                if (alivePlayersInZone.Contains(player))
                {
                    OnPlayerLeaveCaptureZone(player);
                }
            }

            void OnDestroy()
            {
                CancelInvoke(nameof(Rotate));
                CancelInvoke(nameof(EventTick));

                mapMarker?.Kill();

                allEvents?.Remove(this);
            }

            #endregion

            #region Collider, rotation, markers

            void SetupCollider()
            {
                Destroy(GetComponent<PhysicsEffects>());
                Destroy(GetComponent<EntityCollisionMessage>());

                var rb = GetComponent<Rigidbody>();
                rb.isKinematic = true;
                rb.detectCollisions = true;

                Assert.IsNotNull(rb, "Rigidbody is null!");

                var collider = gameObject.AddComponent<SphereCollider>();

                collider.enabled = true;
                collider.isTrigger = true;
                collider.radius = settings.CaptureRadius;

                gameObject.layer = 3;
            }

            void SetupRotation()
            {
                var height =
                    TerrainMeta.HeightMap.GetHeight(
                        transform.position
                    ); // TODO: get actual height considering buildings

                var targetHeight = height + 1.5f;

                transform.position = new Vector3(transform.position.x, targetHeight, transform.position.z);

                transform.Rotate(90, 0, 0);
                InvokeRepeating(nameof(Rotate), 0.1f, 0.1f);
            }

            void SetupMarker()
            {
                mapMarker = (MapMarkerGenericRadius)GameManager.server.CreateEntity(
                    PREFAB_MARKER_GENERIC,
                    transform.position
                );
                mapMarker.Spawn();

                mapMarker.alpha = 0.65f;
                mapMarker.radius = settings.CaptureRadius * 0.0178f;
                mapMarker.color2 = Color.black;
            }

            void UpdateMarkerColors()
            {
                if (!mapMarker)
                {
                    return;
                }

                switch (State)
                {
                    case EventState.Stale:
                        mapMarker.color1 = Color.red;
                        break;

                    case EventState.Capturing:
                        mapMarker.color1 = Color.green;
                        break;

                    case EventState.Contested:
                        mapMarker.color1 = Color.yellow;
                        break;
                }
            }

            void SendMarkerUpdate(BasePlayer player)
            {
                if (!mapMarker)
                {
                    return;
                }

                mapMarker.ClientRPCEx(
                    new SendInfo(player.Connection),
                    null,
                    "MarkerUpdate",
                    new Vector3(mapMarker.color1.r, mapMarker.color1.g, mapMarker.color1.b),
                    mapMarker.color1.a,
                    mapMarker.alpha,
                    mapMarker.radius
                );
            }

            void UpdateMarkerForAll()
            {
                if (!mapMarker)
                {
                    return;
                }

                List<Connection> list = Pool.GetList<Connection>();

                list.AddRange(BasePlayer.activePlayerList.Select(p => p.Connection));

                mapMarker.ClientRPCEx(
                    new SendInfo(list),
                    null,
                    "MarkerUpdate",
                    new Vector3(mapMarker.color1.r, mapMarker.color1.g, mapMarker.color1.b),
                    mapMarker.color1.a,
                    mapMarker.alpha,
                    mapMarker.radius
                );

                Pool.FreeList(ref list);
            }

            void Rotate()
            {
                transform.Rotate(0, 0, 5);
            }

            #endregion

            void EventTick()
            {
                for (int i = 0; i < allPlayersInZone.Count; i++)
                {
                    var player = allPlayersInZone[i];

                    if ((player.IsDead() || player.IsSleeping()) && alivePlayersInZone.Contains(player))
                    {
                        OnPlayerLeaveCaptureZone(player);
                    }
                    else if (!player.IsDead() && !player.IsSleeping() && !alivePlayersInZone.Contains(player))
                    {
                        OnPlayerEnterCaptureZone(player);
                    }
                }

                if (State == EventState.Stale && Time.realtimeSinceStartup >= endTime)
                {
                    TimedDispose();
                }
                else
                {
                    if (State == EventState.Capturing)
                    {
                        OnCaptureTick(Time.realtimeSinceStartup - lastCaptureTickTime, currentCapturers.Count);
                    }

                    Instance.OnEventTick(this);
                }
            }

            void OnPlayerEnterCaptureZone(BasePlayer player)
            {
                alivePlayersInZone.Add(player);

                Instance.OnPlayerEnterCaptureZone(this, player);

                player.SendMessage("OnCtfEnterZone", this, SendMessageOptions.DontRequireReceiver);

                LogDebug("OnPlayerEnterCaptureZone {0}", player.displayName);

                switch (State)
                {
                    case EventState.Stale:
                        currentCapturers.Add(player);
                        State = EventState.Capturing;
                        OnCaptureStart(player);
                        break;
                    case EventState.Capturing:
                        var isTeamMate = player.Team != null &&
                                         player.Team.teamID != 0 &&
                                         player.Team.teamID == currentCapturers[0].Team.teamID;

                        if (isTeamMate && settings.AllowTeamCapture)
                        {
                            currentCapturers.Add(player);
                        }
                        else
                        {
                            State = EventState.Contested;
                            OnContestedStart(player);
                        }

                        break;
                }
            }

            void OnPlayerLeaveCaptureZone(BasePlayer player)
            {
                alivePlayersInZone.Remove(player);

                Instance.OnPlayerLeaveCaptureZone(this, player);

                player.SendMessage("OnCtfLeaveZone", this, SendMessageOptions.DontRequireReceiver);

                LogDebug("OnPlayerLeaveCaptureZone {0}", player.displayName);

                switch (State)
                {
                    case EventState.Capturing:
                        if (currentCapturers.Remove(player) && currentCapturers.Count == 0)
                        {
                            State = EventState.Stale;
                            OnCaptureStop(player);
                        }

                        break;
                    case EventState.Contested:
                        if (currentCapturers.Remove(player))
                        {
                            if (currentCapturers.Count == 0)
                            {
                                BasePlayer newCapturer = alivePlayersInZone[0];
                                currentCapturers.Add(newCapturer);

                                if (settings.AllowTeamCapture)
                                {
                                    currentCapturers.AddRange(
                                        alivePlayersInZone.Skip(1).Where(
                                            p => p.Team != null &&
                                                 p.Team.teamID != 0 &&
                                                 p.Team.teamID == newCapturer.Team.teamID
                                        )
                                    );
                                }

                                if (alivePlayersInZone.Count != currentCapturers.Count)
                                {
                                    State = EventState.Contested;
                                    OnContestedStart(newCapturer);
                                }
                                else
                                {
                                    State = EventState.Capturing;
                                    OnCaptureStart(newCapturer);
                                }
                            }
                        }
                        else if (currentCapturers.Count == alivePlayersInZone.Count)
                        {
                            State = EventState.Capturing;
                        }

                        break;
                }
            }

            void OnCaptureStart(BasePlayer player)
            {
                lastCaptureTickTime = Time.realtimeSinceStartup;
                capturePercentage = 0f;

                LogDebug("OnCaptureStart: {0}", player.displayName);
            }

            void OnContestedStart(BasePlayer player)
            {
                //alivePlayersInZone.ForEach(
                //    p => p.SendMessage("OnCtfContested", this, SendMessageOptions.DontRequireReceiver)
                //);

                LogDebug("OnContestedStart: {0}", player.displayName);
            }

            void OnCaptureStop(BasePlayer player)
            {
                LogDebug("OnCaptureStop: {0}", player.displayName);
            }

            void OnCaptureTick(float deltaTime, int capturerCount)
            {
                var basePercentage = deltaTime / settings.CaptureTime;
                var addPercentage = basePercentage * (capturerCount - 1) * settings.MultipleCapturersSpeedup;

                var totalPercentage = basePercentage + addPercentage;

                capturePercentage += totalPercentage;

                lastCaptureTickTime = Time.realtimeSinceStartup;

                LogDebug(
                    "OnCaptureTick:\n" +
                    "deltaTime: {0}, capturers: {1}, basePercentage: {2}, additionalPerc: {3}\n" +
                    "resulting capture percentage: {4}",
                    deltaTime,
                    capturerCount,
                    basePercentage,
                    addPercentage,
                    capturePercentage
                );

                alivePlayersInZone.ForEach(
                    player => player.SendMessage("OnCtfStatusUpdate", this, SendMessageOptions.DontRequireReceiver)
                );

                if (capturePercentage >= 1f)
                {
                    OnCaptureSuccess();
                }
            }

            void OnCaptureSuccess()
            {
                if (currentCapturers.Count == 1)
                {
                    BasePlayer winner = currentCapturers[0];

                    LogDebug("OnCaptureSuccess -> {0}", winner.displayName);

                    OnEventEnd(winner);
                }
                else
                {
                    OnEventEnd(currentCapturers);
                }

                Dispose();
            }

            void OnEventStart()
            {
                LogDebug("OnEventStart {0}", gridCell);

                Instance.OnEventStarted(this);
            }

            void OnEventStart(IPlayer manager)
            {
                LogDebug("OnEventStart by player {0}: {1}", manager, gridCell);

                Instance.OnEventStarted(this, manager);
            }

            void OnEventStart(Plugin caller)
            {
                LogDebug("OnEventStart by plugin {0}: {1}", caller.Name, gridCell);

                Instance.OnEventStarted(this, caller);
            }

            void OnEventEnd(BasePlayer winner = null)
            {
                if (winner)
                {
                    // ReSharper disable PossibleNullReferenceException
                    LogDebug("Event at {0} was won by player {1}", gridCell, winner.displayName);
                    // ReSharper enable PossibleNullReferenceException

                    Instance.OnEventFinished(this, winner);
                }
                else
                {
                    LogDebug("Event at {0} ended with no winner", gridCell);

                    Instance.OnEventFinished(this);
                }
            }

            void OnEventEnd(List<BasePlayer> winners)
            {
                LogDebug("Event at {0} was won by group of players ({1})", gridCell, winners.Count);

                Instance.OnEventFinished(this, winners);
            }

            void Dispose()
            {
                Item item = bindObject.GetItem();

                item.RemoveFromWorld();
                item.Remove(0f);

                LogDebug("Disposing event at cell {0}", gridCell);
            }

            void TimedDispose()
            {
                LogDebug("TimedDispose of {0}", gridCell);
                OnEventEnd();
                Dispose();
            }

            void ForceDispose(IPlayer manager)
            {
                LogDebug("Player {0} force disposed event at {1}", manager, gridCell);
                Instance.OnEventFinished(this, manager);
                Dispose();
            }

            void ForceDispose(Plugin caller)
            {
                LogDebug("Plugin {0} force disposed event at {1}", caller.Name, gridCell);
                Instance.OnEventFinished(this, caller);
                Dispose();
            }

            public enum EventState
            {
                Stale,
                Capturing,
                Contested
            }
        }

        #endregion

        #region Configuration

        class PluginSettings
        {
            public static PluginSettings Default => new PluginSettings {
                CaptureItemShortName = "rifle.ak",
                CaptureItemSkinId = 1167207039ul,
                TotalEventTime = 300f,
                CaptureTime = 60f,
                CaptureRadius = 30f,
                AllowTeamCapture = false,
                MultipleCapturersSpeedup = 0.5f,
                EnableMapMarkers = true,
                EventTickNotificationFrequency = 15f,
                EventAutoCreateFrequency = 900f,
                AutoCreateIfAnyExists = false,
                EventLimit = -1
            };

            [JsonProperty("Capture item shortname")]
            public string CaptureItemShortName { get; set; }
            [JsonProperty("Capture item skin ID")]
            public ulong CaptureItemSkinId { get; set; }
            [JsonProperty("Total event time")]
            public float TotalEventTime { get; set; }
            [JsonProperty("Time needed to capture")]
            public float CaptureTime { get; set; }
            [JsonProperty("Capture radius")]
            public float CaptureRadius { get; set; }
            [JsonProperty("Allow capturing with teammates")]
            public bool AllowTeamCapture { get; set; }
            [JsonProperty("Capture speed increase per teammate")]
            public float MultipleCapturersSpeedup { get; set; }
            [JsonProperty("Enable map markers")]
            public bool EnableMapMarkers { get; set; }
            [JsonProperty("Event status update notifications frequency")]
            public float EventTickNotificationFrequency { get; set; }
            [JsonProperty("Event autospawn frequency")]
            public float EventAutoCreateFrequency { get; set; }
            [JsonProperty("Allow autospawn if another event is present")]
            public bool AutoCreateIfAnyExists { get; set; }
            [JsonProperty("Event count limit")]
            public int EventLimit { get; set; }
        }

        #endregion

        #endregion
    }
}


// --- End of file: CTFEvents.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/clothed-murderers ---
// --- Original File Path: C/ClothedMurderers/ClothedMurderers.cs ---

using System;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Clothed Murderers", "Substrata", "1.0.1")]
    [Description("Puts the default clothing back on murderer NPCs")]
    class ClothedMurderers : RustPlugin
    {
        void OnEntitySpawned(NPCMurderer murderer)
        {       
                var inv_wear = murderer.inventory.containerWear;

                Item burlap_headwrap = ItemManager.CreateByName("burlap.headwrap", 1, 807624505);
                Item gloweyes = ItemManager.CreateByName("gloweyes");
                Item tshirt = ItemManager.CreateByName("tshirt", 1, 795997221);
                Item burlap_gloves = ItemManager.CreateByName("burlap.gloves", 1, 1132774091);
                Item burlap_trousers = ItemManager.CreateByName("burlap.trousers", 1, 806966575);
                Item boots = ItemManager.CreateByName("shoes.boots");

                inv_wear.Clear();
                if (burlap_headwrap != null) burlap_headwrap.MoveToContainer(inv_wear);
                if (gloweyes != null) gloweyes.MoveToContainer(inv_wear);
                if (tshirt != null) tshirt.MoveToContainer(inv_wear);
                if (burlap_gloves != null) burlap_gloves.MoveToContainer(inv_wear);
                if (burlap_trousers != null) burlap_trousers.MoveToContainer(inv_wear);
                if (boots != null) boots.MoveToContainer(inv_wear);
        }
    }
}

// --- End of file: ClothedMurderers.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/cupboard-messages ---
// --- Original File Path: C/CupboardMessages/CupboardMessages.cs ---

﻿using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Plugins.CupboardMessagesExt;

namespace Oxide.Plugins
{
    [Info("Cupboard Messages", "Ryan", "1.1.0")]
    [Description("Sends a configured message to a user when they place a tool cupboard")]

    public class CupboardMessages : RustPlugin
    {
        #region Declaration

        public static CupboardMessages Instance;
        private const string Perm = "cupboardmessages.use";
        private bool UseTooltips;
        private readonly Dictionary<ulong, Timer> NoticeTimers = new Dictionary<ulong, Timer>();

        #endregion

        #region Configuration

        protected override void LoadDefaultConfig()
        {
            Config["Use Tooltips"] = UseTooltips = true;
        }

        #endregion

        #region Lang

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Notice.1"] = "Remember to put resources in your cupboard to prevent it decaying!",
                ["Notice.2"] = "This cupboard needs resources in its contents to prevent your base from being removed.",
                ["Notice.3"] = "Your base will removed if you don't put sufficient resources in it's storage!"
            }, this);
        }

        #endregion

        #region Methods

        private void NoticePlayer(BasePlayer player, string notice)
        {
            if (NoticeTimers.ContainsKey(player.userID))
            {
                NoticeTimers[player.userID]?.Destroy();
                player.SendConsoleCommand("gametip.hidegametip");
            }
            player.SendConsoleCommand("gametip.showgametip", notice);
            var noticeTimer = Instance.timer.Once(7.5f, () =>
            {
                if (player.IsConnected)
                    player.SendConsoleCommand("gametip.hidegametip");
            });
            if (!NoticeTimers.ContainsKey(player.userID))
                NoticeTimers.Add(player.userID, noticeTimer);
            else NoticeTimers[player.userID] = noticeTimer;
        }

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(Perm, this);
            Instance = this;
            if(!bool.TryParse(Config["Use Tooltips"].ToString(), out UseTooltips))
                LoadDefaultConfig();
        }

        private void OnEntitySpawned(BaseNetworkable networkable)
        {
            if (!(networkable is BuildingPrivlidge)) return;
            var cupboard = (BuildingPrivlidge) networkable;
            var player = BasePlayer.FindByID(cupboard.OwnerID);
            if (player != null && player.HasPermission(Perm))
            {
                if (UseTooltips)
                {
                    NoticePlayer(player, $"Notice.{UnityEngine.Random.Range(1, 3)}".Lang(player.UserIDString));
                    return;
                }
                PrintToChat(player, $"Notice.{UnityEngine.Random.Range(1, 3)}".Lang(player.UserIDString));
            }
        }

        #endregion
    }
}

namespace Oxide.Plugins.CupboardMessagesExt
{
    public static class Extensions
    {
        private static readonly Permission permission = Interface.Oxide.GetLibrary<Permission>();
        private static readonly Lang lang = Interface.Oxide.GetLibrary<Lang>();

        public static bool HasPermission(this BasePlayer player, string perm) =>
            permission.UserHasPermission(player.UserIDString, perm);

        public static string Lang(this string key, string id = null, params object[] args) =>
            string.Format(lang.GetMessage(key, CupboardMessages.Instance, id), args);
    }
}

// --- End of file: CupboardMessages.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/coroutines ---
// --- Original File Path: C/Coroutines/Coroutines.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Coroutines", "birthdates", "3.0.8")]
    [Description(
        "Allows other plugins to spread out large workloads over time to reduce lag spikes")]
    public class Coroutines : CovalencePlugin
    {
        #region Variables

        private readonly LinkedList<KeyValuePair<string, LinkedList<Coroutine>>> _coroutines =
            new LinkedList<KeyValuePair<string, LinkedList<Coroutine>>>();

        private int _currentCoroutineCount;

        private readonly IDictionary<string, Number> _maxCoroutineCounter = new Dictionary<string, Number>();
        private readonly IDictionary<string, int> _idToMax = new Dictionary<string, int>();

        private readonly LinkedList<Coroutine> _queuedCoroutines = new LinkedList<Coroutine>();
        private readonly Stopwatch _stopwatch = new Stopwatch();
        public static Coroutines Instance { get; private set; }

        #endregion

        #region Classes

        /// <summary>
        ///     The main coroutine class that handles instructions via <see cref="Coroutines.OnFrame" />
        /// </summary>
        public class Coroutine
        {
            public Coroutine(Plugin owner, IEnumerator instructions, Action onComplete, string id = null,
                int cachedMaxInstances = -1)
            {
                Owner = owner;
                OnComplete = onComplete;
                RecursiveInstructions = new LinkedList<IEnumerator>();
                RecursiveInstructions.AddFirst(instructions);
                CurrentInstructions = instructions;
                Id = id;
                CachedMaxInstances = cachedMaxInstances;
            }

            /// <summary>
            ///     The maximum allowed of this instance
            /// </summary>
            public int CachedMaxInstances { get; }

            /// <summary>
            ///     Returns if we should do counter cleanup for <see cref="Coroutines.OnFrame" />
            /// </summary>
            public bool HasCounter => CachedMaxInstances != -1;

            public string Id { get; }

            /// <summary>
            ///     The owner of this coroutine
            /// </summary>
            public Plugin Owner { get; }

            /// <summary>
            ///     The recursive list of instructions
            /// </summary>
            private LinkedList<IEnumerator> RecursiveInstructions { get; }

            /// <summary>
            ///     The current set of instructions
            /// </summary>
            private IEnumerator CurrentInstructions { get; set; }

            /// <summary>
            ///     The current stage/index of <see cref="CurrentInstructions" />
            /// </summary>
            private int CurrentStage { get; set; } = -1;

            /// <summary>
            ///     The current level/index of <see cref="RecursiveInstructions" />
            /// </summary>
            private int CurrentLevel { get; set; }

            /// <summary>
            ///     A bool used to stop ticking
            /// </summary>
            public bool Stop { get; set; }

            /// <summary>
            ///     The callback for when this coroutine is complete
            /// </summary>
            private Action OnComplete { get; }

            /// <summary>
            ///     <para>
            ///         On tick, it checks if the current instruction is completed or null, if so, it continues on to the next
            ///         instruction
            ///     </para>
            ///     <para>
            ///         If there are no more instructions, we will mark this coroutine as finished and to be removed & call
            ///         <see cref="OnComplete" />
            ///     </para>
            /// </summary>
            /// <param name="deltaTime">The current deltaTime</param>
            public void Tick(float deltaTime)
            {
                if (Stop) return;
                if (CurrentInstructions == null) goto finish;
                var currentInstruction = CurrentInstructions.Current;
                var coroutineInstruction = currentInstruction as ICoroutineInstruction;
                if (!coroutineInstruction?.IsCompleted ?? false)
                {
                    coroutineInstruction.Tick(deltaTime);
                    return;
                }

                CurrentStage++;
                try
                {
                    RestartStopWatch(Instance._stopwatch);
                    Owner.TrackStart();
                    var ret = CurrentInstructions.MoveNext();
                    Owner.TrackEnd();
                    if (ret)
                    {
                        CheckStopwatch();
                        CheckForInstructionRecursion();
                        return;
                    }
                }
                catch (Exception exception)
                {
                    Instance.PrintError(
                        "An exception occurred whilst executing coroutine from {0} {1} at stage {2}, level {3}:\n{4}\n{5}",
                        Owner.Name, GetIdOrEmpty(), CurrentStage, CurrentLevel,
                        exception.Message, exception.StackTrace);
                    goto finish;
                }

                CurrentStage = 0;
                CurrentLevel++;
                if (UpdateCurrentInstructions()) return;
                finish:
                Stop = true;
                OnComplete?.Invoke();
            }

            private string GetIdOrEmpty()
            {
                return string.IsNullOrEmpty(Id) ? string.Empty : $"named {Id}";
            }

            /// <summary>
            ///     Check if the current instruction is another list of instructions, if so add it to
            ///     <see cref="RecursiveInstructions" />
            /// </summary>
            private void CheckForInstructionRecursion()
            {
                var enumeratorInstruction = CurrentInstructions.Current as IEnumerator;
                if (enumeratorInstruction == null)
                {
                    var coroutineInstruction = CurrentInstructions.Current as Coroutine;
                    enumeratorInstruction = coroutineInstruction?.CurrentInstructions;
                    if (enumeratorInstruction == null) return;
                }

                RecursiveInstructions.AddLast(enumeratorInstruction);
                CurrentInstructions = enumeratorInstruction;
            }

            /// <summary>
            ///     Check if the execution time of the coroutine is greater than the time specified in the config
            /// </summary>
            private void CheckStopwatch()
            {
                Instance._stopwatch.Stop();
                var elapsed = Instance._stopwatch.ElapsedMilliseconds;
                if (Instance._config.WarnTimeMilliseconds > 0 &&
                    elapsed < Instance._config.WarnTimeMilliseconds) return;
                var stackTrace = Instance._config.PrintStackTraceOnWarn
                    ? $"\n{new Exception().StackTrace}"
                    : string.Empty;
                Instance.PrintWarning("A coroutine from {0} {1} stage {2}, level {3} took {4}ms{5}", Owner.Name,
                    GetIdOrEmpty(),
                    CurrentStage, CurrentLevel, elapsed,
                    stackTrace);
            }

            /// <summary>
            ///     Update the current recursive instructions and set it null if there are none left
            /// </summary>
            /// <returns>True if we have anymore instructions</returns>
            private bool UpdateCurrentInstructions()
            {
                RecursiveInstructions.RemoveLast();
                CurrentInstructions = RecursiveInstructions.Last?.Value;
                return true;
            }
        }

        #region Coroutine Instructions

        /// <summary>
        ///     The class used for coroutine instructions like <see cref="WaitForSeconds" />
        /// </summary>
        public interface ICoroutineInstruction
        {
            /// <summary>
            ///     Returns if this current instruction is complete
            /// </summary>
            bool IsCompleted { get; }

            /// <summary>
            ///     Tick the current instruction
            /// </summary>
            /// <param name="deltaTime">The current delta time (scaled time)</param>
            void Tick(float deltaTime);
        }


        /// <summary>
        ///     A <see cref="ICoroutineInstruction" /> to wait for a certain amount of milliseconds in real or scaled time
        /// </summary>
        public class WaitForMilliseconds : ICoroutineInstruction
        {
            public WaitForMilliseconds(float time) : this(time, !Instance._config.UseScaledTime)
            {
            }

            public WaitForMilliseconds(float time, bool realTime)
            {
                Reset(time, realTime);
            }

            /// <summary>
            ///     Are we using real or delta/scaled time?
            ///     Warning, not all games use delta/scaled time
            /// </summary>
            private bool RealTime { get; set; }

            /// <summary>
            ///     Returns the date time
            /// </summary>
            private static DateTime DateTime => DateTime.UtcNow;

            /// <summary>
            ///     Returns the current time in seconds
            /// </summary>
            private static double Milliseconds => GetMilliseconds(DateTime);

            /// <summary>
            ///     Returns total seconds from <see cref="DateTime" />
            /// </summary>
            private static Func<DateTime, double> GetMilliseconds => dateTime => dateTime.TimeOfDay.TotalMilliseconds;

            /// <summary>
            ///     Returns the time until this instruction expires (completes)
            /// </summary>
            private double ExpiryTime { get; set; }

            /// <summary>
            ///     The seconds given
            /// </summary>
            protected float Time { get; private set; }

            /// <summary>
            ///     Returns <see langword="true" /> if <see cref="ExpiryTime" /> has expired
            /// </summary>
            public bool IsCompleted => RealTime ? ExpiryTime <= Milliseconds : ExpiryTime <= 0f;

            /// <summary>
            ///     Remove <see cref="deltaTime" /> as milliseconds from <see cref="Time" />
            /// </summary>
            /// <param name="deltaTime">Current delta time (scaled time)</param>
            public void Tick(float deltaTime)
            {
                if (RealTime) return;
                ExpiryTime -= SecondsToMilliseconds(deltaTime);
            }

            /// <summary>
            ///     Set <see cref="Time" /> if given a time and reset expiry time
            /// </summary>
            public void Reset(float time = -1f)
            {
                Reset(time, !Instance._config.UseScaledTime);
            }

            public void Reset(float time, bool realTime)
            {
                RealTime = realTime;
                if (time > 0f) Time = time;
                ExpiryTime = realTime ? GetMilliseconds.Invoke(DateTime.AddMilliseconds(Time)) : time;
            }
        }

        /// <summary>
        ///     A <see cref="ICoroutineInstruction" /> to wait for a certain amount of seconds in real or scaled time
        /// </summary>
        public class WaitForSeconds : WaitForMilliseconds
        {
            public WaitForSeconds(float time) : this(time, !Instance._config.UseScaledTime)
            {
            }

            public WaitForSeconds(float time, bool realTime) : base(SecondsToMilliseconds(time), realTime)
            {
            }

            public new void Reset(float time = -1f)
            {
                Reset(time, !Instance._config.UseScaledTime);
            }

            public new void Reset(float time, bool realTime)
            {
                base.Reset(time > 0f ? SecondsToMilliseconds(time) : Time, realTime);
            }
        }


        /// <summary>
        ///     A <see cref="ICoroutineInstruction" /> to wait for a given boolean
        /// </summary>
        public class WaitForBool : ICoroutineInstruction
        {
            public WaitForBool(Func<bool> predicate)
            {
                Predicate = predicate;
            }

            /// <summary>
            ///     The boolean we are waiting for
            /// </summary>
            private Func<bool> Predicate { get; }

            /// <summary>
            ///     Returns if <see cref="Predicate" /> is true
            /// </summary>
            public bool IsCompleted => Predicate.Invoke();

            public void Tick(float deltaTime)
            {
            }
        }

        #endregion

        #endregion

        #region Hooks

        /// <summary>
        ///     On initialized, set instance
        /// </summary>
        private void Init()
        {
            Instance = this;
        }

        /// <summary>
        ///     On unload, unset instance
        /// </summary>
        private void Unload()
        {
            Instance = null;
        }

        /// <summary>
        ///     Tick all of the active coroutines and cleanup any of them that are done
        /// </summary>
        /// <param name="deltaTime">The current delta/scaled time</param>
        private void OnFrame(float deltaTime = 0f)
        {
            if (_currentCoroutineCount == 0) return;
            TrackEnd(); //end track on coroutine ticks
            var currentPluginNode = _coroutines.First;
            while (currentPluginNode != null)
            {
                var entry = currentPluginNode.Value;
                var currentCoroutineNode = entry.Value.First;
                while (currentCoroutineNode != null)
                {
                    var coroutine = currentCoroutineNode.Value;
                    coroutine.Tick(deltaTime);
                    if (!coroutine.Stop) goto end;
                    if (coroutine.HasCounter)
                    {
                        Number counter;
                        if (_maxCoroutineCounter.TryGetValue(coroutine.Id, out counter) &&
                            (counter.Value += 1) >= counter.Max)
                            _maxCoroutineCounter.Remove(coroutine.Id);
                    }

                    _currentCoroutineCount--;
                    entry.Value.Remove(currentCoroutineNode);
                    end:
                    currentCoroutineNode = currentCoroutineNode.Next;
                }

                if (entry.Value.Count <= 0) _coroutines.Remove(currentPluginNode);
                currentPluginNode = currentPluginNode.Next;
            }

            TrackStart(); //continue track on cleanup
            if (!_config.CheckQueueOnFrame) return;
            CheckQueue();
        }

        /// <summary>
        ///     On unload of a plugin, stop all of it's coroutines
        /// </summary>
        /// <param name="plugin">Target plugin (owner)</param>
        private void OnPluginUnloaded(Plugin plugin)
        {
            StopCoroutines(plugin);
        }

        #endregion

        #region Hook Methods

        /// <summary>
        ///     Register a maximum amount of instances of an id
        /// </summary>
        /// <param name="id">Target id</param>
        /// <param name="max">Target maximum</param>
        [HookMethod("RegisterMax")]
        public void RegisterMax(string id, int max)
        {
            _idToMax[id] = max;
        }

        /// <summary>
        ///     Unregister a previously set maximum of instances from <see cref="RegisterMax" />
        /// </summary>
        /// <param name="id">Target id</param>
        /// <returns><see langword="true" /> if an item was removed from <see cref="_idToMax" /></returns>
        [HookMethod("UnregisterMax")]
        public bool UnregisterMax(string id)
        {
            return _idToMax.Remove(id);
        }

        /// <summary>
        ///     Start an asynchronous task that isn't repeated
        /// </summary>
        /// <param name="owner">Owner</param>
        /// <param name="task">The task to complete</param>
        /// <param name="initialDelay">Any initial delay</param>
        /// <param name="id">Id for this coroutine</param>
        /// <param name="onComplete">Callback for when the task is completed</param>
        /// <returns>A <see cref="Coroutine" /> to run</returns>
        [HookMethod("GetDelayedTask")]
        public Coroutine GetDelayedTask(Plugin owner, Action task, float initialDelay = 0f, string id = null,
            Action onComplete = null)
        {
            return CreateCoroutine(owner, GetInitialDelayCoroutine(initialDelay, task), id, onComplete);
        }

        /// <summary>
        ///     The same as <see cref="StartDelayedTask" /> but it repeats
        /// </summary>
        /// <param name="owner">Owner</param>
        /// <param name="continuePredicate">Predicate to keep repeating</param>
        /// <param name="interval">Interval between each repetition</param>
        /// <param name="initialDelay">Any initial delay</param>
        /// <param name="id">Id of this coroutine</param>
        /// <param name="onComplete">Callback when <see cref="continuePredicate" /> returns false (task is complete)</param>
        /// <returns>A <see cref="Coroutine" /> to run</returns>
        [HookMethod("GetAsynchronousRepeatingTask")]
        public Coroutine GetAsynchronousRepeatingTask(Plugin owner, Func<bool> continuePredicate, float interval,
            float initialDelay = 0f, string id = null, Action onComplete = null)
        {
            return CreateCoroutine(owner, GetRepeatingCoroutine(
                continuePredicate, interval, initialDelay), id, onComplete);
        }

        /// <summary>
        ///     Asynchronously loop through list (this loops through the whole list no stopping)
        /// </summary>
        /// <param name="owner">Owner</param>
        /// <param name="callback">The callback for each item in the list</param>
        /// <param name="list">Target list</param>
        /// <param name="interval">Interval between each repetition</param>
        /// <param name="startIndex">The index in the list to start at</param>
        /// <param name="reverse">If it just should loop in reverse</param>
        /// <param name="completePerTick">How many loops to complete each tick</param>
        /// <param name="initialDelay">Any initial delay</param>
        /// <param name="id">Id of this coroutine</param>
        /// <param name="onComplete">Callback when list is done looping</param>
        /// <typeparam name="T">Type parameter of <see cref="list" /></typeparam>
        /// <returns>A <see cref="Coroutine" /> to run</returns>
        public Coroutine LoopListAsynchronously<T>(Plugin owner, Action<T> callback, IList<T> list,
            float interval, int startIndex = -1, bool reverse = false, int completePerTick = 1, float initialDelay = 0f,
            string id = null, Action onComplete = null)
        {
            if (list.Count != 0)
                return LoopListAsynchronously(owner, obj =>
                {
                    callback.Invoke(obj);
                    return true;
                }, list, interval, startIndex, reverse, completePerTick, initialDelay, id, onComplete);
            onComplete?.Invoke();
            return null;
        }

        /// <summary>
        ///     Asynchronously loop through list
        /// </summary>
        /// <param name="owner">Owner</param>
        /// <param name="callback">The callback for each item in the list (return false to stop looping)</param>
        /// <param name="list">Target list</param>
        /// <param name="interval">Interval between each repetition</param>
        /// <param name="startIndex">The index in the list to start at</param>
        /// <param name="reverse">If it just should loop in reverse</param>
        /// <param name="completePerTick">How many loops to complete each tick</param>
        /// <param name="initialDelay">Any initial delay</param>
        /// <param name="id">Id of this coroutine</param>
        /// <param name="onComplete">Callback when list is done looping</param>
        /// <typeparam name="T">Type parameter of <see cref="list" /></typeparam>
        /// <returns>A <see cref="Coroutine" /> to run</returns>
        public Coroutine LoopListAsynchronously<T>(Plugin owner, Func<T, bool> callback, IList<T> list,
            float interval, int startIndex = -1, bool reverse = false, int completePerTick = 1,
            float initialDelay = 0f, string id = null, Action onComplete = null)
        {
            var index = startIndex == -1 ? reverse ? list.Count - 1 : 0 : startIndex;
            if (reverse && completePerTick > 0) completePerTick = -completePerTick;
            var increment = reverse ? -1 : 1;
            return GetAsynchronousRepeatingTask(owner, () =>
            {
                var max = index + completePerTick;
                for (var i = index; reverse ? i >= 0 : i < max && i < list.Count; i += increment)
                {
                    var obj = list[i];
                    if (callback.Invoke(obj)) continue;
                    return false;
                }

                index = max;
                return reverse ? index > 0 : index < list.Count;
            }, interval, initialDelay, id, onComplete);
        }

        /// <summary>
        ///     Asynchronously search through a list (check if value is in list)
        /// </summary>
        /// <param name="owner">Owner</param>
        /// <param name="target">Target value</param>
        /// <param name="callback">Callback on complete</param>
        /// <param name="list">Target list</param>
        /// <param name="interval">Interval between loop</param>
        /// <param name="startIndex">The index in the list to start at</param>
        /// <param name="reverse">If it just should loop in reverse</param>
        /// <param name="completePerTick">How many loops to complete each tick</param>
        /// <param name="initialDelay">Any initial delay</param>
        /// <param name="id">Id of this coroutine</param>
        /// <typeparam name="T">Type parameter of <see cref="list" /></typeparam>
        /// <returns>A <see cref="Coroutine" /> to run</returns>
        public Coroutine SearchListAsynchronously<T>(Plugin owner, T target, Action<bool> callback, IList<T> list,
            float interval, int startIndex = -1, bool reverse = false, int completePerTick = 1, float initialDelay = 0f,
            string id = null)
        {
            var found = false;
            return LoopListAsynchronously(owner, obj =>
            {
                if (!obj.Equals(target)) return true;
                found = true;
                callback.Invoke(true);
                return false;
            }, list, interval, startIndex, reverse, completePerTick, initialDelay, id, () =>
            {
                if (found) return;
                callback.Invoke(false);
            });
        }

        /// <summary>
        ///     Asynchronously find a value from it's corresponding key in a <see cref="IDictionary{TKey,TValue}" />
        /// </summary>
        /// <param name="owner">Owner</param>
        /// <param name="target">Target key (Key -> Value)</param>
        /// <param name="callback">Callback with value</param>
        /// <param name="dictionary">Target dictionary</param>
        /// <param name="interval">Interval between loop</param>
        /// <param name="completePerTick">How many loops to complete each tick</param>
        /// <param name="initialDelay">Any initial delay</param>
        /// <param name="id">Id of this coroutine</param>
        /// <typeparam name="TK">Key type</typeparam>
        /// <typeparam name="TV">Value type</typeparam>
        /// <returns>A <see cref="Coroutine" /> to run</returns>
        public Coroutine SearchDictionaryAsynchronously<TK, TV>(Plugin owner, TK target, Action<TV> callback,
            IDictionary<TK, TV> dictionary, float interval, int completePerTick = 1, float initialDelay = 0f,
            string id = null)
        {
            if (dictionary.Count != 0)
                return SearchAsynchronously(owner, target, dictionary, item => item.Count,
                    (index, item) => index < item.Count,
                    (index, givenTarget, item) =>
                    {
                        var element = item.ElementAt(index);
                        return !element.Key?.Equals(target) ?? false ? default(TV) : element.Value;
                    }, callback, interval, completePerTick, initialDelay, id);
            callback.Invoke(default(TV));
            return null;
        }

        /// <summary>
        ///     Method to be implemented (searching)
        /// </summary>
        /// <param name="owner">Owner</param>
        /// <param name="target">Target item</param>
        /// <param name="item">Object to search in</param>
        /// <param name="getSize">Get size method</param>
        /// <param name="keepSearchGoing">Keep search going method</param>
        /// <param name="handleSearchIndex">Handle search method</param>
        /// <param name="callback">Callback with found object</param>
        /// <param name="interval">Interval between each repetition</param>
        /// <param name="completePerTick">How many loops to complete each tick</param>
        /// <param name="initialDelay">Any initial delay</param>
        /// <param name="id">Id of this coroutine</param>
        /// <typeparam name="T">Type to search in</typeparam>
        /// <typeparam name="TK">Type of <see cref="target" /></typeparam>
        /// <typeparam name="TV">Type of <see cref="handleSearchIndex" /> return</typeparam>
        /// <returns>A <see cref="Coroutine" /> to run</returns>
        public Coroutine SearchAsynchronously<T, TK, TV>(Plugin owner, TK target, T item, Func<T, int> getSize,
            Func<int, T, bool> keepSearchGoing, Func<int, TK, T, TV> handleSearchIndex, Action<TV> callback,
            float interval,
            int completePerTick = 1, float initialDelay = 0f, string id = null)
        {
            var found = false;
            var index = 0;
            return GetAsynchronousRepeatingTask(owner, () =>
            {
                var max = index + completePerTick;
                for (var i = index; i < max && i < getSize.Invoke(item); i++)
                {
                    var value = handleSearchIndex.Invoke(i, target, item);
                    if (value == null) continue;
                    found = true;
                    callback.Invoke(value);
                    return false;
                }

                index = max;
                return keepSearchGoing.Invoke(index, item);
            }, interval, initialDelay, id, () =>
            {
                if (found) return;
                callback.Invoke(default(TV));
            });
        }

        /// <summary>
        ///     Find a player from the server asynchronously
        /// </summary>
        /// <param name="owner">Owner plugin</param>
        /// <param name="data">Data about the player (name/id)</param>
        /// <param name="callback">Callback with player or <see langword="null" /></param>
        /// <param name="includeName">Should we check for name?</param>
        /// <param name="ignoreCase">Should we check name ignore case?</param>
        /// <param name="interval">Interval between each repetition</param>
        /// <param name="completePerTick">How many loops to complete each tick</param>
        /// <param name="initialDelay">Any initial delay</param>
        /// <param name="reverse">Start in reverse?</param>
        /// <param name="startIndex">Start index</param>
        /// <param name="id">Id of this coroutine</param>
        /// <typeparam name="T"></typeparam>
        private void FindPlayerAsynchronously<T>(Plugin owner, string data, Action<T> callback, bool includeName = true,
            bool ignoreCase = false, float interval = 0.01f, int completePerTick = 15, float initialDelay = 0f,
            bool reverse = false, int startIndex = -1, string id = null) where T : class, IPlayer
        {
            var list = players.Connected.ToList();
            if (list.Count == 0)
            {
                callback(null);
                return;
            }

            var found = false;
            LoopListAsynchronously(owner, player =>
                {
                    if (!player.Id.Equals(data) && (!includeName || !player.Name.Equals(data,
                        ignoreCase ? StringComparison.InvariantCultureIgnoreCase : StringComparison.Ordinal)))
                        return false;
                    callback(player as T);
                    found = true;
                    return true;
                }, list, interval, startIndex, reverse, completePerTick,
                initialDelay, id,
                () =>
                {
                    if (found) return;
                    callback(null);
                });
        }

        /// <summary>
        ///     Get a <see cref="IEnumerable{T}"/> of coroutines with that id
        /// </summary>
        /// <param name="id">Target id</param>
        /// <returns><see cref="IEnumerable{T}"/> of coroutines</returns>
        private IEnumerable<Coroutine> GetCoroutinesById(string id)
        {
            return GetAllCoroutines()
                .Select(coroutines =>
                    coroutines.FirstOrDefault(coroutine => Equals(coroutine.Id, id)))
                .DefaultIfEmpty();
        }

        /// <summary>
        ///     Check if a coroutine is running
        /// </summary>
        /// <param name="id">Coroutine id</param>
        /// <returns><see langword="true" /> if coroutine is running</returns>
        public bool IsCoroutineRunning(string id)
        {
            var coroutine = GetCoroutinesById(id).FirstOrDefault();
            return coroutine != null && !coroutine.Stop;
        }
        
        /// <summary>
        ///     Stop a coroutine with a given id
        /// </summary>
        /// <param name="id">Given id</param>
        /// <returns>If a coroutine was stopped</returns>
        [HookMethod("StopCoroutine")]
        public bool StopCoroutine(string id)
        {
            return GetCoroutinesById(id)
                .All(StopCoroutine);
        }

        /// <summary>
        ///     Stop coroutines started by <see cref="owner" />
        /// </summary>
        /// <param name="owner">Target plugin</param>
        [HookMethod("StopCoroutines")]
        private void StopCoroutines(Plugin owner)
        {
            LinkedList<Coroutine> coroutines;
            if (!TryGetCoroutines(owner.Name, out coroutines)) return;
            StopCoroutines(coroutines);
        }

        #endregion

        #region Coroutines

        /// <summary>
        ///     Start checking the queue from <see cref="_queuedCoroutines" />
        /// </summary>
        private void StartCheckingQueue()
        {
            if (_config.CheckQueueOnFrame || _queuedCoroutines.Count == 0) return;
            timer.In(_config.QueueCheckTime, () =>
            {
                CheckQueue();
                StartCheckingQueue();
            });
        }

        /// <summary>
        ///     Check if we should remove any coroutines from the queue
        /// </summary>
        private void CheckQueue()
        {
            var count = _currentCoroutineCount;
            if (!CanTakeCoroutine(count)) return;
            var allowed = Math.Min(_config.MaxRoutines - count, _queuedCoroutines.Count - 1);
            RemoveFromQueue(allowed);
        }

        /// <summary>
        ///     Remove <see cref="Coroutine" /> from the queue & run it
        /// </summary>
        /// <param name="allowed">Amount of <see cref="Coroutine" /> to run</param>
        private void RemoveFromQueue(int allowed)
        {
            var currentNode = _queuedCoroutines.First;
            var i = -1;
            while (currentNode != null && i < allowed)
            {
                var coroutine = currentNode.Value;
                if (coroutine.HasCounter && !CanTakeCoroutine(coroutine.Id, coroutine.CachedMaxInstances)) goto end;

                i++;
                ForcefullyAddCoroutine(coroutine);
                _queuedCoroutines.Remove(currentNode);
                end:
                currentNode = currentNode.Next;
            }
        }

        /// <summary>
        ///     Are there too many coroutines?
        /// </summary>
        /// <param name="count">Current number (if applicable)</param>
        /// <returns>If we can add another coroutine</returns>
        private bool CanTakeCoroutine(int count = -1)
        {
            if (count == -1) count = _currentCoroutineCount;
            return count < _config.MaxRoutines;
        }

        /// <summary>
        ///     Return the corresponding maximum from <see cref="_idToMax" />
        /// </summary>
        /// <param name="id">Target id</param>
        /// <returns>The instance maximum if applicable</returns>
        private int GetMaximumInstances(string id)
        {
            int max;
            return !string.IsNullOrEmpty(id) && _idToMax.TryGetValue(id, out max) ? max : -1;
        }

        /// <summary>
        ///     Create a <see cref="Coroutine" />
        /// </summary>
        /// <param name="owner">Owner</param>
        /// <param name="enumerator">The instructions (leave null to create instructions</param>
        /// <param name="id">Id of this coroutine</param>
        /// <param name="onComplete">Callback when the task completes</param>
        /// <returns>A <see cref="Coroutine" /> to run</returns>
        [HookMethod("CreateCoroutine")]
        private Coroutine CreateCoroutine(Plugin owner, IEnumerator enumerator = null, string id = null,
            Action onComplete = null)
        {
            var instructions = enumerator;
            var max = GetMaximumInstances(id);
            var routine = new Coroutine(owner, instructions, onComplete, id, max);
            return routine;
        }

        /// <summary>
        ///     Start a <see cref="Coroutine" />
        /// </summary>
        /// <param name="coroutine">Target coroutine</param>
        /// <returns>
        ///     <see langword="true" /> if the coroutine was stored & <see langword="false" /> if the coroutine is
        ///     <see langword="null" /> or it was queued
        /// </returns>
        public bool StartCoroutine(Coroutine coroutine)
        {
            if (coroutine == null) return false; //just in case you don't check it
            if (!CanTakeCoroutine() || !CanTakeCoroutine(coroutine.Id, coroutine.CachedMaxInstances))
            {
                if (_queuedCoroutines.AddLast(coroutine).Previous == null) StartCheckingQueue(); //if we're the first element
                return false;
            }

            ForcefullyAddCoroutine(coroutine);
            return true;
        }

        /// <summary>
        ///     Are there too many coroutines with the id of <see cref="id" /> (max being <see cref="max" />)
        /// </summary>
        /// <param name="id">Target id</param>
        /// <param name="max">Target maximum</param>
        /// <returns>
        ///     <see langword="true" /> if the amount of active coroutines with the id <see cref="id" /> is less than
        ///     <see cref="max" />
        /// </returns>
        private bool CanTakeCoroutine(string id, int max)
        {
            if (max == -1 || string.IsNullOrEmpty(id)) return true;

            Number count;
            var check = false;
            if (!_maxCoroutineCounter.TryGetValue(id, out count))
            {
                _maxCoroutineCounter[id] = count = new Number(max);
                check = true;
            }

            var newValue = count.Value - 1;
            var ret = newValue > 0;
            if ((newValue == 0 || ret) && !check) count.Value = newValue;
            return ret;
        }

        /// <summary>
        ///     Forcefully add a coroutine
        /// </summary>
        /// <param name="coroutine">Target coroutine</param>
        private void ForcefullyAddCoroutine(Coroutine coroutine)
        {
            var ownerName = coroutine.Owner.Name;
            LinkedList<Coroutine> coroutines;
            if (!TryGetCoroutines(ownerName, out coroutines))
            {
                _coroutines.AddLast(new KeyValuePair<string, LinkedList<Coroutine>>(ownerName,
                    coroutines = new LinkedList<Coroutine>()));
                _currentCoroutineCount++;
            }

            coroutines.AddLast(coroutine);
        }

        /// <summary>
        ///     Stop a <see cref="IEnumerable{T}" /> of coroutines
        /// </summary>
        /// <param name="coroutines"><see cref="IEnumerable{T}" /> of coroutines</param>
        private static void StopCoroutines(IEnumerable<Coroutine> coroutines)
        {
            foreach (var coroutine in coroutines) StopCoroutine(coroutine);
        }

        /// <summary>
        ///     Stop an individual coroutine
        /// </summary>
        /// <param name="coroutine">Target coroutine</param>
        private static bool StopCoroutine(Coroutine coroutine)
        {
            if (coroutine == null) return false;
            return coroutine.Stop = true;
        }

        /// <summary>
        ///     Returns coroutine instructions that wait an initial delay before completing a task
        /// </summary>
        /// <param name="initialDelay">Time to wait</param>
        /// <param name="task">Task to complete</param>
        /// <param name="waitForSeconds">The initial wait object if it exists</param>
        /// <returns></returns>
        private static IEnumerator GetInitialDelayCoroutine(float initialDelay = 0f, Action task = null,
            WaitForSeconds waitForSeconds = null)
        {
            waitForSeconds = waitForSeconds ?? new WaitForSeconds(initialDelay);
            yield return waitForSeconds;
            task?.Invoke();
        }

        /// <summary>
        ///     Get the coroutine to start it
        /// </summary>
        /// <param name="continuePredicate">Returns if the task should keep repeating</param>
        /// <param name="interval">Interval between repetitions</param>
        /// <param name="initialDelay">Any initial delay</param>
        /// <returns>A <see cref="IEnumerator" /> for a coroutine</returns>
        private static IEnumerator GetRepeatingCoroutine(Func<bool> continuePredicate,
            float interval,
            float initialDelay = 0f)
        {
            var hasInitial = initialDelay > 0f;
            var wait = new WaitForSeconds(hasInitial ? initialDelay : interval);
            if (hasInitial)
            {
                yield return GetInitialDelayCoroutine(waitForSeconds: wait);
                wait.Reset(interval);
            }

            while (continuePredicate.Invoke())
            {
                yield return wait;
                wait.Reset();
            }
        }

        #endregion

        #region Helpers

        /// <summary>
        ///     Get a list of all the coroutines
        /// </summary>
        /// <returns>All coroutines</returns>
        private IEnumerable<LinkedList<Coroutine>> GetAllCoroutines()
        {
            return _coroutines.Select(entry => entry.Value);
        }

        /// <summary>
        ///     Finds the corresponding <see cref="coroutines" /> from <see cref="owner" />
        /// </summary>
        /// <param name="owner">Target owner</param>
        /// <param name="coroutines">Output coroutines</param>
        /// <returns>If we found coroutines</returns>
        private bool TryGetCoroutines(string owner, out LinkedList<Coroutine> coroutines)
        {
            foreach (var entry in _coroutines.Where(entry => entry.Key.Equals(owner)))
            {
                coroutines = entry.Value;
                return true;
            }

            coroutines = null;
            return false;
        }

        /// <summary>
        ///     Restart a stopwatch (a feature in modern .NET)
        /// </summary>
        /// <param name="stopwatch">Target stopwatch</param>
        private static void RestartStopWatch(Stopwatch stopwatch)
        {
            stopwatch.Reset();
            stopwatch.Start();
        }

        /// <summary>
        ///     Change <see cref="time" /> to milliseconds
        /// </summary>
        /// <param name="time">Time in seconds</param>
        /// <returns><see cref="time" /> as milliseconds</returns>
        private static float SecondsToMilliseconds(float time)
        {
            return time * 1000f;
        }

        private class Number
        {
            public Number(int value)
            {
                Value = value;
                Max = value;
            }

            public int Max { get; }
            public int Value { get; set; }
        }

        #endregion

        #region Configuration

        private ConfigFile _config;

        private class ConfigFile
        {
            [JsonProperty("Max Routines (others will be stacked up in a queue)")]
            public int MaxRoutines { get; set; }

            [JsonProperty("Queue Check Time (Seconds)")]
            public float QueueCheckTime { get; set; }

            [JsonProperty("Check Queue on Frame?")]
            public bool CheckQueueOnFrame { get; set; }

            [JsonProperty("Execution Warn Time (Milliseconds)")]
            public long WarnTimeMilliseconds { get; set; }

            [JsonProperty("Print Stacktrace on Warn?")]
            public bool PrintStackTraceOnWarn { get; set; }

            [JsonProperty("Use scaled time for time calculations?")]
            public bool UseScaledTime { get; set; }

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    MaxRoutines = 100,
                    QueueCheckTime = 1f,
                    WarnTimeMilliseconds = 150,
                    PrintStackTraceOnWarn = false,
                    CheckQueueOnFrame = false,
                    UseScaledTime = true
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if (_config == null) LoadDefaultConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        #endregion
    }
}

// --- End of file: Coroutines.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/custom-craft-times ---
// --- Original File Path: C/CustomCraftTimes/CustomCraftTimes.cs ---

using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Custom Craft Times", "Camoec", "1.1.1")]
    [Description("Allows you to change the crafting times")]

    public class CustomCraftTimes : RustPlugin
    {
        private const string UsePerm = "CustomCraftTimes.use";

        Dictionary<int, BPItem> _restore = new Dictionary<int, BPItem>();
        private PluginConfig _config;

        private class BPItem
        {
            public string shortname;
            public float time;
        }        
        private class PluginConfig
        {
            public Dictionary<int,BPItem> itemdefinitions = new Dictionary<int, BPItem>();
        }

        private void Init()
        {
            permission.RegisterPermission(UsePerm, this);
        }

        protected override void SaveConfig() => Config.WriteObject(_config, true);
        private void _LoadDefaultConfig()
        {
            Puts("Creating new config file");
            _config = new PluginConfig();
            foreach(var bp in ItemManager.bpList)
            {
                _config.itemdefinitions.Add(bp.targetItem.itemid,new BPItem()
                {
                    shortname = bp.targetItem.shortname,
                    time = bp.time
                });
            }
            SaveConfig();
        }
        private void _LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<PluginConfig>();

                if (_config == null)
                    throw new Exception();

                SaveConfig(); // override posible obsolet / outdated config
            }
            catch (Exception)
            {
                PrintError("Loaded default config");

                _LoadDefaultConfig();
            }
            
        }

        [ConsoleCommand("cct")]
        void GlobalSetup(ConsoleSystem.Arg arg)
        {
            if (arg == null && !arg.IsRcon && (arg.Player() != null && !permission.UserHasPermission(arg.Player().UserIDString, UsePerm)))
                return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                arg.ReplyWith("Use cct [category] [multiplier]");
                return;
            }

            ItemCategory category = 0;
            float mult = 0;

            if(!float.TryParse(arg.Args[1], out mult))
            {
                arg.ReplyWith("Invalid multiplier!");
            }

            if ((arg.Args[0].ToLower() != "all" && !Enum.TryParse<ItemCategory>(arg.Args[0], out category)))
            {
                string availables = "";
                foreach(var e in Enum.GetValues(typeof(ItemCategory)))
                {
                    availables += $"{e} ";
                }
                arg.ReplyWith($"Invalid Category, try with: {availables}");
                return;
            }

            int affected = 0;
            foreach(var bp in _restore)
            {
                var itemDef = ItemManager.FindItemDefinition(bp.Key);
                if(itemDef.category == category || arg.Args[0].ToLower() == "all")
                {
                    _config.itemdefinitions[bp.Key].time = bp.Value.time * mult;
                    affected++;
                }
            }
            SaveConfig();


            arg.ReplyWith($"{affected} affected items, use 'oxide.reload CustomCraftTimes' to reload times");
        }

        void OnServerInitialized(bool initial)
        {
            _LoadConfig();
            Puts("Loading new times");
            
            foreach (var bp in ItemManager.bpList)
            {
                _restore.Add(bp.targetItem.itemid, new BPItem() { time = bp.time, shortname = bp.name });
                if (_config.itemdefinitions.ContainsKey(bp.targetItem.itemid))
                {
                    bp.time = _config.itemdefinitions[bp.targetItem.itemid].time;
                }
            }
        }

        void Unload()
        {
            if (ItemManager.bpList == null)
                return;
            foreach (var bp in ItemManager.bpList)
            {
                bp.time = _restore[bp.targetItem.itemid].time;
            }
        }
    }
}

// --- End of file: CustomCraftTimes.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/sa-combat-log-info ---
// --- Original File Path: C/CombatLogInfo/CombatLogInfo.cs ---

using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("CombatLog Info", "Pho3niX90", "1.0.13")]
    [Description("Collects combat log entries, and submits them to SA for analysis.")]
    class CombatLogInfo : RustPlugin
    {
        const bool debug = false;
        [PluginReference] Plugin ServerArmour;

        List<int> usedHashes = new List<int>();

        // Simple stats
        DateTime logsSince = DateTime.Now;
        int totalLogs = 0;
        int totalLogsUploaded = 0;
        int pendingGeneration = 0;
        int failedUploads = 0;
        //

        void OnServerInitialized(bool first)
        {
            Server.Command("server.combatlogsize 45");
        }

        void OnServerSave()
        {
            this.cleanupHashes();
        }

        #region log generation

        private void GenCombatLog(BasePlayer forPlayer)
        {
            if (forPlayer.IsNpc || !forPlayer.userID.IsSteamId())
                return;

            var pInfo = new PInfo { Name = forPlayer.displayName, SteamId = forPlayer.UserIDString };
            var cLog = CombatLog.Get(forPlayer.userID);

            pendingGeneration++;

            timer.Once(ConVar.Server.combatlogdelay + 1, () =>
            {
                AddEntries(forPlayer, cLog);
            });
        }
        #endregion

        #region commands
        [ConsoleCommand("clog.stats")]
        void printStats(ConsoleSystem.Arg arg)
        {
            arg.ReplyWith($"Stats since {logsSince}\n\nTotal Logs: {totalLogs}\nTotal Logs Uploaded: {totalLogsUploaded}\nFailed Logs Upload: {failedUploads}\nPending Log Generation: {pendingGeneration}");
        }

        [ConsoleCommand("combatlog")]
        void printCombatLog(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (!player)
                return;

            TextTable textTable = new TextTable();

            if (config.advancedLogs)
                textTable.AddColumns("time", "attacker", "id", "target", "id", "weapon", "ammo", "area", "distance", "old_hp", "new_hp", "info", "desync");
            else
                textTable.AddColumns("time", "attacker", "target", "weapon", "ammo", "area", "distance", "old_hp", "new_hp", "info", "desync");

            foreach (CombatLog.Event evt in CombatLog.Get(player.userID))
            {
                var entry = CLogEntry.from(player, evt);
                if (entry != null)
                {
                    if (config.advancedLogs)
                    {
                        textTable.AddRow((Time.realtimeSinceStartup - entry.EventTime).ToString("0.0s"),
                        GetUsername(player, entry.AttackerSteamId), entry.AttackerSteamId,
                        GetUsername(player, entry.TargetSteamId), entry.TargetSteamId,
                        entry.Weapon, entry.Ammo,
                        entry.Area, entry.Distance.ToString("0.0m"),
                        entry.HealthOld.ToString("0.0"), entry.HealthNew.ToString("0.0"), entry.EventInfo, entry.Desync.ToString());
                    }
                    else
                    {
                        textTable.AddRow((Time.realtimeSinceStartup - entry.EventTime).ToString("0.0s"),
                        entry.AttackerSteamId,
                        entry.TargetSteamId,
                        entry.Weapon, entry.Ammo,
                        entry.Area, entry.Distance.ToString("0.0m"),
                        entry.HealthOld.ToString("0.0"), entry.HealthNew.ToString("0.0"), entry.EventInfo, entry.Desync.ToString());
                    }
                }
            }
            player.ConsoleMessage("---------- COMBATLOG  ----------\n");
            player.ConsoleMessage(textTable.ToString());
        }

        string GetUsername(BasePlayer player, string id)
        {
            if (id == player.UserIDString || id == player.net.ID.Value.ToString())
                return "you";

            BasePlayer fp = null;

            try
            {
                fp = BasePlayer.allPlayerList.FirstOrDefault(x => x.UserIDString == id || x.net.ID.Value.ToString() == id);
            }
            catch (Exception e) { }

            return fp?.displayName ?? "N/A";

        }
        #endregion

        #region hooks
        void processingTask()
        {
            var task = Task.Run(() => { });
        }

        object OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            var initiator = info?.InitiatorPlayer;
            if (initiator != null && initiator.userID.IsSteamId())
            {
                GenCombatLog(initiator ?? player);
            }
            else
            {
                GenCombatLog(player);
            }
            return null;
        }

        private void UploadLogs(Dictionary<int, CLogEntry> logs)
        {
            pendingGeneration--;
            totalLogs += logs.Count;

            if (logs.Count > 0)
            {

                if (ServerArmour == null || !ServerArmour.IsLoaded)
                {
                    // LogDebug("ServerArmour plugin is not loaded. Cannot upload logs.");
                    failedUploads += logs.Count;
                    return;
                }

                try
                {
                    // LogDebug($"Requested upload of {logs.Count} entries");
                    ServerArmour.Call("UploadCombatEntries", JsonConvert.SerializeObject(logs.Values));
                    totalLogsUploaded += logs.Count;
                }
                catch (Exception ex)
                {
                    // LogDebug($"Exception during log upload: {ex}");
                    failedUploads += logs.Count;
                }
            }
            else
                LogDebug($"Nothing to upload");
        }

        #endregion

        #region helpers
        private void AddEntries(BasePlayer forPlayer, Queue<CombatLog.Event> cLog)
        {
            Dictionary<int, CLogEntry> logEntries = new Dictionary<int, CLogEntry>();
            foreach (CombatLog.Event evt in cLog)
            {
                var hash = evt.GetHashCode();
                if (!logEntries.ContainsKey(hash) && !usedHashes.Contains(hash))
                {
                    var entry = CreateEntry(forPlayer, evt);
                    if (entry != null)
                    {
                        usedHashes.Add(hash);
                        logEntries.Add(hash, entry);
                    }
                }
            }
            UploadLogs(logEntries);
            logEntries.Clear();
        }

        void cleanupHashes()
        {
            // Check if usedHashes exceeds 100000 entries, then cleanup
            if (usedHashes.Count > 100000)
            {
                // Take the most recent 1000 entries and add a new one
                usedHashes = usedHashes.Skip(usedHashes.Count - 1000).ToList();
            }
        }

        private CLogEntry CreateEntry(BasePlayer forPlayer, CombatLog.Event evt)
        {
            if ((forPlayer is NPCPlayer || forPlayer.IsNpc || !forPlayer.userID.IsSteamId()) && !evt.target_id.IsSteamId())
            {
                // LogDebug($"Event = {evt.GetHashCode()} bot attacker and bot death. Skipped");
                return null;
            }
            totalLogs++;
            // LogDebug($"Event = {evt.GetHashCode()} saved.");
            return CLogEntry.from(forPlayer, evt);
        }

        private void LogDebug(string txt)
        {
            if (debug) Puts($"DEBUG: {txt}");
        }

        static private PInfo UintFind(ulong netId)
        {
            BasePlayer player = null;
            try
            {
                player = BasePlayer.activePlayerList.First(x => x.net.ID.Value == netId);
            }
            catch (Exception e)
            {
            }
            return player != null ? new PInfo { Name = player.displayName, SteamId = player.UserIDString } : new PInfo { Name = netId.ToString(), SteamId = netId.ToString() };
        }

        /**
         * This avoids scientific notations
         */
        static public void RoundOrLimitFloat(ref float value) => value = (value > 1000000) ? value % 1000000 : value;

        public class PInfo
        {
            public string Name;
            public string SteamId;
        }
        #endregion

        public class CLogEntry
        {
            public int EventHash;
            public float EventTime;
            public string AttackerSteamId;
            public string TargetSteamId;
            public string Weapon;
            public string Ammo;
            public string Area;
            public float Distance;
            public float HealthOld;
            public float HealthNew;
            public string EventInfo;
            public int ProjectileHits;
            public float ProjectileIntegrity;
            public float ProjectileTravelTime;
            public float ProjectileTrajectoryMismatch;
            public int Desync;
            public static CLogEntry from(BasePlayer forPlayer, CombatLog.Event evt)
            {
                var pInfo = new PInfo { Name = forPlayer.displayName, SteamId = forPlayer.UserIDString };
                var attacker = evt.attacker == "you" ? pInfo : UintFind(evt.attacker_id);
                var target = evt.target == "you" ? pInfo : UintFind(evt.target_id);
                RoundOrLimitFloat(ref evt.health_new);
                RoundOrLimitFloat(ref evt.health_old);
                return new CLogEntry
                {
                    EventHash = evt.GetHashCode(),
                    AttackerSteamId = attacker.SteamId,
                    TargetSteamId = target.SteamId,
                    Ammo = evt.ammo,
                    Area = HitAreaUtil.Format(evt.area).ToLower(),
                    Distance = evt.distance,
                    EventInfo = evt.info,
                    EventTime = evt.time,
                    HealthNew = evt.health_new,
                    HealthOld = evt.health_old,
                    Desync = evt.desync,
                    ProjectileHits = evt.proj_hits,
                    ProjectileIntegrity = evt.proj_integrity,
                    ProjectileTrajectoryMismatch = evt.proj_mismatch,
                    ProjectileTravelTime = evt.proj_travel,
                    Weapon = evt.weapon
                };
            }
        }


        #region Configuration
        private static ConfigData config = new ConfigData();

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Advanced Logs")]
            public bool advancedLogs = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintError("Your config seems to be corrupted. Will load defaults.");
                LoadDefaultConfig();
                return;
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion
    }
}

// --- End of file: CombatLogInfo.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/computers-plus ---
// --- Original File Path: C/ComputersPlus/ComputersPlus.cs ---

using Oxide.Core.Plugins;
using System.Threading.Tasks;
using Newtonsoft.Json;
using Oxide.Core;
using System;
using System.Collections;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;
using System.Text;
using Oxide.Core.Libraries;
using Oxide.Game.Rust.Cui;
using System.Linq;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
	[Info("Computers Plus", "mr01sam", "1.0.6")]
	[Description("Adds new functionality to the computer stations.")]
	partial class ComputersPlus : CovalencePlugin
	{
		/*
		 * CHANGELOG
		 * - Fixed bug where players would not get emails if they were offline.
		 * - Added message screen for players without permissions.
		 * - Fixed broken images.
		 */
		private static ComputersPlus PLUGIN;

		[PluginReference]
		private Plugin ImageLibrary;

		/* Global Data */
		private static Dictionary<string, string> Language = new Dictionary<string, string>();
		private static Dictionary<string, ComputersPlusApp> RegisteredApps = new Dictionary<string, ComputersPlusApp>();
		private static Dictionary<string, string> AppsInUse = new Dictionary<string, string>();

		#region Properties
		internal EZUI.Component AppComponent { get; private set; } = null;
		private bool Success { get; set; } = true;
        #endregion

        #region Permissions
		private const string PermissionAdmin = "computersplus.admin";
		/* Additional permissions are registered for each App in the format computersplus.<app-name> */
		#endregion

		#region Initialization
		void CreateApps()
		{
			if (RegisteredApps == null)
            {
				RegisteredApps = new Dictionary<string, ComputersPlusApp>();
            }
            RegisterApp(EMAIL_APP);
        }

		void Init()
		{
			PLUGIN = this;
			UnsubscribeAll();
		}

		void Unload()
		{
			CleanupUI();
			UnloadApps();
			NullifyStaticVariables();
		}

		void OnServerSave()
		{
			SaveApps();
		}

		void OnServerInitialized(bool initial)
		{
			try
			{
				ImageLibrary.Call("isLoaded", null);
			}
			catch (Exception)
			{
				PrintWarning($"The required dependency ImageLibary is not installed, {Name} will not work properly without it.");
				Success = false;
				return;
            }
            EZUI.GenerateToken();
			LoadImages();
			InitApps();
			SubscribeAll();
		}

		void UnsubscribeAll()
        {
			Unsubscribe(nameof(OnEntityMounted));
			Unsubscribe(nameof(OnEntityDismounted));
			Unsubscribe(nameof(CanDismountEntity));
			Unsubscribe(nameof(OnBookmarkControl));
			Unsubscribe(nameof(OnBookmarkControlEnd));
		}

		void SubscribeAll()
		{
			Subscribe(nameof(OnEntityMounted));
			Subscribe(nameof(OnEntityDismounted));
			Subscribe(nameof(CanDismountEntity));
			Subscribe(nameof(OnBookmarkControl));
			Subscribe(nameof(OnBookmarkControlEnd));
		}

		void NullifyStaticVariables()
        {
			PLUGIN = null;
			RegisteredApps = null;
			AppsInUse = null;
			Language = null;
        }

		void CleanupUI()
        {
			for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
			{
				EZUI.DestroyAll(BasePlayer.activePlayerList[i]);
			}
		}

		void InitApps()
		{
			foreach(ComputersPlusApp app in RegisteredApps.Values)
            {
				ImageLibrary.Call<bool>("AddImage", app.IconUrl, $"{app.Id}Icon", 0UL);
				Call(app.InitMethod);
            }
		}

		void SaveApps()
		{
			foreach (ComputersPlusApp app in RegisteredApps.Values)
			{
				Call(app.SaveMethod);
			}
		}

		void UnloadApps()
		{
            foreach (ComputersPlusApp app in RegisteredApps.Values)
            {
                Call(app.UnloadMethod);
            }
        }
		#endregion

		#region Oxide Hooks
		void OnEntityMounted(ComputerStation entity, BasePlayer basePlayer)
		{
			ShowHomeUi(basePlayer);
		}

		void OnEntityDismounted(ComputerStation entity, BasePlayer basePlayer)
		{
			CloseUi(basePlayer);
			NextTick(() => 
			{
				CloseUi(basePlayer); // incase it doesn't close initally
			});
		}

		object CanDismountEntity(BasePlayer player, ComputerStation computerStation)
		{
            if (IsUsingApp(player))
            {
                return false;
            }
            return null;
		}

		object OnBookmarkControl(ComputerStation computerStation, BasePlayer basePlayer, string bookmarkName, IRemoteControllable remoteControllable)
		{
			CloseUi(basePlayer);
			return null;
		}

		object OnBookmarkControlEnd(ComputerStation computerStation, BasePlayer basePlayer, BaseEntity controlledEntity)
		{
			ShowHomeUi(basePlayer);
			return null;
		}
		#endregion

		#region Helper Methods
		void RegisterApp(ComputersPlusApp newApp)
        {
			RegisteredApps.Add(newApp.Id, newApp);
			if (!permission.PermissionExists(newApp.Permission))
            {
				permission.RegisterPermission(newApp.Permission, this);
			}
			Call(newApp.CreateMethod);
		}

		void LoadImages()
		{
			ImageLibrary.Call<bool>("AddImage", "https://i.imgur.com/43ytxMa.png", $"App.Close", 0UL);
			ImageLibrary.Call<bool>("AddImage", "https://i.imgur.com/oM0NEIP.png", $"PC.Denied", 0UL);
		}

		bool IsUsingComputer(BasePlayer basePlayer) => basePlayer.GetMounted() != null ? (basePlayer.GetMounted() is ComputerStation) : false;

		bool IsUsingApp(BasePlayer player, string appId = null)
		{
			if (appId != null)
				return AppsInUse.ContainsKey(player.UserIDString) && AppsInUse[player.UserIDString] == appId;
			return AppsInUse.ContainsKey(player.UserIDString);
		}

		bool UserHasAnyPermission(BasePlayer basePlayer)
        {
			return RegisteredApps.Values.Any(app => permission.UserHasPermission(basePlayer.UserIDString, app.Permission));
		}
		#endregion

		#region UI
		private readonly string BASE_UI_ID = "PC";
		private readonly string HOME_UI_ID = "HOME";
		private readonly string APP_UI_ID = "APP";

		void CloseUi(BasePlayer basePlayer)
        {
			AppsInUse.Remove(basePlayer.UserIDString);
			var ui = EZUI.Find(basePlayer.UserIDString, BASE_UI_ID);
			ui?.Destroy(basePlayer);
        }

		void CloseHomeUi(BasePlayer basePlayer)
        {
			var ui = EZUI.Find(basePlayer.UserIDString, $"{BASE_UI_ID}.Content.{HOME_UI_ID}");
			ui?.Destroy(basePlayer);
		}

		void CloseAppUi(BasePlayer basePlayer)
        {
			var ui = EZUI.Find(basePlayer.UserIDString, $"{BASE_UI_ID}.Content.{HOME_UI_ID}.Content.{APP_UI_ID}");
			ui?.Destroy(basePlayer);
			AppsInUse.Remove(basePlayer.UserIDString);
		}

		EZUI.Component CreateAppGrid(EZUI.Component home, BasePlayer basePlayer)
        {
			var grid = new EZUI.LayoutComponent("Apps")
			{
                Transparent = true,
                RowCount = 8,
                ColCount = 15,
				PixelPadding = new EZUI.Dir<int>(5)
            }.Create(home);
            foreach (ComputersPlusApp app in RegisteredApps.Values)
            {
				if (app != null && permission.UserHasPermission(basePlayer.UserIDString, app.Permission))
                {
					var box = new EZUI.BoxComponent(app.Id)
					{
						Transparent = true
					}.Create(grid);
					var icon = new EZUI.ImageComponent("Icon")
					{
						ImageKey = $"{app.Id}Icon",
						Size = 0.6f,
						AnchorTo = EZUI.Anchor.TopCenter
					}.Create(box);
					var text = new EZUI.TextComponent("Title")
					{
						Text = app.Name,
						TextAlign = TextAnchor.UpperCenter,
						FontSize = 10,
						PixelHeight = 25,
						FontColor = EZUI.StyleSheet.DEFAULT.FontColorLight1,
						AnchorTo = EZUI.Anchor.BottomCenter
					}.Create(box);
					var button = new EZUI.ButtonComponent("Click")
					{
						Transparent = true,
						Command = $"app.launch {app.Id}",
						ClickSfx = SFX_LAUNCH
					}.Create(box);
				}
            }
            return grid;
        }

		void ShowHomeUi(BasePlayer basePlayer)
		{
			if (Success)
            {
				bool hasAccess = UserHasAnyPermission(basePlayer);
				var ui = new EZUI.BoxComponent(BASE_UI_ID)
				{
					Height = 0.75f,
					Centered = true,
					Width = 0.75f,
				}.Create();
				var home = new EZUI.BoxComponent(HOME_UI_ID)
				{
					OutlinePixelWeight = 5,
					BackgroundColor = hasAccess ? EZUI.StyleSheet.DEFAULT.HomeBackgroundColor : EZUI.Color.BLACK,
					Centered = true
				}.Create(ui);
				if (hasAccess)
                {
					var version = new EZUI.TextComponent("Version")
					{
						AnchorTo = EZUI.Anchor.BottomRight,
						AutoSizeHeight = true,
						AutoSizeWidth = true,
						FontColor = EZUI.Color.WHITE,
						FontSize = 10,
						Up = 5,
						Left = 5,
						TextAlign = TextAnchor.LowerRight,
						Text = $"COBALT OS v{Version.Major}.{Version.Minor}.{Version.Patch}"
					}.Create(home);
					var grid = CreateAppGrid(home, basePlayer);
				}
				else
                {
					var denied = new EZUI.ImageComponent("Deny")
					{
						ImageKey = "PC.Denied",
						ImageColor = EZUI.Color.RED,
						Size = 0.2f,
						AnchorTo = EZUI.Anchor.MiddleCenter,
						Up = 50
					}.Create(home);
					var text = new EZUI.TextComponent("Text")
					{
						Text = Lang("app.access.denied", basePlayer),
						FontColor = EZUI.Color.RED,
						TextAlign = TextAnchor.UpperCenter,
						FontSize = 28,
						TopAlign = denied.BottomSide.Pixels,
						Down = 20,
						PixelHeight = 100
					}.Create(home);
					var reason = new EZUI.TextComponent("Reason")
					{
						Text = Lang("app.access.reason", basePlayer),
						FontColor = EZUI.Color.WHITE,
						TextAlign = TextAnchor.LowerCenter,
						AnchorTo = EZUI.Anchor.BottomCenter,
						FontSize = 12,
						PixelHeight = 100
					}.Create(home);
				}

				ui.Render(basePlayer);
			}
		}

		void ShowAppUi(BasePlayer basePlayer, ComputersPlusApp app)
		{
			var home = EZUI.Find(basePlayer, $"{BASE_UI_ID}.{HOME_UI_ID}");
			var window = new EZUI.WindowComponent(APP_UI_ID)
			{
				HeaderText = app.Name,
				Scale = 0.85f,
				Centered = true,
				OnCloseCommand = "app.close"
			}.Create(home);
			this.AppComponent = window;
			window.Render(basePlayer);
			if (!AppsInUse.ContainsKey(basePlayer.UserIDString))
            {
				AppsInUse.Add(basePlayer.UserIDString, app.Id);
			}
		}
		#endregion

		#region Commands
		[Command("app.launch")]
		private void cmd_app_launch(IPlayer player, string command, string[] args)
		{
			BasePlayer basePlayer = player.Object as BasePlayer;
			if (basePlayer != null && IsUsingComputer(basePlayer))
			{
				string appId = args[0];
				ComputersPlusApp app = null;
				if (RegisteredApps.TryGetValue(appId, out app) && permission.UserHasPermission(player.Id, app.Permission)) {
					ShowAppUi(basePlayer, app);
					Call(app.LaunchMethod, basePlayer.UserIDString);
				}
				else
                {
					player.Reply(Lang("app.launch.error", basePlayer));
                }
			}
		}

		[Command("app.close")]
		private void cmd_app_close(IPlayer player, string command, string[] args)
		{
			BasePlayer basePlayer = player.Object as BasePlayer;
			if (basePlayer != null)
            {
				CloseAppUi(basePlayer);
			}
		}

		[Command("pc.leave")]
		private void cmd_pc_leave(IPlayer player, string command, string[] args)
		{
			BasePlayer basePlayer = player.Object as BasePlayer;
			if (basePlayer != null)
            {
				EZUI.DestroyAll(basePlayer);
				BaseMountable mountable = basePlayer.GetMounted();
				if (mountable != null && mountable is ComputerStation)
				{
					mountable.DismountPlayer(basePlayer);
				}
			}
		}
		#endregion

	}
}

namespace Oxide.Plugins
{
    partial class ComputersPlus
    {
        class ComputersPlusApp {
            private string _id;
            private string _name;
            private string _iconUrl;
            private string _permission;

            public ComputersPlusApp(string id, string name, string iconUrl, string permission)
            {
                this._id = id;
                this._name = name;
                this._iconUrl = iconUrl;
                this._permission = permission;
            }
   
            public string Id
            {
                get { return _id; }
            }

            public string Name
            {
                get { return _name; }
            }

            public string IconUrl
            {
                get { return _iconUrl; }
            }

            public string Permission
            {
                get { return _permission; }
            }

            public string LaunchMethod
            {
                get { return $"Launch{Id.TitleCase()}App"; }
            }

            public string SaveMethod
            {
                get { return $"Save{Id.TitleCase()}App"; }
            }

            public string CreateMethod
            {
                get { return $"Create{Id.TitleCase()}App"; }
            }

            public string InitMethod
            {
                get { return $"Init{Id.TitleCase()}App"; }
            }

            public string UnloadMethod
            {
                get { return $"Unload{Id.TitleCase()}App"; }
            }

            public override string ToString()
            {
                return Id.ToString();
            }
        }
    }
}

namespace Oxide.Plugins
{
    partial class ComputersPlus : CovalencePlugin
    {
		private Configuration config;

		private partial class Configuration 
		{

		}

		protected override void LoadConfig()
		{
			base.LoadConfig();

			try
			{
				config = Config.ReadObject<Configuration>();
				if (config == null) throw new Exception();
			}
			catch
			{
				PrintError("Your configuration file contains an error. Default configuration values will be used. It is recommended to backup your current configuration file and remove it to generate a fresh one.");
				LoadDefaultConfig();
			}
			base.SaveConfig();
		}

		protected override void SaveConfig() => Config.WriteObject(config);

		protected override void LoadDefaultConfig() => config = new Configuration();

	}
}

namespace Oxide.Plugins
{
    partial class ComputersPlus
    {
        class DoubleDictionary<TkeyA, TkeyB, Tvalue>
		{
			private Dictionary<TkeyA, Dictionary<TkeyB, Tvalue>> a2b;
			private Dictionary<TkeyB, Dictionary<TkeyA, Tvalue>> b2a;

			public DoubleDictionary()
			{
				a2b = new Dictionary<TkeyA, Dictionary<TkeyB, Tvalue>>();
				b2a = new Dictionary<TkeyB, Dictionary<TkeyA, Tvalue>>();
			}

			public void Set(TkeyA keyA, TkeyB keyB, Tvalue value)
			{
				if (!a2b.ContainsKey(keyA))
					a2b.Add(keyA, new Dictionary<TkeyB, Tvalue>());
				if (!b2a.ContainsKey(keyB))
					b2a.Add(keyB, new Dictionary<TkeyA, Tvalue>());
				if (!a2b[keyA].ContainsKey(keyB))
					a2b[keyA].Add(keyB, value);
				else
					a2b[keyA][keyB] = value;
				if (!b2a[keyB].ContainsKey(keyA))
					b2a[keyB].Add(keyA, value);
				else
					b2a[keyB][keyA] = value;
			}

			public Tvalue Get(TkeyA keyA, TkeyB keyB)
			{
				if (a2b.ContainsKey(keyA) && a2b[keyA].ContainsKey(keyB))
					return a2b[keyA][keyB];
				return default(Tvalue);
			}

			public Dictionary<TkeyB, Tvalue> GetA(TkeyA keyA)
			{
				if (a2b.ContainsKey(keyA))
					return a2b[keyA];
				return new Dictionary<TkeyB, Tvalue>();
			}

			public Dictionary<TkeyA, Tvalue> GetB(TkeyB keyB)
			{
				if (b2a.ContainsKey(keyB))
					return b2a[keyB];
				return new Dictionary<TkeyA, Tvalue>();
			}

			public bool ContainsKey(TkeyA keyA, TkeyB keyB)
			{
				return a2b.ContainsKey(keyA) && a2b[keyA].ContainsKey(keyB);
			}

			public bool ContainsKey(TkeyA keyA)
			{
				return a2b.ContainsKey(keyA);
			}

			public void Delete(TkeyA keyA, TkeyB keyB)
			{
				if (a2b.ContainsKey(keyA) && a2b[keyA].ContainsKey(keyB))
					a2b[keyA].Remove(keyB);
				if (b2a.ContainsKey(keyB) && b2a[keyB].ContainsKey(keyA))
					b2a[keyB].Remove(keyA);
			}

			public void DeleteA(TkeyA keyA)
			{
				foreach (TkeyB keyB in b2a.Keys)
					if (b2a[keyB].ContainsKey(keyA))
						b2a[keyB].Remove(keyA);
				if (a2b.ContainsKey(keyA))
					a2b.Remove(keyA);
			}

			public void DeleteB(TkeyB keyB)
			{
				foreach (TkeyA keyA in a2b.Keys)
					if (a2b[keyA].ContainsKey(keyB))
						a2b[keyA].Remove(keyB);
				if (b2a.ContainsKey(keyB))
					b2a.Remove(keyB);
			}

			public int Count(TkeyA keyA)
			{
				return a2b[keyA].Count;
			}
		}
	}
}

namespace Oxide.Plugins
{
    partial class ComputersPlus : CovalencePlugin
    {
		protected override void LoadDefaultMessages()
		{
            Language = new Dictionary<string, string>();
            CreateApps();
            Language = Language.Concat(new Dictionary<string, string>
            {
                ["app.error.launch"] = "That app is not registered or this player does not have permission to use it.",
                ["app.access.denied"] = "Access Denied",
                ["app.access.reason"] = "You do not have any app permissions for this plugin."
            }).ToDictionary(x => x.Key, y => y.Value);
            lang.RegisterMessages(Language, this);
        }

        private string Lang(string key, string id, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        private string Lang(string key, BasePlayer basePlayer, params object[] args) => string.Format(lang.GetMessage(key, this, basePlayer?.UserIDString), args);
    }
}

namespace Oxide.Plugins
{
    partial class ComputersPlus : CovalencePlugin
    {
        public static readonly string SFX_LAUNCH = "assets/prefabs/tools/binoculars/sound/fovchange.prefab";
        public static readonly string SFX_CLICK = "assets/prefabs/tools/detonator/effects/unpress.prefab";
        public static readonly string SFX_SUBMIT = "assets/prefabs/tools/flashlight/effects/turn_on.prefab";
    }
}

namespace Oxide.Plugins
{
    partial class ComputersPlus
    {

        private T LoadDataFile<T>(string fileName)
        {
            try
            {
                return Interface.Oxide.DataFileSystem.ReadObject<T>($"{Name}/{fileName}");
            }
            catch (Exception)
            {
                return default(T);
            }
        }

        private void SaveDataFile<T>(string fileName, T data)
        {
            Interface.Oxide.DataFileSystem.WriteObject($"{Name}/{fileName}", data);
        }

        private void PlaySfx(BasePlayer player, string sound) => EffectNetwork.Send(new Effect(sound, player, 0, Vector3.zero, Vector3.forward), player.net.connection);
    }
}

namespace Oxide.Plugins
{
	partial class ComputersPlus : CovalencePlugin
	{
		private readonly ComputersPlusApp EMAIL_APP = new ComputersPlusApp("email", "Email", "https://freeiconshop.com/wp-content/uploads/edd/mail-var-outline-filled.png", "computersplus.email");

		#region App Hooks
		void CreateEmailApp(string userIdString)
		{
			RegisterEmailLanguage();
		}

		void InitEmailApp()
		{
			EmailManager.MaxInboxSize = config.Email.MaxInboxSize;
			
			LoadEmails();
			AddEmailAppImages();
			RegisterEmailFunctions();
		}

		void LaunchEmailApp(string userIdString)
		{
			BasePlayer basePlayer = BasePlayer.FindByID(ulong.Parse(userIdString));
			RenderEmailApp(basePlayer);
		}

		void SaveEmailApp()
		{
			SaveEmails();
		}

		void UnloadEmailApp()
		{
			SaveEmails();
		}
        #endregion

        #region Config
        private partial class Configuration
		{
			[JsonProperty(PropertyName = "Email Config")]
			public EmailConfiguration Email = new EmailConfiguration();
		}

		private class EmailConfiguration
		{
			[JsonProperty(PropertyName = "Max Inbox Size")]
			public int MaxInboxSize { get; set; } = 24;
		}
        #endregion

        #region Helper Methods
        private void AddEmailAppImages()
		{
			ImageLibrary.Call<bool>("AddImage", "https://freeiconshop.com/wp-content/uploads/edd/mail-var-outline-filled.png", $"{EMAIL_APP.Id}Unread", 0UL);
			ImageLibrary.Call<bool>("AddImage", "https://imgur.com/GYiA73s.png", $"{EMAIL_APP.Id}Read", 0UL);
			ImageLibrary.Call<bool>("AddImage", "https://imgur.com/dUlC5Yf.png", $"{EMAIL_APP.Id}Compose", 0UL);
			ImageLibrary.Call<bool>("AddImage", "https://i.imgur.com/HMcxb5Q.png", $"{EMAIL_APP.Id}Delete", 0UL);
			ImageLibrary.Call<bool>("AddImage", "https://uxwing.com/wp-content/themes/uxwing/download/communication-chat-call/send-icon.png", $"{EMAIL_APP.Id}Send", 0UL);
		}

		private void RegisterEmailLanguage()
		{
			Language = Language.Concat(new Dictionary<string, string>
			{
				["email.compose"] = "Compose",
				["email.subject"] = "Subject",
				["email.recipients"] = "Recipients",
				["email.send"] = "Send",
				["email.message"] = "Message",
				["email.to"] = "To",
				["email.from"] = "From",
				["email.received"] = "Received",
				["email.unread"] = "Unread",
				["email.inbox"] = "Inbox",
				["email.days"] = "days ago",
				["email.hours"] = "hrs ago",
				["email.minutes"] = "min ago",
				["email.now"] = "just now",
				["email.cleared"] = "Cleared inbox for {0}",
				["email.success"] = "Successfully sent to {0} recipients",
				["email.partial"] = "Successfully sent to {0} recipients. Failed to find {1} recipients.",
				["email.fail"] = "Failed to find any recipients. No messages sent.",
				["email.usage.clear"] = "Usage: email.clear <username>"
			}).ToDictionary(x => x.Key, x => x.Value);
        }

        private void RegisterEmailFunctions()
		{
			EZUI.RegisterFunction(nameof(RenderEmailView));
			EZUI.RegisterFunction(nameof(RenderEmailCompose));
			EZUI.RegisterFunction(nameof(SendEmail));
			EZUI.RegisterFunction(nameof(DeleteEmail));
		}

		private void LoadEmails()
		{
			var existing = LoadDataFile<Dictionary<string, List<EmailMessage>>>("Emails");
			if (existing != null)
			{
				EmailManager.SetAllEmails(existing);
			}
		}

		private void SaveEmails()
		{
			var all = EmailManager.GetAllEmails();
			SaveDataFile("Emails", all);
		}

		private void DeleteEmail(string userIdString, string emailGuid)
        {
			BasePlayer basePlayer = BasePlayer.FindAwakeOrSleeping(userIdString);
			if (basePlayer != null)
            {
				EmailManager.DeleteEmail(userIdString, Guid.Parse(emailGuid));
				var inbox = UpdateInbox(basePlayer);
				inbox.Paginator?.UpdatePageAndRender(basePlayer);
			}
		}

		private void SendEmail(string userIdString)
		{
			BasePlayer basePlayer = BasePlayer.FindAwakeOrSleeping(userIdString);
			var recipients = EZUI.Get(basePlayer, EMAIL_APP, "Recipients")?.As<EZUI.InputComponent>()?.Data;
			var subject = EZUI.Get(basePlayer, EMAIL_APP, "Subject")?.As<EZUI.InputComponent>()?.Data;
			var text = EZUI.Get(basePlayer, EMAIL_APP, "Message")?.As<EZUI.InputComponent>()?.Data;
			var split = recipients.Split(',').Select(x => x.Trim()).Where(x => x.Length > 0).Distinct().ToList();
			var recipientIds = split.Select(y => players.FindPlayer(y)?.Id).Distinct().Where(x => !string.IsNullOrEmpty(x)).ToList();
			if (recipients != null && subject != null && text != null)
			{
				int count = 0;
				if (split.Count > 0)
                {
					foreach (var id in recipientIds)
					{
						var email = new EmailMessage(userIdString, id, subject, text);
						EmailManager.SendEmail(email);
						count++;
					}
				}
				else
                {
					UpdateInfoText(basePlayer, Lang("email.fail", basePlayer));
				}
				string status;
				if (count == split.Count)
				{
					status = Lang("email.success", basePlayer, count);
				}
				else if (count > 0)
                {
					int fails = split.Count - count;
					status = Lang("email.partial", basePlayer, count, fails);
				}
				else
                {
					status = Lang("email.fail", basePlayer, count);
				}
				var window = EZUI.Get(basePlayer, EMAIL_APP, "Compose");
				if (window != null)
				{
					window.Destroy(basePlayer);
					timer.In(0.5f, () =>
					{
						UpdateInfoText(basePlayer, status);
						timer.In(4f, () =>
						{
							UpdateInfoText(basePlayer, string.Empty);
						});
					});
				}
				UpdateInbox(basePlayer).Render(basePlayer);
			}
		}
        #endregion

        #region UI
        private void RenderEmailCompose(string userIdString)
		{
			var basePlayer = BasePlayer.FindByID(ulong.Parse(userIdString));
			if (basePlayer != null)
			{
				var height = 45;
				var width = 0.5f;
				var window = new EZUI.WindowComponent("Compose")
				{
					HeaderText = Lang("email.compose", basePlayer),
					Scale = 0.5f
				}.Tag(EMAIL_APP).Create();
				var subject = new EZUI.InputComponent("Subject")
				{
					Text = $"{Lang("email.subject", basePlayer)}:",
					CharsLimit = 55,
					AnchorTo = EZUI.Anchor.TopLeft,
					PixelMargin = new EZUI.Dir<int>(0, 0, 10, 0),
					PixelHeight = height,
					Width = width
				}.Tag(EMAIL_APP).Create(window);
				var recipients = new EZUI.InputComponent("Recipients")
				{
					Text = $"{Lang("email.recipients", basePlayer)}:",
					CharsLimit = 1024,
					TopAlign = subject.BottomSide.Pixels,
					PixelMargin = new EZUI.Dir<int>(0, 0, 10, 0),
					PixelHeight = height,
					Width = width
				}.Tag(EMAIL_APP).Create(window);
				var send = new EZUI.ButtonComponent("Send")
				{
                    Text = Lang("email.send", basePlayer),
                    AnchorTo = EZUI.Anchor.BottomRight,
					TextAlign = TextAnchor.MiddleCenter,
					BackgroundColor = EZUI.StyleSheet.DEFAULT.BackgroundColorDark1,
					OutlineColor = EZUI.StyleSheet.DEFAULT.BackgroundColorLight1,
					OutlinePixelWeight = 1,
					PixelWidth = 75,
					PixelHeight = 25,
					ClickSfx = SFX_SUBMIT,
					Command = $"ezui.call {EZUI.Token} SendEmail {basePlayer.UserIDString}",
					PixelMargin = new EZUI.Dir<int>(5, 0, 0, 0)
				}.Create(window);
				var message = new EZUI.InputComponent("Message")
				{
					Text = $"{Lang("email.message", basePlayer)}:",
					CharsLimit = 2048,
					TextAlign = TextAnchor.UpperLeft,
					TopAlign = recipients.BottomSide.Pixels,
					BottomAlign = send.TopSide.Pixels
				}.Tag(EMAIL_APP).Create(window);

				window.Render(basePlayer);
			}
		}
		private void RenderEmailView(string userIdString, string emailGuid)
        {
			var basePlayer = BasePlayer.FindByID(ulong.Parse(userIdString));
			if (basePlayer != null)
            {
                var email = EmailManager.GetEmail(userIdString, Guid.Parse(emailGuid));
				email.MarkAsRead();
				UpdateInbox(basePlayer).Render(basePlayer);
				var window = new EZUI.WindowComponent("View")
                {
                    HeaderText = email.Subject,
                    Scale = 0.5f,
                }.Create();
				var height = 20;
				var width = 100;
				var to = new EZUI.LayoutComponent("To")
				{
					AnchorTo = EZUI.Anchor.TopLeft,
					PixelHeight = height,
					PixelWidth = width,
					ColCount = 2,
					Entries = new List<EZUI.Component>()
                    {
						new EZUI.TextComponent("Label") { Text = $"{Lang("email.to", basePlayer)}:" },
						new EZUI.TextComponent("Value") { Text = $"{email.RecipientDisplayName}" },
					}
				}.Create(window);
                var from = new EZUI.LayoutComponent("From")
                {
                    TopAlign = to.BottomSide.Pixels,
                    PixelHeight = height,
                    PixelWidth = width,
                    ColCount = 2,
                    Entries = new List<EZUI.Component>()
                    {
                        new EZUI.TextComponent("Label") { Text = $"{Lang("email.from", basePlayer)}:" },
                        new EZUI.TextComponent("Value") { Text = $"{email.ComposerDisplayName}" },
                    }
                }.Create(window);
                var received = new EZUI.LayoutComponent("Received")
                {
                    TopAlign = from.BottomSide.Pixels,
                    PixelHeight = height,
                    PixelWidth = width,
                    ColCount = 2,
                    Entries = new List<EZUI.Component>()
                    {
                        new EZUI.TextComponent("Label") { Text = $"{Lang("email.received", basePlayer)}:" },
                        new EZUI.TextComponent("Value") { Text = $"{email.ElapsedTimeString(basePlayer)}" },
                    }
                }.Create(window);
                var subject = new EZUI.LayoutComponent("Subject")
                {
                    TopAlign = received.BottomSide.Pixels,
                    PixelHeight = height,
                    PixelWidth = width,
                    ColCount = 2,
                    PixelMargin = new EZUI.Dir<int>(0, 0, 5, 0),
                    Entries = new List<EZUI.Component>()
                    {
                        new EZUI.TextComponent("Label") { Text = $"{Lang("email.subject", basePlayer)}:" },
                        new EZUI.TextComponent("Value") { Text = $"{email.Subject}" },
                    }
                }.Create(window);
                var text = new EZUI.TextComponent("Message")
                {
                    TopAlign = subject.BottomSide.Pixels,
                    TextAlign = TextAnchor.UpperLeft,
                    PixelPadding = new EZUI.Dir<int>(5),
                    Text = email.Text,
                    BackgroundColor = EZUI.Color.WHITE
                }.Create(window);
                window.Render(basePlayer);
            }
		}
        private EZUI.Component CreateEmailEntryComponent(BasePlayer basePlayer, EmailMessage email, EZUI.Component list)
		{
			var box = new EZUI.BoxComponent("Item")
			{
				BackgroundColor = email.Unread ? EZUI.StyleSheet.DEFAULT.BackgroundColorHighlight1 : EZUI.StyleSheet.DEFAULT.BackgroundColorLight2,
				PixelPadding = new EZUI.Dir<int>(5),
			}.Create(list);
			var img = new EZUI.ImageComponent("Icon")
			{
				Transparent = true,
				Height = 0.8f,
				PixelWidth = 18,
				//PixelHeight = 36,
				ImageKey = $"{EMAIL_APP.Id}Unread",
				ImageHidden = !email.Unread,
				CenterY = true,
				AnchorTo = EZUI.Anchor.Left
			}.Create(box);
			var from = new EZUI.TextComponent("From")
			{
				Text = email.ComposerDisplayName,
				PixelWidth = 100,
				Right = 100
			}.Create(box);
			var subject = new EZUI.TextComponent("Subject")
			{
				Text = email.Subject,
				PixelWidth = 250,
				Right = 250
			}.Create(box);
			var received = new EZUI.TextComponent("Received")
			{
				Text = email.ElapsedTimeString(basePlayer),
				PixelWidth = 100,
				Right = 550
			}.Create(box);
            var btn = new EZUI.ButtonComponent("Clickable")
            {
                Transparent = true,
                Command = $"ezui.call {EZUI.Token} RenderEmailView {basePlayer.UserIDString} {email.Guid}",
				Width = 0.97f
            }.Create(box);
            var delete = new EZUI.ButtonComponent("Delete")
			{
				Transparent = true,
				ImageKey = $"{EMAIL_APP.Id}Delete",
				Command = $"ezui.call {EZUI.Token} DeleteEmail {basePlayer.UserIDString} {email.Guid}",
				Size = 0.5f,

				CenterY = true,
				AnchorTo = EZUI.Anchor.MiddleRight,
				Left = 5
			}.Create(box);
			return box;
		}

		EZUI.LayoutComponent UpdateInbox(BasePlayer basePlayer, EZUI.Component inbox = null)
        {
			if (inbox == null)
            {
				inbox = EZUI.Get(basePlayer, EMAIL_APP, "Inbox");
            }
			var layout = inbox.As<EZUI.LayoutComponent>();
			layout.ClearEntries();
			var emails = EmailManager.GetPlayerInbox(basePlayer.UserIDString);
			foreach (var email in emails)
			{
				var entry = CreateEmailEntryComponent(basePlayer, email, layout);
			}
			UpdateStatusText(basePlayer);
			return layout;
		}

		private string StatusText(BasePlayer basePlayer)
        {
			return $"{Lang("email.inbox", basePlayer)} ({EmailManager.GetPlayerInboxCount(basePlayer.UserIDString)}/{EmailManager.MaxInboxSize})";
		}

		void UpdateStatusText(BasePlayer basePlayer)
        {
			var status = EZUI.Get(basePlayer, EMAIL_APP, "Status")?.As<EZUI.TextComponent>();
			if (status != null)
            {
				status.Text = StatusText(basePlayer);
				status.Create().Render(basePlayer);
			}
		}

		void UpdateInfoText(BasePlayer basePlayer, string newText)
		{
			var info = EZUI.Get(basePlayer, EMAIL_APP, "Info")?.As<EZUI.TextComponent>();
			if (info != null)
			{
				info.Text = newText;
				info.Create().Render(basePlayer);
			}
		}

		void RenderEmailApp(BasePlayer basePlayer)
		{
			var main = new EZUI.BoxComponent("Container")
			{
				Transparent = true
			}.Tag(EMAIL_APP.Id).Create(AppComponent);
			var button = new EZUI.ButtonComponent("Compose")
			{
				Text = $"{Lang("email.compose", basePlayer)}",
				PixelHeight = 15,
				PixelWidth = 70,
				TextAlign = TextAnchor.MiddleCenter,
				AnchorTo = EZUI.Anchor.TopLeft,
				BackgroundColor = EZUI.StyleSheet.DEFAULT.BackgroundColorDark1,
				Command = $"ezui.call {EZUI.Token} RenderEmailCompose {basePlayer.UserIDString}",
				PixelMargin = new EZUI.Dir<int>(0, 0, 5, 0),
				OutlinePixelWeight = 1
			}.Create(main);
			var header = new EZUI.BoxComponent("Header")
			{
				PixelHeight = 30,
				TopAlign = button.BottomSide.Pixels,
				PixelPadding = new EZUI.Dir<int>(5),
				PixelMargin = new EZUI.Dir<int>(0, 0, 5, 0)
			}.Create(main);
            var h1 = new EZUI.TextComponent("H1")
            {
                Text = $"{Lang("email.unread", basePlayer)}",
				AutoSizeWidth = true,
				Right = 0
            }.Create(header);
            var h2 = new EZUI.TextComponent("H2")
            {
                Text = $"{Lang("email.from", basePlayer)}",
				AutoSizeWidth = true,
				Right = 100
			}.Create(header);
            var h3 = new EZUI.TextComponent("H3")
            {
                Text = $"{Lang("email.subject", basePlayer)}",
				AutoSizeWidth = true,
				Right = 250
			}.Create(header);
            var h4 = new EZUI.TextComponent("H4")
            {
                Text = $"{Lang("email.received", basePlayer)}",
				AutoSizeWidth = true,
				Right = 550
            }.Create(header);
			var pag = new EZUI.PaginatorComponent("Paginator")
			{
				AnchorTo = EZUI.Anchor.BottomLeft,
				PixelHeight = 25,
				OutlinePixelWeight = 1,
				PixelMargin = new EZUI.Dir<int>(5, 0, 0, 0)
			}.Create(main).As<EZUI.PaginatorComponent>();
			var body = new EZUI.BoxComponent("Body")
			{
				TopAlign = header.BottomSide.Pixels,
				BottomAlign = pag.TopSide.Pixels,
				OutlinePixelWeight = 1,
				BackgroundColor = EZUI.Color.WHITE
			}.Create(main);
			var status = new EZUI.TextComponent("Status")
			{
				AnchorTo = EZUI.Anchor.BottomLeft,
				PixelPadding = new EZUI.Dir<int>(5),
				FontSize = 10,
				Text = StatusText(basePlayer),
				Width = 0.5f,
				PixelHeight = 25
			}.Tag(EMAIL_APP).Create(body);
			var info = new EZUI.TextComponent("Info")
			{
				AnchorTo = EZUI.Anchor.BottomRight,
				PixelPadding = new EZUI.Dir<int>(5),
				FontSize = 10,
				Text = string.Empty,
				TextAlign = TextAnchor.MiddleRight,
				PixelHeight = 25,
				Width = 0.5f,
			}.Tag(EMAIL_APP).Create(body);
			var inbox = new EZUI.LayoutComponent("Inbox")
			{
				RowCount = 8,
				ColCount = 1,
				EntryPixelPadding = new EZUI.Dir<int>(5),
				BottomAlign = status.TopSide.Pixels
			}.Tag(EMAIL_APP.Id).As<EZUI.LayoutComponent>().SetPaginator(pag).Create(body).As<EZUI.LayoutComponent>();
			inbox = UpdateInbox(basePlayer, inbox);
			main.Render(basePlayer);
			pag.UpdatePageAndRender(basePlayer, 1);
			
		}
		#endregion

		#region Commands
		[Command("email.clear"), Permission(PermissionAdmin)]  // email.clear <username> 
		private void cmd_email_clear(IPlayer player, string command, string[] args)
		{
			if (args.Length == 1)
            {
				var username = args[0];
				var target = players.FindPlayer(username);
				if (target != null)
                {
					EmailManager.ClearPlayerInbox(target.Id);
					player.Reply(Lang("email.cleared", player.Id, target.Name));
					return;
				}
            }
			player.Reply(Lang("email.usage.clear", player.Id));
		}
		#endregion
	}
}

namespace Oxide.Plugins
{
    partial class ComputersPlus
    {
        private static class EmailManager
        {
            private static Dictionary<string, List<EmailMessage>> EmailMessages = new Dictionary<string, List<EmailMessage>>();
            public static int MaxInboxSize { get; set; } = 24;
            public static int SendEmail(EmailMessage email)
            {
                if (EmailMessages.ContainsKey(email.RecipientStringId))
                {
                    if (EmailMessages[email.RecipientStringId].Count < MaxInboxSize)
                    {
                        EmailMessages[email.RecipientStringId].Add(email);
                        return 1;
                    }
                }
                else
                {
                    EmailMessages.Add(email.RecipientStringId, new List<EmailMessage>() { email });
                    return 1;
                }
                return 0;
            }
            public static void SetAllEmails(Dictionary<string, List<EmailMessage>> emailMessages)
            {
                EmailMessages = emailMessages;
            }
            public static Dictionary<string, List<EmailMessage>> GetAllEmails()
            {
                return EmailMessages;
            }
            public static EmailMessage[] GetPlayerInbox(string userIdString)
            {
                if (EmailMessages.ContainsKey(userIdString))
                {
                    return EmailMessages[userIdString].Reverse<EmailMessage>().ToArray();
                }
                else
                {
                    return new EmailMessage[] { };
                }
            }
            public static int GetPlayerInboxCount(string userIdString)
            {
                if (EmailMessages.ContainsKey(userIdString))
                {
                    return EmailMessages[userIdString].Count;
                }
                else
                {
                    return 0;
                }
            }
            public static void ClearPlayerInbox(string userIdString)
            {
                if (EmailMessages.ContainsKey(userIdString))
                {
                    EmailMessages.Remove(userIdString);
                }
            }
            public static void DeleteEmail(string userIdString, Guid emailGuid)
            {
                if (EmailMessages.ContainsKey(userIdString))
                {
                    EmailMessages[userIdString].RemoveAll(x => x.Guid == emailGuid);
                }
            }
            public static EmailMessage GetEmail(string userIdString, Guid emailGuid)
            {
                if (EmailMessages.ContainsKey(userIdString))
                {
                    return EmailMessages[userIdString].Where(x => x.Guid == emailGuid).FirstOrDefault();
                }
                else
                {
                    return null;
                }
            }
        }
    }
}

namespace Oxide.Plugins
{
	partial class ComputersPlus : CovalencePlugin
	{
		[Serializable]
		private class EmailMessage
		{
			public EmailMessage(string composerStringId, string recipientStringId, string subject, string text)
            {
				Guid = Guid.NewGuid();
				Unread = true;
				Subject = subject;
				ComposerStringId = composerStringId;
				RecipientStringId = recipientStringId;
				Timestamp = DateTimeOffset.Now.ToUnixTimeSeconds();
				Text = text;
            }
			public Guid Guid { get; set; }
			public bool Unread { get; set; }
			public string Subject { get; set; }
			public string ComposerStringId { get; set; }
			public string RecipientStringId { get; set; }
			public long Timestamp { get; set; }
			public string Text { get; set; }

			[JsonIgnore]
			public string ComposerDisplayName
            {
				
				get
                {
					return BasePlayer.FindAwakeOrSleeping(ComposerStringId)?.displayName;
				}
            }
			[JsonIgnore]
			public string RecipientDisplayName
			{
				get
				{
					return BasePlayer.FindAwakeOrSleeping(RecipientStringId)?.displayName;
				}
			}
			public void MarkAsRead()
			{
				this.Unread = false;
			}
			public string ElapsedTimeString(BasePlayer basePlayer)
			{
				var elapsed = TimeSpan.FromSeconds(DateTimeOffset.Now.ToUnixTimeSeconds() - Timestamp);
				if (elapsed.TotalDays >= 1)
				{
					return $"{(int)Math.Floor(elapsed.TotalDays)} {PLUGIN.Lang("email.days", basePlayer)}";
				}
				else if (elapsed.TotalHours >= 1)
				{
					return $"{(int)Math.Floor(elapsed.TotalHours)} {PLUGIN.Lang("email.hours", basePlayer)}";
				}
				else if (elapsed.TotalMinutes >= 1)
				{
					return $"{(int)Math.Floor(elapsed.TotalMinutes)} {PLUGIN.Lang("email.minutes", basePlayer)}";
				}
				else
				{
					return $"{PLUGIN.Lang("email.now", basePlayer)}";
				}
			}
		}
	}
}

namespace Oxide.Plugins
{
    partial class ComputersPlus : CovalencePlugin
    {
        public static partial class EZUI
        {
            public class BasicComponent : Component
            {
                public BasicComponent(string id) : base(id)
                {
                }

                protected override Component CreateHelper()
                {
                    return this;
                }

                public override Component Inherit(Component from, bool recursive = false)
                {
                    this.BackgroundColor = from.BackgroundColor;
                    this.PixelHeight = from.PixelHeight;
                    this.PixelWidth = from.PixelWidth;
                    this.PixelX = from.PixelX;
                    this.PixelY = from.PixelY;
                    this.PixelPadding = from.PixelPadding;
                    this.PixelMargin = from.PixelMargin;

                    return recursive ? base.Inherit(from) : this;
                }
            }
        }
    }
}

namespace Oxide.Plugins
{
    partial class ComputersPlus : CovalencePlugin
    {
        public static partial class EZUI
        {
            private interface IBoxComponent
            {
                Color OutlineColor { get; set; }
                int OutlinePixelWeight { get; set; }
            }

            public class BoxComponent : Component, IBoxComponent
            {
                public BoxComponent(string id) : base(id)
                {
                }

                public override Color BackgroundColor { get; set; } = StyleSheet.DEFAULT.BackgroundColorLight1;
                public Color OutlineColor { get; set; } = StyleSheet.DEFAULT.OutlineColorDark1;
                public int OutlinePixelWeight { get; set; } = 0;

                protected override Component CreateHelper()
                {
                    if (OutlinePixelWeight > 0)
                    {
                        var outline = new BasicComponent("Outline")
                        {
                            BackgroundColor = BackgroundColor == Color.TRANSPARENT ? Color.TRANSPARENT : OutlineColor,
                            PixelPadding = new Dir<int>(OutlinePixelWeight)
                        }.Create(this);
                        var content = new BasicComponent("Content")
                        {
                            BackgroundColor = BackgroundColor
                        }.Create(outline);
                        this.Content = content;
                    }
                    else
                    {
                        this.Content = this;
                    }
                    return this;
                }

                public override Component Inherit(Component from, bool recursive=false)
                {
                    var casted = (IBoxComponent)from;
                    this.OutlineColor = this.OutlineColor ?? casted.OutlineColor;
                    this.OutlinePixelWeight = casted.OutlinePixelWeight;
                    return recursive ? base.Inherit(from) : this;
                }
            }
        }
    }
}

namespace Oxide.Plugins
{
    partial class ComputersPlus : CovalencePlugin
    {
        [Command("button.click")] // button.click <token> <sfx> <command..>
        private void cmd_button_click(IPlayer player, string command, string[] args)
        {
            if (args.Length == 0 || !EZUI.ValidateToken(player, command, args[0])) { return; }
            var basePlayer= player.Object as BasePlayer;
            if (basePlayer != null && args.Length >= 2)
            {
                var sfx = args[1];
                PlaySfx(basePlayer, sfx);
                if (args.Length > 2)
                {
                    var cmd = args[2];
                    args = args.Skip(3).ToArray();
                    player.Command(cmd, args);
                }
            }
        }

        public static partial class EZUI
        {
            private interface IButtonComponent
            {
                string Command { get; set; }
            }

            public class ButtonComponent : Component, IButtonComponent, IBoxComponent, ITextComponent, IImageComponent
            {
                public ButtonComponent(string id) : base(id)
                {
                }

                public override Color BackgroundColor { get; set; } = StyleSheet.DEFAULT.BackgroundColorLight3;
                public string Command { get; set; } = "";
                public Color OutlineColor { get; set; } = StyleSheet.DEFAULT.OutlineColorDark1;
                public int OutlinePixelWeight { get; set; } = 0;
                public string Text { get; set; } = "";
                public string FontType { get; set; } = DEFAULT_FONT_TYPE;
                public int FontSize { get; set; } = DEFAULT_FONT_SIZE;
                public Color FontColor { get; set; } = StyleSheet.DEFAULT.FontColorLight1;
                public TextAnchor TextAlign { get; set; } = TextAnchor.MiddleLeft;
                public string ImageKey { get; set; }
                public string ClickSfx { get; set; } = SFX_CLICK;
                public bool ImageHidden { get; set; } = false;
                public bool AutoSizeHeight { get; set; } = false;
                public bool AutoSizeWidth { get; set; } = false;
                public Color ImageColor { get; set; } = null;

                public override Component Init(Component parent)
                {
                    if (AutoSizeHeight)
                    {
                        this.PixelHeight = FontSize + 1;
                    }
                    if (AutoSizeWidth)
                    {
                        this.PixelWidth = (int)Math.Ceiling((FontSize + 1) * 0.50f) * Text?.Length ?? 0;
                    }
                    return base.Init(parent);
                }

                protected override Component CreateHelper()
                {
                    var box = new BoxComponent("Box")
                    {
                        BackgroundColor = BackgroundColor
                    }
                    .Inherit(this)
                    .Create(this);
                    var parent = box;
                    if (ImageKey != null)
                    {
                        var image = new ImageComponent("Image"){}
                        .Inherit(this)
                        .Create(parent);
                        parent = image;
                    }
                    if (Text != null)
                    {
                        var text = new TextComponent("Text") { }
                        .Inherit(this)
                        .Create(parent);
                        parent = text;
                    }
                    
                    var button = new BasicComponent("Button") { Empty = true }.Create(parent);
                    button.Elements.Add(new CuiElement
                    {
                        Name = button.GlobalId,
                        Parent = button.ParentGlobalId,
                        Components = {
                            new CuiButtonComponent
                            {
                                Command = $"button.click {Token} {ClickSfx} {Command}",
                                Color = Color.TRANSPARENT.ToString()
                            },
                            new CuiRectTransformComponent {
                                AnchorMin = "0 0",
                                AnchorMax = "1 1"
                            }
                        }
                    });
                    return this;
                }

                public override Component Inherit(Component from, bool recursive = false)
                {
                    var casted = (IButtonComponent)from;
                    this.Command = casted.Command;
                    return recursive ? base.Inherit(from) : this;
                }
            }
        }
    }
}

namespace Oxide.Plugins
{
    partial class ComputersPlus : CovalencePlugin
    {
        #region Commands
        [Command("component.render")] // component.render <token> <globalId>
        private void cmd_component_render(IPlayer player, string command, string[] args)
        {
            if (args.Length == 0 || !EZUI.ValidateToken(player, command, args[0])){return;}
            var basePlayer= player.Object as BasePlayer;
            if (basePlayer != null && args.Length > 0)
            {
                string globalId = args[0];
                var component = EZUI.Find(basePlayer.UserIDString, globalId);
                if (component != null)
                {
                    component.Render(basePlayer);
                }
            }
        }
        [Command("component.destroy")] // component.destroy <token> <globalId>
        private void cmd_component_destroy(IPlayer player, string command, string[] args)
        {
            if (args.Length == 0 || !EZUI.ValidateToken(player, command, args[0])) { return; }
            var basePlayer= player.Object as BasePlayer;
            if (basePlayer != null && args.Length > 1)
            {
                string globalId = args[1];
                var component = EZUI.Find(basePlayer.UserIDString, globalId);
                if (component != null)
                {
                    component.Destroy(basePlayer);
                }
            }
        }
        #endregion
        public partial class EZUI
        {
            public abstract class Component
            {
                #region Constructors
                public Component(string id)
                {
                    this.LocalId = id;
                    this.Children = new HashSet<Component>();
                }
                #endregion

                #region Private Variables
                private Component _parent = null;
                private int? _pixelX = null;
                private int? _pixelY = null;
                private int? _pixelWidth = null;
                private int? _pixelHeight = null;
                private float _x = 0f;
                private float _y = 0f;
                private float _width = 1f;
                private float _height = 1f;
                private float? _size;

                private int _newPixelX;
                private int _newPixelY;
                private int _newPixelWidth;
                private int _newPixelHeight;
                private float _newX;
                private float _newY;
                private float _newWidth;
                private float _newHeight;
                #endregion

                #region Identity Properties
                public HashSet<string> Tags { get; } = new HashSet<string>();
                public string LocalId { get; set; }
                public string GlobalId { get { return Parent == null ? LocalId : $"{Parent.GlobalId}.{LocalId}"; } }
                public Component Parent { get { return _parent; } }
                public Component Content { get; set; }
                public HashSet<Component> Children { get; set; }
                #endregion

                #region Parent Properties
                public string ParentGlobalId
                {
                    get
                    {
                        return Parent == null ? "Overlay" : Parent.GlobalId;
                    }
                }
                public int ParentPixelY
                {
                    get { return Parent == null ? 0 : Parent.PixelY; }
                }
                public int ParentPixelX
                {
                    get { return Parent == null ? 0 : Parent.PixelX; }
                }
                public Dir<int> ParentPixelPadding
                {
                    get
                    {
                        return Parent == null ? new Dir<int>(0) : Parent.PixelPadding;
                    }
                }
                public int ParentPixelWidth
                {
                    get { return Parent == null ? MAX_X : Parent.PixelWidth; }
                }
                public int ParentPixelHeight
                {
                    get { return Parent == null ? MAX_Y : Parent.PixelHeight; }
                }
                #endregion

                #region Anchor and Offset Properties
                public string AnchorMin
                {
                    get
                    {
                        return $"0 0";
                    }
                }
                public string AnchorMax
                {
                    get
                    {
                        return $"0 0";
                    }
                }
                public string OffsetMin
                {
                    get { return $"{PixelX - ParentPixelX} {PixelY - ParentPixelY}"; }
                }
                public string OffsetMax
                {
                    get { return $"{PixelX - ParentPixelX + PixelWidth} {PixelY - ParentPixelY + PixelHeight}"; }
                }
                #endregion

                #region Pixel Properties
                public int PixelX { get { return _newPixelX; } set { _pixelX = value; } }
                public int PixelY { get { return _newPixelY; } set { _pixelY = value; } }
                public int PixelHeight { get { return _newPixelHeight; } set { _pixelHeight = value; } }
                public int PixelWidth { get { return _newPixelWidth; } set { _pixelWidth = value; } }
                public int PixelSize { get { return _newPixelHeight; } set { _pixelWidth = value; _pixelHeight = value; } }
                public virtual Dir<int> PixelPadding { get; set; } = new Dir<int>(0);
                public Dir<int> PixelMargin { get; set; } = new Dir<int>(0);
                public Dir<int> PixelCrop { get; set; } = new Dir<int>(0);
                #endregion

                #region Relative Properties
                public float X { get { return _newX; } set { _x = value; } }
                public float Y { get { return _newY; } set { _y = value; } }
                public float Height { get { return _newHeight; } set { _height = value; } }
                public float Width { get { return _newWidth; } set { _width = value; } }
                public float Size { get { return _newHeight; } set { _size = value; _height = value; } }
                public float Scale { protected get { return _height; } set { _height = value; _width = value; } }
                public Dir<float> Padding { get; set; }
                public Dir<float> Margin { get; set; }
                #endregion

                #region Element Properties
                public bool Empty { get; set; } = false;
                public List<CuiElement> Elements { get; set; } = new List<CuiElement>();
                public bool Transparent { get { return BackgroundColor.Alpha == 0; } set { BackgroundColor = Color.TRANSPARENT; } }
                public virtual Color BackgroundColor { get; set; } = Color.TRANSPARENT;
                public float Opacity { get { return BackgroundColor.Alpha; } set { BackgroundColor.Alpha = value; } }
                public bool Created { get; protected set; } = false;
                public bool Rendered { get; protected set; } = false;
                #endregion

                #region Positional Properties
                public virtual bool CenterX { get; set; } = false;
                public bool CenterY { get; set; } = false;
                public bool Centered { get { return CenterX && CenterY; } set { CenterX = true; CenterY = true; } }
                public Anchor? AnchorTo { private get; set; }
                public int? TopAlign { private get; set; }
                public int? BottomAlign { private get; set; }
                public int? RightAlign { private get; set; }
                public int? LeftAlign { private get; set; }
                public int Left { private get; set; } = 0;
                public int Right { private get; set; } = 0;
                public int Up { private get; set; } = 0;
                public int Down { private get; set; } = 0;
                #endregion

                #region Value Properties
                public Value TopSide
                {
                    get
                    {
                        return new Value(PixelY + PixelHeight + PixelMargin.Top, MAX_Y);
                    }
                }
                public Value BottomSide
                {
                    get
                    {
                        return new Value(PixelY - PixelMargin.Bottom, MAX_Y);
                    }
                }
                public Value LeftSide
                {
                    get
                    {
                        return new Value(PixelX - PixelMargin.Left, MAX_X);
                    }
                }
                public Value RightSide
                {
                    get
                    {
                        return new Value(PixelX + PixelWidth + PixelMargin.Right, MAX_X);
                    }
                }
                #endregion

                #region Info Properties
                public Dictionary<string, object> Info
                {
                    get
                    {
                        var info = new Info()
                        {
                            LocalId = LocalId,
                            GlobalId = GlobalId,
                            ParentId = Parent == null ? "Overlay" : Parent.GlobalId,
                            Children = $"{Children.Count}",
                            Position = $"({PixelX},{PixelY}) ({PixelX + PixelWidth},{PixelY + PixelHeight})",
                            Dimensions = $"({PixelWidth}x{PixelHeight})",
                            Proportions = $"({Math.Round(Width, 3)}x{Math.Round(Height, 3)})",
                            Padding = $"{PixelPadding}",
                            Margin = $"{PixelMargin}",
                            Color = $"{(BackgroundColor != null ? BackgroundColor.ToString() : "Null")}"
                        };
                        return JsonConvert.DeserializeObject<Dictionary<string, object>>(JsonConvert.SerializeObject(info));
                    }
                }

                public override string ToString()
                {
                    StringBuilder sb = new StringBuilder();
                    int col1 = 20;
                    int col2 = 40;
                    int num = col1 + col2 + 9;
                    sb.AppendLine();
                    sb.AppendLine(new string('#', num));
                    sb.AppendLine($"## COMPONENT - {GlobalId.ToUpper().PadRight(col1 + col2 - 9)} ##");
                    sb.AppendLine(new string('#', num));
                    foreach (var item in Info)
                    {
                        sb.AppendLine($"## {item.Key.PadLeft(col1)} | {item.Value.ToString().PadRight(col2)} ##");
                    }
                    sb.AppendLine(new string('#', num));
                    sb.AppendLine();
                    return sb.ToString();
                }
                #endregion

                #region Methods
                public virtual Component Init(Component parent)
                {
                    this.Content = null;
                    this.Children = new HashSet<Component>();
                    this._parent = parent?.Content == null ? parent : parent.Content;

                    // Calculate boundaries
                    var bounds = new BoundingBox(ParentPixelY + ParentPixelPadding.Bottom, ParentPixelX + ParentPixelPadding.Left, ParentPixelY + ParentPixelHeight - ParentPixelPadding.Top, ParentPixelX + ParentPixelWidth - ParentPixelPadding.Right); // includes padding

                    // Init bounds
                    bounds.Bottom = _pixelY ?? ParentPixelY;
                    bounds.Left = _pixelX ?? ParentPixelX;
                    bounds.Height = _pixelHeight ?? ParentPixelHeight; // takes padding into account
                    bounds.Width = _pixelWidth ?? ParentPixelWidth;

                    // Apply relative transformations
                    bounds.Bottom += (int)Math.Round(bounds.Height * _y);
                    bounds.Left += (int)Math.Round(bounds.Width * _x);
                    bounds.Height = (int)Math.Round(bounds.Height * _height);
                    bounds.Width = _size != null ? bounds.Height : (int)Math.Round(bounds.Width * _width);

                    // Apply positional modifications
                    if (AnchorTo != null)
                    {
                        switch (AnchorTo)
                        {
                            case Anchor.Left:
                                LeftAlign = bounds.MinLeft;
                                break;
                            case Anchor.Right:
                                RightAlign = bounds.MaxRight;
                                break;
                            case Anchor.TopCenter:
                                TopAlign = bounds.MaxTop;
                                CenterX = true;
                                break;
                            case Anchor.TopLeft:
                                TopAlign = bounds.MaxTop;
                                LeftAlign = bounds.MinLeft;
                                break;
                            case Anchor.TopRight:
                                TopAlign = bounds.MaxTop;
                                RightAlign = bounds.MaxRight;
                                break;
                            case Anchor.MiddleRight:
                                CenterY = true;
                                RightAlign = bounds.MaxRight;
                                break;
                            case Anchor.MiddleLeft:
                                CenterY = true;
                                LeftAlign = bounds.MinLeft;
                                break;
                            case Anchor.MiddleCenter:
                                Centered = true;
                                break;
                            case Anchor.BottomLeft:
                                BottomAlign = bounds.MinBottom;
                                LeftAlign = bounds.MinLeft;
                                break;
                            case Anchor.BottomRight:
                                BottomAlign = bounds.MinBottom;
                                RightAlign = bounds.MaxRight;
                                break;
                        }
                    }
                    if (CenterX)
                    {
                        var gapX = bounds.GapX / 2;
                        bounds.Left = bounds.MinLeft + gapX;
                        bounds.Right = bounds.MaxRight - gapX;
                    }
                    if (CenterY)
                    {
                        var gapY = bounds.GapY / 2;
                        bounds.Bottom = bounds.MinBottom + gapY;
                        bounds.Top = bounds.MaxTop - gapY;
                    }
                    // Right and Left Align
                    if (RightAlign != null && LeftAlign != null)
                    {
                        bounds.Right = (int)RightAlign;
                        bounds.Left = (int)LeftAlign;
                    }
                    else if (RightAlign != null)
                    {
                        var width = bounds.Width;
                        bounds.Right = (int)RightAlign;
                        bounds.Left = bounds.Right - width;
                    }
                    else if (LeftAlign != null)
                    {
                        var width = bounds.Width;
                        bounds.Left = (int)LeftAlign;
                        bounds.Right = bounds.Left + width;
                    }
                    // Top and Bottom Align
                    if (TopAlign != null && BottomAlign != null)
                    {
                        bounds.Top = (int)TopAlign;
                        bounds.Bottom = (int)BottomAlign;
                    }
                    else if (TopAlign != null)
                    {
                        var height = bounds.Height;
                        bounds.Top = (int)TopAlign;
                        bounds.Bottom = bounds.Top - height;
                    }
                    else if (BottomAlign != null)
                    {
                        var height = bounds.Height;
                        bounds.Bottom = (int)BottomAlign;
                        bounds.Top = bounds.Bottom + height;
                    }

                    // Pixel cropping
                    bounds.Left += PixelCrop.Left;
                    bounds.Right -= PixelCrop.Right;
                    bounds.Bottom += PixelCrop.Bottom;
                    bounds.Top -= PixelCrop.Top;

                    // Pixel nudging
                    bounds.Left -= Left;
                    bounds.Right -= Left;
                    bounds.Left += Right;
                    bounds.Right += Right;
                    bounds.Bottom -= Down;
                    bounds.Top -= Down;
                    bounds.Bottom += Up;
                    bounds.Top += Up;

                    // Set property values
                    this._newPixelX = bounds.Left;
                    this._newPixelY = bounds.Bottom;
                    this._newPixelWidth = bounds.Width;
                    this._newPixelHeight = bounds.Height;
                    this._newX = (float)bounds.Left / (ParentPixelX + ParentPixelWidth);
                    this._newY = (float)bounds.Bottom / (ParentPixelY + ParentPixelHeight);
                    this._newWidth = (float)bounds.Width / ParentPixelWidth;
                    this._newHeight = (float)bounds.Height / ParentPixelHeight;
                    this.Parent?.AddChild(this);
                    return this;
                }

                public Component Tag(string tag)
                {
                    this.Tags.Add(tag);
                    return this;
                }
                public Component Tag(object tag)
                {
                    return Tag(tag.ToString());
                }


                public Component Create()
                {
                    return Create(this.Parent);
                }

                public Component Create(Component parent)
                {
                    this.Created = false;
                    Init(parent);
                    this.Elements = CreateBaseElements();
                    var component = CreateHelper();
                    component.Created = true;
                    return component;
                }

                public Component CreateRecursively()
                {
                    return this.CreateRecursively(this.Parent);
                }

                public Component CreateRecursively(Component parent)
                {
                    var children = this.Children;
                    var comp = this.Create(parent);
                    foreach (var child in children)
                    {
                        child?.CreateRecursively(comp);
                    }
                    return comp;
                }

                protected abstract Component CreateHelper();

                public virtual Component Inherit(Component from, bool recursive=false)
                {
                    this.BackgroundColor = this.BackgroundColor ?? from.BackgroundColor;
                    return this;
                }

                protected virtual List<CuiElement> CreateBaseElements()
                {
                    var elements = new List<CuiElement>();
                    if (!Empty)
                    {
                        elements.Add(new CuiElement
                        {
                            Name = GlobalId,
                            Parent = ParentGlobalId,
                            Components ={
                            new CuiImageComponent {
                                Color = BackgroundColor.ToString()
                            },
                            new CuiRectTransformComponent {
                                AnchorMin = this.AnchorMin,
                                AnchorMax = this.AnchorMax,
                                OffsetMin = this.OffsetMin,
                                OffsetMax = this.OffsetMax
                            }
                        }
                        });
                    }
                    return elements;
                }

                public virtual Component Include(Component[] components)
                {
                    if (Content == null)
                    {
                        this.Children.UnionWith(components);
                    }
                    else
                    {
                        this.Content.Children.UnionWith(components);
                    }
                    return this;
                }

                public virtual void AddChild(Component child)
                {
                    if (Content == null)
                    {
                        this.Children.Add(child);
                    }
                    else
                    {
                        this.Content.Children.Add(child);
                    }
                }

                public void Render(BasePlayer basePlayer)
                {
                    UnloadNested(basePlayer.UserIDString, this);
                    var elements = RenderHelper(basePlayer, new List<CuiElement>());
                    CuiHelper.DestroyUi(basePlayer, GlobalId);
                    CuiHelper.AddUi(basePlayer, elements);
                    Rendered = true;
                }

                private List<CuiElement> RenderHelper(BasePlayer basePlayer, List<CuiElement> elements)
                {
                    var component = OnRender(basePlayer);
                    elements.AddRange(component.Elements);
                    EZUI.Load(basePlayer.UserIDString, component);
                    foreach(var tag in component.Tags)
                    {
                        EZUI.Tag(basePlayer, component, tag);
                    }
                    foreach (var child in component.Children)
                    {
                        elements = child.RenderHelper(basePlayer, elements);
                    }
                    return elements;
                }
                public List<Component> GetNestedChildren()
                {
                    return GetNestedChildrenHelper(new List<Component>());
                }

                private List<Component> GetNestedChildrenHelper(List<Component> children)
                {
                    children.AddRange(this.Children);
                    foreach (var child in this.Children)
                    {
                        children = child.GetNestedChildrenHelper(children);
                    }
                    return children;
                }


                public void Destroy(BasePlayer basePlayer)
                {
                    var component = OnDestroy(basePlayer);
                    CuiHelper.DestroyUi(basePlayer, GlobalId);
                    EZUI.UnloadNested(basePlayer.UserIDString, component);
                }

                public TComponent As<TComponent>() where TComponent : Component
                {
                    return (TComponent)this;
                }

                #endregion

                #region Protected Hooks
                protected virtual Component OnRender(BasePlayer basePlayer)
                {
                    return this;
                }

                protected virtual Component OnDestroy(BasePlayer basePlayer)
                {
                    return this;
                }
                #endregion
                #region HashSet overrides
                public override int GetHashCode()
                {
                    return this.GlobalId.GetHashCode();
                }
                public override bool Equals(object obj) 
                {
                    if ((obj == null) || !this.GetType().Equals(obj.GetType()))
                    {
                        return false;
                    }
                    else
                    {
                        Component c = (Component)obj;
                        return GlobalId == c.GlobalId;
                    }
                }
                #endregion
            }
        }
    }
}

namespace Oxide.Plugins
{
    partial class ComputersPlus : CovalencePlugin
    {
        [Command("ezui.call")] // ezui.call <token> <function> <args..>
        private void cmd_ezui_call(IPlayer player, string command, string[] args)
        {
            if (args.Length == 0 || !EZUI.ValidateToken(player, command, args[0])) { return; }
            if (args.Length >= 3)
            {
                string function = args[1];
                if (EZUI.FunctionIsRegisterd(function))
                {
                    args = args.Skip(2).ToArray();
                    Call(function, args);
                }
            }
        }

        public partial class EZUI
        {

            #region Static
            private readonly static DoubleDictionary<string, string, Component> loaded = new DoubleDictionary<string, string, Component>();
            private readonly static DoubleDictionary<string, string, Component> tagged = new DoubleDictionary<string, string, Component>();
            private readonly static int MAX_X = 1280;
            private readonly static int MAX_Y = 720;
            private readonly static string DEFAULT_FONT_TYPE = "RobotoCondensed-Regular.ttf";
            private readonly static int DEFAULT_FONT_SIZE = 12;
            private static string _token = "";
            private readonly static List<string> RegisteredFunctions = new List<string>();
            internal static string Token
            {
                get
                {
                    return _token;
                }
            }

            public static void RegisterFunction(string function)
            {
                RegisteredFunctions.Add(function);
            }

            public static bool FunctionIsRegisterd(string function)
            {
                return RegisteredFunctions.Contains(function);
            }

            public static void GenerateToken()
            {
                _token = Guid.NewGuid().ToString();
            }

            public static bool ValidateToken(IPlayer player, string command, string token)
            {
                if (token == Token)
                {
                    return true;
                }
                PLUGIN.PrintWarning($"Player '{player.Name}' attempted to use command '{command}' with an invalid token");
                return false;
            }

            public static void Tag(BasePlayer basePlayer, Component component, string tag)
            {
                tagged.Set(basePlayer.UserIDString, $"{tag}.{component.LocalId}", component);
            }

            public static Component Get(BasePlayer basePlayer, object tag, string localId)
            {
                return tagged.Get(basePlayer.UserIDString, $"{tag}.{localId}");
            }

            private static void Load(string userIdString, Component ui)
            {
                loaded.Set(userIdString, ui.GlobalId, ui);
            }

            public static void Unload(string userIdString, Component ui)
            {
                Unload(userIdString, ui.GlobalId);
            }

            public static void Unload(string userIdString, string globalId)
            {
                loaded.Delete(userIdString, globalId);
            }

            public static void UnloadNested(string userIdString, Component ui)
            {
                var filtered = loaded.GetA(userIdString).Where(x => x.Key.StartsWith(ui.GlobalId)).Select(x => x.Key).ToList();
                for (int i = 0; i < filtered.Count; i++)
                {
                    Unload(userIdString, filtered[i]);;
                }
            }

            public static void DestroyAll(BasePlayer basePlayer)
            {
                var all = loaded.GetA(basePlayer.UserIDString).Values.ToList();
                for (int i = 0; i < all.Count; i++)
                {
                    var baseUI = all[i];
                    baseUI?.Destroy(basePlayer);
                }
            }

            public static List<Component> GetAll(BasePlayer basePlayer)
            {
                return loaded.GetA(basePlayer.UserIDString).Values.ToList();
            }

            public static string PrintLoaded(BasePlayer basePlayer)
            {
                StringBuilder sb = new StringBuilder();
                sb.AppendLine();
                var all = loaded.GetA(basePlayer.UserIDString);
                int i = 0;
                foreach (var entry in all)
                {
                    var baseUI = entry.Value;
                    string index = $"[{i}]";
                    sb.AppendLine($"{index.PadLeft(5)} {baseUI.GlobalId}");
                    i++;
                }
                sb.AppendLine();
                return sb.ToString();
            }

            public static Component Find(string userIdString, string globalId)
            {
                return loaded.Get(userIdString, globalId);
            }

            public static Component Find(BasePlayer basePlayer, string globalId)
            {
                return Find(basePlayer.UserIDString, globalId);
            }

            public static Component Query(string userIdString, string localId)
            {
                return loaded.GetA(userIdString).Where(x => x.Key.Contains(localId)).FirstOrDefault().Value;
            }

            public static Component Query(BasePlayer basePlayer, string localId)
            {
                return Query(basePlayer.UserIDString, localId);
            }
            #endregion

            #region Classes
            public enum Anchor
            {
                TopLeft, TopCenter, TopRight, MiddleLeft, MiddleCenter, MiddleRight, BottomLeft, BottomCenter, BottomRight, Top, Right, Bottom, Left
            }

            public class Info
            {
                public string LocalId { get; set; }
                public string GlobalId { get; set; }
                public string ParentId { get; set; }
                public string Position { get; set; }
                public string Children { get; set; }
                public string Dimensions { get; set; }
                public string Proportions { get; set; }
                public string Padding { get; set; }
                public string Margin { get; set; }
                public string Color { get; set; }
            }

            public class Color
            {
                public static Color WHITE = new Color(1f, 1f, 1f);
                public static Color RED = new Color(1f, 0f, 0f);
                public static Color GREEN = new Color(0f, 1f, 0f);
                public static Color BLUE = new Color(0f, 0f, 1f);
                public static Color BLACK = new Color(0f, 0f, 0f);
                public static Color TRANSPARENT = new Color(0f, 0f, 0f, 0f);

                public Color() { }

                public Color(string colorString, char delim = ' ')
                {
                    try
                    {
                        string[] split = colorString.Split(delim);
                        Red = float.Parse(split[0]);
                        Green = float.Parse(split[1]);
                        Blue = float.Parse(split[2]);
                        Alpha = float.Parse(split[3]);
                    }
                    catch (Exception)
                    {
                        PLUGIN.PrintError($"Invalid color string '{colorString}'");
                    }
                }

                public Color(int r, int g, int b)
                {
                    Red = r / 255f;
                    Green = g / 255f;
                    Blue = b / 255f;
                }

                public Color(float r, float g, float b)
                {
                    Red = r;
                    Green = g;
                    Blue = b;
                }

                public Color(float r, float g, float b, float a)
                {
                    Red = r;
                    Green = g;
                    Blue = b;
                    Alpha = a;
                }

                public float Red
                {
                    get; set;
                } = 1f;

                public float Green
                {
                    get; set;
                } = 1f;

                public float Blue
                {
                    get; set;
                } = 1f;

                public float Alpha
                {
                    get; set;
                } = 1f;

                public override string ToString()
                {
                    return $"{Red} {Green} {Blue} {Alpha}";
                }
            }

            public class Dir<T>
            {
                public readonly static Dir<int> ZERO = new Dir<int>(0, 0, 0, 0);

                public Dir() { }

                public Dir(T all) : this(all, all, all, all) { }

                public Dir(T top, T right, T bottom, T left)
                {
                    Top = top;
                    Right = right;
                    Bottom = bottom;
                    Left = left;
                }

                public Dir<float> ConvertToFloat()
                {
                    return new Dir<float>()
                    {
                        Top = CastToFloat(Top) / MAX_Y,
                        Right = CastToFloat(Right) / MAX_X,
                        Bottom = CastToFloat(Bottom) / MAX_Y,
                        Left = CastToFloat(Left) / MAX_X
                    };
                }

                public Dir<int> ConvertToInt()
                {
                    return new Dir<int>()
                    {
                        Top = (int)Math.Round(CastToFloat(Top) * MAX_Y),
                        Right = (int)Math.Round(CastToFloat(Right) * MAX_X),
                        Bottom = (int)Math.Round(CastToFloat(Bottom) * MAX_Y),
                        Left = (int)Math.Round(CastToFloat(Left) * MAX_X)
                    };
                }

                private float CastToFloat(T value)
                {
                    return float.Parse(((object)value).ToString());
                }

                private int CastToInt(T value)
                {
                    return (int)Math.Round(CastToFloat(value));
                }

                public T Top { get; set; }
                public T Right { get; set; }
                public T Bottom { get; set; }
                public T Left { get; set; }

                public override string ToString()
                {
                    return $"{Top} {Right} {Bottom} {Left}";
                }
            }

            public class Value
            {
                public Value() { }
                public Value(int pixels, int max) {
                    Pixels = pixels;
                    Percent = pixels / max;
                }
                public float Percent { get; }
                public int Pixels { get; }
            }

            public class BoundingBox
            {
                private int _left;
                private int _right;
                private int _bottom;
                private int _top;
                public BoundingBox(int minBottom, int minLeft, int maxTop, int maxRight) 
                {
                    this.MinBottom = minBottom;
                    this.MinLeft = minLeft;
                    this.MaxTop = maxTop;
                    this.MaxRight = maxRight;
                    _bottom = minBottom;
                    _left = minLeft;
                    _top = maxTop;
                    _right = maxRight;
                }
                public int GapX
                {
                    get
                    {
                        return (_left - MinLeft) + (MaxRight - _right);
                    }
                }
                public int GapY
                {
                    get
                    {
                        return (_bottom - MinBottom) + (MaxTop - _top);
                    }
                }
                public int MaxTop { get; set; }
                public int MaxRight { get; set; }
                public int MinBottom { get; set; }
                public int MinLeft { get; set; }
                public int Bottom
                {
                    get
                    {
                        return _bottom;
                    }
                    set
                    {
                        _bottom = Math.Max(MinBottom, value);
                    }
                }
                public int Left
                {
                    get
                    {
                        return _left;
                    }
                    set
                    {
                        _left = Math.Max(MinLeft, value);
                    }
                }
                public int Right
                {
                    get
                    {
                        return _right;
                    }
                    set
                    {
                        _right = Math.Min(MaxRight, value);
                    }
                }
                public int Top
                {
                    get
                    {
                        return _top;
                    }
                    set
                    {
                        _top = Math.Min(MaxTop, value);
                    }
                }
                public int Height
                {
                    get { return Math.Max(0, Top - Bottom); }
                    set { Top = Bottom + value; }
                }
                public int Width
                {
                    get { return Math.Max(0, Right - Left); }
                    set { Right = Left + value; }
                }

                public override string ToString()
                {
                    return $"{Top} {Right} {Bottom} {Left}";
                }
            }

            #endregion
        }
    }
}

namespace Oxide.Plugins
{
	partial class ComputersPlus : CovalencePlugin
	{
		public static partial class EZUI
        {
            private interface IImageComponent
            {
                string ImageKey { get; set; }
                bool ImageHidden { get; set; }
                Color ImageColor { get; set; }
            }

            public class ImageComponent : Component, IBoxComponent, IImageComponent
            {
                public ImageComponent(string id) : base(id)
                {
                }

                public override Color BackgroundColor { get; set; } = Color.TRANSPARENT;
                public Color OutlineColor { get; set; } = StyleSheet.DEFAULT.BackgroundColorDark1;
                public int OutlinePixelWeight { get; set; } = 0;
                public string ImageKey { get; set; } = "";
                public bool ImageHidden { get; set; } = false;
                public Color ImageColor { get; set; } = null;

                protected override Component CreateHelper()
                {
                    var box = new BoxComponent("Box")
                    {
                        BackgroundColor = BackgroundColor
                    }
                    .Inherit(this)
                    .Create(this);
                    var image = new BasicComponent("Image") { Empty = true }.Create(box);
                    if (!ImageHidden)
                    {

                        var element = new CuiElement
                        {
                            Name = image.GlobalId,
                            Parent = image.ParentGlobalId,
                            Components ={
                                new CuiRectTransformComponent {
                                    AnchorMin = $"0 0",
                                    AnchorMax = $"1 1"
                                }
                            }
                        };
                        if (ImageColor == null)
                        {
                            element.Components.Add(new CuiRawImageComponent
                            {
                                Png = PLUGIN.ImageLibrary?.Call<string>("GetImage", ImageKey)
                            });
                        }
                        else
                        {
                            element.Components.Add(new CuiImageComponent
                            {
                                Png = PLUGIN.ImageLibrary?.Call<string>("GetImage", ImageKey),
                                Color = ImageColor.ToString()
                            });
                        }
                        image.Elements.Add(element);
                    }
                    return this;
                }

                public override Component Inherit(Component from, bool recursive = false)
                {
                    var casted = (IImageComponent)from;
                    this.ImageKey = casted.ImageKey;
                    this.ImageHidden = casted.ImageHidden;
                    return recursive ? base.Inherit(from) : this;
                }
            }
        }
	}
}

namespace Oxide.Plugins
{
    partial class ComputersPlus : CovalencePlugin
    {
        #region Commands
        [Command("input.data")] // input.data <token> <globalId> <commandLength> <command> <data..>
        private void cmd_input_data(IPlayer player, string command, string[] args)
        {
            if (args.Length == 0 || !EZUI.ValidateToken(player, command, args[0])) { return; }
            var basePlayer= player.Object as BasePlayer;
            if (basePlayer != null && args.Length >= 4)
            {
                string globalId = args[1];
                var component = EZUI.Find(basePlayer.UserIDString, globalId);
                if (component != null)
                {
                    int cmdLength = 0;
                    var cmdArgs = new string[] { };
                    var value = "";
                    if (int.TryParse(args[3], out cmdLength) && cmdLength > 0)
                    {
                        args = args.Skip(3).ToArray();
                        cmdArgs = args.Take(cmdLength).ToArray();
                        args = args.Skip(cmdLength).ToArray();
                    }
                    else
                    {
                        args = args.Skip(3).ToArray();
                    }
                    if (args.Length > 0)
                    {
                        value = string.Join(" ", args);
                        ((EZUI.InputComponent)component).Data = value;
                    }
                    if (cmdArgs.Length > 0)
                    {
                        var cmd = cmdArgs[0];
                        var newCmdArgs = cmdArgs.Skip(1).ToList();
                        newCmdArgs.AddRange(value.Split(' '));
                        player.Command(cmd, newCmdArgs.ToArray());
                    }
                }
            }
        }
        #endregion

        public static partial class EZUI
        {
            private interface IInputComponent
            {
                string Command { get; set; }
                int CharsLimit { get; set; }
            }

            public class InputComponent : Component, IInputComponent, IBoxComponent, ITextComponent
            {
                public InputComponent(string id) : base(id)
                {
                }

                public override Dir<int> PixelPadding { get; set; } = new Dir<int>(0);
                public override Color BackgroundColor { get; set; } = Color.WHITE;
                public string Command { get; set; } = "";
                public int CharsLimit { get; set; } = 6;
                public string Text { get; set; } = null;
                public string FontType { get; set; } = StyleSheet.DEFAULT.FontType1;
                public int FontSize { get; set; } = 12;
                public Color FontColor { get; set; } = StyleSheet.DEFAULT.FontColorDark1;
                public TextAnchor TextAlign { get; set; } = TextAnchor.MiddleLeft;
                public Color OutlineColor { get; set; } = StyleSheet.DEFAULT.OutlineColorDark1;
                public int OutlinePixelWeight { get; set; } = 0;
                public bool AutoSizeHeight { get; set; } = false;
                public bool AutoSizeWidth { get; set; } = false;
                public string Data { get; set; } = null;

                private int CommandLength
                {
                    get
                    {
                        return string.IsNullOrEmpty(Command) ? 0 : Command.Split(' ').Length;
                    }
                }

                protected override Component CreateHelper()
                {
                    var box = new BoxComponent("Input")
                    {
                        BackgroundColor = this.Parent?.BackgroundColor
                    }
                    .Inherit(this)
                    .Create(this);
                    var parent = box;
                    if (Text != null)
                    {
                        var label = new TextComponent("Label")
                        {
                            BackgroundColor = Color.TRANSPARENT,
                            AnchorTo = Anchor.TopLeft,
                            Text = Text,
                            AutoSizeHeight = true,
                            PixelMargin = new Dir<int>(0, 0, 5, 0)
                        }.Create(box);
                        var body = new BoxComponent("Body")
                        {
                            TopAlign = label.BottomSide.Pixels,
                            BackgroundColor = BackgroundColor,
                            PixelPadding = new Dir<int>(5)
                        }.Create(box);
                        parent = body;
                    }
                    var input = new BasicComponent("Typer") { Empty = true }.Create(parent);
                    input.Elements.Add(new CuiElement
                    {
                        Name = input.GlobalId,
                        Parent = parent.GlobalId,
                        Components = {
                            new CuiInputFieldComponent
                            {
                                CharsLimit = CharsLimit,
                                Command = $"input.data {Token} {GlobalId} {CommandLength} {Command}",
                                Font = FontType,
                                FontSize = FontSize,
                                Color = FontColor.ToString(),
                                Align = TextAlign
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = input.AnchorMin,
                                AnchorMax = input.AnchorMax,
                                OffsetMin = input.OffsetMin,
                                OffsetMax = input.OffsetMax
                            }
                        }
                    });
                    return this;
                }
            }
        }
    }
}

namespace Oxide.Plugins
{
    partial class ComputersPlus : CovalencePlugin
    {
        public static partial class EZUI
        {
            public enum LayoutFlow
            {
                Horizontal,
                Vertical,
                HorizontalReverse,
                VerticalReverse
            }

            private interface ILayoutComponent
            {
                List<Component> Entries { get; set; }
                LayoutFlow LayoutFlow { get; set; }
                int RowCount { get; set; }
                int ColCount { get; set; }
                int Page { get; }
                Dir<int> EntryPixelPadding { get; set; }
            }

            public class LayoutComponent : Component, IBoxComponent, ILayoutComponent
            {
                public LayoutComponent(string id) : base(id)
                {
                }

                public override Color BackgroundColor { get; set; } = Color.TRANSPARENT;
                public Color OutlineColor { get; set; } = StyleSheet.DEFAULT.BackgroundColorDark1;
                public int OutlinePixelWeight { get; set; } = 1;
                public List<Component> Entries { get; set; } = new List<Component>();
                public LayoutFlow LayoutFlow { get; set; } = LayoutFlow.Horizontal;
                public int RowCount { get; set; } = 1;
                public int ColCount { get; set; } = 1;
                public Dir<int> EntryPixelPadding { get; set; } = new Dir<int>(0);
                public int Page { get; internal set; } = 1;
                private Component ListContent { get; set; } = null;
                public int MaxPage { get { return Math.Max(1, (int)Math.Ceiling((float)Entries.Count / (RowCount * ColCount))); } }
                public PaginatorComponent Paginator { get; internal set; }


                protected override Component CreateHelper()
                {
                    var box = CreateListContent();
                    this.ListContent = box;
                    return this;
                }

                private Component CreateListContent()
                {
                    var box = new BoxComponent("Layout")
                    {
                        BackgroundColor = BackgroundColor
                    }.Inherit(this).Create(this);
                    return box;
                }

                private void CreateEntries()
                {
                    var box = this.ListContent;
                    int pixelWidth = box.Content.PixelWidth / ColCount;
                    int pixelHeight = box.Content.PixelHeight / RowCount;
                    int startX = box.Content.PixelX + EntryPixelPadding.Right;
                    int startY = box.Content.PixelY + box.Content.PixelHeight - pixelHeight - EntryPixelPadding.Bottom;
                    int pixelX = startX;
                    int pixelY = startY;
                    int i = (Page - 1) * RowCount * ColCount;
                    int startI = i;
                    int count = RowCount * ColCount;
                    int row = 0;
                    int col = 0;
                    foreach (var entry in Entries.Skip(startI).Take(count))
                    {
                        var flex = new BasicComponent($"{i}")
                        {
                            PixelX = pixelX,
                            PixelY = pixelY,
                            PixelWidth = pixelWidth,
                            PixelHeight = pixelHeight,
                            PixelPadding = new Dir<int>(0, EntryPixelPadding.Right, EntryPixelPadding.Bottom, 0),
                            BackgroundColor = Color.TRANSPARENT
                        }.Create(box);
                        CreateEntry(flex, entry);

                        if (col < ColCount - 1)
                        {
                            col++;
                            pixelX += pixelWidth;
                        }
                        else
                        {
                            row++;
                            col = 0;
                            pixelX = startX;
                            pixelY -= flex.PixelHeight;
                        };
                        if (row >= RowCount)
                        {
                            break;
                        }
                        i++;
                    }
                }

                public void CreateEntry(Component parent, Component entry, int i = 0)
                {
                    var children = entry.Children;
                    var e = entry.Create(parent);
                    foreach (var child in children)
                    {
                        CreateEntry(e, child, i++);
                    }
                }
                protected override Component OnRender(BasePlayer basePlayer)
                {
                    var c = CreateRecursively().As<EZUI.LayoutComponent>();
                    c.CreateEntries();
                    if (this.Paginator != null)
                    {
                        Paginator.MaxPage = MaxPage;
                        Paginator.Create().Render(basePlayer);
                    }
                    return this;
                }

                public void ClearEntries()
                {
                    this.Entries.Clear();
                }

                public override void AddChild(Component child)
                {
                    if (Created && child.LocalId != "Layout")
                    {
                        Entries.Add(child);
                        if (this.Paginator != null)
                        {
                            this.Paginator.MaxPage = MaxPage;
                        }
                    }
                    else
                    {
                        base.AddChild(child);
                    }
                }

                public LayoutComponent SetPaginator(PaginatorComponent paginator)
                {
                    this.Paginator = paginator;
                    if (Paginator.Layout == null)
                    {
                        Paginator.SetLayout(this);
                    }
                    return this;
                }
            }
        }
    }
}

namespace Oxide.Plugins
{
    partial class ComputersPlus : CovalencePlugin
    {
        [Command("page.set")] // page.set <token> <paginatorId> <layoutId> <page> 
        private void cmd_page_set(IPlayer player, string command, string[] args)
        {
            if (args.Length == 0 || !EZUI.ValidateToken(player, command, args[0])) { return; }
            args = args.Skip(1).ToArray();
            BasePlayer basePlayer = player.Object as BasePlayer;
            int page;
            if (args.Length >= 3 && int.TryParse(args[2], out page) && page > 0)
            {
                string pagId = args[0];
                string layoutId = args[1];
                var pag = (EZUI.PaginatorComponent)EZUI.Find(basePlayer.UserIDString, pagId.ToString());
                if (pag.Page != page)
                {
                    var layout = (EZUI.LayoutComponent)EZUI.Find(basePlayer.UserIDString, layoutId.ToString());
                    if (pag != null && layout != null && page <= layout.MaxPage)
                    {
                        pag.UpdatePageAndRender(basePlayer, page);
                    }
                }
            }
        }

        public static partial class EZUI
        {
            private interface IPaginatorComponent
            {
                LayoutComponent Layout { get; }
                int Page { get; }
                int MaxPage { get; }
            }

            public class PaginatorComponent : Component, IPaginatorComponent, IBoxComponent, ITextComponent
            {
                public PaginatorComponent(string id) : base(id)
                {
                }

                public override Color BackgroundColor { get; set; } = StyleSheet.DEFAULT.BackgroundColorLight2;
                public Color OutlineColor { get; set; } = StyleSheet.DEFAULT.BackgroundColorDark1;
                public int OutlinePixelWeight { get; set; } = 0;
                public List<Component> Entries { get; set; }
                public string Text { get; set; }
                public string FontType { get; set; } = DEFAULT_FONT_TYPE;
                public int FontSize { get; set; } = 12;
                public Color FontColor { get; set; } = StyleSheet.DEFAULT.FontColorDark1;
                public TextAnchor TextAlign { get; set; } = TextAnchor.MiddleCenter;
                public LayoutComponent Layout { get; internal set; }
                public int Page { get; internal set; } = 1;
                public int MaxPage { get; set; } = 1;
                public bool AutoSizeHeight { get; set; } = false;
                public bool AutoSizeWidth { get; set; } = true;

                protected override Component CreateHelper()
                {
                    var box = new BoxComponent("Box")
                    {
                        BackgroundColor = BackgroundColor
                    }
                    .Inherit(this)
                    .Create(this);
                    var left = new ButtonComponent("Left")
                    {
                        Command = $"page.set {Token} {GlobalId} {Layout?.GlobalId} {(Page > 1 ? Page - 1 : 1)}",
                        PixelWidth = 60,
                        Text = "<<",
                        BackgroundColor = StyleSheet.DEFAULT.BackgroundColorLight3,
                        TextAlign = TextAlign,
                        FontType = FontType,
                        FontSize = 14,
                        FontColor = FontColor,
                        AnchorTo = Anchor.MiddleLeft
                    }.Create(box);
                    var right = new ButtonComponent("Right")
                    {
                        Command = $"page.set {Token} {GlobalId} {Layout?.GlobalId} {(Page + 1)}",
                        PixelWidth = 60,
                        BackgroundColor = StyleSheet.DEFAULT.BackgroundColorLight3,
                        FontType = FontType,
                        FontSize = 14,
                        FontColor = FontColor,
                        Text = ">>",
                        TextAlign = TextAlign,
                        AnchorTo = Anchor.MiddleRight
                    }.Create(box);
                    var text = new TextComponent("Text")
                    {
                        Text = $"{Page}/{MaxPage}",
                        Centered = true,
                        TextAlign = TextAlign
                    }.Inherit(this).Create(box);

                    return this;
                }

                public PaginatorComponent SetLayout(LayoutComponent layout)
                {
                    this.Layout = layout;
                    if (Layout.Paginator == null)
                    {
                        Layout.SetPaginator(this);
                    }
                    return this;
                }

                public PaginatorComponent UpdatePageAndRender(BasePlayer basePlayer, int page = 0)
                {
                    if (page <= 0)
                    {
                        page = Page;
                    }
                    this.MaxPage = Layout.MaxPage;
                    this.Page = Math.Min(page, MaxPage);
                    this.Layout.Page = Page;
                    Layout.Create().Render(basePlayer);
                    this.Create().Render(basePlayer);
                    return this;
                }
            }
        }
    }
}

namespace Oxide.Plugins
{
    partial class ComputersPlus : CovalencePlugin
    {
        public static partial class EZUI
        {
            public class StyleSheet
            {
                #region Defaults
                public static readonly StyleSheet DEFAULT = new StyleSheet();
                #endregion
                #region Home Colors
                public Color HomeBackgroundColor { get; set; } = new Color(0.125f, 0.549f, 0.443f);
                #endregion
                #region Background Colors
                public Color BackgroundColorLight1 { get; set; } = new Color(200, 200, 200);
                public Color BackgroundColorLight2 { get; set; } = new Color(185, 185, 185);
                public Color BackgroundColorLight3 { get; set; } = new Color(170, 170, 170);
                public Color BackgroundColorLight4 { get; set; } = new Color(155, 155, 155);
                public Color BackgroundColorDark1 { get; set; } = new Color(42, 0, 255);
                public Color BackgroundColorDark2 { get; set; } = new Color(42, 0, 255);
                public Color BackgroundColorDark3 { get; set; } = new Color(42, 0, 255);
                public Color BackgroundColorDark4 { get; set; } = new Color(42, 0, 255);
                public Color BackgroundColorHighlight1 { get; set; } = new Color(255, 240, 150);
                #endregion
                #region Outline Colors
                public Color OutlineColorLight1 { get; set; } = new Color(255, 255, 255);
                public Color OutlineColorDark1 { get; set; } = new Color(0, 0, 0);
                #endregion
                #region Font Colors
                public Color FontColorLight1 { get; set; } = new Color(255, 255, 255);
                public Color FontColorLight2 { get; set; } = new Color(220, 220, 220);
                public Color FontColorDark1 { get; set; } = new Color(0, 0, 0);
                public Color FontColorDark2 { get; set; } = new Color(40, 40, 40);
                #endregion
                #region Font Types
                public string FontType1 { get; set; } = "RobotoCondensed-Regular.ttf";
                public string FontType2 { get; set; } = "RobotoCondensed-Bold.ttf";
                #endregion
                #region Font Size
                public int FontSize1 { get; set; } = 14;
                public int FontSize2 { get; set; } = 12;
                public int FontSize3 { get; set; } = 10;
                #endregion
            }
        }
    }
}

namespace Oxide.Plugins
{
    partial class ComputersPlus : CovalencePlugin
    {
        public static partial class EZUI
        {
            private interface ITextComponent
            {
                string Text { get; set; }
                string FontType { get; set; }
                int FontSize { get; set; }
                Color FontColor { get; set; }
                TextAnchor TextAlign { get; set; }
                bool AutoSizeHeight { get; set; }
                bool AutoSizeWidth { get; set; }
            }

            public class TextComponent : Component, ITextComponent, IBoxComponent
            {
                public TextComponent(string id) : base(id)
                {
                }

                public override Color BackgroundColor { get; set; } = Color.TRANSPARENT;
                public string Text { get; set; } = "";
                public string FontType { get; set; } = DEFAULT_FONT_TYPE;
                public int FontSize { get; set; } = DEFAULT_FONT_SIZE;
                public Color FontColor { get; set; } = StyleSheet.DEFAULT.FontColorDark1;
                public TextAnchor TextAlign { get; set; } = TextAnchor.MiddleLeft;
                public Color OutlineColor { get; set; } = StyleSheet.DEFAULT.OutlineColorDark1;
                public int OutlinePixelWeight { get; set; } = 0;
                public bool AutoSizeHeight { get; set; } = false;
                public bool AutoSizeWidth { get; set; } = false;

                protected override Component CreateHelper()
                {
                    var box = new BoxComponent("Box")
                    {
                        BackgroundColor = BackgroundColor
                    }.Inherit(this)
                    .Create(this);
                    var text = new BasicComponent("Text") { Empty = true }.Create(box);
                    text.Elements.Add(new CuiElement
                    {
                        Name = text.GlobalId,
                        Parent = text.ParentGlobalId,
                        Components = {
                        new CuiTextComponent {
                            Text = Text,
                            Font = FontType,
                            FontSize = FontSize,
                            Color = FontColor.ToString(),
                            Align = TextAlign
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1"
                        }
                    }
                    });
                    return this;
                }

                public override Component Init(Component parent)
                {
                    if (AutoSizeHeight)
                    {
                        this.PixelHeight = FontSize + 1;
                    }
                    if (AutoSizeWidth)
                    {
                        this.PixelWidth = (int) Math.Ceiling((FontSize+1) * 0.48f) * Text?.Length ?? 0;
                    }
                    return base.Init(parent);
                }

                public override Component Inherit(Component from, bool recursive = false)
                {
                    var casted = (ITextComponent)from;
                    this.Text = casted.Text ?? Text;
                    this.FontType = casted.FontType;
                    this.FontSize = casted.FontSize;
                    this.FontColor = casted.FontColor;
                    this.TextAlign = casted.TextAlign;
                    this.AutoSizeHeight = casted.AutoSizeHeight;
                    this.AutoSizeWidth = casted.AutoSizeWidth;
                    return recursive ? base.Inherit(from) : this;
                }
            }
        }
    }
}

namespace Oxide.Plugins
{
    partial class ComputersPlus : CovalencePlugin
    {
		[Command("t.show")]
		private void cmd_ui_test_show(IPlayer player, string command, string[] args)
		{
			BasePlayer basePlayer = player.Object as BasePlayer;
            //var main = new EZUI.BasicComponent("test") { Height = 0.5f, Width = 0.5f }.Create(null);
            //var main = new EZUI.BoxComponent("test") { Height = 0.8f, Width = 0.8f, Centered = true }.Create(null);
            //var box1 = new EZUI.BoxComponent("Box1") { Height = 0.2f, Width = 0.2f, BackgroundColor = EZUI.Color.RED, Centered = true}.Create(main);
            //var box2 = new EZUI.BoxComponent("Box2") { Height = 0.1f, Width = 0.1f, BackgroundColor = EZUI.Color.GREEN, TopAlign = box1.BottomSide.Pixels, LeftAlign = box1.LeftSide.Pixels }.Create(main);

            //var main = new EZUI.ButtonComponent("test")
            //{
            //    PixelHeight = 100,
            //    PixelWidth = 100,
            //    Text = "Hello",
            //    Command = "t.close",
            //    BackgroundColor = EZUI.Color.WHITE,
            //    TextAlign = UnityEngine.TextAnchor.MiddleCenter
            //}.Create(null);

            //var main = new EZUI.ImageComponent("test")
            //{
            //    PixelHeight = 100,
            //    PixelWidth = 100,
            //    ImageKey = "note"
            //}.Create(null);

            //var main = new EZUI.TextComponent("test")
            //{
            //    PixelHeight = 100,
            //    PixelWidth = 500,
            //    Text = "Hellooooo"
            //}.Create(null);
            //var main = new EZUI.WindowComponent("test")
            //{
            //    Scale = 0.5f,
            //    Centered = true
            //}.Create();
            //var pag = new EZUI.PaginatorComponent("Pag")
            //{
            //    PixelHeight = 40
            //}.Create(main).As<EZUI.PaginatorComponent>();
            //var list = new EZUI.LayoutComponent("List")
            //{
            //    Centered = true,
            //    ColCount = 4,
            //    RowCount = 1,
            //    BottomAlign = pag.TopSide.Pixels
            //}.Init(main).As<EZUI.LayoutComponent>().SetPaginator(pag).Create();
            //for (int i = 0; i < 15; i++)
            //{
            //    //var img = new EZUI.ImageComponent($"Img") { Size = 0.25f, ImageKey = "note", Centered = true }.Init(list);
            //    var txt = new EZUI.TextComponent("Txt")
            //    {
            //        Text = "Entry" + i.ToString(),
            //        TextAlign = UnityEngine.TextAnchor.MiddleCenter,
            //        Centered = true
            //    }.Init(list);
            //}
            //list.Create(main);
            //main.Render(basePlayer);
            //var main = new EZUI.BoxComponent("test")
            //{
            //    Height = 0.5f,
            //    Width = 0.5f,
            //    PixelPadding = new EZUI.Dir<int>(20)
            //}.Create(null);
            //var pag = new EZUI.PaginatorComponent("pag")
            //{
            //    PixelHeight = 40,
            //    BackgroundColor = EZUI.Color.RED
            //}.Create(main).As<EZUI.PaginatorComponent>();
            //var list = new EZUI.LayoutComponent("list")
            //{
            //    BackgroundColor = EZUI.Color.BLUE,
            //    Centered = true,
            //    ColCount = 4,
            //    RowCount = 1,
            //    BottomAlign = pag.TopSide.Pixels
            //}.Create(main).As<EZUI.LayoutComponent>().SetPaginator(pag);
            //for (int i = 0; i < 6; i++)
            //{
            //    //var img = new EZUI.ImageComponent($"Img") { Size = 0.25f, ImageKey = "note", Centered = true }.Init(list);
            //    var box = new EZUI.BoxComponent("MyBox")
            //    {
            //        BackgroundColor = EZUI.Color.GREEN,
            //        Size = 0.4f
            //    }.Create(list);
            //    var sub = new EZUI.BoxComponent("Sub")
            //    {
            //        BackgroundColor = EZUI.Color.BLACK,
            //        Size = 0.6f
            //    }.Create(box);
            //}
            //var main = new EZUI.WindowComponent("test")
            //{
            //    Scale = 0.5f,
            //    Centered = true
            //}.Create();
            //var toolbar = new EZUI.ToolbarComponent("TB")
            //{
            //    PixelHeight = 20,
            //    Buttons = new List<EZUI.ToolbarButton>()
            //        {
            //            new EZUI.ToolbarButton() { /*ImageKey = "note"*/ Text = "Compose" },
            //            new EZUI.ToolbarButton() { /*ImageKey = "note"*/ Text = "Delete" }
            //        },
            //    AnchorTo = EZUI.Anchor.TopLeft
            //}.Create(main);
            //var text = new EZUI.TextComponent("txt")
            //{
            //    Text = "Hello my name is Sam",
            //    FontSize = 8,
            //    AutoSizeWidth = true,
            //    BackgroundColor = EZUI.Color.RED
            //}.Create(main);
            //main.Render(basePlayer);
        }

        [Command("t.email")]
        private void cmd_ui_test_email(IPlayer player, string command, string[] args)
        {

            var inbox = EmailManager.GetPlayerInbox(player.Id);
            PLUGIN.Puts($"Inbox size {inbox.Length}");
        }

        [Command("t.close")]
		private void cmd_ui_test_close(IPlayer player, string command, string[] args)
		{

			BasePlayer basePlayer = player.Object as BasePlayer;


            var test = EZUI.Find(basePlayer.UserIDString, "test");
            test.Destroy(basePlayer);
            //test.Destroy(basePlayer);
            CuiHelper.DestroyUi(basePlayer, "test");
            CuiHelper.DestroyUi(basePlayer, "test.Box1");
            CuiHelper.DestroyUi(basePlayer, "Box1");
            CuiHelper.DestroyUi(basePlayer, "Box1.Content");
            CuiHelper.DestroyUi(basePlayer, "cpBase");
            CuiHelper.DestroyUi(basePlayer, "cpHome");
            CuiHelper.DestroyUi(basePlayer, "cpApp");
            
        }

        [Command("t.close2")]
        private void cmd_ui_test_close2(IPlayer player, string command, string[] args)
        {

            BasePlayer basePlayer = player.Object as BasePlayer;
            CuiHelper.DestroyUi(basePlayer, "PC");
            CuiHelper.DestroyUi(basePlayer, "test");
            CuiHelper.DestroyUi(basePlayer, "Box1");
            CuiHelper.DestroyUi(basePlayer, "Box1.Content");
            CuiHelper.DestroyUi(basePlayer, "cpBase");
            CuiHelper.DestroyUi(basePlayer, "cpHome");
            CuiHelper.DestroyUi(basePlayer, "test");
            CuiHelper.DestroyUi(basePlayer, "test.Content");
            CuiHelper.DestroyUi(basePlayer, "test.Content.Entry0");
            CuiHelper.DestroyUi(basePlayer, "test.Content.Entry0.Content");
            CuiHelper.DestroyUi(basePlayer, "test.Content.Entry0.Content.Box");
            CuiHelper.DestroyUi(basePlayer, "test.Content.Entry0.Content.Box.Content");
        }

        [Command("t.print")]
		private void cmd_ui_test_print(IPlayer player, string command, string[] args)
		{
			BasePlayer basePlayer = player.Object as BasePlayer;
			Puts($"{new string('\n', 30)}{EZUI.PrintLoaded(basePlayer)}");
			if (args.Length > 0)
            {
				var gid = args[0];
                int i;
                if (int.TryParse(gid, out i))
                {
                    var all = EZUI.GetAll(basePlayer);
                    if (i < all.Count)
                    {
                        var ui = all[i];
                        Puts(ui.ToString());
                    }
                }
                else
                {
                    var ui = EZUI.Find(basePlayer.UserIDString, gid);
                    if (ui != null)
                    {
                        Puts(ui.ToString());
                    }
                }
            }
		}

        [Command("sfx")]
        private void cmd_sfx(IPlayer player, string command, string[] args)
        {
            BasePlayer basePlayer = player.Object as BasePlayer;
            var sfx = string.Join(" ", args);
            PlaySfx(basePlayer, sfx);
        }

        [Command("pc.destroy")]
        private void cmd_pc_destroy(IPlayer player, string command, string[] args)
        {
            var allPcs = GameObject.FindObjectsOfType<ComputerStation>();
            foreach (ComputerStation stat in allPcs)
            {
                stat.Kill();
            }
        }

        #region Tests
        private void TestBox(BasePlayer basePlayer)
        {
            //var box1 = new EZUI.BoxFactory(null, "test")
            //{
            //    Size = 0.6f,
            //    BackgroundColor = EZUI.Color.RED,
            //    Centered = true
            //}.Create();
            //var box2 = new EZUI.BoxFactory(box1, "Box2")
            //{
            //    Height = 0.3f,
            //    Width = 0.5f,
            //    BackgroundColor = EZUI.Color.BLUE,
            //    AnchorTo = EZUI.Anchor.TopRight,
            //    PixelMargin = new EZUI.Dir<int>(0, 0, 5, 0)
            //}.Create();
            //var box3 = new EZUI.BoxFactory(box1, "Box3")
            //{
            //    PixelHeight = 200,
            //    PixelWidth = 5,
            //    BackgroundColor = EZUI.Color.GREEN,
            //    TopAlign = box2.BottomSide.Pixels,
            //    LeftAlign = box2.LeftSide.Pixels
            //}.Create();
            //box1.Render(basePlayer);
        }

        private void TestWindow(BasePlayer basePlayer)
        {
            //var main = new EZUI.WindowBoxFactory(null, "test")
            //{
            //    PixelPadding = new EZUI.Dir<int>(5),
            //    Height = 0.8f,
            //    Width = 0.8f,
            //    Centered = true
            //}.Create();
            //var box = new EZUI.BoxFactory(main, "Box")
            //{
            //    PixelX = 50,
            //    PixelY = 50,
            //    PixelWidth = 100,
            //    PixelHeight = 100,
            //    BackgroundColor = EZUI.Color.RED
            //}.Create();
            //var box2 = new EZUI.BoxFactory(main, "Box2")
            //{
            //    X = 0,
            //    Y = 0,
            //    Width = 0.1f,
            //    Height = 0.5f,
            //    BackgroundColor = EZUI.Color.BLUE
            //}.Create();
            //main.Render(basePlayer);
        }
        #endregion
    }
}

namespace Oxide.Plugins
{
    partial class ComputersPlus : CovalencePlugin
    {
        public static partial class EZUI
        {
            private interface IWindowComponent
            {
                Color HeaderBackgroundColor { get; set; }
                int HeaderPixelHeight { get; set; }
                string HeaderText { get; set; }
            }

            public class WindowComponent : Component, IWindowComponent, IBoxComponent
            {
                public WindowComponent(string id) : base(id)
                {
                }

                public override Color BackgroundColor { get; set; } = StyleSheet.DEFAULT.BackgroundColorLight1;
                public Color HeaderBackgroundColor { get; set; } = StyleSheet.DEFAULT.BackgroundColorDark1;
                public string HeaderText { get; set; } = "Header";
                public int HeaderPixelHeight { get; set; } = 24;
                public Color OutlineColor { get; set; } = StyleSheet.DEFAULT.OutlineColorDark1;
                public int OutlinePixelWeight { get; set; } = 4;
                private float WindowScale { get; set; } = 1.0f;
                private Color WindowBackgroundColor { get; set; } = StyleSheet.DEFAULT.BackgroundColorLight1;
                public string OnCloseCommand { get; set; } = "";

                protected override List<CuiElement> CreateBaseElements()
                {
                    WindowBackgroundColor = this.BackgroundColor;
                    WindowScale = this.Scale;
                    this.Scale = 1f;
                    this.BackgroundColor = Color.TRANSPARENT;
                    this.Init(this.Parent);
                    return base.CreateBaseElements();
                }

                private Component CreateHeader(Component box)
                {
                    var header = new BoxComponent("Header")
                    {
                        BackgroundColor = HeaderBackgroundColor,
                        PixelHeight = HeaderPixelHeight,
                        AnchorTo = Anchor.TopLeft,
                        PixelMargin = new Dir<int>(0, 0, OutlinePixelWeight, 0),
                        PixelPadding = new Dir<int>(5)
                    }
                    .Create(box);
                    var text = new TextComponent("Text")
                    {
                        Text = HeaderText,
                        AnchorTo = Anchor.TopLeft,
                        Width = 0.5f,
                        TextAlign = UnityEngine.TextAnchor.MiddleLeft,
                        FontColor = Color.WHITE
                    }.Create(header);
                    var close = new ButtonComponent("Close")
                    {
                        Transparent = true,
                        ImageKey = "App.Close",
                        AnchorTo = Anchor.Right,
                        Size = 1f,
                        Left = 2,
                        CenterY = true,
                        Command = $"component.destroy {Token} {GlobalId}"
                    }.Create(header);
                    return header;
                }

                protected override Component CreateHelper()
                {
                    var shadow = new BoxComponent("Shadow")
                    {
                        BackgroundColor = new Color(0, 0, 0, 0.9f)
                    }.Create(this);
                    var box = new BoxComponent("Window")
                    {
                        BackgroundColor = OutlineColor,
                        Scale = WindowScale,
                        Centered = Centered
                    }
                    .Inherit(this)
                    .Create(shadow);
                    var header = CreateHeader(box);
                    var content = new BoxComponent("Body")
                    {
                        BackgroundColor = WindowBackgroundColor,
                        PixelPadding = new Dir<int>(5),
                        TopAlign = header.BottomSide.Pixels
                    }
                    .Create(box);
                    this.Content = content;
                    return this;
                }

                protected override Component OnDestroy(BasePlayer basePlayer)
                {
                    var split = OnCloseCommand.Split(' ');
                    var command = split[0];
                    var args = split.Skip(1);
                    basePlayer.Command(command, args);
                    return base.OnDestroy(basePlayer);
                }
            }
        }
    }
}


// --- End of file: ComputersPlus.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ch47-keeper ---
// --- Original File Path: C/CH47Keeper/CH47Keeper.cs ---

﻿using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("CH47 Keeper", "Homi", "0.1.1")]
    [Description("Restore position and rotation of CH47 own by user when the server restarts.")]
    public class CH47Keeper : RustPlugin
    {
        #region config
        class CH47Data
        {
            public ulong ownerid;
            public Vector3 pos;
            public float rotX;
            public float rotY;
            public float rotZ;
            public float rotW;
        }
        #endregion

        #region Hooks
        private void OnServerInitialized()
        {
            ch47_Data = Interface.Oxide.DataFileSystem.ReadObject<List<CH47Data>>("CH47Keeper");
            if (!CheckIsWipe())
            {
                RestoreCH47();
            }
        }
        void Unload()
        {
            SaveCH47();
        }
        private void OnServerSave()
        {
            SaveCH47();
        }
        #endregion

        #region Honmono
        private readonly DynamicConfigFile dataFile1 = Interface.Oxide.DataFileSystem.GetFile("CH47Keeper");
        private List<CH47Data> ch47_Data = new List<CH47Data>();
        private void SaveCH47()
        {
            if (ch47_Data.Count > 0)
            {
                ch47_Data.Clear();
            }
            foreach (BaseNetworkable bna in BaseNetworkable.serverEntities.entityList.Values)
            {
                if (bna.ShortPrefabName == "ch47.entity")
                {
                    BaseEntity ent = (BaseEntity)bna;
                    if (!(ent.transform.position.x < -5000) && !(ent.transform.position.x > 5000) && !(ent.transform.position.y > 5000) && !(ent.transform.position.z < -5000) && !(ent.transform.position.z > 5000))
                    {
                        ch47_Data.Add(new CH47Data() { ownerid = ent.OwnerID, pos = ent.transform.position, rotX = ent.transform.rotation.x, rotY = ent.transform.rotation.y, rotZ = ent.transform.rotation.z, rotW = ent.transform.rotation.w });
                    }
                }
            }
            dataFile1.WriteObject(ch47_Data);
            Puts("CH47 Save");
        }
        private void RestoreCH47()
        {
            foreach (CH47Data ch47 in ch47_Data)
            {
                bool ishere = false;
                foreach (BaseNetworkable bna in BaseNetworkable.serverEntities.entityList.Values)
                {
                    if (bna.ShortPrefabName == "ch47.entity" && Vector3.Distance(bna.transform.position, ch47.pos) < 1)
                    {
                        ishere = true;
                    }
                }
                if (!ishere)
                {
                    BaseEntity ent = GameManager.server.CreateEntity("assets/prefabs/npc/ch47/ch47.entity.prefab", ch47.pos, new Quaternion() { x = ch47.rotX, y = ch47.rotY, z = ch47.rotZ, w = ch47.rotW }, true);
                    if (ent == null) { PrintWarning("Entity is Null"); }
                    ent.OwnerID = ch47.ownerid;
                    ent.Spawn();
                }
            }
        }
        private bool CheckIsWipe()
        {
            foreach (BaseNetworkable bna in BaseNetworkable.serverEntities.entityList.Values)
            {
                if (bna.ShortPrefabName.Contains("foundation") || (BasePlayer.activePlayerList.Count > 1) || (BasePlayer.sleepingPlayerList.Count > 1))
                {
                    return false;
                }
            }
            return true;
        }
        #endregion
    }
}

// --- End of file: CH47Keeper.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/cannibal ---
// --- Original File Path: C/Cannibal/Cannibal.cs ---

﻿using Rust;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using UnityEngine;

#region Changelogs and ToDo
/**********************************************************************
* 2.0.0 :   Rewrite
* 2.0.1 :   Removed a double using directive
*           Removed usage of ImageLibrary (obsolete)
*           Added more checks on Animal/Npc deaths.
*           Added ZombieHorde checks.
*           Hud is now completely transparent
* 2.0.2 :   Fixed exploit on meatconsumption outside playerinventory
*           Harvesting heli/bradley gibs hqm will count as hqm gather
*           Fixed Colors running the same after rank 3

**********************************************************************/
#endregion

namespace Oxide.Plugins
{
    [Info("Cannibal", "Krungh Crow", "2.0.2")]
    [Description("Cannibal Game Mode")]
    class Cannibal : CovalencePlugin
    {
        [PluginReference] private Plugin SimpleKillFeed;

        #region Variables
        ulong SteamIDIcon = 76561199232739560;
        string cannibalicon = "assets/icons/skull.png";
        const string Admin_Perm = "cannibal.admin";
        const string CPermanent_Perm = "cannibal.permanent";
        const string FXEatingSound = "assets/bundled/prefabs/fx/gestures/eat_generic.prefab";
        #endregion

        #region Configuration

        private ConfigData configData;

        class ConfigData
        {
            [JsonProperty(PropertyName = "Prefix")]
            public string Prefix = "[Cannibal] ";
            [JsonProperty(PropertyName = "UI Settings")]
            public UISettings Settings = new UISettings();
            [JsonProperty(PropertyName = "FX Settings")]
            public FXSettings FX = new FXSettings();
            [JsonProperty(PropertyName = "Cannibal Settings")]
            public CSettings CannibalS = new CSettings();
        }

        class UISettings
        {
            [JsonProperty(PropertyName = "Use Bloody background")]
            public bool UseBloody = true;
            [JsonProperty(PropertyName = "Hud Anchor Min")]
            public string Anchormin = "0 0.95";
            [JsonProperty(PropertyName = "Hud Anchor Max")]
            public string Anchormax = "0.10 1";
        }

        class CSettings
        {
            [JsonProperty(PropertyName = "Save frequency (seconds)")]
            public float TimerAdd = 5;
            [JsonProperty(PropertyName = "Minimum Cannibal time (seconds)")]
            public float MinTime = 300;
            [JsonProperty(PropertyName = "Cannibal Healing")]
            public CHSettings Heal = new CHSettings();
            [JsonProperty(PropertyName = "Cannibal Eating")]
            public CESettings Eat = new CESettings();
            [JsonProperty(PropertyName = "Cannibal Gather")]
            public CGSettings Gather = new CGSettings();
            [JsonProperty(PropertyName = "Cannibal Damage Dealt")]
            public CDSettings Dmg = new CDSettings();
        }

        class FXSettings
        {
            [JsonProperty(PropertyName = "FX during Melee hits")]
            public string MeleeHit = "assets/bundled/prefabs/fx/player/gutshot_scream.prefab";
            [JsonProperty(PropertyName = "FX Turning Cannibal")]
            public string Turned = "assets/bundled/prefabs/fx/player/howl.prefab";
            [JsonProperty(PropertyName = "FX Buff end notification")]
            public string BuffEnd = "assets/bundled/prefabs/fx/invite_notice.prefab";
        }

        class CHSettings
        {
            [JsonProperty(PropertyName = "Can heal self (bandages)")]
            public bool CanHealBandage = true;
            [JsonProperty(PropertyName = "Heal Bonus self (bandages)")]
            public int BonusBandage = 5;
            [JsonProperty(PropertyName = "Can heal others (bandage)")]
            public bool CanHealOthersBandage = true;
            [JsonProperty(PropertyName = "Can heal self (syringe)")]
            public bool CanHealSyringe= true;
            [JsonProperty(PropertyName = "Heal Bonus self (syringe)")]
            public int BonusSyringe = 10;
            [JsonProperty(PropertyName = "Can heal others (syringe)")]
            public bool CanHealOthersSyringe = true;
            [JsonProperty(PropertyName = "Can consume largemedkit")]
            public bool CanConsumeLmedkit = true;
            [JsonProperty(PropertyName = "Can consume antiradpill")]
            public bool CanConsumeRadpills = true;
        }

        class CESettings
        {
            [JsonProperty(PropertyName = "Buff on Human Meat")]
            public bool BuffHumMeat = true;
            [JsonProperty(PropertyName = "Buff Comfort duration (seconds)")]
            public int BuffDuration = 60;
            [JsonProperty(PropertyName = "Buff Comfort (0-100)")]
            public float BuffComfort = 50f;
            [JsonProperty(PropertyName = "Extra nutrition (incl heal)")]
            public int BuffHunger = 20;
            [JsonProperty(PropertyName = "Extra hydration")]
            public int BuffThirst = 30;
            [JsonProperty(PropertyName = "Radiation penalty")]
            public int BuffRadiation = 10;
            [JsonProperty(PropertyName = "Food items (shortname , true/false)")]
            public Dictionary<string , bool> FoodItems = new Dictionary<string , bool>
            { };
        }

        class CGSettings
        {
            [JsonProperty(PropertyName = "Wood Gather rate")]
            public float GWood = 1.0f;
            [JsonProperty(PropertyName = "Stone Gather rate")]
            public float GStone = 1.0f;
            [JsonProperty(PropertyName = "Sulfur Gather rate")]
            public float GSulfur = 1.0f;
            [JsonProperty(PropertyName = "Metal Gather rate")]
            public float GMetal = 1.0f;
            [JsonProperty(PropertyName = "HQM Gather rate")]
            public float GHQM = 1.0f;
        }

        class CDSettings
        {
            [JsonProperty(PropertyName = "Cannibal vs Cannibal Scale Boost")]
            public bool CanScaleBoost = true;
            [JsonProperty(PropertyName = "Melee Weapons (shortname , damagescale)")]
            public Dictionary<string , float> MeleeWeapons = new Dictionary<string , float>
            {};
            [JsonProperty(PropertyName = "Ranged Weapons (shortname , damagescale)")]
            public Dictionary<string , float> RangedWeapons = new Dictionary<string , float>
            {};
        }

        private bool LoadConfigVariables()
        {
            try
            {
                configData = Config.ReadObject<ConfigData>();
            }
            catch
            {
                return false;
            }
            SaveConf();
            return true;
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Fresh install detected Creating a new config file.");
            configData = new ConfigData();
            SaveConf();
        }

        void SaveConf() => Config.WriteObject(configData , true);

        #endregion

        #region Datafile
        private DynamicConfigFile data;
        DataFile dataFile;

        private CannibalLifeTimeDataFile cannibalLifeTimeDataFile;
        private class CannibalLifeTimeDataFile
        {
            public Dictionary<string , CannibalLifeTimeData> CannibalLifeTime { get; set; } = new Dictionary<string , CannibalLifeTimeData>();
        }

        private class CannibalLifeTimeData
        {
            [JsonProperty(PropertyName = "Name")]
            public string PlayerName { get; set; }
            [JsonProperty(PropertyName = "Total Time as Cannibal")]
            public double CannibalLifeTime { get; set; }
            [JsonProperty(PropertyName = "Total Human Meat Consumed")]
            public int HumanMeatConsumed { get; set; }
            [JsonProperty(PropertyName = "Total Humans Killed")]
            public int HumansKilled { get; set; }
            [JsonProperty(PropertyName = "Total Cannibals Killed")]
            public int CannibalsKilled { get; set; }
            [JsonProperty(PropertyName = "Total Npc Killed")]
            public int NpcKilled { get; set; }
            [JsonProperty(PropertyName = "Total Animals Killed")]
            public int AnimalsKilled { get; set; }
            [JsonProperty(PropertyName = "Total Wood Collected")]
            public int WoodCollected = 0;
            [JsonProperty(PropertyName = "Total Stone Collected")]
            public int StoneCollected = 0;
            [JsonProperty(PropertyName = "Total Sulfur Ore Collected")]
            public int SulfurCollected = 0;
            [JsonProperty(PropertyName = "Total Metal Ore Collected")]
            public int MetalCollected = 0;
            [JsonProperty(PropertyName = "Total Hqm Ore Collected")]
            public int HQMCollected = 0;
        }

        private void LoadCannibalLifeTimeData()
        {
            cannibalLifeTimeDataFile = Interface.Oxide.DataFileSystem.ReadObject<CannibalLifeTimeDataFile>("Cannibal/CannibalsLife") ?? new CannibalLifeTimeDataFile();
        }

        private void SaveCannibalLifeTimeData()
        {
            if (cannibalLifeTimeDataFile == null)
            {
                cannibalLifeTimeDataFile = new CannibalLifeTimeDataFile();
            }

            Interface.Oxide.DataFileSystem.WriteObject("Cannibal/CannibalsLife" , cannibalLifeTimeDataFile);
        }

        private void SaveData()
        {
            if (dataFile == null) return;
            Interface.Oxide.DataFileSystem.WriteObject("Cannibal/Cannibals" , dataFile);
        }

        private void LoadData()
        {
            dataFile = Interface.Oxide.DataFileSystem.ReadObject<DataFile>("Cannibal/Cannibals");

            if (dataFile == null)
            {
                dataFile = new DataFile();
                SaveData();
            }
        }

        private class DataFile
        {
            public Dictionary<string , PlayerData> Players = new Dictionary<string , PlayerData>();
        }

        private class PlayerData
        {
            [JsonProperty(PropertyName = "Name")]
            public string DisplayName = string.Empty;
            [JsonProperty(PropertyName = "Current Time as Cannibal")]
            public double TotalTimeAsCannibal = 0.0;
            [JsonProperty(PropertyName = "Current Human Meat Consumed")]
            public int HumanMeatConsumed = 0;
            [JsonProperty(PropertyName = "Current Humans Killed")]
            public int HumansKilled = 0;
            [JsonProperty(PropertyName = "Current Cannibals Killed")]
            public int CannibalsKilled = 0;
            [JsonProperty(PropertyName = "Current Npc Killed")]
            public int NpcKilled = 0;
            [JsonProperty(PropertyName = "Current Animals Killed")]
            public int AnimalsKilled = 0;
            [JsonProperty(PropertyName = "Wood Collected")]
            public int WoodCollected = 0;
            [JsonProperty(PropertyName = "Stone Collected")]
            public int StoneCollected = 0;
            [JsonProperty(PropertyName = "Sulfur Ore Collected")]
            public int SulfurCollected = 0;
            [JsonProperty(PropertyName = "Metal Ore Collected")]
            public int MetalCollected = 0;
            [JsonProperty(PropertyName = "Hqm Ore Collected")]
            public int HQMCollected = 0;
        }

        private void AddPlayerData(IPlayer player)
        {
            if (dataFile == null)
            {
                LoadData();
            }

            string playerId = player.Id;

            if (!dataFile.Players.ContainsKey(playerId))
            {
                dataFile.Players.Add(playerId , new PlayerData
                {
                    DisplayName = player.Name
                });
                SaveData();
                StartCannibalTimer(player);
                if (cannibalLifeTimeDataFile == null)
                {
                    LoadCannibalLifeTimeData();
                }
            }
        }

        private void RemovePlayer(IPlayer player)
        {
            if (dataFile == null)
            {
                LoadData();
            }

            if (cannibalLifeTimeDataFile == null)
            {
                LoadCannibalLifeTimeData();
            }

            string playerId = player.Id;

            if (dataFile.Players.ContainsKey(playerId))
            {
                double cannibalLifeTime = dataFile.Players[playerId].TotalTimeAsCannibal;
                string playerName = player.Name;
                int humanMeatConsumed = dataFile.Players[playerId].HumanMeatConsumed;
                int humansKilled = dataFile.Players[playerId].HumansKilled;
                int cannibalsKilled = dataFile.Players[playerId].CannibalsKilled;
                int animalsKilled = dataFile.Players[playerId].AnimalsKilled;
                int npcKilled = dataFile.Players[playerId].NpcKilled;
                int woodCollected = dataFile.Players[playerId].WoodCollected;
                int stoneCollected = dataFile.Players[playerId].StoneCollected;
                int sulfurCollected = dataFile.Players[playerId].SulfurCollected;
                int metalCollected = dataFile.Players[playerId].MetalCollected;
                int hqmCollected = dataFile.Players[playerId].HQMCollected;

                if (cannibalLifeTimeDataFile.CannibalLifeTime.ContainsKey(playerId))
                {
                    cannibalLifeTimeDataFile.CannibalLifeTime[playerId].CannibalLifeTime += cannibalLifeTime;
                    cannibalLifeTimeDataFile.CannibalLifeTime[playerId].HumanMeatConsumed += humanMeatConsumed;
                    cannibalLifeTimeDataFile.CannibalLifeTime[playerId].HumansKilled += humansKilled;
                    cannibalLifeTimeDataFile.CannibalLifeTime[playerId].CannibalsKilled += cannibalsKilled;
                    cannibalLifeTimeDataFile.CannibalLifeTime[playerId].AnimalsKilled += animalsKilled;
                    cannibalLifeTimeDataFile.CannibalLifeTime[playerId].NpcKilled += npcKilled;
                    cannibalLifeTimeDataFile.CannibalLifeTime[playerId].WoodCollected += woodCollected;
                    cannibalLifeTimeDataFile.CannibalLifeTime[playerId].StoneCollected += stoneCollected;
                    cannibalLifeTimeDataFile.CannibalLifeTime[playerId].SulfurCollected += sulfurCollected;
                    cannibalLifeTimeDataFile.CannibalLifeTime[playerId].MetalCollected += metalCollected;
                    cannibalLifeTimeDataFile.CannibalLifeTime[playerId].HQMCollected += hqmCollected;
                }
                else
                {
                    CannibalLifeTimeData cannibalLifeTimeData = new CannibalLifeTimeData
                    {
                        PlayerName = playerName ,
                        CannibalLifeTime = cannibalLifeTime,
                        HumanMeatConsumed = humanMeatConsumed,
                        HumansKilled = humansKilled,
                        CannibalsKilled = cannibalsKilled,
                        AnimalsKilled = animalsKilled,
                        NpcKilled = npcKilled,
                        WoodCollected = woodCollected ,
                        StoneCollected = stoneCollected ,
                        SulfurCollected = sulfurCollected ,
                        MetalCollected = metalCollected ,
                        HQMCollected = hqmCollected
                    };
                    cannibalLifeTimeDataFile.CannibalLifeTime.Add(playerId , cannibalLifeTimeData);
                }
                dataFile.Players.Remove(playerId);
                SaveData();
                SaveCannibalLifeTimeData();
                Puts($"{playerName} has been removed from the list of cannibals.");
            }
            else
            {
                //Puts($"{player.Name} was not found in the list of cannibals.");
            }
        }

        #endregion

        #region LanguageAPI en/fr
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["N/a"] = "N/a" ,
                ["All"] = "All" ,
                ["SKFTurned"] = "Turned into a Cannibal" ,
                ["TotalCannibals"] = "There are a total of {0} cannibals" ,
                ["TotalCannibalsOnline"] = "There are a {0}/{1} cannibals online" ,
                ["Permission"] = "Permission" ,
                ["Admin"] = "Admin" ,
                ["InvalidInput"] = "Please enter a valid command!" ,
                ["NoPermission"] = "You dont have permission for this command!" ,
                ["AteHumanMeat"] = "You ate human meat and turned into a cannibal!" ,
                ["BuffEnd"] = "Your buff ended eat more meat to have one again." ,
                ["GetCannibalTime"] = "You have been Cannibal for {0} days, {1} hours, {2} minutes, and {3} seconds.",
                ["StartCannibalCmd"] = "You became a cannibal by choice.",
                ["NotCannibalCmd"] = "You are not a Cannibal" ,
                ["AllreadyCannibalCmd"] = "You are allready a Cannibal" ,
                ["PermanentCannibalCmd"] = "You are a Cannibal permanantly" ,
                ["EndCannibalCmd"] = "You have been Cannibal long enough and returned to normal life." ,
                ["EndCannibalCmdNotification"] = "{player} Is no longer a cannibal after {0} days, {1} hrs, {2} minutes, and {3} seconds." ,
                ["FailEndCannibalCmd"] = "You have not been Cannibal long enough to return to normal life.",
                ["BonusHeal"] = "You recieved {0} additional health!" ,
                ["CannotHealSelfBandage"] = "Cannibals cannot be healed with bandages.",
                ["CannotHealSelfMedkit"] = "Cannibals cannot use Large Medical Kits." ,
                ["CannotHealSelfPills"] = "Cannibals cannot use Anti radiation Pills." ,
                ["CannotHealSelfSyringe"] = "Cannibals cannot be healed with syringes.",
                ["ExtraDmg"] = "You dealt {0} extra damage." ,
                ["ExtraDmgPenalty"] = "You dealt {0} less damage." ,
                ["OnConsumeHumanMeat"] = "Meaaaaat ... !!!!",
                ["OnConsumeWater"] = "Cannibals cannot drink water in a normal way.",
                ["InfoTitle"] = "Cannibal Information" ,
                ["InfoTitleMain"] = "Main Page" ,
                ["InfoTitleStat"] = "Statistics" ,
                ["InfoClose"] = "Exit" ,
                ["InfoMainLeftPanelTitle"] = "Server Information" ,
                ["InfoMainLeftPanel"] = "This panel Is for your servers description on the Cannibal system.\n" +
                "This can be a very long language file entry.\n" +
                "\n\nPlace your text here for your players to read" ,
                ["InfoWelcome"] = "Welcome to our server" ,
                ["InfoMain"] = "Main" ,
                ["InfoDamage"] = "Damage" ,
                ["InfoStat"] = "Statistics" ,
                ["InfoStatDescription"] = "Description" ,
                ["InfoStatCurrent"] = "Current" ,
                ["InfoStatTotal"] = "Total" ,
                ["InfoStatTime"] = "Time" ,
                ["InfoStatMeats"] = "Human Meat" ,
                ["InfoStatKillHuman"] = "Humans Killed" ,
                ["InfoStatKillCannibal"] = "Cannibals Killed" ,
                ["InfoStatKillNpc"] = "NPC Killed" ,
                ["InfoStatKillAnimal"] = "Animals Killed" ,
                ["InfoStatWood"] = "Wood Collected" ,
                ["InfoStatStone"] = "Stone Collected" ,
                ["InfoStatSulfur"] = "Sulfur Ore Collected" ,
                ["InfoStatMetal"] = "Metal Ore Collected" ,
                ["InfoStatHQM"] = "HQM Ore Collected" ,
                ["InfoStatSubtext"] = "This panel shows your Cannibal related statistics like how long you have been one.\nAnd future placeholder for more related stuff like kills etc etc.",
                ["InfoWeaponTitle"] = "Weapon Damage Scaling" ,
                ["InfoWeaponTitleMelee"] = "Melee Weapons" ,
                ["InfoWeaponTitleRanged"] = "Ranged Weapons" ,
                ["InfoCmdInfoTitle"] = "Chat Commands" ,
                ["InfoCmdInfo"] = "This Information UI" ,
                ["InfoCmdStart"] = "Manually start Cannibal mode" ,
                ["InfoCmdEnd"] = "Manually end Cannibal mode" ,
                ["InfoCmdTime"] = "Shows how long you are a Cannibal" ,
                ["InfoCmdTotal"] = "Shows total Cannibals logd" ,
                ["InfoCmdOnline"] = "Shows how many Cannibals are on" ,
                ["InfoGatheringTitle"] = "Gathering" ,
                ["InfoGatheringDescription"] = "Gathering Boost or penalty" ,
                ["InfoRankings"] = "Rankings" ,
                ["InfoRankingsTitle"] = "Top 10 Ranks" ,
                ["Top Eaters"] = "Top Eaters" ,
                ["Top Slayers"] = "Top Slayers" ,
                ["Top Traitors"] = "Top Traitors" ,
                ["Top PVE"] = "Top PVE" ,
                ["Top Butchers"] = "Top Butchers" ,
                ["Wood"] = "Wood" ,
                ["Stones"] = "Stones" ,
                ["Sulfur"] = "Sulfur" ,
                ["Metal"] = "Metal" ,
                ["HQM"] = "HQM" ,
            } , this);

            lang.RegisterMessages(new Dictionary<string , string>
            {
                ["N/a"] = "N/D" ,
                ["All"] = "Tous" ,
                ["SKFTurned"] = "Transformé en cannibale",
                ["TotalCannibals"] = "Il y a un total de {0} cannibales" ,
                ["TotalCannibalsOnline"] = "Il y a {0}/{1} cannibales en ligne" ,
                ["Permission"] = "Permission" ,
                ["Admin"] = "Admin" ,
                ["InvalidInput"] = "Veuillez entrer une commande valide !" ,
                ["NoPermission"] = "Vous n'avez pas la permission d'utiliser cette commande !" ,
                ["AteHumanMeat"] = "Vous avez mangé de la viande humaine et êtes devenu cannibale !" ,
                ["BuffEnd"] = "Votre buff a pris fin. Mangez plus de viande pour en obtenir un nouveau." ,
                ["GetCannibalTime"] = "Vous êtes cannibale depuis {0} jours, {1} heures, {2} minutes et {3} secondes." ,
                ["StartCannibalCmd"] = "Vous êtes devenu cannibale par choix." ,
                ["NotCannibalCmd"] = "Vous n'êtes pas un cannibale." ,
                ["AllreadyCannibalCmd"] = "Vous êtes déjà un cannibale." ,
                ["PermanentCannibalCmd"] = "Vous êtes cannibale de manière permanente." ,
                ["EndCannibalCmd"] = "Vous avez été cannibale assez longtemps et êtes revenu à une vie normale." ,
                ["EndCannibalCmdNotification"] = "{player} n'est plus un cannibale après {0} jours, {1} heures, {2} minutes et {3} secondes." ,
                ["FailEndCannibalCmd"] = "Vous n'avez pas été cannibale assez longtemps pour revenir à une vie normale." ,
                ["BonusHeal"] = "Vous avez reçu {0} points de vie supplémentaires !" ,
                ["CannotHealSelfBandage"] = "Les cannibales ne peuvent pas être soignés avec des bandages." ,
                ["CannotHealSelfMedkit"] = "Les cannibales ne peuvent pas utiliser de grands kits médicaux." ,
                ["CannotHealSelfPills"] = "Les cannibales ne peuvent pas utiliser de pilules contre les radiations." ,
                ["CannotHealSelfSyringe"] = "Les cannibales ne peuvent pas être soignés avec des seringues." ,
                ["ExtraDmg"] = "Vous avez infligé {0} dégâts supplémentaires." ,
                ["ExtraDmgPenalty"] = "Vous avez infligé {0} dégâts de moins." ,
                ["OnConsumeHumanMeat"] = "Viande... !!!!" ,
                ["OnConsumeWater"] = "Les cannibales ne peuvent pas boire de l'eau normalement." ,
                ["InfoTitle"] = "Information Cannibale" ,
                ["InfoTitleMain"] = "Page principale" ,
                ["InfoTitleStat"] = "Statistiques" ,
                ["InfoClose"] = "Fermer" ,
                ["InfoWelcome"] = "Bienvenue sur notre serveur" ,
                ["InfoMain"] = "Principal" ,
                ["InfoMainLeftPanelTitle"] = "Informations sur le serveur" ,
                ["InfoMainLeftPanel"] = "Ce panneau est destiné à la description de votre serveur sur le système Cannibal.\n" +
                "Ceci peut être une entrée de fichier de langue très longue.\n" +
                "\n\nPlacez votre texte ici pour que vos joueurs le lisent" ,
                ["InfoDamage"] = "Dommages" ,
                ["InfoStat"] = "Statistiques" ,
                ["InfoStatDescription"] = "Description" ,
                ["InfoStatCurrent"] = "Actuel" ,
                ["InfoStatTotal"] = "Total" ,
                ["InfoStatTime"] = "Temps" ,
                ["InfoStatMeats"] = "Viande humaine" ,
                ["InfoStatKillHuman"] = "Humains tués" ,
                ["InfoStatKillCannibal"] = "Cannibales tués" ,
                ["InfoStatKillNpc"] = "PNJ tués" ,
                ["InfoStatKillAnimal"] = "Animaux tués" ,
                ["InfoStatWood"] = "Bois collecté" ,
                ["InfoStatStone"] = "Pierre collectée" ,
                ["InfoStatSulfur"] = "Minerai de soufre collecté" ,
                ["InfoStatMetal"] = "Minerai de métal collecté" ,
                ["InfoStatHQM"] = "Minerai de HQM collecté" ,
                ["InfoStatSubtext"] = "Ce panneau affiche vos statistiques liées au cannibalisme, telles que la durée pendant laquelle vous avez été cannibale. Et futur espace réservé pour plus de statistiques liées, comme les victoires, etc." ,
                ["InfoWeaponTitle"] = "Échelle de dégâts des armes" ,
                ["InfoWeaponTitleMelee"] = "Armes de mêlée" ,
                ["InfoWeaponTitleRanged"] = "Armes à distance" ,
                ["InfoCmdInfoTitle"] = "Commandes de Chat" ,
                ["InfoCmdInfo"] = "Cette interface d'information" ,
                ["InfoCmdStart"] = "Démarrer manuellement le mode cannibale" ,
                ["InfoCmdEnd"] = "Arrêter manuellement le mode cannibale" ,
                ["InfoCmdTime"] = "Affiche depuis combien de temps vous êtes un cannibale" ,
                ["InfoCmdTotal"] = "Affiche le total des Cannibales enregistrés" ,
                ["InfoCmdOnline"] = "Affiche le nombre de Cannibales en ligne" ,
                ["InfoGatheringTitle"] = "Collecte" ,
                ["InfoGatheringDescription"] = "Bonus ou pénalité de collecte" ,
                ["InfoRankings"] = "Classements" ,
                ["InfoRankingsTitle"] = "Top 10 Classements" ,
                ["Top Eaters"] = "Top Mangeurs" ,
                ["Top Slayers"] = "Top Tueurs" ,
                ["Top Traitors"] = "Top Traîtres" ,
                ["Top PVE"] = "Top JcE" ,
                ["Top Butchers"] = "Top Bouchers" ,
                ["Wood"] = "Bois" ,
                ["Stones"] = "Pierres" ,
                ["Sulfur"] = "Soufre" ,
                ["Metal"] = "Métal" ,
                ["HQM"] = "HQM" ,
            } , this , "fr");

        }
        #endregion

        #region Commands
        [Command("Cannibal")]
        private void CannibalCmd(IPlayer player , string command , string[] args)
        {
            string prefix = configData.Prefix;

            if (args.Length < 1)
            {
                if (player.IsServer)
                {

                    Puts(lang.GetMessage("InvalidInput" , this , null));
                    return;
                }

                SendMessage(player , "InvalidInput");
                return;
            }
            switch (args[0])
            {
                case "time":
                    {
                        if (player.IsServer)
                        {
                            Puts(lang.GetMessage("InvalidInput" , this , null));
                            return;
                        }
                        if (IsCannibal(player))
                        {
                            double GetTime = GetCannibalTime(player);
                            TimeSpan formattedTime = FormatTime(GetTime);
                            string message = lang.GetMessage("GetCannibalTime" , this , player.Id);
                            message = message.Replace("{0}" , formattedTime.Days.ToString());
                            message = message.Replace("{1}" , formattedTime.Hours.ToString());
                            message = message.Replace("{2}" , formattedTime.Minutes.ToString());
                            message = message.Replace("{3}" , formattedTime.Seconds.ToString());
                            SendMessage(player , message);
                            return;
                        }
                        else
                        {
                            SendMessage(player , "NotCannibalCmd");
                        }
                        break;
                    }
                case "start":
                    {
                        if (player.IsServer)
                        {
                            Puts(lang.GetMessage("InvalidInput" , this , null));
                            return;
                        }
                        if (!IsCannibal(player))
                        {
                            if (!HasPerm(player , CPermanent_Perm))
                            {
                                SetupPlayer(player);
                                SendMessage(player , "StartCannibalCmd");
                                SimpleKillFeed?.Call("SendKillfeedmessage" , $"{player.Name} {Translate(player, "SKFTurned")}");
                            }
                            else
                            {
                                SendMessage(player , "NoPermission");
                            }
                        }
                        else
                        {
                            SendMessage(player , "AllreadyCannibalCmd");
                        }
                        break;
                    }
                case "end":
                    {
                        if (player.IsServer)
                        {
                            Puts(lang.GetMessage("InvalidInput" , this , null));
                            return;
                        }
                        if (!HasPerm(player , CPermanent_Perm))
                        {
                            if (IsCannibal(player))
                            {
                                if (GetCannibalTime(player) > configData.CannibalS.MinTime || HasPerm(player , Admin_Perm))
                                {

                                    double GetTime = GetCannibalTime(player);
                                    TimeSpan formattedTime = FormatTime(GetTime);
                                    string message = lang.GetMessage("EndCannibalCmdNotification" , this , player.Id);
                                    message = message.Replace("{player}" , player.Name.ToString());
                                    message = message.Replace("{0}" , formattedTime.Days.ToString());
                                    message = message.Replace("{1}" , formattedTime.Hours.ToString());
                                    message = message.Replace("{2}" , formattedTime.Minutes.ToString());
                                    message = message.Replace("{3}" , formattedTime.Seconds.ToString());
                                    SimpleKillFeed?.Call("SendKillfeedmessage" , message);
                                    NextTick(() =>
                                    {
                                        RemovePlayer(player);
                                        SendMessage(player , "EndCannibalCmd");
                                        // Stop and destroy the timer
                                        StopCannibalTimer(player);
                                        Cannibalhud(player.Object as BasePlayer);
                                    });

                                    break;
                                }
                                else
                                {
                                    SendMessage(player , "FailEndCannibalCmd");
                                }
                            }
                            if (!IsCannibal(player))
                            {
                                SendMessage(player , "NotCannibalCmd");
                            }
                        }
                        else
                        {
                            SendMessage(player , "PermanentCannibalCmd");
                        }
                        break;
                    }
                case "total":
                    {
                        int cannibalCount = CountCannibals();
                        if (player.IsServer)
                        {
                            Puts($"Total number of cannibals: {cannibalCount}"); // Log the count
                            return;
                        }

                        if (HasPerm(player , Admin_Perm))
                        {
                            string message = lang.GetMessage("TotalCannibals" , this , player.Id);
                            message = message.Replace("{0}" , $"{cannibalCount}");
                            SendMessage(player , message);
                        }
                        else
                        {
                            SendMessage(player , "NoPermission");
                        }
                        break;
                    }
                case "info":
                    {
                        CannibalinfoPanel(player);
                        break;
                    }
                case "online":
                    {
                        int totalCannibalCount = CountCannibals();
                        int onlineCannibalCount = CountOnlineCannibals();

                        if (player.IsServer)
                        {

                            Puts($"Total number of cannibals online: {onlineCannibalCount}");
                            return;
                        }

                        if (HasPerm(player , Admin_Perm))
                        {
                            string message = lang.GetMessage("TotalCannibalsOnline" , this , player.Id);
                            message = message.Replace("{0}" , $"{onlineCannibalCount}");
                            message = message.Replace("{1}" , $"{totalCannibalCount}");
                            SendMessage(player , message);
                        }
                        else
                        {
                            SendMessage(player , "NoPermission");
                        }
                        break;
                    }
                default:
                    if (player.IsServer)
                    {

                        Puts(lang.GetMessage("InvalidInput" , this , null));
                        return;
                    }
                    player.Reply(prefix + lang.GetMessage("InvalidInput" , this , player.Id));
                    break;
            }
        }

        #endregion

        #region Hooks

        private void OnDispenserBonus(ResourceDispenser dispenser , BasePlayer player , Item item)
        {
            if (player == null) return;
            OnDispenserGather(dispenser , player , item);
        }

        private void OnDispenserGather(ResourceDispenser dispenser , BaseEntity entity , Item item)
        {
            BasePlayer player = entity.ToPlayer();
            if (player == null || !player.IsValid() || !IsCannibal(player)) return;

            var ent = dispenser.GetComponent<BaseEntity>();
            if (ent == null) return;

            string itemShortname = item.info.shortname;
            int itemAmount = item.amount;
            float multiplier = GetMultiplierForItem(itemShortname);

            int modifiedAmount = (int)(itemAmount * multiplier);
            int ExtraAmount = modifiedAmount - itemAmount;
            //Puts($"OnDispenserGather: Dispenser {ent} : Player {player} gathered {itemAmount}x {itemShortname}.\nModified Amount: {modifiedAmount} Logd amount : {ExtraAmount}");

            Item modifiedItem = ItemManager.CreateByItemID(item.info.itemid , modifiedAmount);

            switch (modifiedItem.info.shortname)
            {
                case "wood":
                    player.GiveItem(modifiedItem);
                    dataFile.Players[player.UserIDString].WoodCollected += ExtraAmount;
                    item.UseItem(itemAmount);
                    break;
                case "stones":
                    player.GiveItem(modifiedItem);
                    dataFile.Players[player.UserIDString].StoneCollected += ExtraAmount;
                    item.UseItem(itemAmount);
                    break;
                case "metal.ore":
                    player.GiveItem(modifiedItem);
                    dataFile.Players[player.UserIDString].MetalCollected += ExtraAmount;
                    item.UseItem(itemAmount);
                    break;
                case "sulfur.ore":
                    player.GiveItem(modifiedItem);
                    dataFile.Players[player.UserIDString].SulfurCollected += ExtraAmount;
                    item.UseItem(itemAmount);
                    break;
                case "hq.metal.ore":
                    player.GiveItem(modifiedItem);
                    dataFile.Players[player.UserIDString].HQMCollected += ExtraAmount;
                    item.UseItem(itemAmount);
                    break;
                case "metal.refined":
                    player.GiveItem(modifiedItem);
                    dataFile.Players[player.UserIDString].HQMCollected += ExtraAmount;
                    item.UseItem(itemAmount);
                    break;
                default:
                    player.GiveItem(modifiedItem);
                    break;
            }
        }

        private void OnEntityDeath(BaseAnimalNPC animal , HitInfo info)
        {
            if (animal == null || info.InitiatorPlayer == null) return;

            var attacker = info.InitiatorPlayer;

            // Check if the attacker is a valid player and a cannibal
            if (info.InitiatorPlayer.userID.IsSteamId() && IsCannibal(attacker))
            {
                string attackerId = attacker.UserIDString;

                // Check if the attacker's data is in the dictionary
                if (dataFile.Players.TryGetValue(attackerId , out var playerData))
                {
                    playerData.AnimalsKilled += 1;
                }
                else
                {
                    Puts($"Player data not found for {attackerId} in OnEntityDeath method.");
                    if (!IsCannibal(attacker)) return;
                }
            }
        }

        private void OnEntityDeath(BasePlayer victim , HitInfo info)
        {
            if (victim == null || info == null || info.InitiatorPlayer == null) return;

            var attacker = info.InitiatorPlayer;

            if (IsZombieHorde(attacker)) return;

            if (IsCannibal(attacker) && !victim.IsNpc && victim.UserIDString.Length == 17 && !IsZombieHorde(victim))
            {
                //Puts("Human attacker is cannibal victim should not be npc");
                dataFile.Players[attacker.UserIDString].HumansKilled += 1;
                return;
            }
            if (IsCannibal(attacker) && victim.IsNpc && victim.UserIDString.Length < 17 && IsZombieHorde(victim))
            {
                //Puts("Human attacker is cannibal victim is npc");
                dataFile.Players[attacker.UserIDString].NpcKilled += 1;
                return;
            }
            if (IsCannibal(attacker) && IsCannibal(victim) && !IsZombieHorde(victim))
            {
                //Puts("Human attacker is cannibal victim is cannibal");
                dataFile.Players[attacker.UserIDString].CannibalsKilled += 1;
                return;
            }
            else
            {
                if (!IsCannibal(attacker)) return;
                //Puts("Human attacker is cannibal victim is a unknown npc type but counted as npc");
                dataFile.Players[attacker.UserIDString].NpcKilled += 1;
                return;
            }
            return;
        }

        private object OnPlayerDrink(BasePlayer player , LiquidContainer container)
        {
            string containerString = container.ToString();
            Match match = Regex.Match(containerString , @"\[(\d+)\]");
            if (match.Success)
            {
                string networkId = match.Groups[1].Value;
                string containerStringWithoutId = Regex.Replace(containerString , @"\[\d+\]" , "");
                string containerShortPrefabName = containerStringWithoutId.Replace('_' , '.');
                if (IsCannibal(player))
                {
                    if (configData.CannibalS.Eat.FoodItems.TryGetValue(containerShortPrefabName , out bool isAllowed))
                    {
                        if (isAllowed)
                        {
                            //Puts($"OnPlayerDrink isAllowed is true: {isAllowed}");
                            return null;
                        }
                        else
                        {
                            SendMessage(player , "OnConsumeWater");
                            //Puts($"OnPlayerDrink isAllowed is false: {isAllowed}");
                            return true;
                        }
                    }
                }
            }

            return null;
        }

        private object OnEntityTakeDamage(BaseCombatEntity entity , HitInfo info)
        {
            BasePlayer attacker = info?.InitiatorPlayer;
            BasePlayer victim = entity as BasePlayer;
            if (entity == null || info == null || attacker == null) return null;

            if (attacker != null && entity != null && IsCannibal(attacker))
            {
                if (entity is BasePlayer || entity is BaseAnimalNPC)
                {
                    if (IsCannibal(attacker) && IsCannibal(victim) && !configData.CannibalS.Dmg.CanScaleBoost) return null;
                    string itemShortName = info?.Weapon?.GetItem()?.info?.shortname;
                    if (itemShortName == null)
                    {
                        BaseEntity heldEntity = attacker.GetHeldEntity();
                        if (heldEntity != null)
                        {

                            string shortName = heldEntity.ShortPrefabName;
                            if (shortName.Contains("rocket_launcher") || shortName.Contains("grenade"))
                            {
                                //Puts($"{shortName}"); //prefab
                                float damageMultiplier = 1.1f;//grab from cfg instead of this test value
                                float originalDamage = info.damageTypes.Total();
                                float modifiedDamage = originalDamage * damageMultiplier;
                                info.damageTypes.ScaleAll(damageMultiplier);
                                if (damageMultiplier > 1.0f)
                                {
                                    SendMessage(attacker , $"Original Damage: {originalDamage}, Modified Damage: {modifiedDamage}");
                                    string message = lang.GetMessage("ExtraDmg" , this , attacker.UserIDString);
                                    message = message.Replace("{0}" , Mathf.Round(modifiedDamage - originalDamage).ToString("F1"));
                                    SendMessage(attacker , message);
                                }
                            }
                            return null;
                        }
                    return null;
                    }

                    if (IsMeleeWeapon(itemShortName , info.Weapon.GetEntity()))
                    {
                        float damageMultiplier = configData.CannibalS.Dmg.MeleeWeapons[itemShortName];
                        float originalDamage = info.damageTypes.Total();
                        float modifiedDamage = originalDamage * damageMultiplier;
                        info.damageTypes.ScaleAll(damageMultiplier);
                        Effect.server.Run(configData.FX.MeleeHit , entity.transform.position + new Vector3(0 , 1 , 0));
                        if (damageMultiplier > 1.0f)
                        {
                            string message = lang.GetMessage("ExtraDmg" , this , attacker.UserIDString);
                            message = message.Replace("{0}" , Mathf.Round(modifiedDamage - originalDamage).ToString("F1"));
                            SendMessage(attacker , message);
                        }
                        else if (damageMultiplier < 1.0f)
                        {
                            string message = lang.GetMessage("ExtraDmgPenalty" , this , attacker.UserIDString);
                            message = message.Replace("{0}" , Mathf.Round(originalDamage - (originalDamage * damageMultiplier)).ToString("F1"));
                            SendMessage(attacker , message);
                        }
                    }
                    else if (IsRangedWeapon(itemShortName , info.Weapon.GetEntity()))
                    {
                        Puts(info?.Initiator.ToString());
                        float damageMultiplier = configData.CannibalS.Dmg.RangedWeapons[itemShortName];
                        float originalDamage = info.damageTypes.Total();
                        float modifiedDamage = originalDamage * damageMultiplier;
                        info.damageTypes.ScaleAll(damageMultiplier);
                        if (damageMultiplier > 1.0f)
                        {
                            string message = lang.GetMessage("ExtraDmg" , this , attacker.UserIDString);
                            message = message.Replace("{0}" , Mathf.Round(modifiedDamage - originalDamage).ToString("F1"));
                            SendMessage(attacker , message);
                        }
                        else if (damageMultiplier < 1.0f)
                        {
                            string message = lang.GetMessage("ExtraDmgPenalty" , this , attacker.UserIDString);
                            message = message.Replace("{0}" , Mathf.Round(originalDamage - (originalDamage * damageMultiplier)).ToString("F1"));
                            SendMessage(attacker , message);
                        }
                    }
                }
                return null;
            }
            return null;
        }

        private object OnHealingItemUse(MedicalTool tool , BasePlayer player)
        {
            if (!player.userID.IsSteamId()) return null;

            IPlayer iPlayer = covalence.Players.FindPlayerById(player.UserIDString);

            if (!IsCannibal(iPlayer)) return null;

            BasePlayer toolOwner = tool.GetOwnerPlayer();
        
            if (toolOwner != null)
            {
                IPlayer toolOwnerIPlayer = covalence.Players.FindPlayerById(toolOwner.UserIDString);

                int itemId = tool.GetItem().info.itemid; // Get the item ID from the item

                switch (itemId)
                {
                    case 1079279582: // syringe.medical
                        if (toolOwner == player && configData.CannibalS.Heal.CanHealSyringe)
                        {
                            int BonusSyringe = (configData.CannibalS.Heal.BonusSyringe);
                            if (BonusSyringe != 0) player.Heal(BonusSyringe);
                            if(player._health < player._maxHealth)
                            {
                                string message = lang.GetMessage("BonusHeal" , this , iPlayer.Id);
                                message = message.Replace("{0}" , BonusSyringe.ToString());
                                SendMessage(iPlayer , message);
                            }
                            return null;
                        }
                        else if (toolOwner != player && configData.CannibalS.Heal.CanHealOthersSyringe) return null;
                        else
                        {
                            SendMessage(iPlayer , "CannotHealSelfSyringe");
                            //Puts($"{iPlayer.Name} is using a syringe but not allowed to heal himself and/or others with syringes.");
                            return true;
                        }
                        break;
                    case -2072273936: // bandage
                        if (toolOwner == player && configData.CannibalS.Heal.CanHealBandage)
                        {
                            int BonusBandage = (configData.CannibalS.Heal.BonusBandage);
                            if (BonusBandage != 0) player.Heal(BonusBandage);
                            if (player._health < player._maxHealth)
                            {
                                string message = lang.GetMessage("BonusHeal" , this , iPlayer.Id);
                                message = message.Replace("{0}" , BonusBandage.ToString());
                                SendMessage(iPlayer , message);
                            }
                            return null;
                        }
                        else if (toolOwner != player && configData.CannibalS.Heal.CanHealOthersBandage) return null;
                        else
                        {
                            SendMessage(iPlayer , "CannotHealSelfBandage");
                            //Puts($"{iPlayer.Name} is using a bandage but not allowed to heal himself and/or others with bandages.");
                            return true;
                        }
                        break;
                    default:
                        Puts($"{iPlayer.Name} is using an unknown medical tool with item ID {itemId}.");
                        break;
                }
            }
            return null;
        }

        // Define a dictionary to keep track of the last time a player consumed raw human meat
        Dictionary<string , float> lastConsumedTimes = new Dictionary<string , float>();

        private object OnItemAction(Item item , string action , BasePlayer player)
        {
            if (item == null || item.GetRootContainer() == null) return null;
            //Puts($"Action was {action} with item {item.ToString()}");
            var itemcontainer = item.GetRootContainer();
            if (action == "drop") return null;

            IPlayer iPlayer = covalence.Players.FindPlayerById(player.UserIDString);
            float oldHealth = player.health; // Get the player's old health
            string foodShortName = item.info.shortname; // Get the shortname of the food item
            string playerId = iPlayer.Id;
            if (IsCannibal(iPlayer) && action == "consumecontents")
            {
                //Puts($"Consumable was : {item} id : {item.info.itemid} inside consumecontents");
                switch (item.info.shortname)
                {
                    case "waterjug": // waterjug
                        if (configData.CannibalS.Eat.FoodItems.TryGetValue(foodShortName , out bool isAllowed))
                        {
                            if (isAllowed)
                            {
                                return null;
                            }
                            else
                            {
                                SendMessage(iPlayer , $"OnConsumeWater");
                                return true;
                            }
                        }
                        break;
                    default:
                        {
                            //Puts($"Action was {action} inside cannibal consumecontents 2 (default) item : {item}");
                            return null;
                        }
                        break;
                        return null;
                }
            }

            if (IsCannibal(iPlayer) && action == "consume")
            {
                //Puts($"Action was {action} inside cannibal consume 1");
                if (configData.CannibalS.Eat.FoodItems.TryGetValue(foodShortName , out bool isAllowed))
                {
                    if (isAllowed)
                    {
                        float newHealth = player.health; // Get the player's new health after giving boosts

                        float healthChange = newHealth - oldHealth; // Calculate the health change
                        string healthChanged = Mathf.Round(healthChange).ToString("F1");

                        //Puts($"{iPlayer.Name} is eating {foodShortName}. Health added: +{healthChanged}");
                        return null;
                    }
                    else
                    {
                        SendMessage(iPlayer , $"Cannot consume {foodShortName}.");//<-- needs message
                        //Puts($"{iPlayer.Name} is not allowed to consume {foodShortName}.");
                        return true;
                    }
                }
                else
                {
                    //Puts($"Item {foodShortName} not found in the foodlist switching to secondary check.");
                    switch (item.info.itemid)
                    {
                        case 254522515: // largemedkit
                            if (configData.CannibalS.Heal.CanConsumeLmedkit) { return null; }
                            else
                            {
                                SendMessage(iPlayer , "CannotHealSelfMedkit");
                                //Puts($"{iPlayer.Name} is using a largemedkit but not allowed to heal himself");
                                return true;
                            }
                            break;
                        case -1432674913: // antiradpills
                            if (configData.CannibalS.Heal.CanConsumeRadpills) { return null; }
                            else
                            {
                                SendMessage(iPlayer , "CannotHealSelfPills");
                                //Puts($"{iPlayer.Name} is using Anti Radiation pills but not allowed to use them");
                                return true;
                            }
                        case 1536610005: // cooked human meat
                            if (!configData.CannibalS.Eat.BuffHumMeat)
                            {
                                return null;
                            }
                            else
                            {
                                if (lastConsumedTimes.TryGetValue(playerId , out float lastConsumedTime) && Time.realtimeSinceStartup - lastConsumedTime < 1.5f)
                                {
                                    return true;
                                }
                                lastConsumedTimes[playerId] = Time.realtimeSinceStartup;
                                ShowCannibalTimer(player);
                                dataFile.Players[player.UserIDString].HumanMeatConsumed += 1;
                                SendMessage(player , "OnConsumeHumanMeat");
                                GiveBoosts(player ,
                                configData.CannibalS.Eat.BuffComfort / 100 ,
                                configData.CannibalS.Eat.BuffRadiation ,
                                configData.CannibalS.Eat.BuffThirst ,
                                configData.CannibalS.Eat.BuffHunger ,
                                configData.CannibalS.Eat.BuffDuration);
                                ShowCannibalTimer(player);
                                return null;
                            }
                            break;
                        case -682687162: // burned human meat
                            if (!configData.CannibalS.Eat.BuffHumMeat)
                            {
                                return null;
                            }
                            else
                            {
                                if (lastConsumedTimes.TryGetValue(playerId , out float lastConsumedTime) && Time.realtimeSinceStartup - lastConsumedTime < 1.5f)
                                {
                                    return true;
                                }
                                lastConsumedTimes[playerId] = Time.realtimeSinceStartup;
                                ShowCannibalTimer(player);
                                dataFile.Players[player.UserIDString].HumanMeatConsumed += 1;
                                SendMessage(player , "OnConsumeHumanMeat");
                                GiveBoosts(player ,
                                configData.CannibalS.Eat.BuffComfort / 100 ,
                                configData.CannibalS.Eat.BuffRadiation ,
                                configData.CannibalS.Eat.BuffThirst ,
                                configData.CannibalS.Eat.BuffHunger ,
                                configData.CannibalS.Eat.BuffDuration);
                                ShowCannibalTimer(player);
                                return null;
                            }
                            break;
                        case -1709878924: // raw human meat
                            if (!configData.CannibalS.Eat.BuffHumMeat)
                            {
                                return null;
                            }
                            else
                            {
                                if (lastConsumedTimes.TryGetValue(playerId , out float lastConsumedTime) && Time.realtimeSinceStartup - lastConsumedTime < 1.5f)
                                {
                                    return true;
                                }
                                lastConsumedTimes[playerId] = Time.realtimeSinceStartup;
                                ShowCannibalTimer(player);
                                dataFile.Players[player.UserIDString].HumanMeatConsumed += 1;
                                SendMessage(player , "OnConsumeHumanMeat");
                                GiveBoosts(player ,
                                configData.CannibalS.Eat.BuffComfort / 100 ,
                                configData.CannibalS.Eat.BuffRadiation ,
                                configData.CannibalS.Eat.BuffThirst ,
                                configData.CannibalS.Eat.BuffHunger ,
                                configData.CannibalS.Eat.BuffDuration);
                                SendFX(player , FXEatingSound);
                                item.UseItem();
                                ShowCannibalTimer(player);
                                return true;
                            }
                            break;
                        default:
                            {
                                //Puts($"Action was {action} inside cannibal consume 2 (default) item : {item}");
                                return null;
                            }
                            break;
                            return null;
                    }

                }

            }
            switch (item.info.itemid)
            {
                case 1536610005: // cooked human meat
                    SetupPlayer(iPlayer);
                    Cannibalhud(player);
                    SendMessage(iPlayer , "AteHumanMeat");
                    SimpleKillFeed?.Call("SendKillfeedmessage" , $"{player.displayName} {Translate(iPlayer , "SKFTurned")}");
                    Effect.server.Run(configData.FX.Turned , player.transform.position);
                    return null;
                    break;
                default:
                    {
                        return null;
                    }
                    break;
            }
            return null;
        }

        private void Init()
        {
            if (!LoadConfigVariables())
            {
                Puts("Config file issue detected. Please delete file, or check syntax and fix.");
                return;
            }
            CheckAndAddBaseWeapons();
            CheckAndAddFoodItems();
            permission.RegisterPermission(Admin_Perm , this);
            permission.RegisterPermission(CPermanent_Perm , this);

            NextTick(() =>
            {
                foreach (var player in players.Connected)
                {
                    Cannibalhud(player.Object as BasePlayer);
                    if (IsCannibal(player))
                    {
                        StartCannibalTimer(player);
                    }
                }
            });

        }

        private void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                DestroyCannibalHuds(player);
                if (textRefreshTimer != null && !textRefreshTimer.Destroyed)
                {
                    textRefreshTimer.Destroy();
                    CuiHelper.DestroyUi(player , "CannibalUITimerPanel_" + player.userID);
                }
                CuiHelper.DestroyUi(player , "Melee WeaponsPanel");
                CuiHelper.DestroyUi(player , "Ranged WeaponsPanel");
                CuiHelper.DestroyUi(player , "MeleeWeaponsPanelCloseButton");
                CuiHelper.DestroyUi(player , "MainPanel");
            }
        }

        private void OnPlayerDisconnected(BasePlayer player , string reason)
        {
            IPlayer iPlayer = covalence.Players.FindPlayerById(player.UserIDString);
            StopCannibalTimer(iPlayer);
            foreach (BasePlayer plyr in BasePlayer.activePlayerList)
                Cannibalhud(plyr);
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            if (player == null || !player.userID.IsSteamId()) return;
            IPlayer iPlayer = covalence.Players.FindPlayerById(player.UserIDString);
            foreach (BasePlayer plyr in BasePlayer.activePlayerList) Cannibalhud(plyr);
            StartCannibalTimer(iPlayer);
        }

        private void OnPlayerDeath(BasePlayer player , HitInfo info) => DestroyCannibalHuds(player);

        #endregion

        #region Cannibal Core

        // Define a dictionary to store the total remaining boost duration for each player
        Dictionary<ulong , int> totalBoostDurations = new Dictionary<ulong , int>();
        // Define a dictionary to store the boost timers for each player
        Dictionary<ulong , Timer> boostTimers = new Dictionary<ulong , Timer>();

        private void GiveBoosts(BasePlayer player , float comfort , int radiation , int thirst , int hunger , int duration)
        {
            Timer existingTimer = null; // Declare existingTimer outside the if statements

            // Check if the player is still a cannibal
            if (!IsCannibal(player))
            {
                // If not a cannibal, stop and destroy the active timer (if any)
                if (boostTimers.TryGetValue(player.userID , out existingTimer))
                {
                    existingTimer.Destroy();
                    boostTimers.Remove(player.userID);
                    player.metabolism.comfort.min = 0;
                }
                return; // Don't apply boosts if not a cannibal
            }
            //Puts("should boost");
            player.metabolism.radiation_poison.Add(radiation);
            player.metabolism.hydration.Add(30 + thirst);
            player.metabolism.calories.Add(hunger);
            player.health += hunger;
            player.metabolism.comfort.min = comfort;
            int remainingDuration;
            // Check if the player already has a boost duration, if yes, add to it
            if (totalBoostDurations.TryGetValue(player.userID , out remainingDuration))
            {
                remainingDuration += duration;
            }
            else
            {
                remainingDuration = duration;
            }
            if (boostTimers.TryGetValue(player.userID , out existingTimer))
            {
                existingTimer.Destroy();
                boostTimers.Remove(player.userID); // Remove the old timer from the dictionary
            }

            existingTimer = timer.Repeat(1, remainingDuration , () =>
            {
                // Update the total boost duration each second
                remainingDuration--;
                totalBoostDurations[player.userID] = remainingDuration;
                // Check if the player is no longer a cannibal or the duration is exhausted
                if (remainingDuration <= 0 || !IsCannibal(player))
                {
                    // Stop and destroy the timer
                    existingTimer.Destroy();
                    boostTimers.Remove(player.userID);
                    player.metabolism.comfort.min = 0;
                    // Clear the player's total boost duration when the timer expires
                    totalBoostDurations[player.userID] = 0;
                    //Puts($"Boost timer ended for player {player.displayName}.");
                    Effect.server.Run(configData.FX.BuffEnd , player.transform.position);
                    SendMessage(player , "Your buff ended");
                }
            });
            boostTimers[player.userID] = existingTimer;// Store the boost timer in the dictionary
            //Puts($"Remaining time for player {player.displayName}: {remainingDuration} seconds");

        }

        private void SetupPlayer(IPlayer player)
        {
            AddPlayerData(player);
            StartCannibalTimer(player);
        }

        private Dictionary<string , Timer> playerTimers = new Dictionary<string , Timer>();

        private void StartCannibalTimer(IPlayer player)
        {
            string playerId = player.Id;
            if (!playerTimers.ContainsKey(playerId))
            {
                Timer cannibalTimer = timer.Repeat(configData.CannibalS.TimerAdd , 0 , () => IncrementCannibalTime(player));
                playerTimers.Add(playerId , cannibalTimer);
            }
        }

        private void IncrementCannibalTime(IPlayer player)
        {
            string playerId = player.Id;
            if (dataFile.Players.ContainsKey(playerId))
            {
                double oldTime = dataFile.Players[playerId].TotalTimeAsCannibal;
                dataFile.Players[playerId].TotalTimeAsCannibal += configData.CannibalS.TimerAdd;
                double newTime = dataFile.Players[playerId].TotalTimeAsCannibal;
                SaveData();
                //Puts($"Player: {player.Name}, Old Time: {oldTime}, New Time: {newTime}");
            }
        }

        private void StopCannibalTimer(IPlayer player)
        {
            string playerId = player.Id;
            if (playerTimers.TryGetValue(playerId , out var cannibalTimer))
            {
                playerTimers.Remove(playerId);
                cannibalTimer.Destroy();
            }
        }

        #endregion

        #region Item Cfg Updater
        private bool IsNotMeleeItem(string shortName)
        {
            string[] IsNotMeleeIKey = new string[]
            {
                "weapon",
                "weapon.mod",
                "pistol",
                "smg",
                "rifle",
                "lmg",
                "homingmissile",
                "hmlmg",
                "multiplegrenadelauncher",
                "bow",
                "crossbow",
                "shotgun",
                "gun",
                "grenade",
                "pistol",
                "rocket",
                "snowball",
                "flamethrower"
            };
            return IsNotMeleeIKey.Any(keyword => shortName.Contains(keyword));
        }

        private void CheckAndAddBaseWeapons()
        {
            IEnumerable<ItemDefinition> weaponDefinitions = ItemManager.itemList.Where(item => item.category == ItemCategory.Weapon);

            foreach (ItemDefinition itemDef in weaponDefinitions)
            {
                string shortName = itemDef.shortname;
                {
                    if (!IsNotMeleeItem(shortName) && !configData.CannibalS.Dmg.MeleeWeapons.ContainsKey(shortName))
                    {
                        if (!configData.CannibalS.Dmg.MeleeWeapons.ContainsKey(shortName))
                        {
                            Puts(shortName + " added to melee");
                            configData.CannibalS.Dmg.MeleeWeapons.Add(shortName , 1.0f);
                        }
                    }
                    else if (!shortName.Contains("weapon.mod") && !shortName.StartsWith("grenade.") && shortName != "snowball" && !configData.CannibalS.Dmg.RangedWeapons.ContainsKey(shortName) && !configData.CannibalS.Dmg.MeleeWeapons.ContainsKey(shortName))
                    {
                        Puts(shortName + " added to projectile");
                        configData.CannibalS.Dmg.RangedWeapons.Add(shortName , 1.0f);
                    }
                    if(shortName.Contains("weapon.mod") && !configData.CannibalS.Dmg.RangedWeapons.ContainsKey(shortName) && !configData.CannibalS.Dmg.MeleeWeapons.ContainsKey(shortName))
                    {
                        //Puts(shortName + " : Should not be added to melee or projectile");//add to debugg later
                    }
                }
            }
            SaveConf();
        }

        private bool ExcludedFood(string shortName)
        {
            string[] excludedFoodItemKeywords = new string[]
            {
                "seed.",
                "smallwaterbottle",
                "botabag",
                "seed.hemp",
                "humanmeat.cooked",
                "humanmeat.burned",
                "humanmeat.raw",
                "humanmeat.spoiled",
                "fish.anchovy",
                "fish.catfish",
                "fish.herring",
                "fish.orangeroughy",
                "fish.salmon",
                "fish.sardine",
                "fish.smallshark",
                "fish.troutsmall",
                "fish.yellowperch",
            };
            return !excludedFoodItemKeywords.Any(keyword => shortName.Contains(keyword));
        }

        private void CheckAndAddFoodItems()
        {
            IEnumerable<ItemDefinition> foodDefinitions = ItemManager.itemList.Where(item => item.category == ItemCategory.Food);
            foreach (ItemDefinition itemDef in foodDefinitions)
            {
                string shortName = itemDef.shortname;
                if (ExcludedFood(shortName) && !shortName.Contains("clone.") && !configData.CannibalS.Eat.FoodItems.ContainsKey(shortName))
                {
                    Puts($"{shortName} added to food items");
                    configData.CannibalS.Eat.FoodItems.Add(shortName , false);
                }
            }
            if (!configData.CannibalS.Eat.FoodItems.ContainsKey("water.catcher.small"))
            {
                configData.CannibalS.Eat.FoodItems.Add("water.catcher.small" , true);
                Puts($"water.catcher.small added to food items");
            }
            if (!configData.CannibalS.Eat.FoodItems.ContainsKey("water.catcher.large"))
            {
                configData.CannibalS.Eat.FoodItems.Add("water.catcher.large" , true);
                Puts($"water.catcher.large added to food items