
            SaveQuestData();
            SaveVendorData();
        }

        private ulong GetLastAttacker(NetworkableId id)
        {
            int hits = 0;
            ulong majorityPlayer = 0U;
            if (HeliAttackers.ContainsKey(id))
            {
                foreach (var score in HeliAttackers[id])
                {
                    if (score.Value > hits)
                        majorityPlayer = score.Key;
                }
            }

            return majorityPlayer;
        }

        private string GetTypeDescription(QuestType type)
        {
            switch (type)
            {
                case QuestType.Kill:
                    return LA("KillOBJ");
                case QuestType.Craft:
                    return LA("CraftOBJ");
                case QuestType.Gather:
                    return LA("GatherOBJ");
                case QuestType.Loot:
                    return LA("LootOBJ");
                case QuestType.Delivery:
                    return LA("DelvOBJ");
            }

            return "";
        }

        private QuestType ConvertStringToType(string type)
        {
            switch (type)
            {
                case "gather":
                case "Gather":
                    return QuestType.Gather;
                case "loot":
                case "Loot":
                    return QuestType.Loot;
                case "craft":
                case "Craft":
                    return QuestType.Craft;
                case "delivery":
                case "Delivery":
                    return QuestType.Delivery;
                default:
                    return QuestType.Kill;
            }
        }

        private string isNPCRegistered(string ID)
        {
            if (vendors.QuestVendors.ContainsKey(ID)) return LA("aQVReg");
            if (vendors.DeliveryVendors.ContainsKey(ID)) return LA("aDVReg");
            return null;
        }

        static double GrabCurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;

        private BasePlayer FindEntity(BasePlayer player)
        {
            var currentRot = Quaternion.Euler(player.serverInput.current.aimAngles) * Vector3.forward;
            var rayResult = Ray(player, currentRot);
            if (rayResult is BasePlayer)
            {
                var ent = rayResult as BasePlayer;
                return ent;
            }

            return null;
        }

        private object Ray(BasePlayer player, Vector3 Aim)
        {
            var hits = Physics.RaycastAll(player.transform.position + new Vector3(0f, 1.5f, 0f), Aim);
            float distance = 50f;
            object target = null;

            foreach (var hit in hits)
            {
                if (hit.collider.GetComponentInParent<BaseEntity>() != null)
                {
                    if (hit.distance < distance)
                    {
                        distance = hit.distance;
                        target = hit.collider.GetComponentInParent<BaseEntity>();
                    }
                }
            }

            return target;
        }

        private void SetVendorName()
        {
            foreach (var npc in vendors.DeliveryVendors)
            {
                var player = BasePlayer.FindByID(ulong.Parse(npc.Key));
                if (player != null)
                {
                    player.displayName = npc.Value.Info.Name;
                }
            }

            foreach (var npc in vendors.QuestVendors)
            {
                var player = BasePlayer.FindByID(ulong.Parse(npc.Key));
                if (player != null)
                {
                    player.displayName = npc.Value.Name;
                }
            }
        }

        private void RemoveVendor(BasePlayer player, string ID, bool isVendor)
        {
            if (isVendor)
            {
                RemoveMapMarker(vendors.QuestVendors[ID].Name);
                vendors.QuestVendors.Remove(ID);

                int i = 1;
                foreach (var npc in vendors.QuestVendors)
                {
                    RemoveMapMarker(npc.Value.Name);
                    AddMapMarker(npc.Value.x, npc.Value.z, npc.Value.Name, $"{configData.LustyMapIntegration.Icon_Vendor}.png");
                    i++;
                }
            }
            else
            {
                RemoveMapMarker(vendors.DeliveryVendors[ID].Info.Name);
                vendors.DeliveryVendors.Remove(ID);

                int i = 1;
                foreach (var npc in vendors.DeliveryVendors)
                {
                    RemoveMapMarker(npc.Value.Info.Name);
                    AddMapMarker(npc.Value.Info.x, npc.Value.Info.z, npc.Value.Info.Name, $"{configData.LustyMapIntegration.Icon_Delivery}_{i}.png");
                    i++;
                }

                foreach (var user in PlayerProgress)
                {
                    if (user.Value.Quests.ContainsKey(ID))
                        user.Value.Quests.Remove(ID);
                }
            }

            DeleteNPCMenu(player);
            PopupMessage(player, $"You have successfully removed the npc with ID: {ID}");
            SaveVendorData();
        }

        private string GetRandomNPC(string ID)
        {
            List<string> npcIDs = vendors.DeliveryVendors.Keys.ToList();
            List<string> withoutSelected = npcIDs;
            if (withoutSelected.Contains(ID))
                withoutSelected.Remove(ID);
            var randNum = UnityEngine.Random.Range(0, withoutSelected.Count - 1);
            return withoutSelected[randNum];
        }

        private string LA(string key, string userID = null) => lang.GetMessage(key, this, userID);

        #endregion

        #region UI

        private void CreateMenu(BasePlayer player)
        {
            CloseMap(player);

            var MenuElement = QUI.CreateElementContainer(UIMain, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0 0", "0.12 1");
            QUI.CreatePanel(ref MenuElement, UIMain, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.05 0.01", "0.95 0.99", true);
            QUI.CreateLabel(ref MenuElement, UIMain, "", $"{textPrimary}Quests</color>", 30, "0.05 0.9", "0.95 1");
            int i = 0;
            CreateMenuButton(ref MenuElement, UIMain, LA("Kill", player.UserIDString), "QUI_ChangeElement kill", i); i++;
            CreateMenuButton(ref MenuElement, UIMain, LA("Gather", player.UserIDString), "QUI_ChangeElement gather", i); i++;
            CreateMenuButton(ref MenuElement, UIMain, LA("Loot", player.UserIDString), "QUI_ChangeElement loot", i); i++;
            CreateMenuButton(ref MenuElement, UIMain, LA("Craft", player.UserIDString), "QUI_ChangeElement craft", i); i++;
            i++;
            if (HumanNPC)
                CreateMenuButton(ref MenuElement, UIMain, LA("Delivery", player.UserIDString), "QUI_ChangeElement delivery", i); i++;
            CreateMenuButton(ref MenuElement, UIMain, LA("Your Quests", player.UserIDString), "QUI_ChangeElement personal", i); i++;

            if (isAdmin(player)) QUI.CreateButton(ref MenuElement, UIMain, QUI.Color(configData.Colors.Button_Accept.Color, configData.Colors.Button_Accept.Alpha), LA("Create Quest", player.UserIDString), 18, "0.1 0.16", "0.9 0.215", "QUI_ChangeElement creation");

            QUI.CreateButton(ref MenuElement, UIMain, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("Close", player.UserIDString), 18, "0.1 0.03", "0.9 0.085", "QUI_DestroyAll");
            CuiHelper.AddUi(player, MenuElement);
        }

        private void CreateEmptyMenu(BasePlayer player)
        {
            CloseMap(player);

            var MenuElement = QUI.CreateElementContainer(UIMain, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0 0", "0.12 1");
            QUI.CreatePanel(ref MenuElement, UIMain, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.05 0.01", "0.95 0.99", true);
            QUI.CreateLabel(ref MenuElement, UIMain, "", $"{textPrimary}Quests</color>", 30, "0.05 0.9", "0.95 1");
            CreateMenuButton(ref MenuElement, UIMain, LA("Your Quests", player.UserIDString), "QUI_ChangeElement personal", 4);

            QUI.CreateButton(ref MenuElement, UIMain, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("Close", player.UserIDString), 18, "0.1 0.03", "0.9 0.085", "QUI_DestroyAll");
            CuiHelper.AddUi(player, MenuElement);
        }

        private void CreateMenuButton(ref CuiElementContainer container, string panelName, string buttonname, string command, int number)
        {
            Vector2 dimensions = new Vector2(0.8f, 0.055f);
            Vector2 origin = new Vector2(0.1f, 0.75f);
            Vector2 offset = new Vector2(0, (0.01f + dimensions.y) * number);

            Vector2 posMin = origin - offset;
            Vector2 posMax = posMin + dimensions;

            QUI.CreateButton(ref container, panelName, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), buttonname, 18, $"{posMin.x} {posMin.y}", $"{posMax.x} {posMax.y}", command);
        }

        private void ListElement(BasePlayer player, QuestType type, int page = 0)
        {
            DestroyEntries(player);
            var Main = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.12 0", "1 1");
            QUI.CreatePanel(ref Main, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.01", "0.99 0.99", true);
            QUI.CreateLabel(ref Main, UIPanel, "", GetTypeDescription(type), 16, "0.1 0.93", "0.9 0.99");
            QUI.CreateLabel(ref Main, UIPanel, "1 1 1 0.015", type.ToString().ToUpper(), 200, "0.01 0.01", "0.99 0.99");
            var quests = Quest[type];
            if (quests.Count > 16)
            {
                var maxpages = (quests.Count - 1) / 16 + 1;
                if (page < maxpages - 1)
                    QUI.CreateButton(ref Main, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("Next", player.UserIDString), 16, "0.86 0.94", "0.97 0.98", $"QUI_ChangeElement listpage {type} {page + 1}");
                if (page > 0)
                    QUI.CreateButton(ref Main, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("Back", player.UserIDString), 16, "0.03 0.94", "0.14 0.98", $"QUI_ChangeElement listpage {type} {page - 1}");
            }

            int maxentries = (16 * (page + 1));
            if (maxentries > quests.Count)
                maxentries = quests.Count;
            int rewardcount = 16 * page;
            List<string> questNames = new List<string>();
            foreach (var entry in Quest[type])
                questNames.Add(entry.Key);

            if (quests.Count == 0)
                QUI.CreateLabel(ref Main, UIPanel, "", $"{textPrimary}{LA("noQ", player.UserIDString)} {type.ToString().ToLower()} {LA("quests", player.UserIDString)} </color>", 24, "0 0.82", "1 0.9");

            CuiHelper.AddUi(player, Main);

            int i = 0;
            for (int n = rewardcount; n < maxentries; n++)
            {
                CreateQuestEntry(player, quests[questNames[n]], i);
                i++;
            }
        }

        private void CreateQuestEntry(BasePlayer player, QuestEntry entry, int num)
        {
            Vector2 posMin = CalcQuestPos(num);
            Vector2 dimensions = new Vector2(0.21f, 0.22f);
            Vector2 posMax = posMin + dimensions;

            var panelName = UIEntry + num;
            AddUIString(player, panelName);

            var questEntry = QUI.CreateElementContainer(panelName, "0 0 0 0", $"{posMin.x} {posMin.y}", $"{posMax.x} {posMax.y}");
            QUI.CreatePanel(ref questEntry, panelName, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), $"0 0", $"1 1");

            string buttonCommand = "";
            string buttonText = "";
            string buttonColor = "";
            QuestStatus status = QuestStatus.Open;
            var prog = PlayerProgress[player.userID].Quests;
            if (prog.ContainsKey(entry.QuestName))
            {
                status = prog[entry.QuestName].Status;
                switch (prog[entry.QuestName].Status)
                {
                    case QuestStatus.Pending:

                        buttonColor = QUI.Color(configData.Colors.Button_Pending.Color, configData.Colors.Button_Pending.Alpha);
                        buttonText = LA("Pending", player.UserIDString);
                        break;
                    case QuestStatus.Completed:
                        buttonColor = QUI.Color(configData.Colors.Button_Completed.Color, configData.Colors.Button_Completed.Alpha);
                        buttonText = LA("Completed", player.UserIDString);
                        break;
                }
            }
            else
            {
                buttonColor = QUI.Color(configData.Colors.Button_Accept.Color, configData.Colors.Button_Accept.Alpha);
                buttonText = LA("Accept Quest", player.UserIDString);
                buttonCommand = $"QUI_AcceptQuest {entry.QuestName}";
            }

            if (configData.PlayerMaxQuests != 0 && !permission.UserHasPermission(player.UserIDString, "quests.bypassQuestsLimit") && playerData.PlayerProgress[player.userID].Quests.Count() >= configData.PlayerMaxQuests)
            {
                QUI.CreateButton(ref questEntry, panelName, QUI.Color(configData.Colors.Button_Cancel.Color, configData.Colors.Button_Cancel.Alpha), "Quests limit reached", 11, $"0.60 0.83", $"0.98 0.97", "");
            }
            else
            {
                QUI.CreateButton(ref questEntry, panelName, buttonColor, buttonText, 14, $"0.60 0.83", $"0.98 0.97", buttonCommand);
            }


            string rewards = GetRewardString(entry.Rewards);
            string questInfo = $"{textPrimary}{LA("Status:", player.UserIDString)}</color> {status}";
            questInfo = questInfo + $"\n{textPrimary}{LA("Desc", player.UserIDString)} </color>{textSecondary}{entry.Description}</color>";
            questInfo = questInfo + $"\n{textPrimary}{LA("Objective:", player.UserIDString)} </color>{textSecondary}{entry.ObjectiveName}</color>";
            questInfo = questInfo + $"\n{textPrimary}{LA("Amount Required:", player.UserIDString)} </color>{textSecondary}{entry.AmountRequired}</color>";
            questInfo = questInfo + $"\n{textPrimary}{LA("Reward:", player.UserIDString)} </color>{textSecondary}{rewards}</color>";

            QUI.CreateLabel(ref questEntry, panelName, "", $"{entry.QuestName}", 16, $"0.02 0.8", "0.72 0.95", TextAnchor.MiddleLeft);
            QUI.CreateLabel(ref questEntry, panelName, buttonColor, questInfo, 14, $"0.02 0.01", "0.98 0.78", TextAnchor.UpperLeft);

            if (isAdmin(player))
            {
                QUI.CreateButton(ref questEntry, panelName, QUI.Color(configData.Colors.Button_Completed.Color, configData.Colors.Button_Completed.Alpha), LA("Edit Quest", player.UserIDString), 10, "0.60 0.70", "0.77 0.80", $"QUI_EditQuest {entry.QuestName}");
                QUI.CreateButton(ref questEntry, panelName, QUI.Color(configData.Colors.Button_Cancel.Color, configData.Colors.Button_Cancel.Alpha), LA("Delete Quest", player.UserIDString), 10, "0.78 0.70", "0.98 0.80", $"QUI_ConfirmDelete {entry.QuestName}");
            }

            CuiHelper.AddUi(player, questEntry);
        }

        private void PlayerStats(BasePlayer player, int page = 0)
        {
            DestroyEntries(player);
            var Main = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.12 0", "1 1");
            QUI.CreatePanel(ref Main, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.01", "0.99 0.99", true);
            QUI.CreateLabel(ref Main, UIPanel, "", LA("yqDesc", player.UserIDString), 16, "0.1 0.93", "0.9 0.99");
            QUI.CreateLabel(ref Main, UIPanel, "1 1 1 0.015", LA("STATS", player.UserIDString), 200, "0.01 0.01", "0.99 0.99");

            var stats = PlayerProgress[player.userID];
            if (stats.Quests.Count > 16)
            {
                var maxpages = (stats.Quests.Count - 1) / 16 + 1;
                if (page < maxpages - 1)
                    QUI.CreateButton(ref Main, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("Next", player.UserIDString), 16, "0.86 0.94", "0.97 0.98", $"QUI_ChangeElement statspage {page + 1}");
                if (page > 0)
                    QUI.CreateButton(ref Main, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("Back", player.UserIDString), 16, "0.03 0.94", "0.14 0.098", $"QUI_ChangeElement statspage {page - 1}");
            }

            int maxentries = (16 * (page + 1));
            if (maxentries > stats.Quests.Count)
                maxentries = stats.Quests.Count;
            int rewardcount = 16 * page;
            List<string> questNames = new List<string>();
            foreach (var entry in stats.Quests)
                questNames.Add(entry.Key);

            if (stats.Quests.Count == 0)
                QUI.CreateLabel(ref Main, UIPanel, "", $"{textPrimary}{LA("noQDSaved", player.UserIDString)}</color>", 24, "0 0.82", "1 0.9");

            CuiHelper.AddUi(player, Main);

            int i = 0;
            for (int n = rewardcount; n < maxentries; n++)
            {
                var Quest = GetQuest(questNames[n]);
                if (Quest == null) continue;
                CreateStatEntry(player, Quest, i);
                i++;
            }
        }

        private void CreateStatEntry(BasePlayer player, QuestEntry entry, int num)
        {
            Vector2 posMin = CalcQuestPos(num);
            Vector2 dimensions = new Vector2(0.21f, 0.22f);
            Vector2 posMax = posMin + dimensions;

            var panelName = UIEntry + num;
            AddUIString(player, panelName);

            var questEntry = QUI.CreateElementContainer(panelName, "0 0 0 0", $"{posMin.x} {posMin.y}", $"{posMax.x} {posMax.y}");
            QUI.CreatePanel(ref questEntry, panelName, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), $"0 0", $"1 1");

            string statusColor = "";
            QuestStatus status = QuestStatus.Open;
            var prog = PlayerProgress[player.userID].Quests;
            if (prog.ContainsKey(entry.QuestName))
            {
                status = prog[entry.QuestName].Status;
                switch (prog[entry.QuestName].Status)
                {
                    case QuestStatus.Pending:
                        statusColor = QUI.Color(configData.Colors.Button_Pending.Color, configData.Colors.Button_Pending.Alpha);
                        break;
                    case QuestStatus.Completed:
                        statusColor = QUI.Color(configData.Colors.Button_Completed.Color, configData.Colors.Button_Completed.Alpha);
                        break;
                }
            }

            if (status != QuestStatus.Completed)
                QUI.CreateButton(ref questEntry, panelName, QUI.Color(configData.Colors.Button_Cancel.Color, configData.Colors.Button_Cancel.Alpha), LA("Cancel Quest", player.UserIDString), 16, $"0.63 0.83", $"0.97 0.97", $"QUI_CancelQuest {entry.QuestName}");
            if (status == QuestStatus.Completed && !prog[entry.QuestName].RewardClaimed)
                QUI.CreateButton(ref questEntry, panelName, statusColor, LA("Claim Reward", player.UserIDString), 16, $"0.62 0.83", $"0.97 0.97", $"QUI_ClaimReward {entry.QuestName}");
            string questStatus = status.ToString();
            if (status == QuestStatus.Completed && prog[entry.QuestName].RewardClaimed)
            {
                if (prog[entry.QuestName].ResetTime < GrabCurrentTime())
                    QUI.CreateButton(ref questEntry, panelName, statusColor, LA("Remove", player.UserIDString), 16, $"0.75 0.83", $"0.97 0.97", $"QUI_RemoveCompleted {entry.QuestName}");
                else
                {
                    TimeSpan dateDifference = TimeSpan.FromSeconds(prog[entry.QuestName].ResetTime - GrabCurrentTime());
                    var days = dateDifference.Days;
                    var hours = dateDifference.Hours;
                    hours += (days * 24);
                    var mins = dateDifference.Minutes;
                    string remaining = string.Format("{0:00}h :{1:00}m", hours, mins);
                    questStatus = $"{LA("Cooldown:", player.UserIDString)} {remaining}";
                }
            }

            var rewards = GetRewardString(entry.Rewards);
            var percent = Math.Round(Convert.ToDouble((float)prog[entry.QuestName].AmountCollected / (float)entry.AmountRequired), 4);
            //Puts($"Collected: {prog[entry.QuestName].AmountCollected.ToString()}, Required: {entry.AmountRequired.ToString()}, Pct: {percent.ToString()}");
            string stats = $"{textPrimary}{LA("Status:", player.UserIDString)}</color> {questStatus}";
            stats += $"\n{textPrimary}{LA("Quest Type:", player.UserIDString)} </color> {textSecondary}{prog[entry.QuestName].Type}</color>";
            stats += $"\n{textPrimary}{LA("Desc", player.UserIDString)} </color>{textSecondary}{entry.Description}</color>";
            stats += $"\n{textPrimary}{LA("Objective:", player.UserIDString)} </color>{textSecondary}{entry.AmountRequired}x {entry.ObjectiveName}</color>";
            stats += $"\n{textPrimary}{LA("Collected:", player.UserIDString)} </color>{textSecondary}{prog[entry.QuestName].AmountCollected}</color> {textPrimary}({percent * 100}%)</color>";
            stats += $"\n{textPrimary}{LA("Reward:", player.UserIDString)} </color>{textSecondary}{rewards}</color>";

            QUI.CreateLabel(ref questEntry, panelName, "", $"{entry.QuestName}", 18, $"0.02 0.8", "0.8 0.95", TextAnchor.UpperLeft);
            QUI.CreateLabel(ref questEntry, panelName, "", stats, 14, $"0.02 0.01", "0.98 0.78", TextAnchor.UpperLeft);

            CuiHelper.AddUi(player, questEntry);
        }

        private void PlayerDelivery(BasePlayer player)
        {
            DestroyEntries(player);
            var Main = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.12 0", "1 1");
            QUI.CreatePanel(ref Main, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.01", "0.99 0.99", true);
            QUI.CreateLabel(ref Main, UIPanel, "", GetTypeDescription(QuestType.Delivery), 16, "0.1 0.93", "0.9 0.99");
            QUI.CreateLabel(ref Main, UIPanel, "1 1 1 0.015", LA("DELIVERY", player.UserIDString), 200, "0.01 0.01", "0.99 0.99");

            var npcid = PlayerProgress[player.userID].CurrentDelivery.VendorID;
            var targetid = PlayerProgress[player.userID].CurrentDelivery.TargetID;
            if (string.IsNullOrEmpty(npcid))
                QUI.CreateLabel(ref Main, UIPanel, "", $"{textPrimary}{LA("noADM", player.UserIDString)}</color>", 24, "0 0.82", "1 0.9");
            else
            {
                var quest = vendors.DeliveryVendors[npcid];
                var target = vendors.DeliveryVendors[targetid];
                if (quest != null && target != null)
                {
                    var distance = Vector2.Distance(new Vector2(quest.Info.x, quest.Info.z), new Vector2(target.Info.x, target.Info.z));
                    var rewardAmount = distance * quest.Multiplier;
                    if (rewardAmount < 1) rewardAmount = 1;
                    var briefing = $"{textPrimary}{quest.Info.Name}\n\n</color>";
                    briefing = briefing + $"{textSecondary}{quest.Description}</color>\n\n";
                    briefing = briefing + $"{textPrimary}{LA("Destination:", player.UserIDString)} </color>{textSecondary}{target.Info.Name}\nX {target.Info.x}, Z {target.Info.z}</color>\n";
                    briefing = briefing + $"{textPrimary}{LA("Distance:", player.UserIDString)} </color>{textSecondary}{distance}M</color>\n";
                    briefing = briefing + $"{textPrimary}{LA("Reward:", player.UserIDString)} </color>{textSecondary}{(int)rewardAmount}x {quest.Reward.DisplayName}</color>";
                    QUI.CreateLabel(ref Main, UIPanel, "", briefing, 20, "0.15 0.2", "0.85 1", TextAnchor.MiddleLeft);

                    QUI.CreateButton(ref Main, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("Cancel", player.UserIDString), 18, "0.2 0.05", "0.35 0.1", $"QUI_CancelDelivery");
                }
            }

            CuiHelper.AddUi(player, Main);
        }

        private void CreationMenu(BasePlayer player)
        {
            DestroyEntries(player);
            var Main = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.12 0", "1 1");
            QUI.CreatePanel(ref Main, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.01", "0.99 0.99", true);

            int i = 0;
            QUI.CreateLabel(ref Main, UIPanel, "", $"{textPrimary}{LA("selCreat", player.UserIDString)}</color>", 20, "0.25 0.8", "0.75 0.9");
            QUI.CreateLabel(ref Main, UIPanel, "1 1 1 0.025", LA("CREATOR", player.UserIDString), 200, "0.01 0.01", "0.99 0.99");
            CreateNewQuestButton(ref Main, UIPanel, LA("Kill", player.UserIDString), "QUI_NewQuest kill", i); i++;
            CreateNewQuestButton(ref Main, UIPanel, LA("Gather", player.UserIDString), "QUI_NewQuest gather", i); i++;
            CreateNewQuestButton(ref Main, UIPanel, LA("Loot", player.UserIDString), "QUI_NewQuest loot", i); i++;
            CreateNewQuestButton(ref Main, UIPanel, LA("Craft", player.UserIDString), "QUI_NewQuest craft", i); i++;
            if (HumanNPC)
                CreateNewQuestButton(ref Main, UIPanel, LA("Delivery", player.UserIDString), "QUI_NewQuest delivery", i); i++;

            CuiHelper.AddUi(player, Main);
        }

        private void CreationHelp(BasePlayer player, int page = 0)
        {
            DestroyEntries(player);
            QuestCreator quest = null;
            if (ActiveCreations.ContainsKey(player.userID))
                quest = ActiveCreations[player.userID];
            else if (ActiveEditors.ContainsKey(player.userID))
                quest = ActiveEditors[player.userID];
            if (quest == null) return;

            var HelpMain = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.4 0.3", "0.95 0.9");
            QUI.CreatePanel(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.02", "0.99 0.98");

            switch (page)
            {
                case 0:
                    QUI.CreateLabel(ref HelpMain, UIPanel, "", $"{textPrimary}{LA("creHelMen", player.UserIDString)}.\n</color> {textSecondary}{LA("creHelFol", player.UserIDString)}.\n\n{LA("creHelExi", player.UserIDString)} </color>{textPrimary}'exit'\n\n\n\n{LA("creHelName", player.UserIDString)}</color>", 20, "0 0", "1 1");
                    break;
                case 1:
                    var MenuMain = QUI.CreateElementContainer(UIMain, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0 0", "1 1", true);
                    QUI.CreatePanel(ref MenuMain, UIMain, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.01", "0.99 0.99");
                    QUI.CreateLabel(ref MenuMain, UIMain, "", $"{textPrimary}{LA("creHelObj", player.UserIDString)}</color>", 20, "0.25 0.85", "0.75 0.95");
                    CuiHelper.AddUi(player, MenuMain);
                    CreateObjectiveMenu(player);
                    return;
                case 2:
                    QUI.CreateLabel(ref HelpMain, UIPanel, "", $"{textPrimary}{LA("creHelRA", player.UserIDString)}</color>", 20, "0.25 0.4", "0.75 0.6");
                    break;
                case 3:
                    QUI.CreateLabel(ref HelpMain, UIPanel, "", $"{textPrimary}{LA("creHelQD", player.UserIDString)}</color>", 20, "0.25 0.4", "0.75 0.6");
                    break;
                case 4:
                    {
                        HelpMain = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.4 0.3", "0.95 0.9");
                        QUI.CreatePanel(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.02", "0.99 0.98", true);
                        QUI.CreateLabel(ref HelpMain, UIPanel, "", $"{textPrimary}{LA("creHelRT", player.UserIDString)}</color>", 20, "0.25 0.8", "0.75 1");
                        int i = 0;
                        if (Economics) CreateRewardTypeButton(ref HelpMain, UIPanel, $"{LA("Coins", player.UserIDString)} (Economics)", "QUI_RewardType coins", i); i++;
                        if (ServerRewards) CreateRewardTypeButton(ref HelpMain, UIPanel, $"{LA("RP", player.UserIDString)} (ServerRewards)", "QUI_RewardType rp", i); i++;
                        CreateRewardTypeButton(ref HelpMain, UIPanel, LA("Item", player.UserIDString), "QUI_RewardType item", i); i++;
                        if (HuntRPG) CreateRewardTypeButton(ref HelpMain, UIPanel, $"{LA("HuntXP", player.UserIDString)} (HuntRPG)", "QUI_RewardType huntxp", i); i++;
                    }
                    break;
                case 5:
                    if (quest.item.isCoins || quest.item.isRP || quest.item.isHuntXP)
                        QUI.CreateLabel(ref HelpMain, UIPanel, "", $"{textPrimary}{LA("creHelRewA", player.UserIDString)}</color>", 20, "0.25 0.4", "0.75 0.6");
                    else
                    {
                        HelpMain = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.3 0.8", "0.7 0.97");
                        QUI.CreatePanel(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.02", "0.99 0.98");
                        QUI.CreateLabel(ref HelpMain, UIPanel, "", $"{textPrimary}{LA("creHelIH", player.UserIDString)} 'quest item'</color>", 20, "0.1 0", "0.9 1");
                    }

                    break;
                case 7:
                    HelpMain = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.4 0.3", "0.95 0.9", true);
                    QUI.CreatePanel(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.02", "0.99 0.98");
                    QUI.CreateLabel(ref HelpMain, UIPanel, "", $"{textPrimary}{LA("creHelAR", player.UserIDString)}</color>", 20, "0.1 0", "0.9 1");
                    QUI.CreateButton(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("Yes", player.UserIDString), 18, "0.6 0.05", "0.8 0.15", $"QUI_AddReward");
                    QUI.CreateButton(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("No", player.UserIDString), 18, "0.2 0.05", "0.4 0.15", $"QUI_RewardFinish");
                    break;
                case 8:
                    if (quest.type != QuestType.Kill)
                    {
                        HelpMain = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.4 0.3", "0.95 0.9", true);
                        QUI.CreatePanel(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.02", "0.99 0.98");
                        QUI.CreateLabel(ref HelpMain, UIPanel, "", $"{textPrimary}{LA("creHelID", player.UserIDString)}</color>", 20, "0.1 0", "0.9 1");
                        QUI.CreateButton(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("Yes", player.UserIDString), 18, "0.6 0.05", "0.8 0.15", $"QUI_ItemDeduction 1");
                        QUI.CreateButton(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("No", player.UserIDString), 18, "0.2 0.05", "0.4 0.15", $"QUI_ItemDeduction 0");
                    }
                    else
                    {
                        CreationHelp(player, 9);
                        return;
                    }

                    break;
                case 9:
                    HelpMain = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.3 0.8", "0.7 0.97");
                    QUI.CreatePanel(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.02", "0.99 0.98");
                    QUI.CreateLabel(ref HelpMain, UIPanel, "", $"{textPrimary}{LA("creHelCD", player.UserIDString)}</color>", 20, "0.1 0", "0.9 1");
                    break;
                case 10:
                    {
                        HelpMain = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.4 0.3", "0.95 0.9");
                        QUI.CreatePanel(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.02", "0.99 0.98", true);
                        QUI.CreateLabel(ref HelpMain, UIPanel, "", $"{textPrimary}{LA("creHelNewRew", player.UserIDString)}</color>", 20, "0.25 0.8", "0.75 1");
                        QUI.CreateButton(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("addNewRew", player.UserIDString), 18, "0.7 0.04", "0.95 0.12", $"QUI_AddReward");
                        QUI.CreateButton(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("Back", player.UserIDString), 18, "0.05 0.04", "0.3 0.12", $"QUI_EndEditing");

                        int i = 0;
                        foreach (var entry in ActiveEditors[player.userID].entry.Rewards)
                        {
                            CreateDelEditButton(ref HelpMain, 0.1f, UIPanel, $"{entry.Amount}x {entry.DisplayName}", i, "", 0.35f);
                            CreateDelEditButton(ref HelpMain, 0.72f, UIPanel, LA("Remove", player.UserIDString), i, $"QUI_RemoveReward {entry.Amount} {entry.DisplayName}");
                            i++;
                        }
                    }
                    break;
                default:
                    HelpMain = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.4 0.3", "0.95 0.9", true);
                    QUI.CreatePanel(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.02", "0.99 0.98");
                    QUI.CreateLabel(ref HelpMain, UIPanel, "", $"{textPrimary}{LA("creHelSQ", player.UserIDString)}</color>", 20, "0.1 0.8", "0.9 0.95");
                    string questDetails = $"{textPrimary}{LA("Quest Type:", player.UserIDString)}</color> {textSecondary}{quest.type}</color>";
                    questDetails = questDetails + $"\n{textPrimary}{LA("Name:", player.UserIDString)}</color> {textSecondary}{quest.entry.QuestName}</color>";
                    questDetails = questDetails + $"\n{textPrimary}{LA("Desc", player.UserIDString)}</color> {textSecondary}{quest.entry.Description}</color>";
                    questDetails = questDetails + $"\n{textPrimary}{LA("Objective:", player.UserIDString)}</color> {textSecondary}{quest.entry.ObjectiveName}</color>";
                    questDetails = questDetails + $"\n{textPrimary}{LA("Required Amount:", player.UserIDString)}</color> {textSecondary}{quest.entry.AmountRequired}</color>";
                    if (quest.type != QuestType.Kill) questDetails = questDetails + $"\n{textPrimary}{LA("Item Deduction:", player.UserIDString)}</color> {textSecondary}{quest.entry.ItemDeduction}</color>";
                    questDetails = questDetails + $"\n{textPrimary}{LA("CDMin", player.UserIDString)}</color> {textSecondary}{quest.entry.Cooldown}</color>";

                    var rewards = GetRewardString(quest.entry.Rewards);

                    questDetails = questDetails + $"\n{textPrimary}{LA("Reward:", player.UserIDString)}</color> {textSecondary}{rewards}</color>";

                    QUI.CreateLabel(ref HelpMain, UIPanel, "", questDetails, 20, "0.1 0.2", "0.9 0.75", TextAnchor.MiddleLeft);
                    QUI.CreateButton(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("Save Quest", player.UserIDString), 18, "0.6 0.05", "0.8 0.15", $"QUI_SaveQuest");
                    QUI.CreateButton(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("Cancel", player.UserIDString), 18, "0.2 0.05", "0.4 0.15", $"QUI_ExitQuest");
                    break;
            }

            CuiHelper.AddUi(player, HelpMain);
        }

        private void CreateObjectiveMenu(BasePlayer player, int page = 0)
        {
            DestroyEntries(player);
            var HelpMain = QUI.CreateElementContainer(UIPanel, "0 0 0 0", "0 0", "1 1");
            QuestType type;
            if (ActiveCreations.ContainsKey(player.userID))
                type = ActiveCreations[player.userID].type;
            else type = ActiveEditors[player.userID].type;
            var objCount = AllObjectives[type].Count;
            if (objCount > 100)
            {
                var maxpages = (objCount - 1) / 96 + 1;
                if (page < maxpages - 1)
                    QUI.CreateButton(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("Next", player.UserIDString), 18, "0.84 0.05", "0.97 0.1", $"QUI_ChangeElement objpage {page + 1}");
                if (page > 0)
                    QUI.CreateButton(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("Back", player.UserIDString), 18, "0.03 0.05", "0.16 0.1", $"QUI_ChangeElement objpage {page - 1}");
            }

            int maxentries = (96 * (page + 1));
            if (maxentries > objCount)
                maxentries = objCount;
            int rewardcount = 96 * page;

            int i = 0;
            for (int n = rewardcount; n < maxentries; n++)
            {
                CreateObjectiveEntry(ref HelpMain, UIPanel, AllObjectives[type][n], i);
                i++;
            }

            CuiHelper.AddUi(player, HelpMain);
        }

        private void DeliveryHelp(BasePlayer player, int page = 0)
        {
            DestroyEntries(player);
            switch (page)
            {
                case 0:
                    var HelpMain = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.12 0.0", "1 1", true);
                    QUI.CreatePanel(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.01", "0.99 0.99");
                    QUI.CreateLabel(ref HelpMain, UIPanel, "", $"{textPrimary}{LA("delHelMen", player.UserIDString)}\n\n</color> {textSecondary}{LA("delHelChoo", player.UserIDString)}.\n\n{LA("creHelExi", player.UserIDString)} </color>{textPrimary}'exit'</color>", 20, "0 0", "1 1");
                    QUI.CreateButton(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("Quest Vendor", player.UserIDString), 18, "0.6 0.05", "0.8 0.15", $"QUI_AddVendor 1");
                    QUI.CreateButton(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("Delivery Vendor", player.UserIDString), 18, "0.2 0.05", "0.4 0.15", $"QUI_AddVendor 2");
                    CuiHelper.AddUi(player, HelpMain);
                    return;
                case 1:
                    var element = QUI.CreateElementContainer(UIMain, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.25 0.85", "0.75 0.95");
                    QUI.CreatePanel(ref element, UIMain, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), "0.005 0.04", "0.995 0.96");
                    QUI.CreateLabel(ref element, UIMain, "", $"{textPrimary}{LA("delHelNewNPC", player.UserIDString)} '/questnpc'</color>", 22, "0 0", "1 1");
                    CuiHelper.AddUi(player, element);
                    return;
                case 2:
                    DestroyUI(player);
                    HelpMain = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.4 0.3", "0.95 0.9");
                    QUI.CreatePanel(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.02", "0.99 0.98", true);
                    QUI.CreateLabel(ref HelpMain, UIPanel, "", $"{textSecondary}{LA("delHelMult", player.UserIDString)}</color>\n{textPrimary}{LA("creHelRT", player.UserIDString)}</color>", 18, "0.05 0.82", "0.95 0.98");
                    int i = 0;
                    if (Economics) CreateRewardTypeButton(ref HelpMain, UIPanel, "Coins (Economics)", "QUI_RewardType coins", i); i++;
                    if (ServerRewards) CreateRewardTypeButton(ref HelpMain, UIPanel, "RP (ServerRewards)", "QUI_RewardType rp", i); i++;
                    CreateRewardTypeButton(ref HelpMain, UIPanel, LA("Item", player.UserIDString), "QUI_RewardType item", i); i++;
                    if (HuntRPG) CreateRewardTypeButton(ref HelpMain, UIPanel, "XP (HuntRPG)", "QUI_RewardType huntxp", i); i++;
                    CuiHelper.AddUi(player, HelpMain);
                    return;
                case 3:
                    {
                        HelpMain = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.4 0.3", "0.95 0.9");
                        QUI.CreatePanel(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.02", "0.99 0.98");
                        var quest = ActiveCreations[player.userID];
                        if (quest.deliveryInfo.Reward.isCoins || quest.deliveryInfo.Reward.isRP || quest.deliveryInfo.Reward.isHuntXP)
                            DeliveryHelp(player, 4);
                        else
                        {
                            HelpMain = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.3 0.8", "0.7 0.97");
                            QUI.CreatePanel(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.02", "0.99 0.98");
                            QUI.CreateLabel(ref HelpMain, UIPanel, "", $"{textPrimary}{LA("creHelIH", player.UserIDString)} 'quest item'</color>", 20, "0.1 0", "0.9 1");
                            CuiHelper.AddUi(player, HelpMain);
                        }
                    }
                    return;
                case 4:
                    ActiveCreations[player.userID].partNum = 5;
                    HelpMain = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.4 0.3", "0.95 0.9");
                    QUI.CreatePanel(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.02", "0.99 0.98");
                    QUI.CreateLabel(ref HelpMain, UIPanel, "", $"{textPrimary}{LA("delHelRM", player.UserIDString)}</color> {textSecondary}\n\n{LA("delHelRM1", player.UserIDString)}</color>{textPrimary} 2000m</color>{textSecondary} {LA("delHelRM2", player.UserIDString)} </color>{textPrimary}0.25</color>{textSecondary}, {LA("delHelRM3", player.UserIDString)} </color>{textPrimary}500</color>", 20, "0.05 0.1", "0.95 0.9");
                    CuiHelper.AddUi(player, HelpMain);
                    return;
                case 5:
                    ActiveCreations[player.userID].partNum = 3;
                    HelpMain = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.4 0.3", "0.95 0.9");
                    QUI.CreatePanel(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.02", "0.99 0.98");
                    QUI.CreateLabel(ref HelpMain, UIPanel, "", $"{textPrimary}{LA("delHelDD", player.UserIDString)}</color>", 20, "0.05 0.1", "0.95 0.9");
                    CuiHelper.AddUi(player, HelpMain);
                    return;
                case 6:
                    {
                        HelpMain = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.4 0.3", "0.95 0.9", true);
                        QUI.CreatePanel(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.02", "0.99 0.98");
                        QUI.CreateLabel(ref HelpMain, UIPanel, "", $"{textPrimary}{LA("delHelNewV", player.UserIDString)}</color>", 20, "0.1 0.8", "0.9 0.95");

                        var quest = ActiveCreations[player.userID];
                        string questDetails = $"{textPrimary}{LA("Quest Type:", player.UserIDString)}</color> {textSecondary}{quest.type}</color>";
                        questDetails = questDetails + $"\n{textPrimary}{LA("Name:", player.UserIDString)}</color> {textSecondary}{quest.deliveryInfo.Info.Name}</color>";
                        questDetails = questDetails + $"\n{textPrimary}{LA("Desc", player.UserIDString)}</color> {textSecondary}{quest.deliveryInfo.Description}</color>";
                        questDetails = questDetails + $"\n{textPrimary}{LA("Reward:", player.UserIDString)}</color> {textSecondary}{quest.deliveryInfo.Reward.DisplayName}</color>";
                        questDetails = questDetails + $"\n{textPrimary}{LA("Multiplier:", player.UserIDString)}</color> {textSecondary}{quest.deliveryInfo.Multiplier}</color>";

                        QUI.CreateLabel(ref HelpMain, UIPanel, "", questDetails, 20, "0.1 0.2", "0.9 0.75", TextAnchor.MiddleLeft);
                        QUI.CreateButton(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("Save Quest", player.UserIDString), 18, "0.6 0.05", "0.8 0.15", $"QUI_SaveQuest");
                        QUI.CreateButton(ref HelpMain, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("Cancel", player.UserIDString), 18, "0.2 0.05", "0.4 0.15", $"QUI_ExitQuest");
                        CuiHelper.AddUi(player, HelpMain);
                    }
                    return;
                default:
                    return;
            }
        }

        private void AcceptDelivery(BasePlayer player, string npcID, int page = 0)
        {
            var quest = vendors.DeliveryVendors[npcID];

            switch (page)
            {
                case 0:
                    {
                        if (vendors.DeliveryVendors.Keys.ToList().Count == 1)
                        {
                            PopupMessage(player, LA("minDV", player.UserIDString));
                            return;
                        }

                        var target = vendors.DeliveryVendors[GetRandomNPC(npcID)];
                        if (quest != null && target != null)
                        {
                            var distance = Vector2.Distance(new Vector2(quest.Info.x, quest.Info.z), new Vector2(target.Info.x, target.Info.z));
                            var rewardAmount = distance * quest.Multiplier;
                            if (rewardAmount < 1) rewardAmount = 1;
                            var briefing = $"{textPrimary}{quest.Info.Name}\n\n</color>";
                            briefing = briefing + $"{textSecondary}{quest.Description}</color>\n\n";
                            briefing = briefing + $"{textPrimary}{LA("Destination:", player.UserIDString)} </color>{textSecondary}{target.Info.Name}\nX {target.Info.x}, Z {target.Info.z}</color>\n";
                            briefing = briefing + $"{textPrimary}{LA("Distance:", player.UserIDString)} </color>{textSecondary}{distance}M</color>\n";
                            briefing = briefing + $"{textPrimary}{LA("Reward:", player.UserIDString)} </color>{textSecondary}{(int)rewardAmount}x {quest.Reward.DisplayName}</color>";

                            var VendorUI = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.4 0.3", "0.95 0.9", true);
                            QUI.CreatePanel(ref VendorUI, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.02", "0.99 0.98");
                            QUI.CreateLabel(ref VendorUI, UIPanel, "", briefing, 20, "0.15 0.2", "0.85 1", TextAnchor.MiddleLeft);

                            QUI.CreateButton(ref VendorUI, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("Accept", player.UserIDString), 18, "0.6 0.05", "0.8 0.15", $"QUI_AcceptDelivery {npcID} {target.Info.ID} {distance}");
                            QUI.CreateButton(ref VendorUI, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("Decline", player.UserIDString), 18, "0.2 0.05", "0.4 0.15", $"QUI_DestroyAll");
                            CuiHelper.AddUi(player, VendorUI);
                        }
                    }
                    return;
                case 1:
                    {
                        var VendorUI = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.4 0.3", "0.95 0.9", true);
                        QUI.CreatePanel(ref VendorUI, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.02", "0.99 0.98");
                        QUI.CreateLabel(ref VendorUI, UIPanel, "", $"{textPrimary} {LA("delComplMSG", player.UserIDString)}</color>", 22, "0 0", "1 1");
                        QUI.CreateButton(ref VendorUI, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("Claim", player.UserIDString), 18, "0.6 0.05", "0.8 0.15", $"QUI_FinishDelivery {npcID}");
                        QUI.CreateButton(ref VendorUI, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("Cancel", player.UserIDString), 18, "0.2 0.05", "0.4 0.15", $"QUI_DestroyAll");
                        CuiHelper.AddUi(player, VendorUI);
                    }
                    return;
                default:
                    return;
            }
        }

        private void DeletionEditMenu(BasePlayer player, string page, string command)
        {
            DestroyEntries(player);
            var Main = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.12 0", "1 1");
            QUI.CreatePanel(ref Main, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.01", "0.99 0.99", true);
            QUI.CreateLabel(ref Main, UIPanel, "1 1 1 0.025", page, 200, "0.01 0.01", "0.99 0.99");

            QUI.CreateLabel(ref Main, UIPanel, "", $"{textPrimary}{LA("Kill", player.UserIDString)}</color>", 20, "0 0.87", "0.25 0.92");
            QUI.CreateLabel(ref Main, UIPanel, "", $"{textPrimary}{LA("Gather", player.UserIDString)}</color>", 20, "0.25 0.87", "0.5 0.92");
            QUI.CreateLabel(ref Main, UIPanel, "", $"{textPrimary}{LA("Loot", player.UserIDString)}</color>", 20, "0.5 0.87", "0.75 0.92");
            QUI.CreateLabel(ref Main, UIPanel, "", $"{textPrimary}{LA("Craft", player.UserIDString)}</color>", 20, "0.75 0.87", "1 0.92");
            if (command == "QUI_ConfirmDelete") QUI.CreateButton(ref Main, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), $"{textPrimary}{LA("Delete NPC", player.UserIDString)}</color>", 18, "0.8 0.94", "0.98 0.98", "QUI_DeleteNPCMenu");

            int killNum = 0;
            int gatherNum = 0;
            int lootNum = 0;
            int craftNum = 0;
            foreach (var entry in questData.Quest[QuestType.Kill])
            {
                CreateDelEditButton(ref Main, 0.035f, UIPanel, entry.Key, killNum, command);
                killNum++;
            }

            foreach (var entry in questData.Quest[QuestType.Gather])
            {
                CreateDelEditButton(ref Main, 0.285f, UIPanel, entry.Key, gatherNum, command);
                gatherNum++;
            }

            foreach (var entry in questData.Quest[QuestType.Loot])
            {
                CreateDelEditButton(ref Main, 0.535f, UIPanel, entry.Key, lootNum, command);
                lootNum++;
            }

            foreach (var entry in questData.Quest[QuestType.Craft])
            {
                CreateDelEditButton(ref Main, 0.785f, UIPanel, entry.Key, craftNum, command);
                craftNum++;
            }

            CuiHelper.AddUi(player, Main);
        }

        private void DeleteNPCMenu(BasePlayer player)
        {
            DestroyEntries(player);
            var Main = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.12 0", "1 1");
            QUI.CreatePanel(ref Main, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.01", "0.99 0.99", true);
            QUI.CreateLabel(ref Main, UIPanel, "1 1 1 0.025", LA("REMOVER", player.UserIDString), 200, "0.01 0.01", "0.99 0.99");

            QUI.CreateLabel(ref Main, UIPanel, "", $"{textPrimary}{LA("Delivery Vendors", player.UserIDString)}</color>", 20, "0 0.87", "0.5 0.92");
            QUI.CreateLabel(ref Main, UIPanel, "", $"{textPrimary}{LA("Quest Vendors", player.UserIDString)}</color>", 20, "0.5 0.87", "1 0.92");

            int VendorNum = 0;
            int DeliveryNum = 0;
            foreach (var entry in vendors.QuestVendors)
            {
                CreateDelVendorButton(ref Main, 0.535f, UIPanel, entry.Value.Name, DeliveryNum, $"QUI_RemoveVendor {entry.Key}");
                VendorNum++;
            }

            foreach (var entry in vendors.DeliveryVendors)
            {
                CreateDelVendorButton(ref Main, 0.035f, UIPanel, entry.Value.Info.Name, DeliveryNum, $"QUI_RemoveVendor {entry.Key}");
                DeliveryNum++;
            }

            CuiHelper.AddUi(player, Main);
        }

        private void ConfirmDeletion(BasePlayer player, string questName)
        {
            var ConfirmDelete = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.2 0.4", "0.8 0.8", true);
            QUI.CreatePanel(ref ConfirmDelete, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.02", "0.99 0.98");
            QUI.CreateLabel(ref ConfirmDelete, UIPanel, "", $"{textPrimary}{LA("confDel", player.UserIDString)} {questName}</color>", 20, "0.1 0.6", "0.9 0.9");
            QUI.CreateButton(ref ConfirmDelete, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("Yes", player.UserIDString), 18, "0.6 0.2", "0.8 0.3", $"QUI_DeleteQuest {questName}");
            QUI.CreateButton(ref ConfirmDelete, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("No", player.UserIDString), 18, "0.2 0.2", "0.4 0.3", $"QUI_DeleteQuest reject");

            CuiHelper.AddUi(player, ConfirmDelete);
        }

        private void ConfirmCancellation(BasePlayer player, string questName)
        {
            var ConfirmDelete = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.2 0.4", "0.8 0.8", true);
            QUI.CreatePanel(ref ConfirmDelete, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.02", "0.99 0.98");
            QUI.CreateLabel(ref ConfirmDelete, UIPanel, "", $"{textPrimary}{LA("confCan", player.UserIDString)} {questName}</color>\n{textSecondary}{LA("confCan2", player.UserIDString)}</color>", 20, "0.1 0.6", "0.9 0.9");
            QUI.CreateButton(ref ConfirmDelete, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("Yes", player.UserIDString), 18, "0.6 0.2", "0.8 0.3", $"QUI_ConfirmCancel {questName}");
            QUI.CreateButton(ref ConfirmDelete, UIPanel, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), LA("No", player.UserIDString), 18, "0.2 0.2", "0.4 0.3", $"QUI_ConfirmCancel reject");

            CuiHelper.AddUi(player, ConfirmDelete);
        }

        private void QuestEditorMenu(BasePlayer player)
        {
            DestroyEntries(player);
            var Main = QUI.CreateElementContainer(UIPanel, QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.12 0", "1 1");
            QUI.CreatePanel(ref Main, UIPanel, QUI.Color(configData.Colors.Background_Light.Color, configData.Colors.Background_Light.Alpha), "0.01 0.01", "0.99 0.99", true);
            QUI.CreateLabel(ref Main, UIPanel, "1 1 1 0.025", LA("EDITOR", player.UserIDString), 200, "0.01 0.01", "0.99 0.99");

            int i = 0;
            QUI.CreateLabel(ref Main, UIPanel, "", $"{textPrimary}{LA("chaEdi", player.UserIDString)}</color>", 20, "0.25 0.8", "0.75 0.9");
            CreateNewQuestButton(ref Main, UIPanel, LA("Name", player.UserIDString), "QUI_EditQuestVar name", i); i++;
            CreateNewQuestButton(ref Main, UIPanel, LA("Description", player.UserIDString), "QUI_EditQuestVar description", i); i++;
            CreateNewQuestButton(ref Main, UIPanel, LA("Objective", player.UserIDString), "QUI_EditQuestVar objective", i); i++;
            CreateNewQuestButton(ref Main, UIPanel, LA("Amount", player.UserIDString), "QUI_EditQuestVar amount", i); i++;
            CreateNewQuestButton(ref Main, UIPanel, LA("Reward", player.UserIDString), "QUI_EditQuestVar reward", i); i++;

            CuiHelper.AddUi(player, Main);
        }

        private void CreateObjectiveEntry(ref CuiElementContainer container, string panelName, string name, int number)
        {
            var pos = CalcEntryPos(number);
            QUI.CreateButton(ref container, panelName, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), name, 10, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"QUI_SelectObj {name}");
        }

        private void CreateNewQuestButton(ref CuiElementContainer container, string panelName, string buttonname, string command, int number)
        {
            Vector2 dimensions = new Vector2(0.2f, 0.07f);
            Vector2 origin = new Vector2(0.4f, 0.7f);
            Vector2 offset = new Vector2(0, (0.01f + dimensions.y) * number);

            Vector2 posMin = origin - offset;
            Vector2 posMax = posMin + dimensions;

            QUI.CreateButton(ref container, panelName, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), buttonname, 18, $"{posMin.x} {posMin.y}", $"{posMax.x} {posMax.y}", command);
        }

        private void CreateRewardTypeButton(ref CuiElementContainer container, string panelName, string buttonname, string command, int number)
        {
            Vector2 dimensions = new Vector2(0.36f, 0.1f);
            Vector2 origin = new Vector2(0.32f, 0.7f);
            Vector2 offset = new Vector2(0, (0.01f + dimensions.y) * number);

            Vector2 posMin = origin - offset;
            Vector2 posMax = posMin + dimensions;

            QUI.CreateButton(ref container, panelName, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), buttonname, 18, $"{posMin.x} {posMin.y}", $"{posMax.x} {posMax.y}", command);
        }

        private void CreateDelEditButton(ref CuiElementContainer container, float xPos, string panelName, string buttonname, int number, string command, float width = 0.18f)
        {
            Vector2 dimensions = new Vector2(width, 0.05f);
            Vector2 origin = new Vector2(xPos, 0.8f);
            Vector2 offset = new Vector2(0, (-0.01f - dimensions.y) * number);

            Vector2 posMin = origin + offset;
            Vector2 posMax = posMin + dimensions;

            QUI.CreateButton(ref container, panelName, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), buttonname, 14, $"{posMin.x} {posMin.y}", $"{posMax.x} {posMax.y}", $"{command} {buttonname}");
        }

        private void CreateDelVendorButton(ref CuiElementContainer container, float xPos, string panelName, string buttonname, int number, string command)
        {
            if (number > 15) xPos += 0.25f;
            Vector2 dimensions = new Vector2(0.18f, 0.05f);
            Vector2 origin = new Vector2(xPos, 0.8f);
            Vector2 offset = new Vector2(0, (-0.01f - dimensions.y) * number);

            Vector2 posMin = origin + offset;
            Vector2 posMax = posMin + dimensions;

            QUI.CreateButton(ref container, panelName, QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), buttonname, 14, $"{posMin.x} {posMin.y}", $"{posMax.x} {posMax.y}", command);
        }

        private void PopupMessage(BasePlayer player, string msg)
        {
            CuiHelper.DestroyUi(player, "PopupMsg");
            var element = QUI.CreateElementContainer("PopupMsg", QUI.Color(configData.Colors.Background_Dark.Color, configData.Colors.Background_Dark.Alpha), "0.25 0.85", "0.75 0.95");
            QUI.CreatePanel(ref element, "PopupMsg", QUI.Color(configData.Colors.Button_Standard.Color, configData.Colors.Button_Standard.Alpha), "0.005 0.04", "0.995 0.96");
            QUI.CreateLabel(ref element, "PopupMsg", "", $"{textPrimary}{msg}</color>", 22, "0 0", "1 1");
            CuiHelper.AddUi(player, element);
            timer.Once(3, () => CuiHelper.DestroyUi(player, "PopupMsg"));
        }

        private Vector2 CalcQuestPos(int number)
        {
            Vector2 position = new Vector2(0.1325f, 0.71f);
            Vector2 dimensions = new Vector2(0.21f, 0.22f);
            float offsetY = 0f;
            float offsetX = 0;
            if (number >= 0 && number < 4)
            {
                offsetX = (0.005f + dimensions.x) * number;
            }

            if (number > 3 && number < 8)
            {
                offsetX = (0.005f + dimensions.x) * (number - 4);
                offsetY = (-0.008f - dimensions.y) * 1;
            }

            if (number > 7 && number < 12)
            {
                offsetX = (0.005f + dimensions.x) * (number - 8);
                offsetY = (-0.008f - dimensions.y) * 2;
            }

            if (number > 11 && number < 16)
            {
                offsetX = (0.005f + dimensions.x) * (number - 12);
                offsetY = (-0.008f - dimensions.y) * 3;
            }

            return new Vector2(position.x + offsetX, position.y + offsetY);
        }

        private float[] CalcEntryPos(int number)
        {
            Vector2 position = new Vector2(0.014f, 0.8f);
            Vector2 dimensions = new Vector2(0.12f, 0.055f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 8)
            {
                offsetX = (0.002f + dimensions.x) * number;
            }

            if (number > 7 && number < 16)
            {
                offsetX = (0.002f + dimensions.x) * (number - 8);
                offsetY = (-0.0055f - dimensions.y) * 1;
            }

            if (number > 15 && number < 24)
            {
                offsetX = (0.002f + dimensions.x) * (number - 16);
                offsetY = (-0.0055f - dimensions.y) * 2;
            }

            if (number > 23 && number < 32)
            {
                offsetX = (0.002f + dimensions.x) * (number - 24);
                offsetY = (-0.0055f - dimensions.y) * 3;
            }

            if (number > 31 && number < 40)
            {
                offsetX = (0.002f + dimensions.x) * (number - 32);
                offsetY = (-0.0055f - dimensions.y) * 4;
            }

            if (number > 39 && number < 48)
            {
                offsetX = (0.002f + dimensions.x) * (number - 40);
                offsetY = (-0.0055f - dimensions.y) * 5;
            }

            if (number > 47 && number < 56)
            {
                offsetX = (0.002f + dimensions.x) * (number - 48);
                offsetY = (-0.0055f - dimensions.y) * 6;
            }

            if (number > 55 && number < 64)
            {
                offsetX = (0.002f + dimensions.x) * (number - 56);
                offsetY = (-0.0055f - dimensions.y) * 7;
            }

            if (number > 63 && number < 72)
            {
                offsetX = (0.002f + dimensions.x) * (number - 64);
                offsetY = (-0.0055f - dimensions.y) * 8;
            }

            if (number > 71 && number < 80)
            {
                offsetX = (0.002f + dimensions.x) * (number - 72);
                offsetY = (-0.0055f - dimensions.y) * 9;
            }

            if (number > 79 && number < 88)
            {
                offsetX = (0.002f + dimensions.x) * (number - 80);
                offsetY = (-0.0055f - dimensions.y) * 10;
            }

            if (number > 87 && number < 96)
            {
                offsetX = (0.002f + dimensions.x) * (number - 88);
                offsetY = (-0.0055f - dimensions.y) * 11;
            }

            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private void AddUIString(BasePlayer player, string name)
        {
            if (!OpenUI.ContainsKey(player.userID))
                OpenUI.Add(player.userID, new List<string>());
            OpenUI[player.userID].Add(name);
        }

        private void DestroyUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, UIMain);
            DestroyEntries(player);
        }

        private void DestroyEntries(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, UIPanel);
            if (OpenUI.ContainsKey(player.userID))
            {
                foreach (var entry in OpenUI[player.userID])
                    CuiHelper.DestroyUi(player, entry);
                OpenUI.Remove(player.userID);
            }
        }

        #endregion

        #region UI Commands

        [ConsoleCommand("QUI_AcceptQuest")]
        private void cmdAcceptQuest(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var questName = string.Join(" ", arg.Args);
            CheckPlayerEntry(player);
            var data = PlayerProgress[player.userID].Quests;
            if (!data.ContainsKey(questName))
            {
                var type = GetQuestType(questName);
                if (type != null)
                {
                    var quest = Quest[(QuestType)type][questName];
                    data.Add(questName, new PlayerQuestInfo { Status = QuestStatus.Pending, Type = (QuestType)type });
                    PlayerProgress[player.userID].RequiredItems.Add(new QuestInfo { ShortName = quest.Objective, Type = (QuestType)type });
                    DestroyEntries(player);
                    ListElement(player, (QuestType)type);
                    PopupMessage(player, $"{LA("qAccep", player.UserIDString)} {questName}");
                    return;
                }
            }
        }

        [ConsoleCommand("QUI_AcceptDelivery")]
        private void cmdAcceptDelivery(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var vendorID = arg.Args[0];
            var targetID = arg.Args[1];
            var distance = arg.Args[2];
            PlayerProgress[player.userID].CurrentDelivery = new ActiveDelivery { VendorID = vendorID, TargetID = targetID, Distance = float.Parse(distance) };
            PopupMessage(player, LA("dAccep", player.UserIDString));
            DestroyUI(player);
        }

        [ConsoleCommand("QUI_CancelDelivery")]
        private void cmdCancelDelivery(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (!string.IsNullOrEmpty(PlayerProgress[player.userID].CurrentDelivery.TargetID))
            {
                PlayerProgress[player.userID].CurrentDelivery = new ActiveDelivery();
                DestroyUI(player);
                PopupMessage(player, LA("canConf", player.UserIDString));
            }
        }

        [ConsoleCommand("QUI_FinishDelivery")]
        private void cmdFinishDelivery(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            if (PlayerProgress[player.userID].CurrentDelivery != null && PlayerProgress[player.userID].CurrentDelivery.TargetID == arg.GetString(0))
            {
                var npcID = PlayerProgress[player.userID].CurrentDelivery.VendorID;
                var distance = PlayerProgress[player.userID].CurrentDelivery.Distance;
                var quest = vendors.DeliveryVendors[npcID];
                var rewardAmount = distance * quest.Multiplier;
                if (rewardAmount < 1) rewardAmount = 1;

                var reward = quest.Reward;
                reward.Amount = rewardAmount;
                if (GiveReward(player, new List<RewardItem> { reward }))
                {
                    var rewards = GetRewardString(new List<RewardItem> { reward });
                    PopupMessage(player, $"{LA("rewRec", player.UserIDString)} {rewards}");
                    PlayerProgress[player.userID].CurrentDelivery = new ActiveDelivery();
                }

                DestroyUI(player);
            }
        }

        [ConsoleCommand("QUI_ChangeElement")]
        private void cmdChangeElement(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            CheckPlayerEntry(player);
            var panelName = arg.GetString(0);
            switch (panelName)
            {
                case "kill":
                    ListElement(player, QuestType.Kill);
                    return;
                case "gather":
                    ListElement(player, QuestType.Gather);
                    return;
                case "loot":
                    ListElement(player, QuestType.Loot);
                    return;
                case "craft":
                    ListElement(player, QuestType.Craft);
                    return;
                case "delivery":
                    PlayerDelivery(player);
                    return;
                case "personal":
                    PlayerStats(player);
                    return;
                case "editor":
                    if (isAdmin(player))
                        DeletionEditMenu(player, LA("EDITOR", player.UserIDString), "QUI_EditQuest");
                    return;
                case "creation":
                    if (isAdmin(player))
                    {
                        if (ActiveCreations.ContainsKey(player.userID))
                            ActiveCreations.Remove(player.userID);
                        CreationMenu(player);
                    }
                    return;
                case "objpage":
                    if (isAdmin(player))
                    {
                        var pageNumber = arg.GetString(1);
                        CreateObjectiveMenu(player, int.Parse(pageNumber));
                    }
                    return;
                case "listpage":
                    {
                        var pageNumber = arg.GetString(2);
                        var type = ConvertStringToType(arg.GetString(1));
                        ListElement(player, type, int.Parse(pageNumber));
                    }
                    return;
                case "statspage":
                    {
                        var pageNumber = arg.GetString(1);
                        PlayerStats(player, int.Parse(pageNumber));
                    }
                    return;
            }
        }

        [ConsoleCommand("QUI_DestroyAll")]
        private void cmdDestroyAll(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (StatsMenu.Contains(player.userID))
                StatsMenu.Remove(player.userID);
            if (ActiveCreations.ContainsKey(player.userID))
                ActiveCreations.Remove(player.userID);
            if (ActiveEditors.ContainsKey(player.userID))
                ActiveEditors.Remove(player.userID);
            if (OpenMenuBind.Contains(player.userID))
                OpenMenuBind.Remove(player.userID);
            DestroyUI(player);
            OpenMap(player);
        }

        [ConsoleCommand("QUI_NewQuest")]
        private void cmdNewQuest(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (isAdmin(player))
            {
                var questType = arg.GetString(0);
                var Type = ConvertStringToType(questType);
                if (Type == QuestType.Delivery)
                {
                    DeliveryHelp(player);
                    return;
                }

                ActiveCreations.Add(player.userID, new QuestCreator { type = Type, entry = new QuestEntry { Rewards = new List<RewardItem>() }, item = new RewardItem() });
                DestroyUI(player);
                CreationHelp(player);
            }
        }

        [ConsoleCommand("QUI_AddVendor")]
        private void cmdAddVendor(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (isAdmin(player))
            {
                var vendorType = arg.GetString(0);
                bool isVendor = false;
                if (vendorType == "1")
                    isVendor = true;
                if (!AddVendor.ContainsKey(player.userID))
                    AddVendor.Add(player.userID, isVendor);
                DestroyUI(player);
                DeliveryHelp(player, 1);
            }
        }

        [ConsoleCommand("QUI_SelectObj")]
        private void cmdSelectObj(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (isAdmin(player))
            {
                var questItem = string.Join(" ", arg.Args);
                QuestCreator Creator;
                if (ActiveCreations.ContainsKey(player.userID))
                    Creator = ActiveCreations[player.userID];
                else Creator = ActiveEditors[player.userID];

                Creator.entry.Objective = questItem;
                if (DisplayNames.ContainsKey(questItem))
                    Creator.entry.ObjectiveName = DisplayNames[questItem];
                else
                    Creator.entry.ObjectiveName = questItem;

                Creator.partNum++;
                DestroyUI(player);

                CreationHelp(player, 2);
            }
        }

        [ConsoleCommand("QUI_RewardType")]
        private void cmdRewardType(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (isAdmin(player))
            {
                var rewardType = arg.GetString(0);
                QuestCreator Creator;

                if (ActiveCreations.ContainsKey(player.userID))
                    Creator = ActiveCreations[player.userID];
                else Creator = ActiveEditors[player.userID];

                bool isRP = false;
                bool isCoins = false;
                bool isHuntXP = false;
                string name = "";

                switch (rewardType)
                {
                    case "rp":
                        isRP = true;
                        name = LA("RP", player.UserIDString);
                        break;
                    case "coins":
                        isCoins = true;
                        name = LA("Coins", player.UserIDString);
                        break;
                    case "huntxp":
                        isHuntXP = true;
                        name = LA("HuntXP", player.UserIDString);
                        break;
                    default:
                        break;
                }

                Creator.partNum = 5;
                if (Creator.type != QuestType.Delivery)
                {
                    Creator.item.isRP = isRP;
                    Creator.item.isCoins = isCoins;
                    Creator.item.isHuntXP = isHuntXP;
                    Creator.item.DisplayName = name;
                    CreationHelp(player, 5);
                }
                else
                {
                    Creator.deliveryInfo.Reward.isRP = isRP;
                    Creator.deliveryInfo.Reward.isCoins = isCoins;
                    Creator.deliveryInfo.Reward.isHuntXP = isHuntXP;
                    Creator.deliveryInfo.Reward.DisplayName = name;
                    DeliveryHelp(player, 3);
                }
            }
        }

        [ConsoleCommand("QUI_ClaimReward")]
        private void cmdClaimReward(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            var questName = string.Join(" ", arg.Args);
            var quest = GetQuest(questName);
            if (quest == null) return;

            if (IsQuestCompleted(player.userID, questName))
            {
                if (GiveReward(player, quest.Rewards))
                {
                    var rewards = GetRewardString(quest.Rewards);
                    PopupMessage(player, $"{LA("rewRec", player.UserIDString)} {rewards}");
                    SendMSG(player, $"{LA("rewRec", player.UserIDString)} {rewards}");
                    PlayerProgress[player.userID].Quests[questName].RewardClaimed = true;
                }
                else
                {
                    PopupMessage(player, LA("rewError", player.UserIDString));
                    SendMSG(player, LA("rewError", player.UserIDString));
                }
            }

            PlayerStats(player);
        }

        bool IsQuestCompleted(ulong playerId, string questName = "") => !string.IsNullOrEmpty(questName) && PlayerProgress[playerId].Quests[questName].Status == QuestStatus.Completed;

        [ConsoleCommand("QUI_CancelQuest")]
        private void cmdCancelQuest(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var questName = string.Join(" ", arg.Args);
            DestroyUI(player);
            ConfirmCancellation(player, questName);
        }

        [ConsoleCommand("QUI_ItemDeduction")]
        private void cmdItemDeduction(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (isAdmin(player))
            {
                QuestCreator Creator;
                if (ActiveCreations.ContainsKey(player.userID))
                    Creator = ActiveCreations[player.userID];
                else Creator = ActiveEditors[player.userID];
                switch (arg.Args[0])
                {
                    case "0":
                        Creator.entry.ItemDeduction = false;
                        break;
                    default:
                        Creator.entry.ItemDeduction = true;
                        break;
                }

                CreationHelp(player, 9);
            }
        }

        [ConsoleCommand("QUI_ConfirmCancel")]
        private void cmdConfirmCancel(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var questName = string.Join(" ", arg.Args);
            if (questName.Contains("reject"))
            {
                DestroyUI(player);
                if (StatsMenu.Contains(player.userID))
                    CreateEmptyMenu(player);
                else CreateMenu(player);
                PlayerStats(player);
                return;
            }

            var quest = GetQuest(questName);
            if (quest == null) return;
            var info = PlayerProgress[player.userID];
            var items = info.RequiredItems;
            for (int i = 0; i < items.Count; i++)
            {
                if (items[i].ShortName == questName && items[i].Type == info.Quests[questName].Type)
                {
                    items.Remove(items[i]);
                    break;
                }
            }

            var type = (QuestType)GetQuestType(questName);
            if (type != QuestType.Delivery && type != QuestType.Kill)
            {
                string questitem = quest.Objective;
                int amount = info.Quests[questName].AmountCollected;
                if (quest.ItemDeduction)
                    ReturnItems(player, questitem, amount);
            }

            PlayerProgress[player.userID].Quests.Remove(questName);

            if (StatsMenu.Contains(player.userID))
                CreateEmptyMenu(player);
            else CreateMenu(player);

            PlayerStats(player);
        }

        [ConsoleCommand("QUI_RemoveCompleted")]
        private void cmdRemoveCompleted(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var questName = string.Join(" ", arg.Args);
            var quest = GetQuest(questName);
            if (quest == null) return;
            var info = PlayerProgress[player.userID];
            var items = info.RequiredItems;
            for (int i = 0; i < items.Count; i++)
            {
                if (items[i].ShortName == questName && items[i].Type == info.Quests[questName].Type)
                {
                    items.Remove(items[i]);
                    break;
                }
            }

            PlayerProgress[player.userID].Quests.Remove(questName);
            PlayerStats(player);
        }

        [ConsoleCommand("QUI_DeleteQuest")]
        private void cmdDeleteQuest(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (isAdmin(player))
            {
                if (arg.Args == null || arg.Args.Length == 0) return;

                if (arg.Args.Length == 1 && arg.Args[0] == "reject")
                {
                    DestroyUI(player);
                    CreateMenu(player);
                    return;
                }

                var questName = string.Join(" ", arg.Args);
                RemoveQuest(questName);
                DestroyUI(player);
                CreateMenu(player);
            }
        }

        [ConsoleCommand("QUI_DeleteNPCMenu")]
        private void cmdDeleteNPCMenu(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (isAdmin(player))
            {
                DeleteNPCMenu(player);
            }
        }

        [ConsoleCommand("QUI_RemoveVendor")]
        private void cmdRemoveVendor(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (isAdmin(player))
            {
                var ID = arg.Args[0];
                foreach (var npc in vendors.QuestVendors)
                {
                    if (npc.Key == ID)
                    {
                        RemoveVendor(player, ID, true);
                        return;
                    }
                }

                foreach (var npc in vendors.DeliveryVendors)
                {
                    if (npc.Key == ID)
                    {
                        RemoveVendor(player, ID, false);
                        return;
                    }
                }
            }
        }

        [ConsoleCommand("QUI_ConfirmDelete")]
        private void cmdConfirmDelete(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (isAdmin(player))
            {
                var questName = string.Join(" ", arg.Args);
                DestroyUI(player);
                ConfirmDeletion(player, questName);
            }
        }

        [ConsoleCommand("QUI_EditQuest")]
        private void cmdEditQuest(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (isAdmin(player))
            {
                if (ActiveEditors.ContainsKey(player.userID))
                    ActiveEditors.Remove(player.userID);
                ActiveEditors.Add(player.userID, new QuestCreator());

                var questName = string.Join(" ", arg.Args);
                var Quest = GetQuest(questName);
                if (Quest == null) return;
                ActiveEditors[player.userID].entry = Quest;
                ActiveEditors[player.userID].oldEntry = Quest.QuestName;
                ActiveEditors[player.userID].type = (QuestType)GetQuestType(questName);
                ActiveEditors[player.userID].item = new RewardItem();
                QuestEditorMenu(player);
            }
        }

        [ConsoleCommand("QUI_EditQuestVar")]
        private void cmdEditQuestVar(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (isAdmin(player))
            {
                if (ActiveEditors.ContainsKey(player.userID))
                {
                    var Creator = ActiveEditors[player.userID];

                    DestroyUI(player);
                    switch (arg.Args[0].ToLower())
                    {
                        case "name":
                            CreationHelp(player, 0);
                            break;
                        case "description":
                            Creator.partNum = 3;
                            CreationHelp(player, 3);
                            break;
                        case "objective":
                            Creator.partNum = 1;
                            CreationHelp(player, 1);
                            break;
                        case "amount":
                            Creator.partNum = 2;
                            CreationHelp(player, 2);
                            break;
                        case "reward":
                            Creator.partNum = 4;
                            CreationHelp(player, 10);
                            break;
                        default:
                            return;
                    }
                }
            }
        }

        [ConsoleCommand("QUI_RemoveReward")]
        private void cmdEditReward(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (isAdmin(player))
            {
                QuestCreator Creator = ActiveEditors[player.userID];
                var amount = arg.Args[0];
                var dispName = arg.Args[1];
                foreach (var entry in Creator.entry.Rewards)
                {
                    if (entry.Amount == float.Parse(amount) && entry.DisplayName == dispName)
                    {
                        Creator.entry.Rewards.Remove(entry);
                        break;
                    }
                }

                SaveRewardsEdit(player);
            }
        }

        [ConsoleCommand("QUI_EndEditing")]
        private void cmdEndEditing(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (isAdmin(player))
            {
                CreateMenu(player);
                DeletionEditMenu(player, LA("EDITOR", player.UserIDString), "QUI_EditQuest");
            }
        }

        [ConsoleCommand("QUI_SaveQuest")]
        private void cmdSaveQuest(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (isAdmin(player))
            {
                bool creating = false;
                if (ActiveCreations.ContainsKey(player.userID))
                    creating = true;
                SaveQuest(player, creating);
            }
        }

        [ConsoleCommand("QUI_ExitQuest")]
        private void cmdExitQuest(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (isAdmin(player))
            {
                bool creating = false;
                if (ActiveCreations.ContainsKey(player.userID))
                    creating = true;
                ExitQuest(player, creating);
            }
        }

        [ConsoleCommand("QUI_AddReward")]
        private void cmdAddReward(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (isAdmin(player))
            {
                QuestCreator Creator;
                if (ActiveCreations.ContainsKey(player.userID))
                    Creator = ActiveCreations[player.userID];
                else Creator = ActiveEditors[player.userID];
                Creator.partNum = 4;
                CreationHelp(player, 4);
            }
        }

        [ConsoleCommand("QUI_RewardFinish")]
        private void cmdFinishReward(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (isAdmin(player))
            {
                CreationHelp(player, 8);
            }
        }

        [ConsoleCommand("QUI_OpenQuestMenu")]
        private void cmdOpenQuestMenu(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (!OpenMenuBind.Contains(player.userID))
            {
                cmdOpenMenu(player, "q", new string[0]);
                OpenMenuBind.Add(player.userID);
            }
        }

        #endregion

        #region Chat Commands

        [ChatCommand("q")]
        void cmdOpenMenu(BasePlayer player, string command, string[] args)
        {
            if (AddVendor.ContainsKey(player.userID)) return;
            if ((configData.UseNPCVendors && isAdmin(player)) || !configData.UseNPCVendors)
            {
                CheckPlayerEntry(player);
                CreateMenu(player);
                return;
            }

            if (configData.UseNPCVendors)
            {
                CheckPlayerEntry(player);
                if (!StatsMenu.Contains(player.userID))
                    StatsMenu.Add(player.userID);

                CreateEmptyMenu(player);
                PlayerStats(player);
                PopupMessage(player, LA("noVendor", player.UserIDString));
            }
        }

        [ChatCommand("wipePlayerProgress")]
        void wipePlayerProgress(BasePlayer player, string command, string[] args)
        {
            if (!isAdmin(player)) return;
            playerData.PlayerProgress = null;
            Player_Data.WriteObject(Player_Data);
            PopupMessage(player, LA("progressWiped", player.UserIDString));
            LoadData();
        }

        [ChatCommand("questnpc")]
        void cmdQuestNPC(BasePlayer player, string command, string[] args)
        {
            if (!isAdmin(player)) return;
            var NPC = FindEntity(player);
            if (NPC != null)
            {
                var isRegistered = isNPCRegistered(NPC.UserIDString);
                if (!string.IsNullOrEmpty(isRegistered))
                {
                    SendMSG(player, isRegistered, LA("Quest NPCs:", player.UserIDString));
                    return;
                }

                string name = "";
                if (args.Length >= 1)
                    name = string.Join(" ", args);

                if (AddVendor.ContainsKey(player.userID))
                {
                    var pos = new NPCInfo { x = NPC.transform.position.x, z = NPC.transform.position.z, ID = NPC.UserIDString };
                    if (AddVendor[player.userID])
                    {
                        pos.Name = $"QuestVendor_{vendors.QuestVendors.Count + 1}";
                        vendors.QuestVendors.Add(NPC.UserIDString, pos);
                        SendMSG(player, LA("newVSucc", player.UserIDString), LA("Quest NPCs:", player.UserIDString));
                        if (NPC != null)
                        {
                            NPC.displayName = pos.Name;
                            NPC.UpdateNetworkGroup();
                        }

                        AddMapMarker(pos.x, pos.z, pos.Name, configData.LustyMapIntegration.Icon_Vendor + ".png");
                        AddVendor.Remove(player.userID);
                        SaveVendorData();
                        DestroyUI(player);
                        OpenMap(player);
                        return;
                    }
                    else
                    {
                        if (string.IsNullOrEmpty(name))
                            name = $"Delivery_{ vendors.DeliveryVendors.Count + 1}";

                        if (ActiveCreations.ContainsKey(player.userID))
                            ActiveCreations.Remove(player.userID);
                        pos.Name = name;

                        ActiveCreations.Add(player.userID, new QuestCreator
                        {
                            deliveryInfo = new DeliveryInfo
                            {
                                Info = pos,
                                Reward = new RewardItem()
                            },
                            partNum = 4,
                            type = QuestType.Delivery
                        });
                        DeliveryHelp(player, 2);
                    }
                }
            }
            else SendMSG(player, LA("noNPC", player.UserIDString));
        }

        #endregion

        #region Data Management

        void SaveQuestData()
        {
            questData.Quest = Quest;
            Quest_Data.WriteObject(questData);
        }

        void SaveVendorData()
        {
            Quest_Vendors.WriteObject(vendors);
        }

        void SavePlayerData()
        {
            playerData.PlayerProgress = PlayerProgress;
            Player_Data.WriteObject(playerData);
        }

        void SaveDisplayNames()
        {
            itemNames.DisplayNames = DisplayNames;
            Item_Names.WriteObject(itemNames);
        }

        private void SaveLoop()
        {
            SavePlayerData();
            timer.Once(900, () => SaveLoop());
        }

        void LoadData()
        {
            try
            {
                questData = Quest_Data.ReadObject<QuestData>();
                Quest = questData.Quest;
            }
            catch
            {
                Puts("Couldn't load quest data, creating new datafile");
                questData = new QuestData();
            }

            try
            {
                vendors = Quest_Vendors.ReadObject<NPCData>();
            }
            catch
            {
                Puts("Couldn't load quest vendor data, creating new datafile");
                vendors = new NPCData();
            }

            try
            {
                playerData = Player_Data.ReadObject<PlayerData>();
                PlayerProgress = playerData.PlayerProgress;
            }
            catch
            {
                Puts("Couldn't load player data, creating new datafile");
                playerData = new PlayerData();
                PlayerProgress = new Dictionary<ulong, PlayerQuestData>();
            }

            try
            {
                itemNames = Item_Names.ReadObject<ItemNames>();
            }
            catch
            {
                Puts("Couldn't load item display name data, creating new datafile");
                itemNames = new ItemNames();
            }
        }

        #endregion

        #region Data Storage

        class QuestData
        {
            public Dictionary<QuestType, Dictionary<string, QuestEntry>> Quest = new Dictionary<QuestType, Dictionary<string, QuestEntry>>
                {
                    {QuestType.Craft, new Dictionary<string, QuestEntry>()},
                    {QuestType.Delivery, new Dictionary<string, QuestEntry>()},
                    {QuestType.Gather, new Dictionary<string, QuestEntry>()},
                    {QuestType.Kill, new Dictionary<string, QuestEntry>()},
                    {QuestType.Loot, new Dictionary<string, QuestEntry>()}
                };
        }

        class PlayerData
        {
            public Dictionary<ulong, PlayerQuestData> PlayerProgress = new Dictionary<ulong, PlayerQuestData>();
        }

        class NPCData
        {
            public Dictionary<string, NPCInfo> QuestVendors = new Dictionary<string, NPCInfo>();
            public Dictionary<string, DeliveryInfo> DeliveryVendors = new Dictionary<string, DeliveryInfo>();
        }

        #endregion

        #region Config

        class UIColor
        {
            public string Color { get; set; }
            public float Alpha { get; set; }
        }

        class Colors
        {
            public string TextColor_Primary { get; set; }
            public string TextColor_Secondary { get; set; }
            public UIColor Background_Dark { get; set; }
            public UIColor Background_Light { get; set; }
            public UIColor Button_Standard { get; set; }
            public UIColor Button_Accept { get; set; }
            public UIColor Button_Completed { get; set; }
            public UIColor Button_Cancel { get; set; }
            public UIColor Button_Pending { get; set; }
        }

        class Keybinds
        {
            public bool Autoset_KeyBind { get; set; }
            public string KeyBind_Key { get; set; }
        }

        class LMIcons
        {
            public string Icon_Vendor { get; set; }
            public string Icon_Delivery { get; set; }
        }

        class ConfigData
        {
            public Colors Colors { get; set; }
            public Keybinds KeybindOptions { get; set; }
            public LMIcons LustyMapIntegration { get; set; }
            public bool DisableUI_FadeIn { get; set; }
            public bool UseNPCVendors { get; set; }
            public bool UseOxidePermissions { get; set; }
            public bool UsePlayerIsAdmin { get; set; }
            public int PlayerMaxQuests { get; set; }
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        private void LoadConfigVariables()
        {
            configData = Config.ReadObject<ConfigData>();
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            ConfigData config = new ConfigData
            {
                DisableUI_FadeIn = false,

                UseNPCVendors = false,
                UseOxidePermissions = false,
                UsePlayerIsAdmin = true,
                PlayerMaxQuests = 0,
                Colors = new Colors
                {
                    Background_Dark = new UIColor { Color = "#2a2a2a", Alpha = 0.98f },
                    Background_Light = new UIColor { Color = "#696969", Alpha = 0.3f },
                    Button_Accept = new UIColor { Color = "#00cd00", Alpha = 0.9f },
                    Button_Cancel = new UIColor { Color = "#8c1919", Alpha = 0.9f },
                    Button_Completed = new UIColor { Color = "#829db4", Alpha = 0.9f },
                    Button_Pending = new UIColor { Color = "#a8a8a8", Alpha = 0.9f },
                    Button_Standard = new UIColor { Color = "#2a2a2a", Alpha = 0.9f },
                    TextColor_Primary = "#ce422b",
                    TextColor_Secondary = "#939393"
                },
                LustyMapIntegration = new LMIcons
                {
                    Icon_Delivery = "deliveryicon",
                    Icon_Vendor = "vendoricon"
                },
                KeybindOptions = new Keybinds
                {
                    Autoset_KeyBind = false,
                    KeyBind_Key = "k"
                }
            };
            SaveConfig(config);
        }

        void SaveConfig(ConfigData config)
        {
            Config.WriteObject(config, true);
        }

        #endregion

        #region Messaging

        void SendMSG(BasePlayer player, string message, string keyword = "")
        {
            message = $"{textSecondary}{message}</color>";
            if (!string.IsNullOrEmpty(keyword))
                message = $"{textPrimary}{keyword}</color> {message}";
            SendReply(player, message);
        }

        Dictionary<string, string> Localization = new Dictionary<string, string>
        {
            {"Quests", "Quests:"},
            {"delInprog", "You already have a delivery mission in progress."},
            {"QC", "Quest Creator:"},
            {"noAItem", "Unable to find a active item. Place the item in your hands then type "},
            {"nameExists", "A quest with this name already exists"},
            {"objAmount", "You need to enter a objective amount"},
            {"OA", "Objective Amount:"},
            {"Desc", "Description:"},
            {"noRM", "You need to enter a reward multiplier"},
            {"RM", "Reward Multiplier:"},
            {"noRA", "You need to enter a reward amount"},
            {"RA", "Reward Amount:"},
            {"noCD", "You need to enter a cooldown amount"},
            {"CD1", "Cooldown Timer (minutes):"},
            {"qComple", "You have completed the quest"},
            {"claRew", "You can claim your reward from the quest menu."},
            {"qCancel", "You have cancelled this quest."},
            {"rewRet", "has been returned to you"},
            {"minDV","Delivery missions require atleast 2 vendors. Add some more vendors to activate delivery missions"},
            {"DVSucc", "You have successfully added a new delivery vendor"},
            {"saveQ", "You have successfully saved the quest:"},
            {"QCCancel", "You have cancelled quest creation"},
            {"KillOBJ", "Kill quests require you to kill 'X' amount of the target objective"},
            {"CraftOBJ", "Crafting quests require you to craft 'X' amount of the objective item"},
            {"GatherOBJ", "Gather quests require you to gather 'X' amount of the objective from resources"},
            {"LootOBJ", "Loot quests require you to collect 'X' amount of the objective item from containers"},
            {"DelvOBJ", "Delivery quests require you to deliver a package from one vendor to another"},
            {"aQVReg", "This NPC is already a registered Quest vendor"},
            {"aDVReg", "This NPC is already a registed Delivery vendor"},
            {"Kill", "Kill"},
            {"Gather", "Gather"},
            {"Craft", "Craft"},
            {"Loot", "Loot"},
            {"Delivery", "Delivery"},
            {"Your Quests", "Your Quests"},
            {"Create Quest", "Create Quest"},
            {"Edit Quest", "Edit Quest"},
            {"Delete Quest", "Delete Quest"},
            {"Close", "Close"},
            {"Next", "Next"},
            {"Back", "Back"},
            {"noQ", "The are currently no"},
            {"quests", "quests"},
            {"Pending", "Pending"},
            {"Completed", "Completed"},
            {"Accept Quest", "Accept Quest"},
            {"Status:", "Status:"},
            {"Amount Required:", "Amount Required:"},
            {"Reward:", "Reward:"},
            {"yqDesc", "Check your current progress for each quest"},
            {"STATS", "STATS"},
            {"noQDSaved", "You don't have any quest data saved"},
            {"Cancel Quest", "Cancel Quest"},
            {"Claim Reward", "Claim Reward"},
            {"Remove", "Remove"},
            {"Cooldown", "Cooldown"},
            {"Collected:", "Collected:"},
            {"Reward Claimed:", "Reward Claimed:"},
            {"DELIVERY", "DELIVERY"},
            {"noADM", "You do not have a active delivery mission"},
            {"Destination:", "Destination:"},
            {"Distance:", "Distance:"},
            {"Cancel", "Cancel"},
            {"selCreat", "Select a quest type to begin creation"},
            {"CREATOR", "CREATOR"},
            {"creHelMen", "This is the quest creation help menu"},
            {"creHelFol", "Follow the instructions given by typing in chat"},
            {"creHelExi", "You can exit quest creation at any time by typing"},
            {"creHelName", "To proceed enter the name of your new quest!"},
            {"creHelObj", "Choose a quest objective from the list"},
            {"creHelRA", "Enter a required amount"},
            {"creHelQD", "Enter a quest description"},
            {"creHelRT", "Choose a reward type"},
            {"creHelNewRew", "Select a reward to remove, or add a new one"},
            {"Coins", "Coins"},
            {"RP", "RP"},
            {"HuntXP", "XP"},
            {"Item", "Item"},
            {"creHelRewA", "Enter a reward amount"},
            {"creHelIH", "Place the item you want to issue as a reward in your hands and type"},
            {"creHelAR", "Would you like to add additional rewards?"},
            {"Yes", "Yes"},
            {"No", "No"},
            {"creHelID", "Would you like to enable item deduction (take items from player when collected)?"},
            {"creHelCD", "Enter a cooldown time (in minutes)"},
            {"creHelSQ", "You have successfully created a new quest. To confirm click 'Save Quest'"},
            {"Save Quest", "Save Quest"},
            {"Name:", "Name:"},
            {"Objective:", "Objective:"},
            {"CDMin", "Cooldown (minutes):"},
            {"Quest Type:", "Quest Type:"},
            {"Required Amount:", "Required Amount:"},
            {"Item Deduction:", "Item Deduction:"},
            {"delHelMen", "Here you can add delivery missions and Quest vendors."},
            {"delHelChoo", "Choose either a Delivery vendor (delivery mission) or a Quest vendor (npc based quest menu)"},
            {"Quest Vendor", "Quest Vendor"},
            {"Delivery Vendor", "Delivery Vendor"},
            {"delHelNewNPC", "Stand infront of the NPC you wish to add and type"},
            {"delHelMult", "Delivery mission rewards are based on distance X a multiplier. Keep this in mind when selecting a reward."},
            {"delHelRM", "Enter a reward multiplier (per unit)."},
            {"delHelRM1", "For example, if a delivery is"},
            {"delHelRM2", "away, and the multiplier is"},
            {"delHelRM3", "the total reward amount would be"},
            {"delHelDD", "Enter a delivery description."},
            {"delHelNewV", "You have successfully added a new delivery vendor. To confirm click 'Save Quest'"},
            {"Accept", "Accept"},
            {"Decline", "Decline"},
            {"Claim", "Claim"},
            {"delComplMSG", "Thanks for making the delivery"},
            {"Delete NPC", "Delete NPC"},
            {"REMOVER", "REMOVER"},
            {"Delivery Vendors", "Delivery Vendors"},
            {"Quest Vendors", "Quest Vendors"},
            {"confDel", "Are you sure you want to delete:"},
            {"confCan", "Are you sure you want to cancel:"},
            {"confCan2", "Any progress you have made will be lost!"},
            {"EDITOR", "EDITOR"},
            {"chaEdi", "Select a value to change"},
            {"Name", "Name"},
            {"Description", "Description"},
            {"Objective", "Objective"},
            {"Amount", "Amount"},
            {"Reward", "Reward"},
            {"qAccep", "You have accepted the quest"},
            {"dAccep", "You have accepted the delivery mission"},
            {"canConf", "You have cancelled the delivery mission"},
            {"rewRec", "You have recieved"},
            {"rewError", "Unable to issue your reward. Please contact an administrator / check if your inventory is full"},
            {"Quest NPCs:", "Quest NPCs:"},
            {"newVSucc", "You have successfully added a new Quest vendor"},
            {"noNPC", "Unable to find a valid NPC"},
            {"addNewRew", "Add Reward"},
            {"NoTP", "You cannot teleport while you are on a delivery mission"},
            {"noVendor", "To accept new Quests you must find a Quest Vendor"},
            {"progressWiped", "You wiped all player progresses!"},
        };

        #endregion

        #region API

        private bool API_GetNotChatOutput(BasePlayer player)
        {
            if (player == null) return false;
            if (ActiveEditors.ContainsKey(player.userID) || ActiveCreations.ContainsKey(player.userID) || AddVendor.ContainsKey(player.userID)) return true;
            else return false;
        }

        #endregion
    }
}

// --- End of file: Quests.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/qrtl ---
// --- Original File Path: Q/QRTL/QRTL.cs ---

using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("QRTL", "Quapi", "0.2.1")]
    [Description("A fix for RTL Languages")]
    class QRTL : CovalencePlugin
    {
        private object OnBetterChat(Dictionary<string, object> data)
        {
            var message = data["Message"] as string;
            if (IsRightToLeft(message))
            {
                data["Message"] = RtlText(message);
                return data;
            }
            else
                return null;
        }

        #region -Methods-

        protected string RtlText(string text)
        {
            if (!IsRightToLeft(text)) return text;

            //var reversed = Reverse(text);
            //return IsRTLLang(text) ? reversed.Replace(" ", "") : reversed;

            StringBuilder fixedMessage = new StringBuilder();

            // Keep track of insertion proceedings to retain sentence logic
            // If true, insert at beginning of sentence
            bool resetInsertionPos = false;


            string[] words = text.Split(' ');

            for (int i = 0; i < words.Length; i++)
            {
                if (IsRightToLeft(words[i]))
                {
                    StringBuilder fixedRTLPart = new StringBuilder();

                    for (; i < words.Length; i++)
                    {
                        if (IsRightToLeft(words[i]) || IsNumber(words[i]))
                        {
                            string wordToFix = words[i];
                            fixedRTLPart.Insert(0, FixWord(wordToFix) + ' ');
                        }
                        else
                        {
                            i--;
                            break;
                        }
                    }

                    if (!resetInsertionPos)
                    {
                        fixedMessage.Append(fixedRTLPart);
                    }
                    else
                    {
                        fixedMessage.Insert(0, fixedRTLPart);
                        resetInsertionPos = false;
                    }
                }
                else
                {
                    StringBuilder fixedLTRPart = new StringBuilder();

                    for (; i < words.Length; i++)
                    {
                        if (!IsRightToLeft(words[i]))
                        {
                            fixedLTRPart.Append(words[i]).Append(' ');
                        }
                        else
                        {
                            i--;
                            break;
                        }
                    }
                    resetInsertionPos = true;
                    fixedMessage.Insert(0, fixedLTRPart);
                }
            }

            return fixedMessage.ToString();
        }

        protected bool IsBothRTLOrSpecial(char a, char b)
        {
            return IsRTLLang(a) && IsRTLLang(b)
                    || IsRTLLang(a) && IsSpecialChar(b)
                    || IsSpecialChar(a) && IsRTLLang(b)
                    || IsSpecialChar(a) && IsSpecialChar(b);
        }

        protected bool IsSpecialChar(char character)
        {
            return character == '!' || character == ' ' || character == '-' || character == '_' || character == '@'
                    || character == '#' || character == '$' || character == '%' || character == '^' || character == '&' || character == '*'
                    || character == '?' || character == '(' || character == ')' || character == ';';
        }

        protected bool IsNumber(string v)
        {
            foreach (char c in v.ToCharArray())
            {
                if (!char.IsDigit(c))
                    return false;
            }

            return true;
        }

        protected bool IsRTL(string text)
        {
            return IsRightToLeft(text);
        }

        protected bool IsRTLLang(char c)
        {
            return IsRTL(c + "");
        }

        #region -RTL-

        protected string FixWord(string word)
        {
            char[] chars = word.ToCharArray();

            chars = SwapRTLCharacters(chars);
            chars = SwapWordIndexes(chars);

            return new string(chars);
        }

        /**
         * Swaps all RTL characters and switches their order
         */
        protected char[] SwapRTLCharacters(char[] characters)
        {
            Dictionary<int, char> chars = new Dictionary<int, char>();

            for (int i = 0; i < characters.Length; i++)
            {
                chars.Add(i, characters[i]);
            }

            for (int i = 0; i < chars.Count; i++)
            {
                for (int j = i; j < chars.Count; j++)
                {
                    if (IsBothRTLOrSpecial(chars[i], chars[j]))
                    {
                        char tmp = chars[j];
                        chars[j] = chars[i];
                        chars[i] = tmp;
                    }
                    else 
                    {
                        break;
                    }
                }
            }

            char[] returnable = new char[chars.Count];
            for (int i = 0; i < chars.Count; i++)
                returnable[i] = chars[i];


            return returnable;
        }

        protected char[] SwapWordIndexes(char[] characters)
        {
            if (characters.Length == 0) return new char[0];

            char[] chars = characters;

            Stack<string> innerWords = new Stack<string>();

            StringBuilder currentWord = new StringBuilder();
            foreach (char character in chars) {
                if (currentWord.Length == 0 || IsBothRTLOrSpecial(currentWord[0], character)
                        || !IsRightToLeft(currentWord[0].ToString()) && !IsSpecialChar(currentWord[0])
                        && !IsRightToLeft(character.ToString()) && !IsSpecialChar(character))
                {
                    currentWord.Append(character);
                }
                else
                {
                    innerWords.Push(currentWord.ToString());
                    currentWord = new StringBuilder("" + character);
                }
            }

            if (currentWord.Length > 0)
            {
                innerWords.Push(currentWord.ToString());
            }

            if (innerWords.Count == 0)
            {
                return new char[0];
            }

            int currentIndex = 0;
            while (innerWords.Count != 0)
            {
                string s = innerWords.Pop();
                foreach (char c in s.ToCharArray())
                {
                    chars[currentIndex] = c;
                    currentIndex++;
                }
            }

            return chars;
        }

        protected bool IsRightToLeft(string text)
        {
            foreach (var c in text)
            {
                if (c >= 0x5BE && c <= 0x10B7F)
                {
                    if (c <= 0x85E)
                    {
                        if (c == 0x5BE) return true;
                        else if (c == 0x5C0) return true;
                        else if (c == 0x5C3) return true;
                        else if (c == 0x5C6) return true;
                        else if (0x5D0 <= c && c <= 0x5EA) return true;
                        else if (0x5F0 <= c && c <= 0x5F4) return true;
                        else if (c == 0x608) return true;
                        else if (c == 0x60B) return true;
                        else if (c == 0x60D) return true;
                        else if (c == 0x61B) return true;
                        else if (0x61E <= c && c <= 0x64A) return true;
                        else if (0x66D <= c && c <= 0x66F) return true;
                        else if (0x671 <= c && c <= 0x6D5) return true;
                        else if (0x6E5 <= c && c <= 0x6E6) return true;
                        else if (0x6EE <= c && c <= 0x6EF) return true;
                        else if (0x6FA <= c && c <= 0x70D) return true;
                        else if (c == 0x710) return true;
                        else if (0x712 <= c && c <= 0x72F) return true;
                        else if (0x74D <= c && c <= 0x7A5) return true;
                        else if (c == 0x7B1) return true;
                        else if (0x7C0 <= c && c <= 0x7EA) return true;
                        else if (0x7F4 <= c && c <= 0x7F5) return true;
                        else if (c == 0x7FA) return true;
                        else if (0x800 <= c && c <= 0x815) return true;
                        else if (c == 0x81A) return true;
                        else if (c == 0x824) return true;
                        else if (c == 0x828) return true;
                        else if (0x830 <= c && c <= 0x83E) return true;
                        else if (0x840 <= c && c <= 0x858) return true;
                        else if (c == 0x85E) return true;
                    }
                    else if (c == 0x200F) return true;
                    else if (c >= 0xFB1D)
                    {
                        if (c == 0xFB1D) return true;
                        else if (0xFB1F <= c && c <= 0xFB28) return true;
                        else if (0xFB2A <= c && c <= 0xFB36) return true;
                        else if (0xFB38 <= c && c <= 0xFB3C) return true;
                        else if (c == 0xFB3E) return true;
                        else if (0xFB40 <= c && c <= 0xFB41) return true;
                        else if (0xFB43 <= c && c <= 0xFB44) return true;
                        else if (0xFB46 <= c && c <= 0xFBC1) return true;
                        else if (0xFBD3 <= c && c <= 0xFD3D) return true;
                        else if (0xFD50 <= c && c <= 0xFD8F) return true;
                        else if (0xFD92 <= c && c <= 0xFDC7) return true;
                        else if (0xFDF0 <= c && c <= 0xFDFC) return true;
                        else if (0xFE70 <= c && c <= 0xFE74) return true;
                        else if (0xFE76 <= c && c <= 0xFEFC) return true;
                        else if (0x10800 <= c && c <= 0x10805) return true;
                        else if (c == 0x10808) return true;
                        else if (0x1080A <= c && c <= 0x10835) return true;
                        else if (0x10837 <= c && c <= 0x10838) return true;
                        else if (c == 0x1083C) return true;
                        else if (0x1083F <= c && c <= 0x10855) return true;
                        else if (0x10857 <= c && c <= 0x1085F) return true;
                        else if (0x10900 <= c && c <= 0x1091B) return true;
                        else if (0x10920 <= c && c <= 0x10939) return true;
                        else if (c == 0x1093F) return true;
                        else if (c == 0x10A00) return true;
                        else if (0x10A10 <= c && c <= 0x10A13) return true;
                        else if (0x10A15 <= c && c <= 0x10A17) return true;
                        else if (0x10A19 <= c && c <= 0x10A33) return true;
                        else if (0x10A40 <= c && c <= 0x10A47) return true;
                        else if (0x10A50 <= c && c <= 0x10A58) return true;
                        else if (0x10A60 <= c && c <= 0x10A7F) return true;
                        else if (0x10B00 <= c && c <= 0x10B35) return true;
                        else if (0x10B40 <= c && c <= 0x10B55) return true;
                        else if (0x10B58 <= c && c <= 0x10B72) return true;
                        else if (0x10B78 <= c && c <= 0x10B7F) return true;
                    }
                }
            }
            return false;
        }
        #endregion
        #endregion
    }
}


// --- End of file: QRTL.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/queue-limit ---
// --- Original File Path: Q/QueueLimit/QueueLimit.cs ---

using System.Collections.Generic;
using ConVar;

namespace Oxide.Plugins
{
    [Info("Queue Limit", "Ryan", "1.0.1")]
    [Description("Limits the number of players allowed in the connection queue")]
    class QueueLimit : RustPlugin
    {
        private int Limit;
        private string Perm = "queuelimit.bypass";

        private void LoadDefaultConfig()
        {
            PrintWarning("Generating default configuration file");
            Config["Queue Limit"] = Limit = 100;
        }

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                ["KickMessage"] = "Server is full"
            }, this);
        }

        private void Init()
        {
            Limit = (int) Config["Queue Limit"];
            permission.RegisterPermission(Perm, this);
        }

        private string CanClientLogin(Network.Connection connection)
        {
            if (permission.UserHasPermission(connection.userid.ToString(), Perm))
                return null;

            if (Admin.ServerInfo().Queued >= Limit)
                return lang.GetMessage("KickMessage", this, connection.userid.ToString());

            return null;
        }
    }
}


// --- End of file: QueueLimit.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/quarry-lock ---
// --- Original File Path: Q/QuarryLock/QuarryLock.cs ---

using Network;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Random = UnityEngine.Random;

/*
 * Rewritten from scratch and maintained to present by VisEntities
 * Originally created by Orange, up to version 1.2.1
 */

namespace Oxide.Plugins
{
    [Info("Quarry Lock", "VisEntities", "2.3.1")]
    [Description("Deploy code locks onto quarries and pump jacks.")]
    public class QuarryLock : RustPlugin
    {
        #region 3rd Party Dependencies

        [PluginReference]
        private readonly Plugin Clans, Friends;

        #endregion 3rd Party Dependencies

        #region Fields

        private static QuarryLock _plugin;
        private static Configuration _config;
        private Coroutine _codeLockParentUpdateCoroutine;

        private const int ITEM_ID_CODE_LOCK = 1159991980;

        private const string PREFAB_CODE_LOCK = "assets/prefabs/locks/keypad/lock.code.prefab";
        private const string PREFAB_QUARRY_ENGINE = "assets/prefabs/deployable/quarry/engineswitch.prefab";
        private const string PREFAB_QUARRY_FUEL = "assets/prefabs/deployable/quarry/fuelstorage.prefab";
        private const string PREFAB_QUARRY_HOPPER = "assets/prefabs/deployable/quarry/hopperoutput.prefab";
        private const string PREFAB_PUMP_JACK_ENGINE = "assets/prefabs/deployable/oil jack/engineswitch.prefab";
        private const string PREFAB_PUMP_JACK_FUEL = "assets/prefabs/deployable/oil jack/fuelstorage.prefab";
        private const string PREFAB_PUMP_JACK_HOPPER = "assets/prefabs/deployable/oil jack/crudeoutput.prefab";

        private const string FX_CODE_LOCK_DEPLOY = "assets/prefabs/locks/keypad/effects/lock-code-deploy.prefab";
        
        #endregion Fields

        #region Configuration

        private class Configuration
        {
            [JsonProperty("Version")]
            public string Version { get; set; }
            
            [JsonProperty("Only Quarry Owner Can Place Locks")]
            public bool OnlyQuarryOwnerCanPlaceLocks { get; set; }

            [JsonProperty("Enable Auto Locking On Placement")]
            public bool EnableAutoLockingOnPlacement { get; set; }

            [JsonProperty("Enable Lock Placement On Static Extractors")]
            public bool EnableLockPlacementOnStaticExtractors { get; set; }

            [JsonProperty("Auto Authorize Teammates")]
            public bool AutoAuthorizeTeammates { get; set; }

            [JsonProperty("Auto Authorize Clanmates")]
            public bool AutoAuthorizeClanmates { get; set; }

            [JsonProperty("Auto Authorize Friends")]
            public bool AutoAuthorizeFriends { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();

            if (string.Compare(_config.Version, Version.ToString()) < 0)
                UpdateConfig();

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config, true);
        }

        private void UpdateConfig()
        {
            PrintWarning("Config changes detected! Updating...");

            Configuration defaultConfig = GetDefaultConfig();

            if (string.Compare(_config.Version, "1.0.0") < 0)
                _config = defaultConfig;

            if (string.Compare(_config.Version, "2.1.0") < 0)
            {
                _config.EnableLockPlacementOnStaticExtractors = defaultConfig.EnableLockPlacementOnStaticExtractors;
            }

            if (string.Compare(_config.Version, "2.2.0") < 0)
            {
                _config.AutoAuthorizeFriends = defaultConfig.AutoAuthorizeFriends;
            }

            if (string.Compare(_config.Version, "2.3.0") < 0)
            {
                _config.OnlyQuarryOwnerCanPlaceLocks = defaultConfig.OnlyQuarryOwnerCanPlaceLocks;
            }

            PrintWarning("Config update complete! Updated from version " + _config.Version + " to " + Version.ToString());
            _config.Version = Version.ToString();
        }

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                Version = Version.ToString(),
                OnlyQuarryOwnerCanPlaceLocks = true,
                EnableAutoLockingOnPlacement = false,
                EnableLockPlacementOnStaticExtractors = false,
                AutoAuthorizeTeammates = true,
                AutoAuthorizeFriends = false,
                AutoAuthorizeClanmates = false,
            };
        }

        #endregion Configuration

        #region Oxide Hooks

        private void Init()
        {
            _plugin = this;
            PermissionUtil.RegisterPermissions();
        }

        private void Unload()
        {
            CoroutineUtil.StopAllCoroutines();
            _config = null;
            _plugin = null;
        }

        private void OnServerInitialized(bool isStartup)
        {
            if (!isStartup)
                return;

            CoroutineUtil.StartCoroutine(Guid.NewGuid().ToString(), UpdateAllCodeLockParentsCoroutine());      
        }

        private object CanLootEntity(BasePlayer player, ResourceExtractorFuelStorage storageContainer)
        {
            if (player == null || storageContainer == null)
                return null;

            MiningQuarry miningQuarry = storageContainer.GetParentEntity() as MiningQuarry;
            if (miningQuarry == null)
                return null;
           
            CodeLock existingCodeLock = storageContainer.GetSlot(BaseEntity.Slot.Lock) as CodeLock;
            Item item = player.GetActiveItem();

            if (existingCodeLock == null && item != null && item.info.itemid == ITEM_ID_CODE_LOCK)
            {
                if (miningQuarry.isStatic && !_config.EnableLockPlacementOnStaticExtractors)
                {
                    SendReplyToPlayer(player, Lang.StaticExtractorLockingBlocked);
                    return true;
                }

                if (miningQuarry.OwnerID != 0 && _config.OnlyQuarryOwnerCanPlaceLocks && player.userID != miningQuarry.OwnerID)
                {
                    SendReplyToPlayer(player, Lang.OnlyOwnerCanPlaceLocks);
                    return true;
                }

                Vector3 localPosition;
                Quaternion localRotation;

                switch (storageContainer.PrefabName)
                {
                    case PREFAB_QUARRY_FUEL:
                        {
                            localPosition = new Vector3(0.45f, 0.65f, 0.50f);
                            localRotation = Quaternion.Euler(0.0f, 90.0f, 0.0f);
                            break;
                        }
                    case PREFAB_QUARRY_HOPPER:
                        {
                            localPosition = new Vector3(-0.03f, 1.9f, 1.3f);
                            localRotation = Quaternion.Euler(0.0f, 90.0f, 0.0f);
                            break;
                        }
                    case PREFAB_PUMP_JACK_FUEL:
                        {
                            localPosition = new Vector3(-0.70f, 0.56f, 0.49f);
                            localRotation = Quaternion.Euler(0.0f, 90.0f, 0.0f);
                            break;
                        }
                    case PREFAB_PUMP_JACK_HOPPER:
                        {
                            localPosition = new Vector3(0.29f, 0.60f, 0.001f);
                            localRotation = Quaternion.Euler(0.0f, 0.0f, 0.0f);
                            break;
                        }
                    default:
                        return null;
                }

                CodeLock codeLock = DeployCodeLock(player, item, storageContainer, localPosition, localRotation);
                if (codeLock != null)
                {
                    item.UseItem(1);
                    // For compatibility with plugins that utilize the 'OnItemDeployed' hook.
                    Interface.CallHook("OnItemDeployed", item.GetHeldEntity(), miningQuarry, codeLock);
                    return true;
                }
            }
            else if (existingCodeLock != null)
            {
                if (PermissionUtil.VerifyHasPermission(player, PermissionUtil.ADMIN))
                {
                    if (!existingCodeLock.whitelistPlayers.Contains(player.userID))
                        existingCodeLock.whitelistPlayers.Add(player.userID);

                    return null;
                }
                else if (!existingCodeLock.OnTryToOpen(player))
                {
                    SendReplyToPlayer(player, Lang.Locked);
                    return true;
                }
            }

            return null;
        }

        private object OnQuarryToggle(MiningQuarry miningQuarry, BasePlayer player)
        {
            if (miningQuarry == null || player == null)
                return null;

            EngineSwitch engineSwitch = miningQuarry.engineSwitchPrefab.instance as EngineSwitch;
            if (engineSwitch == null)
                return null;

            CodeLock existingCodeLock = engineSwitch.GetSlot(BaseEntity.Slot.Lock) as CodeLock;
            Item item = player.GetActiveItem();

            if (existingCodeLock == null && item != null && item.info.itemid == ITEM_ID_CODE_LOCK)
            {
                if (miningQuarry.isStatic && !_config.EnableLockPlacementOnStaticExtractors)
                {
                    SendReplyToPlayer(player, Lang.StaticExtractorLockingBlocked);
                    return true;
                }

                if (miningQuarry.OwnerID != 0 && _config.OnlyQuarryOwnerCanPlaceLocks && player.userID != miningQuarry.OwnerID)
                {
                    SendReplyToPlayer(player, Lang.OnlyOwnerCanPlaceLocks);
                    return true;
                }

                Vector3 localPosition;
                Quaternion localRotation;

                if (engineSwitch.PrefabName == PREFAB_QUARRY_ENGINE)
                {
                    if (miningQuarry.isStatic)
                    {
                        localPosition = new Vector3(0.29f, 0.82f, 0.07f);
                        localRotation = Quaternion.Euler(0.0f, 0.0f, 0.0f);
                    }
                    else
                    {
                        localPosition = new Vector3(0.07f, 0.91f, -0.70f);
                        localRotation = Quaternion.Euler(0.0f, 90.0f, 0.0f);
                    }
                }
                else if (engineSwitch.PrefabName == PREFAB_PUMP_JACK_ENGINE)
                {
                    if (miningQuarry.isStatic)
                    {
                        localPosition = new Vector3(0.06f, 0.36f, -0.28f);
                        localRotation = Quaternion.Euler(0.0f, 90.0f, 0.0f);
                    }
                    else
                    {
                        localPosition = new Vector3(0.38f, 0.87f, -0.68f);
                        localRotation = Quaternion.Euler(0.0f, 90.0f, 0.0f);
                    }
                }
                else
                    return null;

                CodeLock codeLock = DeployCodeLock(player, item, engineSwitch, localPosition, localRotation);
                if (codeLock != null)
                {
                    item.UseItem(1);
                    // For compatibility with plugins that utilize the 'OnItemDeployed' hook.
                    Interface.CallHook("OnItemDeployed", item.GetHeldEntity(), miningQuarry, codeLock);
                    return true;
                }
            }
            else if (existingCodeLock != null)
            {
                if (!existingCodeLock.OnTryToOpen(player) && !PermissionUtil.VerifyHasPermission(player, PermissionUtil.ADMIN))
                {
                    SendReplyToPlayer(player, Lang.Locked);
                    return true;
                }
            }

            return null;
        }

        #endregion Oxide Hooks

        #region Code Lock Deployment

        private CodeLock DeployCodeLock(BasePlayer player, Item deployerItem, BaseEntity parent, Vector3 localPosition, Quaternion localRotation)
        {
            Vector3 worldPosition = parent.transform.TransformPoint(localPosition);
            Quaternion worldRotation = parent.transform.rotation * localRotation;

            CodeLock codeLock = GameManager.server.CreateEntity(PREFAB_CODE_LOCK, worldPosition, worldRotation) as CodeLock;
            if (codeLock == null)
                return null;

            codeLock.OwnerID = player.userID;

            codeLock.SetParent(parent, parent.GetSlotAnchorName(BaseEntity.Slot.Lock), true, true);
            codeLock.OnDeployed(parent, player, deployerItem);
            codeLock.Spawn();

            parent.SetSlot(BaseEntity.Slot.Lock, codeLock);
            // This's necessary to prevent hopper and fuel storage from being destroyed and recreated on server restart.
            parent.EnableSaving(true);

            if (_config.EnableAutoLockingOnPlacement)
            {
                string randomCode = GenerateRandomCode();
                codeLock.code = randomCode;
                codeLock.whitelistPlayers.Add(player.userID);
                codeLock.SetFlag(BaseEntity.Flags.Locked, true);

                SendReplyToPlayer(player, Lang.AutoLocked, randomCode);

                if (_config.AutoAuthorizeClanmates)
                {
                    string clanTag = ClanUtil.GetClanTagOfPlayer(player);
                    if (!string.IsNullOrEmpty(clanTag))
                    {
                        JObject clanInfo = ClanUtil.GetClanInfo(clanTag);
                        if (clanInfo != null)
                        {
                            JArray members = (JArray)clanInfo["members"];
                            if (members.Count > 0)
                            {
                                foreach (ulong memberId in members)
                                    codeLock.whitelistPlayers.Add(memberId);        

                                SendReplyToPlayer(player, Lang.ClanAuthorized);
                            }
                        }
                    }
                }
                if (_config.AutoAuthorizeFriends)
                {
                    ulong[] friendsList = FriendsUtil.GetFriendsOfPlayer((ulong)player.userID);
                    if (friendsList.Length > 0)
                    {
                        foreach (ulong friendId in friendsList)
                            codeLock.whitelistPlayers.Add(friendId);
                 
                        SendReplyToPlayer(player, Lang.FriendsAuthorized);
                    }
                }
                if (_config.AutoAuthorizeTeammates)
                {
                    if (player.Team != null && player.Team.members.Count > 1)
                    {
                        foreach (ulong memberId in player.Team.members)
                        {
                            if (memberId != player.userID)
                            {
                                codeLock.whitelistPlayers.Add(memberId);
                            }
                        }

                        SendReplyToPlayer(player, Lang.TeamAuthorized);
                    }
                }
            }

            SendReplyToPlayer(player, Lang.CodeLockDeployed);
            RunEffect(FX_CODE_LOCK_DEPLOY, codeLock.transform.position);
            return codeLock;
        }

        private string GenerateRandomCode()
        {
            return Random.Range(1000, 9999).ToString();
        }

        #endregion Code Lock Deployment

        #region Code Lock Parent Refresh

        /// <summary>
        /// Updates the parent of code locks attached to the mining quarry children (engine, hopper, and fuel storage)
        /// to the new instances created after server restart. This's necessary because these children are destroyed
        /// and recreated when the server restarts.
        /// </summary>
        private IEnumerator UpdateAllCodeLockParentsCoroutine()
        {
            foreach (CodeLock codeLock in BaseNetworkable.serverEntities.OfType<CodeLock>())
            {
                yield return CoroutineEx.waitForSeconds(0.1f);

                if (codeLock == null)
                    continue;

                BaseEntity parent = codeLock.GetParentEntity();
                if (parent == null)
                    continue;

                MiningQuarry miningQuarry = parent.GetParentEntity() as MiningQuarry;
                if (miningQuarry == null)
                    continue;

                BaseEntity newParent = null;
                Vector3 localPosition = Vector3.zero;
                Quaternion localRotation = Quaternion.identity;

                switch (parent.PrefabName)
                {
                    case PREFAB_QUARRY_FUEL:
                        {
                            localPosition = new Vector3(0.45f, 0.65f, 0.50f);
                            localRotation = Quaternion.Euler(0.0f, 90.0f, 0.0f);
                            newParent = miningQuarry.fuelStoragePrefab.instance;
                            break;
                        }
                    case PREFAB_QUARRY_HOPPER:
                        {
                            localPosition = new Vector3(-0.03f, 1.9f, 1.3f);
                            localRotation = Quaternion.Euler(0.0f, 90.0f, 0.0f);
                            newParent = miningQuarry.hopperPrefab.instance;
                            break;
                        }
                    case PREFAB_PUMP_JACK_FUEL:
                        {
                            localPosition = new Vector3(-0.70f, 0.56f, 0.49f);
                            localRotation = Quaternion.Euler(0.0f, 90.0f, 0.0f);
                            newParent = miningQuarry.fuelStoragePrefab.instance;
                            break;
                        }
                    case PREFAB_PUMP_JACK_HOPPER:
                        {
                            localPosition = new Vector3(0.29f, 0.60f, 0.001f);
                            localRotation = Quaternion.Euler(0.0f, 0.0f, 0.0f);
                            newParent = miningQuarry.hopperPrefab.instance;
                            break;
                        }
                    case PREFAB_QUARRY_ENGINE:
                        {
                            if (miningQuarry.isStatic)
                            {
                                localPosition = new Vector3(0.29f, 0.82f, 0.07f);
                                localRotation = Quaternion.Euler(0.0f, 0.0f, 0.0f);
                                newParent = miningQuarry.engineSwitchPrefab.instance;
                            }
                            else
                            {
                                localPosition = new Vector3(0.07f, 0.91f, -0.70f);
                                localRotation = Quaternion.Euler(0.0f, 90.0f, 0.0f);
                                newParent = miningQuarry.engineSwitchPrefab.instance;
                            }
                            break;
                        }
                    case PREFAB_PUMP_JACK_ENGINE:
                        {
                            if (miningQuarry.isStatic)
                            {
                                localPosition = new Vector3(0.06f, 0.36f, -0.28f);
                                localRotation = Quaternion.Euler(0.0f, 90.0f, 0.0f);
                                newParent = miningQuarry.engineSwitchPrefab.instance;
                            }
                            else
                            {
                                localPosition = new Vector3(0.38f, 0.87f, -0.68f);
                                localRotation = Quaternion.Euler(0.0f, 90.0f, 0.0f);
                                newParent = miningQuarry.engineSwitchPrefab.instance;
                            }
                            break;
                        }
                }

                if (newParent == null)
                    continue;

                codeLock.SetParent(null);
                codeLock.gameObject.Identity();

                codeLock.SetParent(newParent, true, true);
                codeLock.transform.localPosition = localPosition;
                codeLock.transform.localRotation = localRotation;

                newParent.SetSlot(BaseEntity.Slot.Lock, codeLock);
                newParent.EnableSaving(true);

                parent.Kill();
            }
        }

        #endregion Code Lock Parent Refresh

        #region Coroutine Util

        private static class CoroutineUtil
        {
            private static readonly Dictionary<string, Coroutine> _activeCoroutines = new Dictionary<string, Coroutine>();

            public static void StartCoroutine(string coroutineName, IEnumerator coroutineFunction)
            {
                StopCoroutine(coroutineName);

                Coroutine coroutine = ServerMgr.Instance.StartCoroutine(coroutineFunction);
                _activeCoroutines[coroutineName] = coroutine;
            }

            public static void StopCoroutine(string coroutineName)
            {
                if (_activeCoroutines.TryGetValue(coroutineName, out Coroutine coroutine))
                {
                    if (coroutine != null)
                        ServerMgr.Instance.StopCoroutine(coroutine);

                    _activeCoroutines.Remove(coroutineName);
                }
            }

            public static void StopAllCoroutines()
            {
                foreach (string coroutineName in _activeCoroutines.Keys.ToArray())
                {
                    StopCoroutine(coroutineName);
                }
            }
        }

        #endregion Coroutine Util

        #region Clan Integration

        private static class ClanUtil
        {
            public static string GetClanTagOfPlayer(BasePlayer player)
            {
                if (!VerifyPluginBeingLoaded(_plugin.Clans))
                    return "";

                string clanTag = (string)_plugin.Clans.Call("GetClanOf", player);
                if (clanTag == null)
                    return "";

                return clanTag;
            }

            public static JObject GetClanInfo(string clanTag)
            {
                if (!VerifyPluginBeingLoaded(_plugin.Clans))
                    return null;

                JObject clan = (JObject)_plugin.Clans.Call("GetClan", clanTag);
                if (clan == null)
                    return null;

                return clan;
            }
        }

        #endregion Clan Integration

        #region Friends Integration

        private static class FriendsUtil
        {            
            public static ulong[] GetFriendsOfPlayer(ulong playerId)
            {
                if (!VerifyPluginBeingLoaded(_plugin.Friends))
                    return new ulong[0];

                return (ulong[])_plugin.Friends.Call("GetFriendList", playerId);
            }
        }

        #endregion Friends Integration

        #region Permission

        private static class PermissionUtil
        {
            public const string ADMIN = "quarrylock.admin";

            public static void RegisterPermissions()
            {
                _plugin.permission.RegisterPermission(ADMIN, _plugin);
            }

            public static bool VerifyHasPermission(BasePlayer player, string permissionName = ADMIN)
            {
                return _plugin.permission.UserHasPermission(player.UserIDString, permissionName);
            }
        }

        #endregion Permission

        #region Helper Functions

        private static void RunEffect(string prefab, Vector3 worldPosition = default(Vector3), Vector3 worldDirection = default(Vector3), Connection effectRecipient = null, bool sendToAll = false)
        {
            Effect.server.Run(prefab, worldPosition, worldDirection, effectRecipient, sendToAll);
        }

        private static bool VerifyPluginBeingLoaded(Plugin plugin)
        {
            if (plugin != null && plugin.IsLoaded)
                return true;
            else
                return false;
        }

        #endregion Helper Functions

        #region Localization

        private class Lang
        {
            public const string Locked = "Locked";
            public const string CodeLockDeployed = "CodeLockDeployed";
            public const string AutoLocked = "AutoLocked";
            public const string TeamAuthorized = "TeamAuthorized";
            public const string ClanAuthorized = "ClanAuthorized";
            public const string FriendsAuthorized = "FriendsAuthorized";
            public const string StaticExtractorLockingBlocked = "StaticExtractorLockingBlocked";
            public const string OnlyOwnerCanPlaceLocks = "OnlyOwnerCanPlaceLocks";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.Locked] = "It's locked...",
                [Lang.CodeLockDeployed] = "Code lock deployed successfully.",
                [Lang.AutoLocked] = "Auto locked with code: <color=#FABE28>{0}</color>.",
                [Lang.TeamAuthorized] = "Your team members have been automatically whitelisted on this code lock.",
                [Lang.ClanAuthorized] = "Your clan members have been automatically whitelisted on this code lock.",
                [Lang.FriendsAuthorized] = "Your friends have been automatically whitelisted on this code lock.",
                [Lang.StaticExtractorLockingBlocked] = "Cannot place code locks on static resource extractors.",
                [Lang.OnlyOwnerCanPlaceLocks] = "Only the quarry's owner can place locks on it."
            }, this, "en");
        }

        private void SendReplyToPlayer(BasePlayer player, string messageKey, params object[] args)
        {
            string message = lang.GetMessage(messageKey, this, player.UserIDString);
            if (args.Length > 0)
                message = string.Format(message, args);

            SendReply(player, message);
        }

        #endregion Localization
    }
}

// --- End of file: QuarryLock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/queue-holder ---
// --- Original File Path: Q/QueueHolder/QueueHolder.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Queue Holder", "Tryhard", "1.0.1")]
    [Description("Saves your position in queue if you disconnect")]
    public class QueueHolder : RustPlugin
    {
        private Dictionary<ulong, DateTime> _queueHolder = new Dictionary<ulong, DateTime>();

        #region Hooks
        private void Init()
        {
            permission.RegisterPermission("QueueHolder.skip", this);
            permission.RegisterPermission("QueueHolder.grace", this);
        }

        private object CanBypassQueue(Network.Connection connection)
        {
            if (connection == null) return null;

            if (permission.UserHasPermission(connection.userid.ToString(), "QueueHolder.skip") || (_queueHolder.ContainsKey(connection.userid) && DateTime.Now.Subtract(_queueHolder[connection.userid]).TotalSeconds < config.queueTime))
            {
                _queueHolder.Remove(connection.userid);
                return true;
            }
            return null;
        }
        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null || !config.eQueue) return;

            if (_queueHolder.ContainsKey(player.userID))
            {
                _queueHolder.Remove(player.userID);
            }
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            if (player == null || !config.eQueue) return;

            if (permission.UserHasPermission(player.UserIDString, "QueueHolder.grace"))
            {
                _queueHolder.Add(player.userID, DateTime.Now);
            }
        }

        #endregion


        #region Config
        static Configuration config;
        public class Configuration
        {
            [JsonProperty("Enable queue holding")]
            public bool eQueue = true;

            [JsonProperty("Queue holding timer")]
            public int queueTime = 300;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
                SaveConfig();
            }
            catch (Exception e)
            {
                Debug.LogException(e);
                PrintWarning("Creating new config file.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => config = new Configuration();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion
    }
}


// --- End of file: QueueHolder.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/quantum-battery ---
// --- Original File Path: Q/QuantumBattery/QuantumBattery.cs ---

using UnityEngine;
using Newtonsoft.Json;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Quantum Battery", "Colon Blow", "1.0.3")]
    [Description("Fully Charged and Endless Batteries")]

    public class QuantumBattery : CovalencePlugin
    {

        #region Load

        private const string permMax = "quantumbattery.allowed";
        private bool initComplete = false;

        private void Init()
        {
            permission.RegisterPermission(permMax, this);
        }

        private void OnServerInitialized()
        {
            ProcessExistingBatteries();
            initComplete = true;
        }

        #endregion

        #region Configuration

        private static PluginConfig config;

        private class PluginConfig
        {
            public QuantumSettings quantumSettings { get; set; }

            public class QuantumSettings
            {
                [JsonProperty(PropertyName = "Quantum Battery - Enable Max Connection change : ")] public bool enableMaxOutput { get; set; }
                [JsonProperty(PropertyName = "Quantum Battery - Reset Max Allowed Connections to : ")] public int maxQuantumOutput { get; set; }
            }

            public static PluginConfig DefaultConfig() => new PluginConfig()
            {
                quantumSettings = new PluginConfig.QuantumSettings
                {
                    enableMaxOutput = true,
                    maxQuantumOutput = 9999,
                }
            };
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("New configuration file created!!");
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            SaveConfig();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["SpawnedBattery"] = "Your Quantum Battery is Fully Charged and will never die !!"
            }, this);
        }

        #endregion

        #region Hooks

        private void OnEntitySpawned(ElectricBattery battery)
        {
            if (!initComplete) return;
            ProcessBattery(battery);
        }

        private void ProcessExistingBatteries()
        {
            var batteryList = UnityEngine.Object.FindObjectsOfType<ElectricBattery>();
            foreach (var battery in batteryList)
            {
                ProcessBattery(battery);
            }
        }

        private void ProcessBattery(ElectricBattery battery)
        {
            var iplayer = covalence.Players.FindPlayerById(battery.OwnerID.ToString());
            if (iplayer != null && iplayer.HasPermission(permMax))
            {
                var makeQuantum = battery.gameObject.AddComponent<BatteryAutoCharger>();
                if (initComplete && iplayer.IsConnected) iplayer.Message(lang.GetMessage("SpawnedBattery", this, iplayer.Id));
            }
        }

        #endregion

        #region Battery AutoCharger

        private class BatteryAutoCharger : MonoBehaviour
        {
            ElectricBattery quantumBattery;
            float maxCapacity;

            private void Awake()
            {
                quantumBattery = GetComponent<ElectricBattery>();
                maxCapacity = quantumBattery.maxCapactiySeconds;
                if (config.quantumSettings.enableMaxOutput) quantumBattery.maxOutput = config.quantumSettings.maxQuantumOutput;
            }

            private void FixedUpdate()
            {
                quantumBattery.rustWattSeconds = maxCapacity;
            }

            private void OnDestroy()
            {
                GameObject.Destroy(this);
            }

        }

        #endregion
    }
}

// --- End of file: QuantumBattery.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/quarry-repair ---
// --- Original File Path: Q/QuarryRepair/QuarryRepair.cs ---

using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using UnityEngine;

/*
 * Rewritten from scratch and maintained to present by VisEntities
 * Originally created by Orange, up to version 1.0.21
 */

namespace Oxide.Plugins
{
    [Info("Quarry Repair", "VisEntities", "2.0.0")]
    [Description("Brings back the ability to repair deployable quarries and pump jacks.")]
    public class QuarryRepair : RustPlugin
    {
        #region Fields

        private static QuarryRepair _plugin;
        private static Configuration _config;

        #endregion Fields

        #region Configuration

        private class Configuration
        {
            [JsonProperty("Version")]
            public string Version { get; set; }

            [JsonProperty("Health Per Hit")]
            public float HealthPerHit { get; set; }

            [JsonProperty("Repair Cost")]
            public List<ItemInfo> RepairCost { get; set; }
        }

        public class ItemInfo
        {
            [JsonProperty("Shortname")]
            public string Shortname { get; set; }

            [JsonProperty("Amount")]
            public int Amount { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();

            if (string.Compare(_config.Version, Version.ToString()) < 0)
                UpdateConfig();

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config, true);
        }

        private void UpdateConfig()
        {
            PrintWarning("Config changes detected! Updating...");

            Configuration defaultConfig = GetDefaultConfig();

            if (string.Compare(_config.Version, "1.0.0") < 0)
                _config = defaultConfig;

            PrintWarning("Config update complete! Updated from version " + _config.Version + " to " + Version.ToString());
            _config.Version = Version.ToString();
        }

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                Version = Version.ToString(),
                HealthPerHit = 25f,
                RepairCost = new List<ItemInfo>
                {
                    new ItemInfo
                    {
                        Shortname = "wood",
                        Amount = 100
                    },
                    new ItemInfo
                    {
                        Shortname = "metal.fragments",
                        Amount = 100
                    },
                    new ItemInfo
                    {
                        Shortname = "metal.refined",
                        Amount = 5
                    },
                }
            };
        }

        #endregion Configuration

        #region Oxide Hooks

        private void Init()
        {
            _plugin = this;
        }

        private void Unload()
        {
            _config = null;
            _plugin = null;
        }

        private void OnHammerHit(BasePlayer player, HitInfo hitInfo)
        {
            if (player == null || hitInfo == null)
                return;

            BaseResourceExtractor resourceExtractor = hitInfo.HitEntity as BaseResourceExtractor;
            if (resourceExtractor == null)
                return;

            if (resourceExtractor.SecondsSinceAttacked <= 30f)
                return;

            float damage = resourceExtractor.MaxHealth() - resourceExtractor.Health();
            if (damage <= 0)
                return;

            List<ItemAmount> repairCost = new List<ItemAmount>();
            foreach (ItemInfo item in _config.RepairCost)
            {
                ItemDefinition itemDef = ItemManager.FindItemDefinition(item.Shortname);
                if (itemDef != null)
                    repairCost.Add(new ItemAmount(itemDef, item.Amount));
            }

            foreach (ItemAmount item in repairCost)
            {
                int playerAmount = player.inventory.GetAmount(item.itemid);
                if (playerAmount < item.amount)
                {
                    resourceExtractor.OnRepairFailedResources(player, repairCost);
                    return;
                }
            }

            float healthToAdd = Math.Min(_config.HealthPerHit, damage);

            foreach (ItemAmount item in repairCost)
            {
                int amountToDeduct = (int)item.amount;
                int amountTaken = player.inventory.Take(null, item.itemid, amountToDeduct);

                if (amountTaken > 0)
                    player.Command("note.inv", item.itemid, -amountTaken);
            }

            resourceExtractor.health += healthToAdd;
            resourceExtractor.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            if (resourceExtractor.Health() >= resourceExtractor.MaxHealth())
                resourceExtractor.OnRepairFinished();
            else
                resourceExtractor.OnRepair();
        }

        #endregion Oxide Hooks
    }
}

// --- End of file: QuarryRepair.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/quarry-health ---
// --- Original File Path: Q/QuarryHealth/QuarryHealth.cs ---

using Newtonsoft.Json;
using System.Collections;
using System.Linq;
using UnityEngine;

/*
 * Rewritten from scratch and maintained to present by VisEntities
 * Previous maintenance and contributions by Arainrr
 * Originally created by Waizujin
 */

namespace Oxide.Plugins
{
    [Info("Quarry Health", "VisEntities", "2.0.0")]
    [Description("Alters the health of quarries and pump jacks.")]
    public class QuarryHealth : RustPlugin
    {
        #region Fields

        private Coroutine _healthRefreshCoroutine;
        private static Configuration _config;

        private const string PREFAB_PUMP_JACK = "assets/prefabs/deployable/oil jack/mining.pumpjack.prefab";
        private const string PREFAB_MINING_QUARRY = "assets/prefabs/deployable/quarry/mining_quarry.prefab";

        #endregion Fields

        #region Configuration

        private class Configuration
        {
            [JsonProperty("Version")]
            public string Version { get; set; }

            [JsonProperty("Mining Quarry Hit Points")]
            public float MiningQuarryHitPoints { get; set; }

            [JsonProperty("Pump Jack Hit Points")]
            public float PumpJackQuarryHitPoints { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();

            if (string.Compare(_config.Version, Version.ToString()) < 0)
                UpdateConfig();

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config, true);
        }

        private void UpdateConfig()
        {
            PrintWarning("Config changes detected! Updating...");

            Configuration defaultConfig = GetDefaultConfig();

            if (string.Compare(_config.Version, "1.0.0") < 0)
                _config = defaultConfig;

            PrintWarning("Config update complete! Updated from version " + _config.Version + " to " + Version.ToString());
            _config.Version = Version.ToString();
        }

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                Version = Version.ToString(),
                MiningQuarryHitPoints = 2500f,
                PumpJackQuarryHitPoints = 2500f
            };
        }

        #endregion Configuration

        #region Oxide Hooks

        private void OnServerInitialized()
        {
            StartHealthRefreshCoroutine();
        }

        private void Unload()
        {
            StopHealthRefreshCoroutine();
            _config = null;
        }

        private void OnEntitySpawned(BaseResourceExtractor resourceExtractor)
        {
            if (resourceExtractor != null)
                InitializeResourceExtractorHealth(resourceExtractor);
        }

        #endregion Oxide Hooks

        #region Coroutine

        private void StartHealthRefreshCoroutine()
        {
            _healthRefreshCoroutine = ServerMgr.Instance.StartCoroutine(RefreshAllResourceExtractorsHealth());
        }
        
        private void StopHealthRefreshCoroutine()
        {
            if (_healthRefreshCoroutine != null)
            {
                ServerMgr.Instance.StopCoroutine(_healthRefreshCoroutine);
                _healthRefreshCoroutine = null;
            }
        }

        #endregion Coroutine

        #region Health

        private IEnumerator RefreshAllResourceExtractorsHealth()
        {
            foreach (BaseResourceExtractor resourceExtractor in BaseNetworkable.serverEntities.OfType<BaseResourceExtractor>())
            {
                if (resourceExtractor != null)
                    InitializeResourceExtractorHealth(resourceExtractor);

                yield return CoroutineEx.waitForSeconds(0.5f);
            }
        }

        private void InitializeResourceExtractorHealth(BaseResourceExtractor resourceExtractor)
        {
            if (resourceExtractor.PrefabName == PREFAB_MINING_QUARRY)
            {
                resourceExtractor.InitializeHealth(_config.MiningQuarryHitPoints, _config.MiningQuarryHitPoints);
            }
            else if (resourceExtractor.PrefabName == PREFAB_PUMP_JACK)
            {
                resourceExtractor.InitializeHealth(_config.MiningQuarryHitPoints, _config.PumpJackQuarryHitPoints);
            }

            resourceExtractor.SendNetworkUpdateImmediate();
        }

        #endregion Health
    }
}


// --- End of file: QuarryHealth.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/quarry-near-no-build ---
// --- Original File Path: Q/QuarryNearNoBuild/QuarryNearNoBuild.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Quarry Near No Build", "Arainrr", "1.2.0")]
    [Description("Prevent building near automatically spawned quarries.")]
    internal class QuarryNearNoBuild : RustPlugin
    {
        private const string PERMISSION_IGNORE = "quarrynearnobuild.ignore";
        private readonly List<QuarryInfo> quarryInfos = new List<QuarryInfo>();

        private void Init() => permission.RegisterPermission(PERMISSION_IGNORE, this);

        private void OnServerInitialized() => FindMiningQuarry();

        private class QuarryInfo
        {
            public Vector3 position;
            public float radius;
        }

        private enum QuarryType
        {
            SulfurQuarry,
            StoneQuarry,
            HQMQuarry,
        }

        private void FindMiningQuarry()
        {
            foreach (var monumentInfo in TerrainMeta.Path.Monuments)
            {
                switch (monumentInfo.name)
                {
                    case "assets/bundled/prefabs/autospawn/monument/small/mining_quarry_a.prefab":
                        if (configData.blockRadius[QuarryType.SulfurQuarry] > 0)
                            quarryInfos.Add(new QuarryInfo { position = monumentInfo.transform.position, radius = configData.blockRadius[QuarryType.SulfurQuarry] });
                        continue;

                    case "assets/bundled/prefabs/autospawn/monument/small/mining_quarry_b.prefab":
                        if (configData.blockRadius[QuarryType.StoneQuarry] > 0)
                            quarryInfos.Add(new QuarryInfo { position = monumentInfo.transform.position, radius = configData.blockRadius[QuarryType.StoneQuarry] });
                        continue;

                    case "assets/bundled/prefabs/autospawn/monument/small/mining_quarry_c.prefab":
                        if (configData.blockRadius[QuarryType.HQMQuarry] > 0)
                            quarryInfos.Add(new QuarryInfo { position = monumentInfo.transform.position, radius = configData.blockRadius[QuarryType.HQMQuarry] });
                        continue;

                    default: continue;
                }
            }
        }

        private object CanBuild(Planner planner, Construction prefab, Construction.Target target)
        {
            var player = planner?.GetOwnerPlayer();
            if (player == null) return null;
            if (permission.UserHasPermission(player.UserIDString, PERMISSION_IGNORE)) return null;
            Vector3 position = target.entity?.CenterPoint() ?? target.position;
            foreach (var quarryInfo in quarryInfos)
            {
                if (quarryInfo.radius >= Vector3.Distance(quarryInfo.position, position))
                {
                    Print(player, Lang("CantBulid", player.UserIDString));
                    return false;
                }
            }
            return null;
        }

        #region ConfigurationFile

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Block Radius")]
            public Dictionary<QuarryType, float> blockRadius = new Dictionary<QuarryType, float>()
            {
                [QuarryType.SulfurQuarry] = 60f,
                [QuarryType.StoneQuarry] = 60f,
                [QuarryType.HQMQuarry] = 60f,
            };

            [JsonProperty(PropertyName = "Chat Prefix")]
            public string prefix = "[QuarryNotBuild]: ";

            [JsonProperty(PropertyName = "Chat Prefix Color")]
            public string prefixColor = "#00FFFF";

            [JsonProperty(PropertyName = "Chat SteamID Icon")]
            public ulong steamIDIcon = 0;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                    LoadDefaultConfig();
            }
            catch
            {
                PrintError("The configuration file is corrupted");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        #endregion ConfigurationFile

        #region LanguageFile

        private void Print(BasePlayer player, string message) => Player.Message(player, message, $"<color={configData.prefixColor}>{configData.prefix}</color>", configData.steamIDIcon);

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CantBulid"] = "Prevent building near this quarry"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CantBulid"] = ""
            }, this, "zh-CN");
        }

        #endregion LanguageFile
    }
}

// --- End of file: QuarryNearNoBuild.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/quality-crafting ---
// --- Original File Path: Q/QualityCrafting/QualityCrafting.cs ---

using System.Linq;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.Collections;
using UnityEngine;
using Oxide.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using System;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using System.Threading.Tasks;
using System.Text;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("Quality Crafting", "mr01sam", "2.1.2")]
    [Description("Players can level crafting skills to produce higher quality items that have better stats than vanilla items.")]
    partial class QualityCrafting : CovalencePlugin
    {
        /* CHANGELOG
         *  - Updated for May 4th update
         *  - Fixed issue where storage containers would not update when moving items
         *  - Fixed OnInventoryNetwork update error
         */
        private static QualityCrafting PLUGIN;

        public const string PermissionAdmin = "qualitycrafting.admin";

        [PluginReference]
        private Plugin ImageLibrary;

        private Guid Secret { get; set; } = Guid.NewGuid();

        bool ServerInitialized { get; set; } = false;

        #region Initialization
        void Init()
        {
            UnsubscribeAll();
            PLUGIN = this;
            permission.RegisterPermission(PermissionAdmin, this);
        }

        void Unload()
        {
            SaveAll();
            foreach (var basePlayer in BasePlayer.activePlayerList)
            {
                UnloadPlayer(basePlayer);
            }
        }

        private void OnServerInitialized(bool initial)
        {
            try
            {
                ImageLibrary.Call("isLoaded", null);
            }
            catch (Exception)
            {
                PrintWarning($"The required dependency ImageLibary is not installed, {Name} will not work properly without it.");
                return;
            }
            LoadImages();
            LoadAll();
            LoadItemImages();
            foreach (var basePlayer in BasePlayer.activePlayerList)
            {
                LoadPlayer(basePlayer);
            }
            SubscribeAll();
            ServerInitialized = true;
        }

        void OnPlayerSleepEnded(BasePlayer basePlayer)
        {
            LoadPlayer(basePlayer);
        }

        object OnPlayerDeath(BasePlayer basePlayer, HitInfo info)
        {
            UnloadPlayer(basePlayer);
            return null;
        }

        void SubscribeAll()
        {
            Subscribe(nameof(Unload));
            Subscribe(nameof(OnPlayerSleepEnded));
            Subscribe(nameof(OnPlayerDeath));
            Subscribe(nameof(OnItemAction));
            Subscribe(nameof(OnItemCraft));
            Subscribe(nameof(OnItemCraftFinished));
            Subscribe(nameof(OnPlayerInput));
            Subscribe(nameof(OnActiveItemChanged));
            Subscribe(nameof(OnVendingShopOpened));
            Subscribe(nameof(OnLootEntity));
            Subscribe(nameof(OnLootEntityEnd));
            Subscribe(nameof(OnInventoryNetworkUpdate));
            Subscribe(nameof(OnLootNetworkUpdate));
            Subscribe(nameof(OnEntityTakeDamage));
            Subscribe(nameof(OnServerShutdown));
            Subscribe(nameof(OnServerSave));
        }

        void UnsubscribeAll()
        {
            Unsubscribe(nameof(Unload));
            Unsubscribe(nameof(OnPlayerSleepEnded));
            Unsubscribe(nameof(OnPlayerDeath));
            Unsubscribe(nameof(OnItemAction));
            Unsubscribe(nameof(OnItemCraft));
            Unsubscribe(nameof(OnItemCraftFinished));
            Unsubscribe(nameof(OnPlayerInput));
            Unsubscribe(nameof(OnActiveItemChanged));
            Unsubscribe(nameof(OnVendingShopOpened));
            Unsubscribe(nameof(OnLootEntity));
            Unsubscribe(nameof(OnLootEntityEnd));
            Unsubscribe(nameof(OnInventoryNetworkUpdate));
            Unsubscribe(nameof(OnLootNetworkUpdate));
            Unsubscribe(nameof(OnEntityTakeDamage));
            Unsubscribe(nameof(OnServerShutdown));
            Unsubscribe(nameof(OnServerSave));
        }

        void LoadPlayer(BasePlayer basePlayer)
        {
            RefreshOverlays(basePlayer);
            ShowAllButtons(basePlayer);
            ShowTrackingHud(basePlayer);
        }

        void UnloadPlayer(BasePlayer basePlayer)
        {
            DestroyAllOverlays(basePlayer);
            DestroyAllMenus(basePlayer);
            DestroyAllButtons(basePlayer);
            DestroyTrackingHud(basePlayer);
            NotificationManager.DestroyAllNotifications(basePlayer);
        }

        void OnServerShutdown()
        {
            SaveAll();
        }

        void OnServerSave()
        {
            SaveAll();
        }

        void LoadImages()
        {
            ImageLibrary.Call<bool>("AddImage", config.HUD.InspectButton.Icon, $"qc.inspect", 0UL);
            ImageLibrary.Call<bool>("AddImage", config.Qualities.IconQualityStar, $"qc.star", 0UL);
            ImageLibrary.Call<bool>("AddImage", config.Qualities.Tier1.Icon, $"qc.star.1", 0UL);
            ImageLibrary.Call<bool>("AddImage", config.Qualities.Tier2.Icon, $"qc.star.2", 0UL);
            ImageLibrary.Call<bool>("AddImage", config.Qualities.Tier3.Icon, $"qc.star.3", 0UL);
            ImageLibrary.Call<bool>("AddImage", config.Qualities.Tier4.Icon, $"qc.star.4", 0UL);
            ImageLibrary.Call<bool>("AddImage", config.Qualities.Tier5.Icon, $"qc.star.5", 0UL);
            ImageLibrary.Call<bool>("AddImage", config.HUD.SkillsButton.Icon, $"qc.button.skills", 0UL);
            ImageLibrary.Call<bool>("AddImage", config.HUD.InspectButton.Icon, $"qc.button.inspect", 0UL);
            ImageLibrary.Call<bool>("AddImage", config.HUD.QualityButton.Icon, $"qc.button.quality", 0UL);
            foreach (var category in SkillCategory.ALL)
            {
                ImageLibrary.Call<bool>("AddImage", config.Categories[category.NameTitleCase].Icon, $"qc.category.{category.Name}", 0UL);
            }
            ImageLibrary.Call<bool>("AddImage", config.Images.ArrowUp, $"qc.up", 0UL);
            ImageLibrary.Call<bool>("AddImage", config.Images.ArrowDown, $"qc.down", 0UL);
            ImageLibrary.Call<bool>("AddImage", config.Images.Close, $"qc.close", 0UL);
            ImageLibrary.Call<bool>("AddImage", config.Images.Help, $"qc.help", 0UL);
        }

        void LoadItemImages()
        {
            var url = "https://rustlabs.com/img/items180/";
            var itemList = ItemManager.itemList.ToDictionary(keySelector: m => m.shortname, elementSelector: m => $"{url}{m.shortname}");
            ImageLibrary.Call("ImportImageList", Name, itemList, 0, false, new Action(() =>
            {
            }));
        }

        void LoadAll()
        {
            CraftingManager.Load();
            TrackingManager.Load();
        }

        void SaveAll()
        {
            CraftingManager.Save();
            TrackingManager.Save();
        }
        #endregion
    }
}

namespace Oxide.Plugins
{
    partial class QualityCrafting : CovalencePlugin
    {
        private static readonly string PREFIX = "qc";

        #region Premade Arguments
        private static readonly CommandArgument SKILL_ARGUMENT = new CommandArgument
        {
            Parameter = "skill",
            Validate = (given) =>
            {
                SkillCategory category;
                category = SkillCategory.GetByName(given.ToLower());
                if (category == null)
                {
                    category = SkillCategory.GetByItemName(given);
                }
                return category == null ? new ValidationResponse(ValidationStatusCode.INVALID_VALUE, given) : new ValidationResponse();
            }
        };

        private static readonly CommandArgument CATEGORY_ARGUMENT = new CommandArgument
        {
            Parameter = "category",
            Validate = (given) =>
            {
                SkillCategory category;
                category = SkillCategory.GetByName(given.ToLower());
                return category == null ? new ValidationResponse(ValidationStatusCode.INVALID_VALUE, given) : new ValidationResponse();
            }
        };

        private static readonly CommandArgument QUALITY_ARGUMENT = new CommandArgument
        {
            Parameter = "quality",
            Validate = (given) =>
            {
                int intValue;
                if (int.TryParse(given, out intValue) && intValue >= 0 && intValue <= 5)
                {
                    return new ValidationResponse();
                }
                return new ValidationResponse(ValidationStatusCode.INVALID_VALUE, given);
            }
        };

        private static readonly CommandArgument XP_RATE_ARGUMENT = new CommandArgument
        {
            Parameter = "multiplier",
            Optional = true,
            Validate = (given) =>
            {
                float floatValue;
                if (float.TryParse(given, out floatValue) && floatValue >= 0)
                {
                    return new ValidationResponse();
                }
                return new ValidationResponse(ValidationStatusCode.INVALID_VALUE, given);
            }
        };

        private static readonly CommandArgument XP_ARGUMENT = new CommandArgument
        {
            Parameter = "xp",
            Validate = (given) =>
            {
                int intValue;
                if (int.TryParse(given, out intValue))
                {
                    return new ValidationResponse();
                }
                return new ValidationResponse(ValidationStatusCode.INVALID_VALUE, given);
            }
        };

        private static readonly CommandArgument LEVEL_ARGUMENT = new CommandArgument
        {
            Parameter = "level",
            Validate = (given) =>
            {
                int intValue;
                if (int.TryParse(given, out intValue) && intValue >= 0 && intValue <= 100)
                {
                    return new ValidationResponse();
                }
                return new ValidationResponse(ValidationStatusCode.INVALID_VALUE, given);
            }
        };
        #endregion

        #region Commands

        public static readonly List<CommandInfo> Commands = new List<CommandInfo>()
        {
            new CommandInfo()
            {
                Command = "help",
                Method = "CmdHelp",
                Description = "Opens the plugin help menu.",
                Rank = 1
            },
            new CommandInfo()
            {
                Command = "skills",
                Method = "CmdSkills",
                Description = "Opens the plugin skills menu.",
                Rank = 2
            },
            new CommandInfo()
            {
                Command = "buttons",
                Method = "CmdButtons",
                Description = "Toggles the visibility of the HUD buttons.",
                Arguments = new CommandArgument[]
                {
                    new CommandArgument
                    {
                        Parameter = "show/hide",
                        AllowedValues = new string[] {"show", "hide"}
                    }
                }
            },
            new CommandInfo()
            {
                Command = "wipeskills",
                Method = "CmdWipeSkills",
                Description = "Wipes all skill xp data for a specified player.",
                Permission = PermissionAdmin,
                Arguments = new CommandArgument[]
                {
                    CommandArgument.PLAYER_NAME
                },
            },
            new CommandInfo()
            {
                Command = "grantxp",
                Method = "CmdGrantXp",
                Description = "Grants the specified player crafting xp for the given item or category.",
                Permission = PermissionAdmin,
                Arguments = new CommandArgument[]
                {
                    CommandArgument.PLAYER_NAME,
                    SKILL_ARGUMENT,
                    XP_ARGUMENT
                }
            },
            new CommandInfo()
            {
                Command = "grantlevel",
                Method = "CmdGrantLevel",
                Description = "Advances the crafting skill level of the specified player by the given amount.",
                Permission = PermissionAdmin,
                Arguments = new CommandArgument[]
                {
                    CommandArgument.PLAYER_NAME,
                    SKILL_ARGUMENT,
                    LEVEL_ARGUMENT
                }
            },
            new CommandInfo()
            {
                Command = "setlevel",
                Method = "CmdSetLevel",
                Description = "Sets the crafting skill level for the given item or category.",
                Permission = PermissionAdmin,
                Arguments = new CommandArgument[]
                {
                    CommandArgument.PLAYER_NAME,
                    SKILL_ARGUMENT,
                    LEVEL_ARGUMENT
                }
            },
            new CommandInfo()
            {
                Command = "setquality",
                Method = "CmdSetQuality",
                Description = "Sets the quality level of an item. If no item id is given, the current active item will be targeted.",
                Permission = PermissionAdmin,
                Arguments = new CommandArgument[]
                {
                    CommandArgument.PLAYER_NAME,
                    QUALITY_ARGUMENT,
                    new CommandArgument
                    {
                        Parameter = "item uid",
                        Optional = true
                    }
                }
            },
            new CommandInfo()
            {
                Command = "xprate",
                Method = "CmdSetXpMultiplier",
                Description = "Temporarily overrides the configured xp multiplier for the given category. If a multiplier is not given, it will be reset to the default value.",
                Permission = PermissionAdmin,
                Arguments = new CommandArgument[]
                {
                    CATEGORY_ARGUMENT,
                    XP_RATE_ARGUMENT
                }
            },
            new CommandInfo()
            {
                Command = "getlevel",
                Method = "CmdGetLevel",
                Description = "Displays the crafting skill level information for the specified player",
                Permission = PermissionAdmin,
                Arguments = new CommandArgument[]
                {
                    CommandArgument.PLAYER_NAME,
                    SKILL_ARGUMENT
                }
            }
        };
        #endregion

        [Command("qc")]
        private void CmdController(IPlayer player, string command, string[] args)
        {
            try
            {
                if (args.Length == 0)
                {
                    CmdHelp(player, command, args);
                    return;
                }
                var commandInfo = Commands.FirstOrDefault(x => x.Command == args[0]);
                if (commandInfo == null)
                {
                    CmdHelp(player, command, args);
                    return;
                }
                // Permission
                if (!player.IsAdmin && !player.IsServer)
                {
                    foreach (var perm in commandInfo.Permissions)
                    {
                        if (!permission.UserHasPermission(player.Id, perm))
                        {
                            player.Reply(Lang("no permission", player.Id));
                            return;
                        }
                    }
                }
                args = args.Skip(1).ToArray();
                // Validation
                var resp = commandInfo.Validate(args);
                if (resp.IsValid)
                {
                    commandInfo.Execute(player, command, args);
                }
                else
                {
                    string message = commandInfo.Usage(player, PREFIX);
                    switch (resp.StatusCode)
                    {

                        case ValidationStatusCode.PLAYER_NOT_FOUND:
                            message = Lang("player not found", player.Id, resp.Data);
                            break;
                        case ValidationStatusCode.INVALID_VALUE:
                        case ValidationStatusCode.VALUE_NOT_ALLOWED:
                            message = Lang("invalid value", player.Id, resp.Data);
                            break;
                        case ValidationStatusCode.SUCCESS:
                            message = "weird";
                            break;
                    }
                    player.Reply(message);
                }
            }
            catch (Exception)
            {
                Lang("command error", player.Id);
            }

        }

        private void CmdSkills(IPlayer player, string command, string[] args)
        {
            if (player.IsServer)
            {
                player.Reply(Lang("command success", player.Id));
                return;
            }
            BasePlayer basePlayer = player.Object as BasePlayer;
            ShowSkillsMenu(basePlayer, false);
        }

        private void CmdButtons(IPlayer player, string command, string[] args)
        {
            if (player.IsServer)
            {
                player.Reply(Lang("command success", player.Id));
                return;
            }
            var toggle = args[0];
            BasePlayer basePlayer = player.Object as BasePlayer;
            if (toggle == "show")
            {
                ShowAllButtons(basePlayer);
            }
            else
            {
                DestroyAllButtons(basePlayer);
            }
            player.Reply(Lang("command success", player.Id));
        }

        private void CmdHelp(IPlayer player, string command, string[] args)
        {
            if (player.IsServer)
            {
                Puts("\n" + string.Join("\n", Commands.Select(x => $"{PREFIX} {x.Command} {x.ArgString}".PadRight(60) + x.Description)));
            }
            else
            {
                BasePlayer basePlayer = player.Object as BasePlayer;
                ShowHelpMenu(basePlayer, false, 1);
            }
        }

        private void CmdWipeSkills(IPlayer player, string command, string[] args)
        {
            var name = args[0];
            var target = BasePlayer.FindAwakeOrSleeping(name);
            CraftingManager.Clear(target);
            player.Reply(Lang("command success", player.Id));
        }

        private void CmdGrantXp(IPlayer player, string command, string[] args)
        {
            var name = args[0];
            var skill = args[1].ToLower();
            var xp = uint.Parse(args[2]);
            var target = BasePlayer.FindAwakeOrSleeping(name);
            var icon = "";
            var displayName = "";
            var oldLevel = 0;
            var newLevel = 0;
            var oldXp = 0f;
            var newXp = 0f;
            PlayerSkillSheet skills = CraftingManager.GetSkills(target);
            SkillCategory category = SkillCategory.GetByName(skill);
            if (category == null)
            {
                var itemDef = ItemManager.itemList.FirstOrDefault(x => x.displayName.translated.ToLower() == skill);
                category = SkillCategory.GetByItemDefinition(itemDef);
                var item = ItemManager.Create(itemDef);
                oldLevel = skills.GetLevel(item);
                oldXp = skills.GetLevelPercent(item);
                skills.GrantXP(item, xp);
                newLevel = skills.GetLevel(item);
                newXp = skills.GetLevelPercent(item);
                icon = item.info.shortname;
                displayName = item.info.displayName.translated;
            }
            else
            {
                oldLevel = skills.GetLevel(category);
                oldXp = skills.GetLevelPercent(category);
                skills.GrantXP(category, xp);
                ShowTrackingHud(target);
                newLevel = skills.GetLevel(category);
                newXp = skills.GetLevelPercent(category);
                icon = $"qc.category.{skill}";
                displayName = category.DisplayName(target);
            }
            NotificationManager.AddNotifications(target, new GainedXPNotification
            {
                Icon = icon,
                SkillDisplayName = displayName,
                OldLevel = oldLevel,
                NewLevel = newLevel,
                OldXP = oldXp,
                NewXP = newXp,
                IsLevelUp = newLevel > oldLevel,
                XPGained = xp
            });
            player.Reply(Lang("command success", player.Id));
        }

        private void CmdSetLevel(IPlayer player, string command, string[] args)
        {
            var name = args[0];
            var target = BasePlayer.FindAwakeOrSleeping(name);
            var skill = args[1].ToLower();
            var level = int.Parse(args[2]);
            PlayerSkillSheet skills = CraftingManager.GetSkills(target);
            SkillCategory category = SkillCategory.GetByName(skill);
            if (category == null)
            {
                var itemDef = ItemManager.itemList.FirstOrDefault(x => x.displayName.translated.ToLower() == skill);
                category = SkillCategory.GetByItemDefinition(itemDef);
                var item = ItemManager.Create(itemDef);
                skills.SetLevel(item, level);
            }
            else
            {
                skills.SetLevel(category, level);
                ShowTrackingHud(target);
            }
            player.Reply(Lang("command success", player.Id));
        }

        private void CmdSetQuality(IPlayer player, string command, string[] args)
        {
            var name = args[0];
            var target = BasePlayer.FindAwakeOrSleeping(name);
            var quality = int.Parse(args[1]);
            Item item;
            if (args.Length == 2)
            {
                item = target.GetActiveItem();
            }
            else
            {
                var uid = ulong.Parse(args[2]);
                item = target.inventory.FindItemUID(new ItemId(uid));
            }
            if (item != null)
            {
                var qi = new QualityItem(item);
                BasePlayer creator = null;
                if (qi.HasCreator)
                {
                    creator = BasePlayer.FindAwakeOrSleeping(qi.CreatorId.ToString());
                }
                QualityItemManager.SetItemQuality(item, quality, creator);
                QualityItemManager.ApplyQualityModifiers(item, quality);
            }
            player.Reply(Lang("command success", player.Id));
        }

        private void CmdSetXpMultiplier(IPlayer player, string command, string[] args)
        {
            var categoryName = args[0];
            var category = SkillCategory.GetByName(categoryName);
            if (args.Length == 1)
            {
                category.TemporaryMultiplier = null;
            }
            else
            {
                var multiplier = float.Parse(args[1]);
                category.TemporaryMultiplier = multiplier;
            }
            player.Reply(Lang("command success", player.Id));
        }

        private void CmdGrantLevel(IPlayer player, string command, string[] args)
        {
            var playerName = args[0];
            var basePlayer = BasePlayer.FindAwakeOrSleeping(playerName);
            var skillName = args[1];
            var amount = int.Parse(args[2]);
            var category = SkillCategory.GetByName(skillName);
            var skills = CraftingManager.GetSkills(basePlayer);
            int level;
            if (category == null)
            {
                var item = ItemManager.Create(ItemManager.itemList.FirstOrDefault(x => x.displayName.translated.ToLower() == skillName.ToLower()));
                level = skills.GetLevel(item);
                skills.SetLevel(item, Math.Min(100, level + amount));
            }
            else
            {
                level = skills.GetLevel(category);
                skills.SetLevel(category, Math.Min(100, level + amount));
            }
            player.Reply(Lang("command success", player.Id));
        }

        private void CmdGetLevel(IPlayer player, string command, string[] args)
        {
            var playerName = args[0];
            var basePlayer = BasePlayer.FindAwakeOrSleeping(playerName);
            var skillName = args[1];
            int level;
            string displayName;
            var skills = CraftingManager.GetSkills(basePlayer);
            var category = SkillCategory.GetByName(skillName);
            if (category == null)
            {
                var item = ItemManager.Create(ItemManager.itemList.FirstOrDefault(x => x.displayName.translated.ToLower() == skillName.ToLower()));
                level = skills.GetLevel(item);
                displayName = item.info.displayName.translated;
            }
            else
            {
                level = skills.GetLevel(category);
                displayName = category.DisplayName(basePlayer);
            }
            player.Reply($"{basePlayer.displayName} {displayName} {level}");
        }
    }
}

namespace Oxide.Plugins
{
	partial class QualityCrafting : CovalencePlugin
	{
		private Configuration config;

		private partial class Configuration
		{
			[JsonProperty(PropertyName = "Version")]
			public VersionNumber Version { get; set; } = new VersionNumber(0, 0, 0);

			[JsonProperty(PropertyName = "General")]
			public GeneralConfig Settings { get; set; } = new GeneralConfig();

			[JsonProperty(PropertyName = "Categories")]
			public Dictionary<string, CraftingCategoryConfig> Categories { get; set; } = SkillCategory.ALL.ToDictionary(x => x.Name.TitleCase(), x => new CraftingCategoryConfig()
			{
				Icon = x.DefaultIcon
			});

			[JsonProperty(PropertyName = "Quality Tiers")]
			public QualityConfig Qualities { get; set; } = new QualityConfig();

			[JsonProperty(PropertyName = "Notifications")]
			public NotificationConfig Notifications = new NotificationConfig();

			[JsonProperty(PropertyName = "HUD")]
			public HUDConfig HUD = new HUDConfig();

			[JsonProperty(PropertyName = "Colors")]
			public ColorsConfig Colors = new ColorsConfig();

			[JsonProperty(PropertyName = "Sounds")]
			public SFXConfig SFX = new SFXConfig();

			[JsonProperty(PropertyName = "UI Images")]
			public ImagesConfig Images = new ImagesConfig();
		}

		public class GeneralConfig
        {
			[JsonProperty(PropertyName = "Blueprint XP Gain")]
			public bool BlueprintXPGain = true;
		}

		public class HUDConfig
		{
			[JsonProperty(PropertyName = "Inspect Button")]
			public HUDButton InspectButton = new HUDButton
			{
				Icon = "https://i.imgur.com/tPi2qM4.png",
				X = 407,
				Y = 19,
				Size = 25
			};

			[JsonProperty(PropertyName = "Quality Button")]
			public HUDButton QualityButton = new HUDButton
			{
				Icon = "https://i.imgur.com/KMWMn0K.png",
				X = 407,
				Y = 52,
				Size = 25
			};

			[JsonProperty(PropertyName = "Skills Button")]
			public HUDButton SkillsButton = new HUDButton
			{
				Icon = "https://i.imgur.com/x0Zg12R.png",
				X = 830,
				Y = 30,
				Size = 32
			};

			[JsonProperty(PropertyName = "Tracked Skill")]
			public HUDElement TrackedSkill = new HUDElement
			{
				X = 890,
				Y = 17,
				Size = 160
			};
		}
		public class CraftingCategoryConfig
		{
			[JsonProperty(PropertyName = "Enabled")]
			public bool Enabled { get; set; } = true;
			[JsonProperty(PropertyName = "Icon")]
			public string Icon { get; set; }

			[JsonProperty(PropertyName = "Base XP Multiplier")]
			public float XPMultiplier { get; set; } = 1f;

			[JsonProperty(PropertyName = "Base Crafting Speed")]
			public float BaseCraftingSpeed { get; set; } = 1f;

			[JsonProperty(PropertyName = "Perk Increases Per Level")]
			public CraftingCategoryPerkConfig PerkIncreasesPerLevel { get; set; } = new CraftingCategoryPerkConfig();
		}

		public class CraftingCategoryPerkConfig
        {
			[JsonProperty(PropertyName = "Crafting Speed")]
			public float CraftingSpeed { get; set; } = 0.04f;

			[JsonProperty(PropertyName = "Duplicate Chance")]
			public float DuplicateChance { get; set; } = 0.002f;
		}

		public class HUDButton
        {
			[JsonProperty(PropertyName = "Icon")]
			public string Icon { get; set; }
			[JsonProperty(PropertyName = "X")]
			public int X { get; set; }
			[JsonProperty(PropertyName = "Y")]
			public int Y { get; set; }
			[JsonProperty(PropertyName = "Size")]
			public int Size { get; set; }
		}

		public class HUDElement
		{
			[JsonProperty(PropertyName = "X")]
			public int X { get; set; }
			[JsonProperty(PropertyName = "Y")]
			public int Y { get; set; }
			[JsonProperty(PropertyName = "Size")]
			public int Size { get; set; }
		}

		public class ImagesConfig
		{
			[JsonProperty(PropertyName = "Close")]
			public string Close { get; set; } = "https://i.imgur.com/AbG6hrk.png";

			[JsonProperty(PropertyName = "Help")]
			public string Help { get; set; } = "https://i.imgur.com/tVSQyuX.png";

			[JsonProperty(PropertyName = "Arrow Up")]
			public string ArrowUp { get; set; } = "https://i.imgur.com/Mgua5IP.png";

			[JsonProperty(PropertyName = "Arrow Down")]
			public string ArrowDown { get; set; } = "https://i.imgur.com/L5kufsD.png";
		}

		public class QualityConfig
		{
			[JsonProperty(PropertyName = "Star Icon")]
			public string IconQualityStar = "https://imgur.com/fbELboi.png";

			[JsonProperty(PropertyName = "Tier 0")]
			public QualityTierConfig Tier0 = new QualityTierConfig()
			{
				Color = "0.9 0.9 0.9 1"
			};

			[JsonProperty(PropertyName = "Tier 1")]
			public QualityTierConfig Tier1 = new QualityTierConfig()
			{
				Icon = "https://imgur.com/BKx4Hs8.png",
				Color = "0.11764 1 0 1"
			};

			[JsonProperty(PropertyName = "Tier 2")]
			public QualityTierConfig Tier2 = new QualityTierConfig()
			{
				Icon = "https://imgur.com/NSZTZ4v.png",
				Color = "0 0.43921 1 1"
			};

			[JsonProperty(PropertyName = "Tier 3")]
			public QualityTierConfig Tier3 = new QualityTierConfig()
			{
				Icon = "https://imgur.com/XSbgf72.png",
				Color = "0.63921 0.20784 0.93333 1"
			};

			[JsonProperty(PropertyName = "Tier 4")]
			public QualityTierConfig Tier4 = new QualityTierConfig()
			{
				Icon = "https://imgur.com/cEZUU9F.png",
				Color = "0.87531 0.70196 0 1"
			};

			[JsonProperty(PropertyName = "Tier 5")]
			public QualityTierConfig Tier5 = new QualityTierConfig()
			{
				Icon = "https://imgur.com/RD7ED4R.png",
				Color = "1 0.29803 0.14901 1"
			};
			[JsonProperty(PropertyName = "Percent Stat Increases Per Tier")]
			public ModifiersConfig Modifiers = new ModifiersConfig();
		}

		public class QualityTierConfig
        {
			[JsonProperty(PropertyName = "Icon")]
			public string Icon { get; set; } = null;

			[JsonProperty(PropertyName = "Color")]
			public string Color { get; set; }
		}

		public class ModifiersConfig
		{
			[JsonProperty(PropertyName = "Projectile Damage")]
			public float ProjectileDamage = 0.08f;
			[JsonProperty(PropertyName = "Protection")]
			public float Protection = 0.01f;
			[JsonProperty(PropertyName = "Melee Damage")]
			public float MeleeDamage = 0.20f;
			[JsonProperty(PropertyName = "Durability")]
			public float Durability = 0.20f;
			[JsonProperty(PropertyName = "Gather Rate")]
			public float GatherRate = 0.10f;
		}

		public class NotificationConfig
        {

			[JsonProperty(PropertyName = "Item Crafted Notification")]
			public NotificationUIConfig ItemCraftedNotification = new NotificationUIConfig()
			{
				Show = true,
				X = 480,
				Y = 124
			};

			[JsonProperty(PropertyName = "XP Gained Notification")]
			public NotificationUIConfig LevelUpItemNotification = new NotificationUIConfig()
			{
				Show = true,
				X = 480,
				Y = 124
			};
		}

		public class NotificationUIConfig
        {
			[JsonProperty(PropertyName = "Show")]
			public bool Show;
			[JsonProperty(PropertyName = "X")]
			public int X;
			[JsonProperty(PropertyName = "Y")]
			public int Y;
		}

		public class ColorsConfig
        {
			[JsonProperty(PropertyName = "HUD Background")]
			public string HUDBackground { get; set; } = "0.5 0.5 0.5 0.5";

			[JsonProperty(PropertyName = "Menu Background")]
			public string MenuBackground { get; set; } = "0.16078 0.16078 0.12941 1";

			[JsonProperty(PropertyName = "HUD Button Toggled")]
			public string HUDButtonToggled { get; set; } = "1 1 1 1";

			[JsonProperty(PropertyName = "HUD Button Untoggled")]
			public string HUDButtonUntoggled { get; set; } = "1 1 1 0.4";

			[JsonProperty(PropertyName = "XP Bar")]
			public string XPBar { get; set; } = "0.5 1 0.5 1";

			[JsonProperty(PropertyName = "Text")]
			public string Text { get; set; } = "1 1 1 0.4";
		}

		public class SFXConfig
		{
			[JsonProperty(PropertyName = "Item Crafted Normal")]
			public string ItemCraftedNormal { get; set; } = "assets/bundled/prefabs/fx/notice/loot.start.fx.prefab";

			[JsonProperty(PropertyName = "Item Crafted Rare")]
			public string ItemCraftedRare { get; set; } = "assets/prefabs/deployable/research table/effects/research-success.prefab";

			[JsonProperty(PropertyName = "Item Duplicated")]
			public string ItemDuplicated { get; set; } = "assets/bundled/prefabs/fx/item_unlock.prefab";

			[JsonProperty(PropertyName = "Skill Level Up")]
			public string SkillLevelUp { get; set; } = "assets/prefabs/locks/keypad/effects/lock.code.updated.prefab";
		}

		protected override void LoadConfig()
		{
			base.LoadConfig();
			var recommended = "It is recommended to backup your current configuration file and remove it to generate a fresh one.";
			var usingDefault = "Overriding configuration with default values to avoid errors.";

            try
            {
                config = Config.ReadObject<Configuration>();
				if (config == null) { throw new Exception(); }
				if (config.Version.Major <= 0)
                {
					config.Version = new VersionNumber(Version.Major, Version.Minor, Version.Patch);
				}
				else if (config.Version.Major > 0 && config.Version.Major != Version.Major || config.Version.Minor != Version.Minor) throw new NotSupportedException();
				SaveConfig();
			}
            catch (NotSupportedException)
            {
				PrintError($"Your configuration file is out of date. Your configuration file is for v{config.Version.Major}.{config.Version.Minor}.{config.Version.Patch} but the plugin is on v{Version.Major}.{Version.Minor}.{Version.Patch}. {recommended}");
				PrintWarning(usingDefault);
				LoadDefaultConfig();
			}
			catch(Exception)
            {
				PrintError($"Your configuration file contains an error. {recommended}");
				PrintWarning(usingDefault);
				LoadDefaultConfig();
			}
			//PrintError($"DEFAULT CONFIG LOADED REMOVE!!!!");
			//LoadDefaultConfig(); // TODO Comment this out
		}

		protected override void SaveConfig() => Config.WriteObject(config);

		protected override void LoadDefaultConfig() => config = new Configuration();

	}
}

namespace Oxide.Plugins
{
    partial class QualityCrafting : CovalencePlugin
    {
        object OnItemAction(Item bp, string action, BasePlayer basePlayer)
        {
            if (basePlayer != null && bp != null && bp.IsBlueprint() && action == "study" && basePlayer.blueprints != null && config.Settings.BlueprintXPGain && basePlayer.blueprints.HasUnlocked(bp.blueprintTargetDef))
            {
                bp.UseItem(1);
                var item = ItemManager.Create(bp.blueprintTargetDef);
                var category = SkillCategory.GetByItemDefinition(item.info);
                var skills = CraftingManager.GetSkills(basePlayer);
                int oldItemLevel = skills.GetLevel(item);
                int catLevel = skills.GetLevel(category);
                float catXp = skills.GetLevelPercent(category);
                float oldItemXp = skills.GetLevelPercent(item);
                uint xp = QualityItemManager.GetItemXpRate(item);
                skills = skills.GrantXP(item, xp);
                int newItemLevel = skills.GetLevel(item);
                float newItemXp = skills.GetLevelPercent(item);
                NotificationManager.AddNotifications(basePlayer, new GainedXPNotification
                {
                    Icon = item.info.shortname,
                    SkillDisplayName = item.info.displayName.translated,
                    OldLevel = oldItemLevel,
                    NewLevel = newItemLevel,
                    OldXP = oldItemXp,
                    NewXP = newItemXp,
                    IsLevelUp = newItemLevel > oldItemLevel,
                    XPGained = xp
                });
            }
            return null;
        }

        object OnItemCraft(ItemCraftTask task, BasePlayer basePlayer, Item item)
        {
            if (task != null && task.blueprint != null && task.blueprint.targetItem != null && basePlayer != null)
            {
                var category = SkillCategory.GetByItemDefinition(task.blueprint.targetItem);
                if (category != null)
                {
                    var skills = CraftingManager.GetSkills(basePlayer);
                    if (skills != null)
                    {
                        var baseSpeed = category.GetBaseCraftingSpeed();
                        task.blueprint = UnityEngine.Object.Instantiate(task.blueprint);
                        var speed = skills.GetCraftingSpeedMultiplier(category) * baseSpeed;
                        task.blueprint.time *= (1f / speed);
                    }
                }
            }
            return null;
        }

        void OnItemCraftFinished(ItemCraftTask task, Item item)
        {
            BasePlayer basePlayer = task.owner;
            if (basePlayer != null && item != null)
            {
                SkillCategory category = SkillCategory.GetByItem(item);
                if (category != null)
                {
                    var skills = CraftingManager.GetSkills(basePlayer);
                    var duplicate = skills.GetDuplicateChance(category) >= UnityEngine.Random.Range(0, 100);
                    int quality = CraftingManager.GetCraftedItemQuality(item, skills);
                    int oldCatLevel = skills.GetLevel(category);
                    int oldItemLevel = skills.GetLevel(item);
                    float oldCatXp = skills.GetLevelPercent(category);
                    float oldItemXp = skills.GetLevelPercent(item);
                    var itemXpRate = QualityItemManager.GetItemXpRate(item);
                    var dupeRate = duplicate ? 2f : 1f;
                    var xpMult = category.GetXpMultiplier();
                    var itemXpGained = (uint) ((10 + (quality * 2)) * dupeRate * xpMult);
                    var catXpGained = (uint) (itemXpRate * dupeRate * xpMult);
                    skills = skills.GrantXP(category, catXpGained);
                    ShowTrackingHud(basePlayer);
                    skills = skills.GrantXP(item, itemXpGained);
                    int newCatLevel = skills.GetLevel(category);
                    int newItemLevel = skills.GetLevel(item);
                    float newCatXp = skills.GetLevelPercent(category);
                    float newItemXp = skills.GetLevelPercent(item);
                    QualityItemManager.SetItemQuality(item, quality, basePlayer);
                    QualityItemManager.ApplyQualityModifiers(item, quality);
                    string qualityColor = QualityItemManager.GetColorByQuality(quality);
                    bool isRare = QualityItemManager.IsRareQuality(quality, oldItemLevel);
                    if (duplicate)
                    {
                        var newItem = ItemManager.CreateByItemID(item.info.itemid);
                        QualityItemManager.SetItemQuality(newItem, quality, basePlayer);
                        QualityItemManager.ApplyQualityModifiers(newItem, quality);
                        basePlayer.GiveItem(newItem);
                    }
                    bool catLevelUp = newCatLevel > oldCatLevel;
                    bool itemLevelUp = newItemLevel > oldItemLevel;
                    NotificationManager.AddNotifications(basePlayer, new ItemCraftedNotification
                    {
                        IsItem = true,
                        Icon = item.info.shortname,
                        SkillDisplayName = item.info.displayName.translated,
                        OldCategoryLevel = oldCatLevel,
                        NewCategoryLevel = newCatLevel,
                        OldItemLevel = oldItemLevel,
                        NewItemLevel = newItemLevel,
                        OldCategoryXP = oldCatXp,
                        NewCategoryXP = newCatXp,
                        OldItemXP = oldItemXp,
                        NewItemXP = newItemXp,
                        IsCategoryLevelup = catLevelUp,
                        IsItemLevelup = itemLevelUp,
                        CategoryXPGained = catXpGained,
                        ItemXPGained = itemXpGained,
                        Quality = quality,
                        Category = category.Name,
                        IsRare = isRare,
                        IsDuplicated = duplicate
                    });
                }
            }
        }
    }
}

namespace Oxide.Plugins
{
    partial class QualityCrafting : CovalencePlugin
    {
        [Command("qc.help")]
        private void Cmdhelp(IPlayer player, string command, string[] args)
        {
            var check = new SecurityCheck(args);
            if (!check.Success) { return; } else { args = check.Args; }
            var basePlayer = player.Object as BasePlayer;
            bool autoHide = bool.Parse(args[0]);
            ShowHelpMenu(basePlayer, autoHide, 0);
        }

        [Command("qc.help.tab")]
        private void CmdHelpTab(IPlayer player, string command, string[] args)
        {
            var check = new SecurityCheck(args);
            if (!check.Success) { return; } else { args = check.Args; }
            if (args.Length != 2)
            {
                return;
            }
            var basePlayer = player.Object as BasePlayer;
            bool autoHide = bool.Parse(args[0]);
            var index = int.Parse(args[1]);
            ShowHelpMenu(basePlayer, autoHide, index);
        }


        private void DestroyHelpMenu(BasePlayer basePlayer)
        {
            CuiHelper.DestroyUi(basePlayer, HELP_MENU_OVERLAY);
            CuiHelper.DestroyUi(basePlayer, HELP_MENU);
        }

        private void ShowHelpMenu(BasePlayer basePlayer, bool autoHide = true, int index = 0)
        {
            var container = new CuiElementContainer();
            int width = 800;
            int height = 500;
            int padding = 10;
            int closeButtonSize = 15;
            // Overlay
            var overlay = new CuiElement
            {
                Parent = "Overlay",
                Name = HELP_MENU_OVERLAY,
                Components =
                {
                    new CuiButtonComponent
                    {
                        Command = $"qc.menu.close {Secret}",
                        Color = "0 0 0 0.9",
                        Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                }
            };
            if (!autoHide)
            {
                overlay.Components.Add(new CuiNeedsCursorComponent());
            }
            container.Add(overlay);
            // Base
            container.Add(new CuiElement
            {
                Parent = "Overlay",
                Name = HELP_MENU,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = config.Colors.MenuBackground,
                        Material = "assets/scenes/test/waterlevelterrain/watertexture.png",
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.5 0.5",
                        AnchorMax = "0.5 0.5",
                        OffsetMin = $"{-width/2} {-height/2}",
                        OffsetMax = $"{width/2} {height/2}"
                    }
                }
            });
            // Close Button
            #region CloseBtn
            container.Add(new CuiElement
            {
                Parent = HELP_MENU,
                Name = $"{HELP_MENU}.close",
                Components = {
                    new CuiButtonComponent
                    {
                        Command = $"qc.menu.close {Secret}",
                        Color = "0 0 0 1"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "1 1",
                        AnchorMax = "1 1",
                        OffsetMin = $"{-padding - closeButtonSize} {-padding - closeButtonSize}",
                        OffsetMax = $"{-padding} {-padding}"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Parent = $"{HELP_MENU}.close",
                Components = {
                    new CuiImageComponent
                    {
                        Png = ImageLibrary?.Call<string>("GetImage", $"qc.close"),
                        Color = config.Colors.Text
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1",
                        OffsetMin = $"{3} {3}",
                        OffsetMax = $"{-3} {-3}"
                    }
                }
            });
            #endregion

            #region Return Button
            container.Add(new CuiElement
            {
                Parent = HELP_MENU,
                Name = $"{HELP_MENU}.return",
                Components = {
                    new CuiButtonComponent
                    {
                        Command = $"qc.menu.show {Secret} {autoHide}",
                        Color = "0 0 0 1"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "1 1",
                        AnchorMax = "1 1",
                        OffsetMin = $"{-2*padding - 2*closeButtonSize} {-padding - closeButtonSize}",
                        OffsetMax = $"{-2*padding - closeButtonSize} {-padding}"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Parent = $"{HELP_MENU}.return",
                Components = {
                    new CuiImageComponent
                    {
                        Png = ImageLibrary?.Call<string>("GetImage", $"qc.button.skills"),
                        Color = config.Colors.Text
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1",
                        OffsetMin = $"{3} {3}",
                        OffsetMax = $"{-3} {-3}"
                    }
                }
            });
            #endregion

            // Title
            container.Add(new CuiElement
            {
                Parent = HELP_MENU,
                Components = {
                    new CuiTextComponent
                    {
                        Text = Lang("plugin help", basePlayer),
                        Align = UnityEngine.TextAnchor.UpperCenter
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 1",
                        AnchorMax = "1 1",
                        OffsetMin = $"{padding+100} {-padding-100}",
                        OffsetMax = $"{-padding-100} {-padding}"
                    }
                }
            });
            // Toolbar
            var toolbarId = $"{HELP_MENU}.toolbar";
            var toolBarS = 25;
            var toolbarH = 20;
            var totalToolBarH = toolBarS + toolbarH;
            container.Add(new CuiElement
            {
                Parent = HELP_MENU,
                Name = toolbarId,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0",
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 1",
                        AnchorMax = "1 1",
                        OffsetMin = $"{padding} {-padding-totalToolBarH}",
                        OffsetMax = $"{-padding} {-padding-toolBarS}"
                    }
                }
            });
            // Tab 1 - Overview
            var tabW = 60;
            var tabP = 4;
            var tabLeft = 0;
            var tabColor = "0 0 0 0.6";
            var tabHighlightedColor = "0 0 0 0.2";
            var tabTextColor = "1 1 1 1";
            var tabTextSize = 10;
            var selected = index;
            #region Tab1
            var tab1Id = $"{toolbarId}.tab.1";
            container.Add(new CuiElement
            {
                Name = tab1Id,
                Parent = toolbarId,
                Components = {
                    new CuiButtonComponent
                    {
                        Command = $"qc.help.tab {Secret} {autoHide} 0",
                        Color = selected == 0 ? tabHighlightedColor : tabColor,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 1",
                        OffsetMin = $"{tabLeft} {0}",
                        OffsetMax = $"{tabLeft + tabW} {0}"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Parent = tab1Id,
                Components = {
                    new CuiTextComponent
                    {
                        Text = Lang("overview", basePlayer),
                        Align = UnityEngine.TextAnchor.MiddleCenter,
                        FontSize = tabTextSize,
                        Color = tabTextColor
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                }
            });
            tabLeft += tabW + tabP;
            #endregion

            // Tab 2 - Commands
            #region Tab2
            var tab2Id = $"{toolbarId}.tab.2";
            container.Add(new CuiElement
            {
                Name = tab2Id,
                Parent = toolbarId,
                Components = {
                    new CuiButtonComponent
                    {
                        Command = $"qc.help.tab {Secret} {autoHide} 1",
                        Color = selected == 1 ? tabHighlightedColor : tabColor,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 1",
                        OffsetMin = $"{tabLeft} {0}",
                        OffsetMax = $"{tabLeft + tabW} {0}"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Parent = tab2Id,
                Components = {
                    new CuiTextComponent
                    {
                        Text = Lang("commands", basePlayer),
                        Align = UnityEngine.TextAnchor.MiddleCenter,
                        FontSize = tabTextSize,
                        Color = tabTextColor
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                }
            });
            tabLeft += tabW + tabP;
            #endregion

            // Tab 3 - FAQ
            #region Tab2
            //var tab3Id = $"{toolbarId}.tab.3";
            //container.Add(new CuiElement
            //{
            //    Name = tab3Id,
            //    Parent = toolbarId,
            //    Components = {
            //        new CuiButtonComponent
            //        {
            //            Command = $"qc.help.tab {Secret} {autoHide} 2",
            //            Color = selected == 2 ? tabHighlightedColor : tabColor,
            //        },
            //        new CuiRectTransformComponent
            //        {
            //            AnchorMin = "0 0",
            //            AnchorMax = "0 1",
            //            OffsetMin = $"{tabLeft} {0}",
            //            OffsetMax = $"{tabLeft + tabW} {0}"
            //        }
            //    }
            //});
            //container.Add(new CuiElement
            //{
            //    Parent = tab3Id,
            //    Components = {
            //        new CuiTextComponent
            //        {
            //            Text = "FAQ",
            //            Align = UnityEngine.TextAnchor.MiddleCenter,
            //            FontSize = tabTextSize,
            //            Color = tabTextColor
            //        },
            //        new CuiRectTransformComponent
            //        {
            //            AnchorMin = "0 0",
            //            AnchorMax = "1 1"
            //        }
            //    }
            //});
            //tabLeft += tabW + tabP;
            #endregion

            // Tab 4 - Support
            #region Tab2
            var tab4Id = $"{toolbarId}.tab.4";
            container.Add(new CuiElement
            {
                Name = tab4Id,
                Parent = toolbarId,
                Components = {
                    new CuiButtonComponent
                    {
                        Command = $"qc.help.tab {Secret} {autoHide} 3",
                        Color = selected == 3 ? tabHighlightedColor : tabColor,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 1",
                        OffsetMin = $"{tabLeft} {0}",
                        OffsetMax = $"{tabLeft + tabW} {0}"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Parent = tab4Id,
                Components = {
                    new CuiTextComponent
                    {
                        Text = Lang("support", basePlayer),
                        Align = UnityEngine.TextAnchor.MiddleCenter,
                        FontSize = tabTextSize,
                        Color = tabTextColor
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                }
            });
            tabLeft += tabW + tabP;
            #endregion

            // Content
            var contentId = $"{HELP_MENU}.content";
            container.Add(new CuiElement
            {
                Parent = HELP_MENU,
                Name = contentId,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0.2",
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1",
                        OffsetMin = $"{padding} {padding}",
                        OffsetMax = $"{-padding} {-padding-totalToolBarH-padding}"
                    }
                }
            });

            if (index == 0)
            {
                container = CreateOverviewHelpTab(basePlayer, container, contentId, padding);
            }
            if (index == 1)
            {
                container = CreateCommandsHelpTab(basePlayer, container, contentId, padding);
            }
            if (index == 3)
            {
                container = CreateSupportTab(basePlayer, container, contentId, padding);
            }

            DestroyAllMenus(basePlayer);
            CuiHelper.AddUi(basePlayer, container);
            MenuToggled[basePlayer.UserIDString] = true;
        }

        private CuiElementContainer CreateOverviewHelpTab(BasePlayer basePlayer, CuiElementContainer container, string parent, int padding)
        {
            var halfPad = (padding / 2f);
            var panelColor = "0 0 0 0.6";
            var titleTextSize = 16;
            var titleTextColor = "1 1 1 1";
            var bodyTextSize = 14;
            var bodyTextColor = config.Colors.Text;

            // Left
            #region Left
            var leftId = $"{parent}.left";
            container.Add(new CuiElement
            {
                Parent = parent,
                Name = leftId,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = panelColor,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0.333 1",
                        OffsetMin = $"{0} {0}",
                        OffsetMax = $"{-halfPad} {0}"
                    }
                }
            });
            // Title
            container.Add(new CuiElement
            {
                Parent = leftId,
                Components = {
                    new CuiTextComponent
                    {
                        Text = Lang("level up skills", basePlayer),
                        Align = UnityEngine.TextAnchor.UpperCenter,
                        FontSize = titleTextSize,
                        Color = titleTextColor
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.8",
                        AnchorMax = "1 1",
                        OffsetMin = $"{0} {0}",
                        OffsetMax = $"{0} {-padding}"
                    }
                }
            });
            // Image
            var imgSize = 100;
            container.Add(new CuiElement
            {
                Parent = leftId,
                Components = {
                    new CuiImageComponent
                    {
                        Png = ImageLibrary?.Call<string>("GetImage", $"qc.button.skills"),
                        Color = "0 0.5 0.9 1"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.5 0.8",
                        AnchorMax = "0.5 0.8",
                        OffsetMin = $"{-imgSize/2} {-imgSize}",
                        OffsetMax = $"{imgSize/2} {0}"
                    }
                }
            });
            // Info Text
            container.Add(new CuiElement
            {
                Parent = leftId,
                Components = {
                    new CuiTextComponent
                    {
                        Text = Lang("craft items or study", basePlayer),
                        Align = UnityEngine.TextAnchor.UpperCenter,
                        FontSize = bodyTextSize,
                        Color = bodyTextColor
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 0.7",
                        OffsetMin = $"{padding} {padding}",
                        OffsetMax = $"{-padding} {-imgSize-padding}"
                    }
                }
            });
            #endregion

            // Middle
            #region Middle
            var middleId = $"{parent}.middle";
            container.Add(new CuiElement
            {
                Parent = parent,
                Name = middleId,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = panelColor,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.333 0",
                        AnchorMax = "0.667 1",
                        OffsetMin = $"{halfPad} {0}",
                        OffsetMax = $"{-halfPad} {0}"
                    }
                }
            });
            // Title
            container.Add(new CuiElement
            {
                Parent = middleId,
                Components = {
                    new CuiTextComponent
                    {
                        Text = Lang("craft quality items", basePlayer),
                        Align = UnityEngine.TextAnchor.UpperCenter,
                        FontSize = titleTextSize,
                        Color = titleTextColor
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.8",
                        AnchorMax = "1 1",
                        OffsetMin = $"{0} {0}",
                        OffsetMax = $"{0} {-padding}"
                    }
                }
            });
            // Image
            container.Add(new CuiElement
            {
                Parent = middleId,
                Components = {
                    new CuiImageComponent
                    {
                        Png = ImageLibrary?.Call<string>("GetImage", $"qc.button.quality"),
                        Color = "1 1 0 1"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.5 0.8",
                        AnchorMax = "0.5 0.8",
                        OffsetMin = $"{-imgSize/2} {-imgSize}",
                        OffsetMax = $"{imgSize/2} {0}"
                    }
                }
            });
            // Info Text
            container.Add(new CuiElement
            {
                Parent = middleId,
                Components = {
                    new CuiTextComponent
                    {
                        Text = Lang("advancing your item crafting level", basePlayer),
                        Align = UnityEngine.TextAnchor.UpperCenter,
                        FontSize = bodyTextSize,
                        Color = bodyTextColor
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 0.7",
                        OffsetMin = $"{padding} {padding}",
                        OffsetMax = $"{-padding} {-imgSize-padding}"
                    }
                }
            });
            #endregion

            // Right
            #region Right
            var rightId = $"{parent}.right";
            container.Add(new CuiElement
            {
                Parent = parent,
                Name = rightId,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = panelColor,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.667 0",
                        AnchorMax = "1 1",
                        OffsetMin = $"{halfPad} {0}",
                        OffsetMax = $"{0} {0}"
                    }
                }
            });
            // Title
            container.Add(new CuiElement
            {
                Parent = rightId,
                Components = {
                    new CuiTextComponent
                    {
                        Text = Lang("inspect your creations", basePlayer),
                        Align = UnityEngine.TextAnchor.UpperCenter,
                        FontSize = titleTextSize,
                        Color = titleTextColor
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.8",
                        AnchorMax = "1 1",
                        OffsetMin = $"{0} {0}",
                        OffsetMax = $"{0} {-padding}"
                    }
                }
            });
            // Image
            container.Add(new CuiElement
            {
                Parent = rightId,
                Components = {
                    new CuiImageComponent
                    {
                        Png = ImageLibrary?.Call<string>("GetImage", $"qc.button.inspect"),
                        Color = "0 0.9 0.5 1"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.5 0.8",
                        AnchorMax = "0.5 0.8",
                        OffsetMin = $"{-imgSize/2} {-imgSize}",
                        OffsetMax = $"{imgSize/2} {0}"
                    }
                }
            });
            // Info Text
            container.Add(new CuiElement
            {
                Parent = rightId,
                Components = {
                    new CuiTextComponent
                    {
                        Text = Lang("use the quality and inspect buttons", basePlayer),
                        Align = UnityEngine.TextAnchor.UpperCenter,
                        FontSize = bodyTextSize,
                        Color = bodyTextColor
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 0.7",
                        OffsetMin = $"{padding} {padding}",
                        OffsetMax = $"{-padding} {-imgSize-padding}"
                    }
                }
            });

            return container;
            #endregion
        }

        private CuiElementContainer CreateCommandsHelpTab(BasePlayer basePlayer, CuiElementContainer container, string parent, int padding)
        {
            var entryH = 25;
            var textColor = config.Colors.Text;
            var textSize = 10;
            var top = 0;
            var gap = 4;
            var i = 0;
            bool isAdmin = basePlayer.IsAdmin || permission.UserHasPermission(basePlayer.UserIDString, PermissionAdmin);
            int lists = isAdmin ? 2 : 1;
            for (int j = 0; j < lists; j++)
            {
                List<CommandInfo> commands;
                string titleText;
                if (j == 0)
                {
                    commands = Commands.Where(x => !x.AdminOnly).ToList();
                    titleText = Lang("general commands", basePlayer);
                }
                else
                {
                    top -= entryH;
                    commands = Commands.Where(x => x.AdminOnly).ToList();
                    titleText = Lang("admin commands", basePlayer);
                }
                container.Add(new CuiElement
                {
                    Parent = parent,
                    Components =
                        {
                            new CuiTextComponent
                            {
                                Text = titleText,
                                Color = textColor,
                                FontSize = 12
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 1",
                                AnchorMax = "1 1",
                                OffsetMin = $"{0} {top-entryH}",
                                OffsetMax = $"{0} {top}"
                            }
                        }
                });
                top -= entryH;
                foreach (var command in commands.OrderBy(x => x.Rank).ThenBy(x => x.Command))
                {
                    var entryId = $"/{parent}.command.{i}";
                    var color = textColor;
                    container.Add(new CuiElement
                    {
                        Parent = parent,
                        Name = entryId,
                        Components =
                        {
                            new CuiImageComponent
                            {
                                Color = "0 0 0 0.5",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.02 1",
                                AnchorMax = "1 1",
                                OffsetMin = $"{0} {top-entryH}",
                                OffsetMax = $"{0} {top}"
                            }
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = entryId,
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"/{PREFIX} {command.Command} {command.ArgString}",
                                Align = UnityEngine.TextAnchor.MiddleLeft,
                                FontSize = textSize,
                                Color = color
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 0",
                                AnchorMax = "1 1",
                                OffsetMin = $"{padding} {0}",
                                OffsetMax = $"{0} {0}"
                            }
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = entryId,
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"{command.Description}",
                                Align = UnityEngine.TextAnchor.MiddleLeft,
                                FontSize = textSize,
                                Color = textColor
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.5 0",
                                AnchorMax = "1 1",
                                OffsetMin = $"{0} {0}",
                                OffsetMax = $"{0} {0}"
                            }
                        }
                    });
                    top -= (entryH + gap);
                    i++;
                }
            }

            return container;
        }

        private CuiElementContainer CreateSupportTab(BasePlayer basePlayer, CuiElementContainer container, string parent, int padding)
        {
            var textColor = config.Colors.Text;
            var titleColor = "1 1 1 1";
            // Title
            container.Add(new CuiElement
            {
                Parent = parent,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = "Quality\nCrafting",
                        Color = titleColor,
                        Align = UnityEngine.TextAnchor.UpperCenter,
                        FontSize = 42
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 0.9"
                    }
                }
            });
            // Signature
            container.Add(new CuiElement
            {
                Parent = parent,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = "by mr01sam",
                        Color = textColor,
                        Align = UnityEngine.TextAnchor.UpperCenter,
                        FontSize = 12
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 0.65",
                    }
                }
            });

            // Plugin Page
            var pluginPageUrl = "umod.org/plugins/quality-crafting";
            container.Add(new CuiElement
            {
                Parent = parent,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = $"<size=18>{Lang("plugin page", basePlayer)}</size>\n{pluginPageUrl}",
                        Color = textColor,
                        Align = UnityEngine.TextAnchor.UpperCenter,
                        FontSize = 14
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 0.4",
                        OffsetMin = $"{0} {0}",
                        OffsetMax = $"{0} {0}"
                    }
                }
            });

            // Donate
            var donateUrl = "ko-fi.com/mr01sam";
            container.Add(new CuiElement
            {
                Parent = parent,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = $"<size=18>{Lang("donate", basePlayer)}</size>\n{donateUrl}",
                        Color = textColor,
                        Align = UnityEngine.TextAnchor.UpperCenter,
                        FontSize = 14
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 0.25",
                        OffsetMin = $"{0} {0}",
                        OffsetMax = $"{0} {0}"
                    }
                }
            });

            return container;
        }
    }
}

namespace Oxide.Plugins
{
    partial class QualityCrafting : CovalencePlugin
    {
        #region Data
        private enum OverlayType
        {
            Inspector,
            Quality
        }

        private Dictionary<string, bool> InspectorToggled = new Dictionary<string, bool>();

        private Dictionary<string, bool> QualityToggled = new Dictionary<string, bool>();

        private Dictionary<string, Vector3> PreviousMouseCoords = new Dictionary<string, Vector3>();

        private Dictionary<string, LootedEntity> PreviousLootedEntity = new Dictionary<string, LootedEntity>();

        public bool IsInspectorToggled(BasePlayer basePlayer)
        {
            bool value = false;
            InspectorToggled.TryGetValue(basePlayer.UserIDString, out value);
            return value;
        }

        public bool IsQualityToggled(BasePlayer basePlayer)
        {
            bool value = false;
            QualityToggled.TryGetValue(basePlayer.UserIDString, out value);
            return value;
        }
        #endregion

        #region Commands

        [Command("show.inspector")]
        private void CmdInspector(IPlayer player, string command, string[] args)
        {
            var check = new SecurityCheck(args);
            if (!check.Success) { return; } else { args = check.Args; }
            var basePlayer = player.Object as BasePlayer;
            if (basePlayer != null)
            {
                ShowInspectorButton(basePlayer);
            }
        }

        [Command("close.inspector")]
        private void CmdInspectorClose(IPlayer player, string command, string[] args)
        {
            var check = new SecurityCheck(args);
            if (!check.Success) { return; } else { args = check.Args; }
            var basePlayer = player.Object as BasePlayer;
            if (basePlayer != null)
            {
                DestroyInspectorButton(basePlayer);
            }
        }

        [Command("show.quality")]
        private void CmdQuality(IPlayer player, string command, string[] args)
        {
            var check = new SecurityCheck(args);
            if (!check.Success) { return; } else { args = check.Args; }
            var basePlayer = player.Object as BasePlayer;
            if (basePlayer != null)
            {
                ShowQualityButton(basePlayer);
            }
        }

        [Command("close.quality")]
        private void CmdQualityClose(IPlayer player, string command, string[] args)
        {
            var check = new SecurityCheck(args);
            if (!check.Success) { return; } else { args = check.Args; }
            var basePlayer = player.Object as BasePlayer;
            if (basePlayer != null)
            {
                DestroyQualityButton(basePlayer);
            }
        }

        [Command("qc.inspect.item")] // qc.inspect.item <entityId> <itemUid> 
        private void CmdInspectItem(IPlayer player, string command, string[] args)
        {
            var check = new SecurityCheck(args);
            if (!check.Success) { return; } else { args = check.Args; }
            var basePlayer = player.Object as BasePlayer;
            if (basePlayer != null)
            {
                ulong entityId = ulong.Parse(args[0]);
                BaseEntity entity = BaseNetworkable.serverEntities.Find(new NetworkableId(entityId)) as BaseEntity;
                if (entity != null)
                {
                    Item item = null;
                    var itemId = new ItemId(ulong.Parse(args[1]));
                    if (entity is PlayerCorpse)
                    {
                        var corpse = (PlayerCorpse)entity;
                        foreach (var cont in corpse.containers)
                        {
                            var found = cont.FindItemByUID(itemId);
                            if (found != null)
                            {
                                item = found;
                                break;
                            }
                        }
                    }
                    else if (entity is BasePlayer)
                    {
                        var bp = (BasePlayer)entity;
                        item = bp.inventory.FindItemUID(itemId);
                    }
                    else if (entity is DroppedItemContainer)
                    {
                        var dic = (DroppedItemContainer)entity;
                        item = dic.inventory.FindItemByUID(itemId);
                    }
                    else
                    {
                        var inventory = ((IItemContainerEntity)entity).inventory;
                        if (inventory != null)
                        {
                            item = inventory.FindItemByUID(itemId);
                        }
                    }
                    if (item != null)
                    {
                        ShowInfoOverlay(basePlayer, item);
                    }
                }
            }
        }

        [Command("qc.inspect.item.close")]
        private void CmdInspectItemClose(IPlayer player, string command, string[] args)
        {
            var check = new SecurityCheck(args);
            if (!check.Success) { return; } else { args = check.Args; }
            var basePlayer = player.Object as BasePlayer;
            if (basePlayer != null)
            {
                CuiHelper.DestroyUi(basePlayer, INFO_OVERLAY);
            }
        }

        [Command("qc.toggle.inspector")]
        private void CmdInspectInventory(IPlayer player, string command, string[] args)
        {
            var check = new SecurityCheck(args);
            if (!check.Success) { return; } else { args = check.Args; }
            var basePlayer = player.Object as BasePlayer;
            if (basePlayer != null)
            {
                ToggleInspectorOverlay(basePlayer);
            }
        }

        [Command("qc.toggle.quality")]
        private void CmdShowQuality(IPlayer player, string command, string[] args)
        {
            var check = new SecurityCheck(args);
            if (!check.Success) { return; } else { args = check.Args; }
            var basePlayer = player.Object as BasePlayer;
            if (basePlayer != null)
            {
                ToggleQualityOverlay(basePlayer);
            }
        }
        #endregion

        #region Button Control
        private string INSPECTOR_BUTTON = "qc.button.inspector";
        private string QUALITY_BUTTON = "qc.button.quality";

        private void ShowInspectorButton(BasePlayer basePlayer)
        {
            var id = INSPECTOR_BUTTON;
            var container = new CuiElementContainer();
            int startX = config.HUD.InspectButton.X;
            int startY = config.HUD.InspectButton.Y;
            int size = config.HUD.InspectButton.Size;
            container.Add(new CuiElement
            {
                Name = id,
                Parent = "Overlay",
                Components =
                {
                    new CuiImageComponent
                    {
                        Png = ImageLibrary?.Call<string>("GetImage", "qc.button.inspect"),
                        Color = IsInspectorToggled(basePlayer) ? config.Colors.HUDButtonToggled : config.Colors.HUDButtonUntoggled
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = AnchorDefault,
                        AnchorMax = AnchorDefault,
                        OffsetMin = Offset(startX-GlobalOffset, startY),
                        OffsetMax = Offset(startX+size-GlobalOffset, startY+size),
                    }
                }
            });
            container.Add(new CuiElement
            {
                Parent = id,
                Components = {
                    new CuiButtonComponent
                    {
                        Command = $"qc.toggle.inspector {Secret}",
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                }
            });
            DestroyInspectorButton(basePlayer);
            CuiHelper.AddUi(basePlayer, container);
        }

        private void DestroyInspectorButton(BasePlayer basePlayer)
        {
            CuiHelper.DestroyUi(basePlayer, INSPECTOR_BUTTON);
        }

        private void ShowQualityButton(BasePlayer basePlayer)
        {
            var id = QUALITY_BUTTON;
            var container = new CuiElementContainer();
            int startX = config.HUD.QualityButton.X;
            int startY = config.HUD.QualityButton.Y;
            int size = config.HUD.QualityButton.Size;
            container.Add(new CuiElement
            {
                Name = id,
                Parent = "Overlay",
                Components =
                {
                    new CuiImageComponent
                    {
                        Png = ImageLibrary?.Call<string>("GetImage", "qc.button.quality"),
                        Color = IsQualityToggled(basePlayer) ? config.Colors.HUDButtonToggled : config.Colors.HUDButtonUntoggled
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = AnchorDefault,
                        AnchorMax = AnchorDefault,
                        OffsetMin = Offset(startX-GlobalOffset, startY),
                        OffsetMax = Offset(startX+size-GlobalOffset, startY+size),
                    }
                }
            });
            container.Add(new CuiElement
            {
                Parent = id,
                Components = {
                    new CuiButtonComponent
                    {
                        Command = $"qc.toggle.quality {Secret}",
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                }
            });
            DestroyQualityButton(basePlayer);
            CuiHelper.AddUi(basePlayer, container);
        }

        private void DestroyQualityButton(BasePlayer basePlayer)
        {
            CuiHelper.DestroyUi(basePlayer, QUALITY_BUTTON);
        }

        private void DestroyAllButtons(BasePlayer basePlayer)
        {
            DestroyInspectorButton(basePlayer);
            DestroyQualityButton(basePlayer);
            DestroySkillsMenuButton(basePlayer);
        }

        private void ShowAllButtons(BasePlayer basePlayer)
        {
            ShowInspectorButton(basePlayer);
            ShowQualityButton(basePlayer);
            ShowSkillsMenuButton(basePlayer);
        }
        #endregion

        #region Overlay IDS
        readonly string QUALIY_ID = "quality";
        readonly string INSPECTOR_ID = "inspector";
        readonly string INVENTORY_OVERLAY = "qc.overlay.{0}.inventory";
        readonly string BELT_OVERLAY = "qc.overlay.{0}.belt";
        readonly string WEAR_OVERLAY = "qc.overlay.{0}.wear";
        readonly string STORAGE_OVERLAY = "qc.overlay.{0}.storage";
        readonly string LOCKER_OVERLAY = "qc.overlay.{0}.locker";
        readonly string SHOP_OVERLAY = "qc.overlay.{0}.shop";
        readonly string INFO_OVERLAY = "qc.overlay.info";
        readonly string MODIFIER_OVERLAY = "qc.overlay.modifier";
        readonly string SCREEN_OVERLAY = "qc.overlay.screen";
        readonly string SELECTED_OVERLAY = "qc.overlay.selected";
        readonly string NPC_OVERLAY_MAIN = "qc.overlay.{0}.npc.main";
        readonly string NPC_OVERLAY_WEAR = "qc.overlay.{0}.npc.wear";
        readonly string NPC_OVERLAY_BELT = "qc.overlay.{0}.npc.belt";
        #endregion

        #region General Overlays
        private void ShowOverlayByType(BasePlayer basePlayer, OverlayType overlayType, string id)
        {
            var container = new CuiElementContainer();
            if (overlayType == OverlayType.Quality)
            {
                container = CreateModifiersOverlay(container, basePlayer);
            }
            container = CreateInventoryOverlay(basePlayer.inventory.containerMain, container, string.Format(INVENTORY_OVERLAY, id), 4, 6, 60, 440, 86, overlayType);
            container = CreateInventoryOverlay(basePlayer.inventory.containerBelt, container, string.Format(BELT_OVERLAY, id), 1, 6, 60, 440, 18, overlayType);
            container = CreateInventoryOverlay(basePlayer.inventory.containerWear, container, string.Format(WEAR_OVERLAY, id), 1, 7, 50, 52, 115, overlayType);
            if (PreviousLootedEntity.ContainsKey(basePlayer.UserIDString))
            {
                var looted = PreviousLootedEntity[basePlayer.UserIDString];
                var entity = looted.Entity;
                if (entity is VendingMachine)
                {
                    var machine = (VendingMachine)entity;
                    if (looted.IsShopMenu)
                    {
                        container = CreateShopOverlay(machine, container, string.Format(SHOP_OVERLAY, id), overlayType);
                    }
                    else
                    {
                        container = CreateInventoryOverlay(machine.inventory, container, string.Format(STORAGE_OVERLAY, id), 5, 6, 58, 838, 110, overlayType);
                    }
                }
                else if (entity is Locker)
                {
                    var locker = (Locker)entity;
                    CreateLockerOverlay(locker, container, string.Format(LOCKER_OVERLAY, id), overlayType);
                }
                else if (entity is BoxStorage)
                {
                    var box = (BoxStorage)entity;
                    int rows = 1;
                    int cols = 6;
                    if (box.inventorySlots == 18) // small box
                    {
                        rows = 3;
                    }
                    else if (box.inventorySlots == 48) // large box
                    {
                        rows = 8;
                    }
                    container = CreateInventoryOverlay(box.inventory, container, string.Format(STORAGE_OVERLAY, id), rows, cols, 58, 838, 110, overlayType);
                }
                else if (entity is StashContainer)
                {
                    var stash = (StashContainer)entity;
                    int rows = 1;
                    int cols = 6;
                    container = CreateInventoryOverlay(stash.inventory, container, string.Format(STORAGE_OVERLAY, id), rows, cols, 58, 838, 110, overlayType);
                }
                else if (entity is DroppedItemContainer)
                {
                    var dropped = (DroppedItemContainer)entity;
                    container = CreateInventoryOverlay(dropped.inventory, container, string.Format(STORAGE_OVERLAY, id), 6, 6, 58, 838, 110, overlayType);
                }
                else if (entity is PlayerCorpse)
                {
                    var corpse = (PlayerCorpse)entity;
                    var netId = corpse.net.ID;
                    int i = 0;
                    foreach(var cont in corpse.containers)
                    {
                        if (i == 0)
                        {
                            CreateInventoryOverlay(cont, container, string.Format(NPC_OVERLAY_MAIN, id), 4, 6, 58, 838, 282, overlayType, netId: netId);
                        }
                        if (i == 1)
                        {
                            CreateInventoryOverlay(cont, container, string.Format(NPC_OVERLAY_WEAR, id), 1, 6, 48, 842, 201, overlayType, netId: netId);
                        }
                        if (i == 2)
                        {
                            CreateInventoryOverlay(cont, container, string.Format(NPC_OVERLAY_BELT, id), 1, 6, 58, 838, 110, overlayType, netId: netId);
                        }
                        i++;
                    }
                }
            }
            DestroyOverlayByType(basePlayer, overlayType);
            CuiHelper.AddUi(basePlayer, container);
        }
        private void DestroyOverlayByType(BasePlayer basePlayer, OverlayType overlayType)
        {
            if (overlayType == OverlayType.Inspector)
            {
                DestroyInspectorOverlays(basePlayer);
            }
            if (overlayType == OverlayType.Quality)
            {
                DestroyQualityOverlays(basePlayer);
            }
        }
        private void DestroyAllOverlays(BasePlayer basePlayer)
        {
            DestroyInspectorOverlays(basePlayer);
            DestroyQualityOverlays(basePlayer);
            CuiHelper.DestroyUi(basePlayer, MODIFIER_OVERLAY);
        }
        private void RefreshOverlays(BasePlayer basePlayer)
        {
            if (IsInspectorToggled(basePlayer))
            {
                ShowInspectorOverlay(basePlayer);
            }
            else
            {
                DestroyInspectorOverlays(basePlayer);
            }
            ShowInspectorButton(basePlayer);
            if (IsQualityToggled(basePlayer))
            {
                ShowQualityOverlay(basePlayer);
            }
            else
            {
                DestroyQualityOverlays(basePlayer);
            }
            ShowQualityButton(basePlayer);
        }

        #endregion

        #region Inspector Overlay
        private void ShowInspectorOverlay(BasePlayer basePlayer)
        {
            ShowOverlayByType(basePlayer, OverlayType.Inspector, INSPECTOR_ID);
            InspectorToggled[basePlayer.UserIDString] = true;
        }
        private void ToggleInspectorOverlay(BasePlayer basePlayer)
        {
            if (IsInspectorToggled(basePlayer))
            {
                DestroyInspectorOverlays(basePlayer);
            }
            else
            {
                ShowInspectorOverlay(basePlayer);
            }
            ShowInspectorButton(basePlayer);
        }
        private void DestroyInspectorOverlays(BasePlayer basePlayer)
        {
            if (basePlayer == null || basePlayer.UserIDString == null || InspectorToggled == null)
            {
                return;
            }
            CuiHelper.DestroyUi(basePlayer, string.Format(INVENTORY_OVERLAY, INSPECTOR_ID));
            CuiHelper.DestroyUi(basePlayer, string.Format(BELT_OVERLAY, INSPECTOR_ID));
            CuiHelper.DestroyUi(basePlayer, string.Format(WEAR_OVERLAY, INSPECTOR_ID));
            CuiHelper.DestroyUi(basePlayer, string.Format(STORAGE_OVERLAY, INSPECTOR_ID));
            CuiHelper.DestroyUi(basePlayer, string.Format(LOCKER_OVERLAY, INSPECTOR_ID));
            CuiHelper.DestroyUi(basePlayer, string.Format(SHOP_OVERLAY, INSPECTOR_ID));
            CuiHelper.DestroyUi(basePlayer, string.Format(NPC_OVERLAY_MAIN, INSPECTOR_ID));
            CuiHelper.DestroyUi(basePlayer, string.Format(NPC_OVERLAY_BELT, INSPECTOR_ID));
            CuiHelper.DestroyUi(basePlayer, string.Format(NPC_OVERLAY_WEAR, INSPECTOR_ID));
            CuiHelper.DestroyUi(basePlayer, INFO_OVERLAY);
            CuiHelper.DestroyUi(basePlayer, SCREEN_OVERLAY);
            InspectorToggled[basePlayer.UserIDString] = false;
        }

        #endregion

        #region Quality Overlay
        private void ShowQualityOverlay(BasePlayer basePlayer)
        {
            ShowOverlayByType(basePlayer, OverlayType.Quality, QUALIY_ID);
            QualityToggled[basePlayer.UserIDString] = true;
        }
        private void ToggleQualityOverlay(BasePlayer basePlayer)
        {
            if (IsQualityToggled(basePlayer))
            {
                DestroyQualityOverlays(basePlayer);
            }
            else
            {
                ShowQualityOverlay(basePlayer);
            }
            ShowQualityButton(basePlayer);
        }
        private void DestroyQualityOverlays(BasePlayer basePlayer)
        {
            CuiHelper.DestroyUi(basePlayer, string.Format(INVENTORY_OVERLAY, QUALIY_ID));
            CuiHelper.DestroyUi(basePlayer, string.Format(BELT_OVERLAY, QUALIY_ID));
            CuiHelper.DestroyUi(basePlayer, string.Format(WEAR_OVERLAY, QUALIY_ID));
            CuiHelper.DestroyUi(basePlayer, string.Format(STORAGE_OVERLAY, QUALIY_ID));
            CuiHelper.DestroyUi(basePlayer, string.Format(LOCKER_OVERLAY, QUALIY_ID));
            CuiHelper.DestroyUi(basePlayer, string.Format(SHOP_OVERLAY, QUALIY_ID));
            CuiHelper.DestroyUi(basePlayer, string.Format(NPC_OVERLAY_MAIN, QUALIY_ID));
            CuiHelper.DestroyUi(basePlayer, string.Format(NPC_OVERLAY_BELT, QUALIY_ID));
            CuiHelper.DestroyUi(basePlayer, string.Format(NPC_OVERLAY_WEAR, QUALIY_ID));
            CuiHelper.DestroyUi(basePlayer, MODIFIER_OVERLAY);
            QualityToggled[basePlayer.UserIDString] = false;
        }
        #endregion

        #region Selected Overlay
        private void ShowSelectedOverlay(BasePlayer basePlayer, Item item)
        {
            int startX = 440;
            int startY = 18;
            int size = 60;
            int gap = 4;
            CuiElementContainer container = new CuiElementContainer();
            for (int i = 0; i < basePlayer.inventory.containerBelt.capacity; i++)
            {
                if (basePlayer.inventory.containerBelt.GetSlot(i)?.uid == item?.uid)
                {
                    container.Add(new CuiElement
                    {
                        Name = SELECTED_OVERLAY,
                        Parent = "Hud.Menu",
                        Components =
                        {
                            new CuiRectTransformComponent
                            {
                                AnchorMin = AnchorDefault,
                                AnchorMax = AnchorDefault,
                                OffsetMin = $"{startX + (size * i) + (gap * i)-GlobalOffset} {startY}",
                                OffsetMax = $"{startX + (size * (i+1)) + (gap * i)-GlobalOffset} {startY + size}"
                            }
                        }
                    });
                    int quality = QualityItemManager.GetItemQuality(item);
                    if (quality > 0)
                    {
                        var imgSize = size / 3;
                        container.Add(new CuiElement
                        {
                            Parent = SELECTED_OVERLAY,
                            Components =
                        {
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "1 1",
                                AnchorMax = "1 1",
                                OffsetMin = $"{-imgSize} {-imgSize}",
                                OffsetMax = $"{0} {0}"
                            },
                            new CuiImageComponent
                            {
                                Png = ImageLibrary?.Call<string>("GetImage", $"qc.star.{quality}"),
                                Color = "1 1 0 0.9"
                            }
                        }
                        });
                    }
                }
            }
            DestroySelectedOverlay(basePlayer);
            CuiHelper.AddUi(basePlayer, container);
        }

        private void DestroySelectedOverlay(BasePlayer basePlayer)
        {
            CuiHelper.DestroyUi(basePlayer, SELECTED_OVERLAY);
        }
        #endregion

        #region Overlay Helpers

        private CuiElementContainer CreateOverlaySlot(ItemContainer inventory, Item item, CuiElementContainer container, string id, int i, int x, int y, int w, OverlayType overlayType, NetworkableId? netId = null)
        {
            NetworkableId entityId = netId ?? (inventory.playerOwner != null ? inventory.playerOwner.net.ID : inventory.entityOwner.net.ID);
            bool hasCategory = item != null && SkillCategory.GetByItem(item) != null;
            if (overlayType == OverlayType.Inspector)
            {
                if (hasCategory)
                {
                    int quality = QualityItemManager.GetItemQuality(item);
                    container.Add(new CuiElement
                    {
                        Name = $"{id}.Entry.{i}",
                        Parent = id,
                        Components =
                        {
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 1",
                                AnchorMax = "0 1",
                                OffsetMin = $"{x} {y}",
                                OffsetMax = $"{x+w} {y+w}"
                            },
                            new CuiButtonComponent
                            {
                                Command = $"qc.inspect.item {Secret} {entityId} {item.uid}",
                                Color = SetOpacity(QualityItemManager.GetColorByQuality(quality), 0.4f)
                            }
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = $"{id}.Entry.{i}",
                        Components =
                        {
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.31 0.1",
                                AnchorMax = "0.81 0.6",
                            },
                            new CuiImageComponent
                            {
                                Png = ImageLibrary?.Call<string>("GetImage", $"qc.inspect"),
                            }
                        }
                    });
                }
            }
            else if (overlayType == OverlayType.Quality)
            {
                if (hasCategory)
                {
                    int quality = QualityItemManager.GetItemQuality(item);
                    int imgSize = (w / 3);
                    if (quality > 0)
                    {
                        container.Add(new CuiElement
                        {
                            Name = $"{id}.Entry.{i}.Quality",
                            Parent = id,
                            Components =
                            {
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"{x+w-imgSize} {y+w-imgSize}",
                                    OffsetMax = $"{x+w} {y+w}"
                                },
                                new CuiImageComponent
                                {
                                    Png = ImageLibrary?.Call<string>("GetImage", $"qc.star.{quality}"),
                                    Color = "1 1 0 0.9"
                                }
                            }
                        }) ;
                    }
                }
            }
            return container;
        }

        private CuiElementContainer CreateInventoryOverlay(ItemContainer inventory, CuiElementContainer container, string id, int rows, int cols, int size, int startX, int startY, OverlayType overlayType, int index = 0, string layer = "Overlay", NetworkableId? netId = null)
        {
            if (inventory == null)
            {
                PrintError($"Inspector errored {id}");
                return container;
            }
            int gap = 4;
            int top = startY + (size * rows + gap * (rows-1));
            container.Add(new CuiElement
            {
                Name = id,
                Parent = layer,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "1 0 0 1"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = AnchorDefault,
                        AnchorMax = AnchorDefault,
                        OffsetMin = $"{startX-GlobalOffset} {top}",
                        OffsetMax = $"{startX-GlobalOffset} {top}"
                    }
                }
            });
            int w = size;
            int x = 0;
            int y = -w;
            int row = 0;
            int col = 0;
            for (int i = 0; i < rows * cols; i++)
            {
                var slot = inventory.GetSlot(i + index);
                Item item = null;
                if (slot != null)
                {
                    item = slot.FindItem(slot.uid);
                }
                container = CreateOverlaySlot(inventory, item, container, id, i, x, y, w, overlayType);
                col++;
                if (col >= cols)
                {
                    row++;
                    col = 0;
                    x = 0;
                    y -= gap + w;
                }
                else
                {
                    x += gap + w;
                }
            }
            return container;
        }

        private CuiElementContainer CreateLockerOverlay(Locker locker, CuiElementContainer container, string id, OverlayType overlayType)
        {
            int startX = 835;
            int endX = 1210;
            int startY = 136;
            int endY = 520;
            int size = 50;
            container.Add(new CuiElement
            {
                Name = id,
                Parent = "Overlay",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = AnchorDefault,
                        AnchorMax = AnchorDefault,
                        OffsetMin = $"{startX-GlobalOffset} {startY}",
                        OffsetMax = $"{endX-GlobalOffset} {endY}"
                    }
                }
            });
            int gap = 86;
            var y = -size;
            for (int k = 0; k < 3; k++)
            {
                var x = 0;
                var w = size;
                var g = 4;
                for (int i = 0; i < 13; i++)
                {
                    var idx = (k * 13) + i;
                    var item = locker.inventory.GetSlot(idx);
                    container = CreateOverlaySlot(locker.inventory, item, container, id, idx, x, y, w, overlayType);
                    x += size + g;
                    if (i == 6)
                    {
                        x = 0;
                        y -= size + g;
                    }
                }
                y -= gap;
            }
            return container;
        }

        private CuiElementContainer CreateShopOverlay(VendingMachine machine, CuiElementContainer container, string id, OverlayType overlayType)
        {
            int startX = 850;
            int startY = 114;
            int size = 60;
            int gap = 14;
            int count = machine.sellOrders.sellOrders.Count;
            container.Add(new CuiElement
            {
                Name = id,
                Parent = "Overlay",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "1 1 1 0.1"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = AnchorDefault,
                        AnchorMax = AnchorDefault,
                        OffsetMin = $"{startX-GlobalOffset} {startY}",
                        OffsetMax = $"{startX+size-GlobalOffset} {startY+(size*count)+(gap*(count-1))}"
                    }
                }
            });
            int i = 0;
            foreach(var so in machine.sellOrders.sellOrders)
            {
                var itemId = so.itemToSellID;
                var top = (size * count) + (gap * (count - 1));
                var item = machine.inventory.FindItemByItemID(itemId);
                container = CreateOverlaySlot(machine.inventory, item, container, id, i, 0, -size*(i+1)-gap*(i), size, overlayType);
                i++;
            }
            return container;
        }
        #endregion

        #region Other
        private void ShowInfoOverlay(BasePlayer basePlayer, Item item)
        {
            int w = 250;
            int h = 150;
            int padding = 5;
            var qualityItem = QualityItemManager.GetByItem(item);
            int quality = QualityItemManager.GetItemQuality(item);
            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = INFO_OVERLAY,
                Parent = "Overlay",
                Components =
                {
                    new CuiButtonComponent
                    {
                        Command = $"qc.inspect.item.close {Secret}",
                        Color = "0 0 0 0.9",
                        Sprite = "assets/content/materials/highlight.png",
                        Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                }
            });
            string titleId = $"{INFO_OVERLAY}.title";
            int titleG = 4;
            int titleH = 40;
            container.Add(new CuiElement
            {
                Name = titleId,
                Parent = INFO_OVERLAY,
                Components =
                {
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.5 0.5",
                        AnchorMax = "0.5 0.5",
                        OffsetMin = $"{-w/2} {h/2+titleG}",
                        OffsetMax = $"{w/2} {h/2+titleG+titleH}"
                    },
                    new CuiImageComponent
                    {
                        Color = config.Colors.MenuBackground,
                        Material = "assets/scenes/test/waterlevelterrain/watertexture.png",
                    }
                }
            });
            string titleContentId = $"{INFO_OVERLAY}.title.content";
            container.Add(new CuiElement
            {
                Name = titleContentId,
                Parent = titleId,
                Components =
                {
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1",
                        OffsetMin = $"{padding} {padding}",
                        OffsetMax = $"{-padding} {-padding}"
                    },
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0.5",
                        Material = "assets/scenes/test/waterlevelterrain/watertexture.png",
                    }
                }
            });
            container.Add(new CuiElement
            {
                Parent = titleContentId,
                Components =
                {
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1",
                        OffsetMin = $"{padding} {padding}",
                        OffsetMax = $"{-padding} {-padding}"
                    },
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        Text = Lang("item inspection", basePlayer),
                        Color = config.Colors.Text
                    }
                }
            });
            string baseId = $"{INFO_OVERLAY}.base";
            container.Add(new CuiElement
            {
                Name = baseId,
                Parent = INFO_OVERLAY,
                Components =
                {
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.5 0.5",
                        AnchorMax = "0.5 0.5",
                        OffsetMin = $"{-w/2} {-h/2}",
                        OffsetMax = $"{w/2} {h/2}"
                    },
                    new CuiImageComponent
                    {
                        Color = config.Colors.MenuBackground,
                    }
                }
            });
            string contentId = $"{INFO_OVERLAY}.content";
            container.Add(new CuiElement
            {
                Name = contentId,
                Parent = baseId,
                Components =
                {
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1",
                        OffsetMin = $"{padding} {padding}",
                        OffsetMax = $"{-padding} {-padding}"
                    },
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0.5",
                        Material = "assets/scenes/test/waterlevelterrain/watertexture.png",
                    }
                }
            });
            int starSize = 20;
            int starGap = 5;
            int totalStarWidth = (starSize * 4) + (starGap * 4);
            for (int j = 0; j < 5; j++)
            {
                var color = "0 0 0 0.8";
                if (j < quality)
                {
                    color = "1 1 0 0.8";
                }
                container.Add(new CuiElement
                {
                    Parent = contentId,
                    Components =
                    {
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "1 1",
                            AnchorMax = "1 1",
                            OffsetMin = $"{(-j*starSize-starSize-starGap)} {-padding-starSize}",
                            OffsetMax = $"{(-j*starSize-starGap)} {-padding}"
                        },
                        new CuiImageComponent
                        {
                            Png = ImageLibrary?.Call<string>("GetImage", "qc.star"),
                            Color = color
                        }
                    }
                });
            }
            int imgSize = 100;
            string imgBoxId = $"{contentId}.box";
            container.Add(new CuiElement
            {
                Parent = contentId,
                Name = imgBoxId,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "1 0",
                        AnchorMax = "1 0",
                        OffsetMin = $"{-padding-imgSize} {padding}",
                        OffsetMax = $"{-padding} {padding+imgSize}"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Parent = imgBoxId,
                Components =
                {
                    new CuiRawImageComponent
                    {
                        Png = ImageLibrary?.Call<string>("GetImage", item.info.shortname)
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1",
                        OffsetMin = $"{padding} {padding}",
                        OffsetMax = $"{-padding} {-padding}"
                    }
                }
            });
            int infoW = 180;
            int txtH = 18;
            int sigH = 12;
            container.Add(new CuiElement
            {
                Parent = contentId,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = item.info.displayName.translated,
                        Color = QualityItemManager.GetColorByQuality(quality)
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 1",
                        AnchorMax = "0 1",
                        OffsetMin = $"{padding} {-padding-txtH}",
                        OffsetMax = $"{padding+infoW} {-padding}"
                    }
                }
            });
            string infoBoxId = $"{contentId}.info";
            var created = qualityItem.HasCreator ? Lang("crafted by", basePlayer, qualityItem.CreatorDisplayName) : Lang("no creator", basePlayer);
            container.Add(new CuiElement
            {
                Parent = contentId,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = created,
                        Color = "1 1 1 0.1",
                        FontSize = 10
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 1",
                        AnchorMax = "0 1",
                        OffsetMin = $"{padding} {-padding-txtH-sigH}",
                        OffsetMax = $"{padding+infoW} {-padding-txtH}"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Parent = contentId,
                Name = infoBoxId,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 1",
                        OffsetMin = $"{padding} {padding}",
                        OffsetMax = $"{padding+infoW} {-padding-txtH-sigH-padding}"
                    }
                }
            });
            int fieldH = 20;
            int labelW = 60;
            int imgW = 0;
            int imgG = 2;
            int y = 0;
            var stats = QualityItemManager.GetItemStats(item);
            
            foreach (var stat in stats)
            {
                int value = (int)Math.Round((1f + stat.PercentModified) * 100);
                var statNameLower = stat.StatName.ToLower();
                var color = "1 1 1 1";
                if (value > 100)
                {
                    color = "0.5 1 0.5 1";
                }
                else if (value < 100)
                {
                    color = "1 0.5 0.5 1";
                }
                container.Add(new CuiElement
                {
                    Parent = infoBoxId,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"{Lang(statNameLower, basePlayer)}:",
                            Align = TextAnchor.MiddleLeft,
                            FontSize = 12,
                            Color = config.Colors.Text
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "1 1",
                            OffsetMin = $"{padding+imgW+imgG} {-padding-fieldH-y}",
                            OffsetMax = $"{-padding} {-padding-y}"
                        }
                    }
                });
                container.Add(new CuiElement
                {
                    Parent = infoBoxId,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"{value}%",
                            Align = TextAnchor.MiddleLeft,
                            FontSize = 12,
                            Color = color
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "1 1",
                            OffsetMin = $"{padding+labelW+imgW+imgG} {-padding-fieldH-y}",
                            OffsetMax = $"{-padding} {-padding-y}"
                        }
                    }
                });
                y += fieldH;
            }
            CuiHelper.DestroyUi(basePlayer, INFO_OVERLAY);
            CuiHelper.AddUi(basePlayer, container);
        }

        private void RemovedLootedEntity(BasePlayer basePlayer)
        {
            if (basePlayer != null)
            {
                PreviousLootedEntity.Remove(basePlayer.UserIDString);
                RefreshOverlays(basePlayer);
            }
        }

        private CuiElementContainer CreateModifiersOverlay(CuiElementContainer container, BasePlayer basePlayer)
        {
            var protection = basePlayer.baseProtection;
            int startX = 250;
            int startY = 226;
            int width = 100;
            int height = 405;
            int spacer = 169;
            string color = "0 1 0 0.8";
            container.Add(new CuiElement
            {
                Name = MODIFIER_OVERLAY,
                Parent = "Overlay",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "1 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 0",
                        OffsetMin = $"{startX} {startY}",
                        OffsetMax = $"{startX + width} {startY + height}"
                    }
                }
            });

            int y = 0;
            int h = 41;
            int i = 0;
            foreach (Rust.DamageType dt in new Rust.DamageType[] { Rust.DamageType.Bite, Rust.DamageType.RadiationExposure, Rust.DamageType.ColdExposure, Rust.DamageType.Explosion})
            {
                var baseValue = QualityItemManager.GetClothingStatResistance(basePlayer, dt, true);
                var modValue = QualityItemManager.GetClothingStatResistance(basePlayer, dt);
                var value = modValue - baseValue;
                if (value > 0)
                {
                    container.Add(new CuiElement
                    {
                        Name = $"{MODIFIER_OVERLAY}.{i}",
                        Parent = MODIFIER_OVERLAY,
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Color = color,
                                Text = $"+{(int)Math.Round(value*100)}%",
                                FontSize = 12,
                                Align = TextAnchor.LowerRight

                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 0",
                                AnchorMax = "1 0",
                                OffsetMin = $"{0} {y}",
                                OffsetMax = $"{0} {y+h}"
                            }
                        }
                    });
                    i++;
                }
                y += h;
            }
            y += spacer;
            foreach (Rust.DamageType dt in new Rust.DamageType[] { Rust.DamageType.Slash, Rust.DamageType.Bullet })
            {
                var baseValue = QualityItemManager.GetClothingStatResistance(basePlayer, dt, true);
                var modValue = QualityItemManager.GetClothingStatResistance(basePlayer, dt);
                var value = modValue - baseValue;
                if (value > 0)
                {
                    container.Add(new CuiElement
                    {
                        Name = $"{MODIFIER_OVERLAY}.{i}",
                        Parent = MODIFIER_OVERLAY,
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Color = color,
                                Text = $"+{(int)Math.Round(value*100)}%",
                                FontSize = 12,
                                Align = TextAnchor.LowerRight

                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 0",
                                AnchorMax = "1 0",
                                OffsetMin = $"{0} {y}",
                                OffsetMax = $"{0} {y+h}"
                            }
                        }
                    });
                    i++;
                }
                y += h;
            }
            return container;
        }

        private class LootedEntity
        {
            public BaseEntity Entity;
            public bool IsShopMenu = false;
        }
        #endregion

        #region Hooks
        void OnPlayerInput(BasePlayer basePlayer, InputState input)
        {
            if (input == null || basePlayer.IsDead() || basePlayer.IsSleeping()) return;
            if (!IsInspectorToggled(basePlayer) && !IsQualityToggled(basePlayer) && !IsMenuToggled(basePlayer))
            {
                PreviousMouseCoords[basePlayer.UserIDString] = input.MouseDelta();
            }
            else
            {
                if (input.MouseDelta() != PreviousMouseCoords[basePlayer.UserIDString])
                {
                    DestroyAllMenus(basePlayer);
                    DestroyAllOverlays(basePlayer);
                    ShowQualityButton(basePlayer);
                    ShowInspectorButton(basePlayer);
                }
            }
        }

        void OnActiveItemChanged(BasePlayer basePlayer, Item oldItem, Item newItem)
        {
            if (newItem == null)
            {
                DestroySelectedOverlay(basePlayer);
                return;
            }
            ShowSelectedOverlay(basePlayer, newItem);
            if (!QualityItemManager.IsQualityItem(newItem))
            {
                return;
            }
            var heldEntity = newItem.GetHeldEntity();
            if (heldEntity == null)
            {
                return;
            }
            QualityItemManager.AuditQualityItem(ref newItem, heldEntity);
        }

        void OnLootEntity(BasePlayer player, PlayerCorpse entity)
        {
            if (player != null && entity != null)
            {
                PreviousLootedEntity[player.UserIDString] = new LootedEntity { Entity = entity };
            }
        }

        void OnLootEntity(BasePlayer player, StashContainer entity)
        {
            if (player != null && entity != null)
            {
                PreviousLootedEntity[player.UserIDString] = new LootedEntity { Entity = entity };
            }
        }

        void OnLootEntity(BasePlayer player, Locker entity)
        {
            if (player != null && entity != null)
            {
                PreviousLootedEntity[player.UserIDString] = new LootedEntity { Entity = entity };
            }
        }

        void OnLootEntity(BasePlayer player, BoxStorage entity)
        {
            if (player != null && entity != null)
            {
                PreviousLootedEntity[player.UserIDString] = new LootedEntity { Entity = entity };
            }
        }

        void OnLootEntity(BasePlayer player, DroppedItemContainer entity)
        {
            if (player != null && entity != null)
            {
                PreviousLootedEntity[player.UserIDString] = new LootedEntity { Entity = entity };
            }
        }

        void OnVendingShopOpened(VendingMachine machine, BasePlayer player)
        {
            if (player != null && machine != null)
            {
                PreviousLootedEntity[player.UserIDString] = new LootedEntity { Entity = machine, IsShopMenu = true };
            }
        }

        void OnLootEntity(BasePlayer player, VendingMachine machine)
        {
            if (player != null && machine != null)
            {
                PreviousLootedEntity[player.UserIDString] = new LootedEntity { Entity = machine }; ;
            }
        }

        void OnLootEntityEnd(BasePlayer player, PlayerCorpse entity)
        {
            RemovedLootedEntity(player);
        }

        void OnLootEntityEnd(BasePlayer player, StashContainer entity)
        {
            RemovedLootedEntity(player);
        }

        void OnLootEntityEnd(BasePlayer player, Locker entity)
        {
            RemovedLootedEntity(player);
        }

        void OnLootEntityEnd(BasePlayer player, BoxStorage entity)
        {
            RemovedLootedEntity(player);
        }

        void OnLootEntityEnd(BasePlayer player, VendingMachine entity)
        {
            RemovedLootedEntity(player);
        }

        void OnLootEntityEnd(BasePlayer player, DroppedItemContainer entity)
        {
            RemovedLootedEntity(player);
        }

        void OnLootNetworkUpdate(PlayerLoot loot)
        {
            try
            {
                if (loot != null)
                {
                    BasePlayer basePlayer = loot.baseEntity;
                    if (basePlayer != null)
                    {
                        RefreshOverlays(basePlayer);
                    }
                }
            }
            catch (Exception) { };
        }

        void OnInventoryNetworkUpdate(PlayerInventory inventory, ItemContainer container, ProtoBuf.UpdateItemContainer updateItemContainer, PlayerInventory.Type type, bool broadcast)
        {
            try
            {
                if (inventory != null && ServerInitialized)
                {
                    BasePlayer basePlayer = inventory.loot?.baseEntity;
                    if (basePlayer != null)
                    {
                        RefreshOverlays(basePlayer);
                    }
                }
            }
            catch (Exception) { };
        }
        #endregion

    }
}

namespace Oxide.Plugins
{
    partial class QualityCrafting : CovalencePlugin
    {
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["gunsmithing"] = "Gunsmithing",
                ["toolcrafting"] = "Toolcrafting",
                ["weaponsmithing"] = "Weaponsmithing",
                ["bowmaking"] = "Bowmaking",
                ["tailoring"] = "Tailoring",
                ["top crafters"] = "Top Crafters",
                ["craft speed"] = "Crafting Speed",
                ["total xp"] = "Total XP",
                ["xp"] = "XP",
                ["perks"] = "Perks",
                ["duplicate chance"] = "Duplicate Chance",
                ["no items have been crafted"] = "No items have been crafted in this category yet.",
                ["crafting skills"] = "Crafting Skills",
                ["item inspection"] = "Item Inspection",
                ["crafted by"] = "Crafted by {0}",
                ["no creator"] = "No Creator",
                ["damage"] = "Damage",
                ["durability"] = "Durability",
                ["gathering"] = "Gathering",
                ["protection"] = "Protection",
                ["gain item xp"] = "+{0} XP",
                ["gain item xp with bonus"] = "+{0} XP (+{1} Bonus)",
                ["quality chance"] = "Quality chances",
                ["player not found"] = "Player '{0}' does not exist.",
                ["command success"] = "Successfully executed command.",
                ["command error"] = "Error executing command",
                ["usage"] = "Usage: {0}",
                ["invalid value"] = "Invalid value '{0}'.",
                ["value not allowed"] = "Value '{0}' is not allowed. Allowed Values {1}.",
                ["level up skills"] = "Level Up Skills",
                ["craft items or study"] = "Craft items or study unlocked blueprints to gain XP points to advance your crafting level.\n\nYou can advance your category crafting level as well as your item crafting level for a specific item.",
                ["craft quality items"] = "Craft Quality Items",
                ["advancing your item crafting level"] = "Advancing your item crafting level will increase the chance of crafting a quality item.\n\nThere are five tiers of quality, each tier increases the base stats for that item.",
                ["inspect your creations"] = "Inspect Your Creations",
                ["use the quality and inspect buttons"] = "Use the quality and inspect buttons near the hotbar to reveal the quality level and stats of items in your inventory.\n\nQuality level is represented by a number of stars or a specific color.",
                ["overview"] = "Overview",
                ["commands"] = "Commands",
                ["support"] = "Support",
                ["crafted"] = "Crafted",
                ["max level"] = "Max Level",
                ["duplicated"] = "Duplicated!",
                ["plugin page"] = "Plugin Page",
                ["donate"] = "Donate",
                ["general commands"] = "General Commands",
                ["admin commands"] = "Admin Commands",
                ["plugin help"] = "Plugin Help",
                ["track"] = "Track",
                ["untrack"] = "Untrack",
                ["no permission"] = "You do not have permission to use that command.",
            }, this);
        }

        private string Lang(string key, string id, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        private string Lang(string key, BasePlayer basePlayer, params object[] args) => string.Format(lang.GetMessage(key, this, basePlayer?.UserIDString), args);
    }
}

namespace Oxide.Plugins
{
    partial class QualityCrafting : CovalencePlugin
    {
        [Command("show.menu")]
        private void CmdShowMenu(IPlayer player, string command, string[] args)
        {
            var check = new SecurityCheck(args);
            if (!check.Success) { return; } else { args = check.Args; }
            var basePlayer = player.Object as BasePlayer;
            ShowSkillsMenuButton(basePlayer);
        }

        [Command("close.menu")]
        private void CmdCloseMenu(IPlayer player, string command, string[] args)
        {
            var check = new SecurityCheck(args);
            if (!check.Success) { return; } else { args = check.Args; }
            var basePlayer = player.Object as BasePlayer;
            DestroySkillsMenuButton(basePlayer);
        }

        [Command("qc.menu.show")]
        private void CmdMenuShow(IPlayer player, string command, string[] args)
        {
            var check = new SecurityCheck(args);
            if (!check.Success) { return; } else { args = check.Args; }
            var basePlayer = player.Object as BasePlayer;
            var autoHide = bool.Parse(args[0]);
            ShowSkillsMenu(basePlayer, autoHide);
        }

        [Command("qc.menu.close")]
        private void CmdMenuClose(IPlayer player, string command, string[] args)
        {
            var check = new SecurityCheck(args);
            if (!check.Success) { return; } else { args = check.Args; }
            var basePlayer = player.Object as BasePlayer;
            DestroyAllMenus(basePlayer);
        }

        [Command("qc.menu.category")]
        private void CmdMenuCategory(IPlayer player, string command, string[] args)
        {
            var check = new SecurityCheck(args);
            if (!check.Success) { return; } else { args = check.Args; }
            var basePlayer = player.Object as BasePlayer;
            int id = int.Parse(args[0]);
            int page = Math.Max(0, int.Parse(args[1]));
            var category = SkillCategory.GetByID(id);
            if (category != null)
            {
                ShowCategoryPage(basePlayer, category, page);
            }
        }

        [Command("qc.track")]
        private void CmdTrack(IPlayer player, string command, string[] args)
        {
            var check = new SecurityCheck(args);
            if (!check.Success) { return; } else { args = check.Args; }
            var basePlayer = player.Object as BasePlayer;
            int id = int.Parse(args[0]);
            int page = Math.Max(0, int.Parse(args[1]));
            var category = SkillCategory.GetByID(id);
            if (category != null)
            {
                TrackingManager.Track(basePlayer, category);
                ShowCategoryPage(basePlayer, category, page);
                ShowTrackingHud(basePlayer);
            }
        }

        [Command("qc.untrack")]
        private void CmdUntrack(IPlayer player, string command, string[] args)
        {
            var check = new SecurityCheck(args);
            if (!check.Success) { return; } else { args = check.Args; }
            var basePlayer = player.Object as BasePlayer;
            int id = int.Parse(args[0]);
            int page = Math.Max(0, int.Parse(args[1]));
            var category = SkillCategory.GetByID(id);
            if (category != null)
            {
                TrackingManager.Untrack(basePlayer);
                ShowCategoryPage(basePlayer, category, page);
                DestroyTrackingHud(basePlayer);
            }
        }

        private Dictionary<string, bool> MenuToggled = new Dictionary<string, bool>();

        private string SKILLS_MENU_OVERLAY = "qc.menuoverlay";
        private string SKILLS_MENU = "qc.menu";
        private string SKILLS_MENU_BUTTON = "qc.menu.button";
        private string SKILLS_MENU_CONTENT = "qc.menu.content";
        private string SKILLS_MENU_CATEGORY = "qc.menu.category";
        private string HELP_MENU_OVERLAY = "qc.helpoverlay";
        private string HELP_MENU = "qc.help";

        private bool IsMenuToggled(BasePlayer basePlayer)
        {
            bool value = false;
            MenuToggled.TryGetValue(basePlayer.UserIDString, out value);
            return value;
        }

        private void DestroySkillsMenuButton(BasePlayer basePlayer)
        {
            CuiHelper.DestroyUi(basePlayer, SKILLS_MENU_BUTTON);
        }

        private void ShowSkillsMenuButton(BasePlayer basePlayer)
        {
            var container = new CuiElementContainer();
            int startX = config.HUD.SkillsButton.X;
            int startY = config.HUD.SkillsButton.Y;
            int size = config.HUD.SkillsButton.Size;
            container.Add(new CuiElement
            {
                Name = SKILLS_MENU_BUTTON,
                Parent = "Overlay",
                Components =
                {
                    new CuiImageComponent
                    {
                        Png = ImageLibrary?.Call<string>("GetImage", "qc.button.skills"),
                        Color = config.Colors.HUDButtonUntoggled
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = AnchorDefault,
                        AnchorMax = AnchorDefault,
                        OffsetMin = Offset(startX-GlobalOffset, startY),
                        OffsetMax = Offset(startX+size-GlobalOffset, startY+size)
                    }
                }
            });
            container.Add(new CuiElement
            {
                Parent = SKILLS_MENU_BUTTON,
                Components = {
                    new CuiButtonComponent
                    {
                        Command = $"qc.menu.show {Secret} {true}",
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                }
            });
            CuiHelper.DestroyUi(basePlayer, SKILLS_MENU_BUTTON);
            CuiHelper.AddUi(basePlayer, container);
        }

        private void DestroyAllMenus(BasePlayer basePlayer)
        {
            DestroySkillsMenu(basePlayer);
            DestroyHelpMenu(basePlayer);
            MenuToggled[basePlayer.UserIDString] = false;
        }

        private void DestroySkillsMenu(BasePlayer basePlayer)
        {
            CuiHelper.DestroyUi(basePlayer, SKILLS_MENU_OVERLAY);
            CuiHelper.DestroyUi(basePlayer, SKILLS_MENU);
        }

        private void ShowSkillsMenu(BasePlayer basePlayer, bool autoHide = true)
        {
            CuiElementContainer container = new CuiElementContainer();
            int width = 800;
            int height = 500;
            int padding = 10;
            int header = 30;
            int closeButtonSize = 15;
            var overlay = new CuiElement
            {
                Parent = "Overlay",
                Name = SKILLS_MENU_OVERLAY,
                Components =
                {
                    new CuiButtonComponent
                    {
                        Command = $"qc.menu.close {Secret}",
                        Color = "0 0 0 0.9",
                        Sprite = "assets/content/materials/highlight.png",
                        Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                }
            };
            if (!autoHide)
            {
                overlay.Components.Add(new CuiNeedsCursorComponent());
            }
            container.Add(overlay);
            container.Add(new CuiElement
            {
                Parent = "Overlay",
                Name = SKILLS_MENU,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = config.Colors.MenuBackground,
                        Material = "assets/scenes/test/waterlevelterrain/watertexture.png"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.5 0.5",
                        AnchorMax = "0.5 0.5",
                        OffsetMin = $"{-width/2} {-height/2}",
                        OffsetMax = $"{width/2} {height/2}"
                    }
                }
            });

            #region Close Btn
            container.Add(new CuiElement
            {
                Parent = SKILLS_MENU,
                Name = $"{SKILLS_MENU}.close",
                Components = {
                    new CuiButtonComponent
                    {
                        Command = $"qc.menu.close {Secret}",
                        Color = "0 0 0 1"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "1 1",
                        AnchorMax = "1 1",
                        OffsetMin = $"{-padding - closeButtonSize} {-padding - closeButtonSize}",
                        OffsetMax = $"{-padding} {-padding}"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Parent = $"{SKILLS_MENU}.close",
                Components = {
                    new CuiImageComponent
                    {
                        Png = ImageLibrary?.Call<string>("GetImage", $"qc.close"),
                        Color = config.Colors.Text
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1",
                        OffsetMin = $"{3} {3}",
                        OffsetMax = $"{-3} {-3}"
                    }
                }
            });
            #endregion

            #region Help Btn
            container.Add(new CuiElement
            {
                Parent = SKILLS_MENU,
                Name = $"{SKILLS_MENU}.help",
                Components = {
                    new CuiButtonComponent
                    {
                        Command = $"qc.help {Secret} {autoHide}",
                        Color = "0 0 0 1"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "1 1",
                        AnchorMax = "1 1",
                        OffsetMin = $"{-(2*padding) - (2*closeButtonSize)} {-padding - closeButtonSize}",
                        OffsetMax = $"{-(2*padding) - closeButtonSize} {-padding}"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Parent = $"{SKILLS_MENU}.help",
                Components = {
                    new CuiImageComponent
                    {
                        Png = ImageLibrary?.Call<string>("GetImage", $"qc.help"),
                        Color = config.Colors.Text
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1",
                        OffsetMin = $"{3} {3}",
                        OffsetMax = $"{-3} {-3}"
                    }
                }
            });
            #endregion

            container.Add(new CuiElement
            {
                Parent = SKILLS_MENU,
                Components = {
                    new CuiTextComponent
                    {
                        Text = Lang("crafting skills", basePlayer),
                        Align = UnityEngine.TextAnchor.UpperCenter
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 1",
                        AnchorMax = "1 1",
                        OffsetMin = $"{padding+100} {-padding-header}",
                        OffsetMax = $"{-padding-100} {-padding}"
                    }
                }
            });
            int sideNavWidth = 120;
            contentWidth = width - padding - padding - sideNavWidth;
            contentHeight = height - padding - padding - header - padding;
            container = CreateSkillsMenuSideNav(basePlayer, container, header, padding, sideNavWidth);
            container = CreateSkillsMenuContent(container, header, padding, sideNavWidth + padding, width);
            DestroyAllMenus(basePlayer);
            CuiHelper.AddUi(basePlayer, container);
            var category = SkillCategory.GetDefaultCategory();
            if (category != null)
            {
                ShowCategoryPage(basePlayer, category);
            }
            MenuToggled[basePlayer.UserIDString] = true;
        }

        private int contentWidth = 0;
        private int contentHeight = 0;

        private CuiElementContainer CreateSkillsMenuSideNav(BasePlayer basePlayer, CuiElementContainer container, int header, int padding, int width)
        {
            string id = $"{SKILLS_MENU}.sidenav";
            container.Add(new CuiElement
            {
                Parent = SKILLS_MENU,
                Name = id,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 1",
                        OffsetMin = $"{padding} {padding}",
                        OffsetMax = $"{padding + width} {-padding-header}"
                    }
                }
            });
            int gap = 4;
            int y = 0;
            int h = 20;
            int i = 0;
            foreach (var category in SkillCategory.ALL)
            {
                if (SkillCategory.IsCategoryEnabled(category))
                {
                    string entryId = $"{SKILLS_MENU}.entry.{category.ID}";
                    container.Add(new CuiElement
                    {
                        Parent = id,
                        Name = entryId,
                        Components =
                    {
                        new CuiButtonComponent
                        {
                            Color = "1 1 1 0.1",
                            Command = $"qc.menu.category {Secret} {category.ID} 0"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "1 1",
                            OffsetMin = $"{0} {y-20}",
                            OffsetMax = $"{0} {y}"
                        }
                    }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = entryId,
                        Components =
                    {
                        new CuiTextComponent
                        {
                            Text = category.DisplayName(basePlayer),
                            Align = UnityEngine.TextAnchor.MiddleRight,
                            FontSize = 11,
                            Color = config.Colors.Text
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1",
                            OffsetMin = $"{0} {0}",
                            OffsetMax = $"{-5} {0}"
                        }
                    }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = entryId,
                        Components =
                    {
                        new CuiImageComponent
                        {
                            Png = ImageLibrary?.Call<string>("GetImage", $"qc.category.{category.Name}")
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 1",
                            OffsetMin = $"{4} {4}",
                            OffsetMax = $"{h-4} {-4}"
                        }
                    }
                    });
                    i++;
                    y -= h + gap;
                }
            }
            return container;
        }

        private CuiElementContainer CreateSkillsMenuContent(CuiElementContainer container, int header, int padding, int left, int fullWidth)
        {
            string id = $"{SKILLS_MENU}.content";
            container.Add(new CuiElement
            {
                Parent = SKILLS_MENU,
                Name = id,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0.5",
                        Material = Styles.Material
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 1",
                        OffsetMin = $"{left + padding} {padding}",
                        OffsetMax = $"{fullWidth-padding} {-padding-header}"
                    }
                }
            });
            return container;
        }

        private void DestroyCategoryPage(BasePlayer basePlayer)
        {
            CuiHelper.DestroyUi(basePlayer, SKILLS_MENU_CATEGORY);
        }

        private void ShowCategoryPage(BasePlayer basePlayer, SkillCategory category, int page = 0)
        {
            var skills = CraftingManager.GetSkills(basePlayer);
            CuiElementContainer container = new CuiElementContainer();
            float width = 0.75f;
            container.Add(new CuiElement
            {
                Parent = SKILLS_MENU_CONTENT,
                Name = SKILLS_MENU_CATEGORY,
                Components =
                {
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = $"1 1"
                    }
                }
            });
            var itemIds = skills.GetCategoryItemIDs(category);
            int padding = 10;
            int i = 0;
            int c = 0;
            int r = 0;
            int rows = 3;
            int cols = 2;
            int x = padding;
            int y = -padding;
            int w = (int)Math.Floor(((contentWidth * width) - 2 * padding) / (cols)) - padding;
            int h = ((contentHeight - footerHeight - padding) / (rows)) - padding;
            int maxPage = (int)Math.Ceiling((float)itemIds.Count / (rows * cols));
            if (itemIds.Count == 0)
            {
                container.Add(new CuiElement
                {
                    Parent = SKILLS_MENU_CATEGORY,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = Lang("no items have been crafted", basePlayer),
                            FontSize = 22,
                            Color = "1 1 1 0.2",
                            Align = UnityEngine.TextAnchor.MiddleCenter
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1",
                            OffsetMin = $"{0} {footerHeight + padding}",
                            OffsetMax = $"{0} {0}"
                        }
                    }
                });
            }
            else
            {

                var items = itemIds.Select(z => ItemManager.CreateByItemID(z)).OrderByDescending(z => skills.GetXP(z)).ThenBy(z => z.info.displayName.translated).Skip(rows * cols * page).Take(rows * cols).ToList();
                foreach (var item in items)
                {
                    container = CreateSkillEntry(container, basePlayer, skills, item, i, x, y, w, h);
                    x += w + padding;
                    i++;
                    c++;
                    if (c >= cols)
                    {
                        c = 0;
                        r++;
                        x = padding;
                        y -= (h + padding);
                    }
                    if (r >= rows)
                    {
                        break;
                    }
                }
                CreateLeaderboardSide(container, basePlayer, category, width, padding);
            }
            CreateContentFooter(container, basePlayer, category, skills, padding, page, page >= maxPage-1);
            DestroyCategoryPage(basePlayer);
            CuiHelper.AddUi(basePlayer, container);
        }

        private CuiElementContainer CreateSkillEntry(CuiElementContainer container, BasePlayer basePlayer, PlayerSkillSheet skills, Item item, int i, int x, int y, int w, int h)
        {
            var entryId = $"{SKILLS_MENU_CATEGORY}.entry.{i}";
            //var item = ItemManager.CreateByItemID(itemId);
            var itemDef = item.info;
            int imgPadW = 5;
            int imgPadH = 15;
            int barPad = 5;
            int barH = 10;
            var level = skills.GetLevel(item);
            var maxLevel = level >= 100;
            if (itemDef != null)
            {
                container.Add(new CuiElement
                {
                    Parent = SKILLS_MENU_CATEGORY,
                    Name = entryId,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0.8"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = $"{x} {y-h}",
                            OffsetMax = $"{x+w} {y}"
                        }
                    }
                });
                container.Add(new CuiElement
                {
                    Parent = entryId,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Png = ImageLibrary?.Call<string>("GetImage", itemDef.shortname)
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{imgPadW} {imgPadH}",
                            OffsetMax = $"{imgPadW+(h)-24} {h-imgPadH}"
                        }
                    }
                });
                if (!maxLevel)
                {
                    var barId = $"{entryId}.bar";
                    container.Add(new CuiElement
                    {
                        Name = barId,
                        Parent = entryId,
                        Components =
                        {
                            new CuiImageComponent
                            {
                                Color = "0 0 0 1"
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "1 0",
                                AnchorMax = "1 0",
                                OffsetMin = $"{-barPad - (w + imgPadW - h)} {barPad}",
                                OffsetMax = $"{-barPad} {barH + barPad}"
                            }
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = barId,
                        Components =
                        {
                            new CuiImageComponent
                            {
                                Color = "0.5 1 0.5 1"
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 0",
                                AnchorMax = $"{skills.GetLevelPercent(item)} 1",
                                OffsetMin = "2 2",
                                OffsetMax = "-2 -2"
                            }
                        }
                    });
                }
                
                container.Add(new CuiElement
                {
                    Parent = entryId,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"{level}",
                            Align = UnityEngine.TextAnchor.LowerLeft,
                            Color = config.Colors.Text,
                            FontSize = 11
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "1 0",
                            AnchorMax = "1 0",
                            OffsetMin = $"{-barPad - (w + imgPadW - h) + 4} {barPad + 12}",
                            OffsetMax = $"{-barPad + 4} {barH + barPad + 36}"
                        }
                    }
                });
                container.Add(new CuiElement
                {
                    Parent = entryId,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"{itemDef.displayName.translated}",
                            Align = UnityEngine.TextAnchor.LowerLeft,
                            Color = config.Colors.Text,
                            FontSize = 11
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "1 0",
                            AnchorMax = "1 0",
                            OffsetMin = $"{-barPad - (w + imgPadW - h) + 4} {barPad + 26}",
                            OffsetMax = $"{-barPad + 4} {barH + barPad + 50}"
                        }
                    }
                });

                var chances = CraftingManager.GetQualityChances(level).Where(qc => qc.Percent > 0);
                int ch = 12;
                int cw = 40;
                int cp = 4;
                int top = -cp;
                int j = 0;
                foreach (var chance in chances)
                {
                    container.Add(new CuiElement
                    {
                        Parent = entryId,
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"L{chance.Quality}",
                                Align = UnityEngine.TextAnchor.UpperRight,
                                Color = config.Colors.Text,
                                FontSize = 8
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "1 1",
                                AnchorMax = "1 1",
                                OffsetMin = $"{-cw-cp-24} {top-ch-cp-2}",
                                OffsetMax = $"{-cp-24} {top-2}"
                            }
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = entryId,
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"{chance.Percent}%",
                                Align = UnityEngine.TextAnchor.UpperRight,
                                Color = QualityItemManager.GetColorByQuality(chance.Quality),
                                FontSize = 10
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "1 1",
                                AnchorMax = "1 1",
                                OffsetMin = $"{-cw-cp} {top-ch-cp}",
                                OffsetMax = $"{-cp} {top}"
                            }
                        }
                    });
                    top -= ch + cp;
                    j++;
                }


            }
            return container;
        }

        private int footerHeight = 70;

        private CuiElementContainer CreateLeaderboardSide(CuiElementContainer container, BasePlayer basePlayer, SkillCategory category, float width, int padding)
        {
            string id = $"{SKILLS_MENU_CATEGORY}.leaderboard";
            int titleH = 30;
            container.Add(new CuiElement
            {
                Parent = SKILLS_MENU_CATEGORY,
                Name = id,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = $"{width} 0",
                        AnchorMax = "1 1",
                        OffsetMin = $"{0} {padding + footerHeight + padding}",
                        OffsetMax = $"{-padding} {-padding}"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Parent = id, 
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = Lang("top crafters", basePlayer),
                        Align = UnityEngine.TextAnchor.UpperLeft,
                        Color = config.Colors.Text,
                        FontSize = 14
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = $"0 1",
                        AnchorMax = "1 1",
                        OffsetMin = $"{padding} {-titleH-padding}",
                        OffsetMax = $"{-padding} {-padding}"
                    }
                }
            });
            var listId = $"{id}.list";
            container.Add(new CuiElement
            {
                Parent = id,
                Name = listId,
                Components =
                {
                    new CuiRectTransformComponent
                    {
                        AnchorMin = $"0 0",
                        AnchorMax = "1 1",
                        OffsetMin = $"{padding} {0}",
                        OffsetMax = $"{-padding} {-titleH-padding}"
                    }
                }
            });
            int numPerPage = 10;
            int page = 0;
            var playerRankings = CraftingManager.GetTopPlayerSkills(category, 0, numPerPage).Where(x => !string.IsNullOrEmpty(x.UserDisplayName));
            //for (int n = playerRankings.Count; n < numPerPage; n++)
            //{
            //    playerRankings.Add(new LeaderboardRank { Level = 10, UserIdString = playerRankings[0].UserIdString });
            //}
            int rowIdx = 0;
            float rowH = 0.8f / numPerPage;
            float top = 1f;
            foreach(var ranking in playerRankings)
            {
                int rank = 1 + rowIdx + (numPerPage * page);
                var rowId = $"{listId}.{rowIdx}";
                var color = (basePlayer.UserIDString == ranking.UserIdString) ? "1 1 1 1" : config.Colors.Text;
                container.Add(new CuiElement
                {
                    Parent = listId,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"{rank}.",
                            Align = UnityEngine.TextAnchor.MiddleLeft,
                            Color = color,
                            FontSize = 12
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = $"0 {top-rowH}",
                            AnchorMax = $"1 {top}"
                        }
                    }
                });
                container.Add(new CuiElement
                {
                    Parent = listId,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"{ranking.UserDisplayName} (LVL {ranking.Level})",
                            Align = UnityEngine.TextAnchor.MiddleRight,
                            Color = color,
                            FontSize = 12
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = $"0 {top-rowH}",
                            AnchorMax = $"1 {top}"
                        }
                    }
                });
                top -= rowH;
                rowIdx++;
            }
            return container;
        }

        private CuiElementContainer CreateContentFooter(CuiElementContainer container, BasePlayer basePlayer, SkillCategory category, PlayerSkillSheet skills, int padding, int page, bool maxed)
        {
            string id = $"{SKILLS_MENU_CATEGORY}.footer";
            int h = footerHeight;
            int c = 10;
            var lvl = skills.GetLevel(category);
            bool IsMaxLevel = lvl >= 100;
            container.Add(new CuiElement
            {
                Parent = SKILLS_MENU_CATEGORY,
                Name = id,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0.8"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 0",
                        OffsetMin = $"{padding} {padding}",
                        OffsetMax = $"{-padding} {padding + h}"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Parent = id,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Png = ImageLibrary?.Call<string>("GetImage", $"qc.category.{category.Name}")
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{c} {c}",
                            OffsetMax = $"{h-c} {h-c}"
                        }
                    }
            });
            
            int barPad = padding;
            int barW = 200;
            int barH = 15;
            if (!IsMaxLevel)
            {
                var barId = $"{id}.bar";
                container.Add(new CuiElement
                {
                    Name = barId,
                    Parent = id,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 1"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{h-c+barPad} {c}",
                            OffsetMax = $"{h-c+barPad+barW} {c + barH}"
                        }
                    }
                });
                container.Add(new CuiElement
                {
                    Parent = barId,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = config.Colors.XPBar
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = $"{skills.GetLevelPercent(category)} 1",
                            OffsetMin = "2 2",
                            OffsetMax = "-2 -2"
                        }
                    }
                });
                var cumPrevLevelXp = lvl > 0 ? category.GetCategoryLevelXPReq(lvl) : 0;
                var cumCurrentXp = skills.GetXP(category);
                var cumNextLevelXp = category.GetCategoryLevelXPReq(lvl + 1);
                var relCurrentXp = cumCurrentXp - cumPrevLevelXp;
                var relNextLevelXp = cumNextLevelXp - cumPrevLevelXp;
                container.Add(new CuiElement
                {
                    Parent = id,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"{relCurrentXp}/{relNextLevelXp} {Lang("xp", basePlayer)}",
                            Align = UnityEngine.TextAnchor.LowerRight,
                            Color = config.Colors.Text,
                            FontSize = 10
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{h-c+barPad+3} {c+barH+3}",
                            OffsetMax = $"{h-c+barPad+barW} {c+barH+42}"
                        }
                    }
                });
            }
            container.Add(new CuiElement
            {
                Parent = id,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = $"{skills.GetLevel(category)}",
                        Align = UnityEngine.TextAnchor.LowerLeft,
                        Color = config.Colors.Text,
                        FontSize = 14
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 0",
                        OffsetMin = $"{h-c+barPad+3} {c+barH+1}",
                        OffsetMax = $"{h-c+barPad+barW+3} {c+barH+42}"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Parent = id,
                Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"{category.DisplayName(basePlayer)}",
                            Align = UnityEngine.TextAnchor.LowerLeft,
                            Color = config.Colors.Text,
                            FontSize = 14
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{h-c+barPad+2} {c+barH+18}",
                            OffsetMax = $"{h-c+barPad+barW+2} {c+barH+42}"
                        }
                    }
            });

            #region Stats
            var craftSpeed = skills.GetCraftingSpeedMultiplier(category);
            var left = h - c + barPad + barW + 60;
            var color = config.Colors.Text;
            int valueX = 80;
            int hmin = c + barH + 18;
            int hmax = c + barH + 42;
            int rowh = 15;
            int bottom = hmin - rowh;
            int leftV = 4;
            // Perks
            container.Add(new CuiElement
            {
                Parent = id,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = $"{Lang("perks", basePlayer)}:",
                        Align = UnityEngine.TextAnchor.LowerLeft,
                        Color = config.Colors.Text,
                        FontSize = 14
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 0",
                        OffsetMin = $"{left} {c+barH+18}",
                        OffsetMax = $"{left+200} {c+barH+42}"
                    }
                }
            });
            left += leftV;
            var statSize = 10;
            // Craft Speed
            container.Add(new CuiElement
            {
                Parent = id,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = $"{Lang("craft speed", basePlayer)}:",
                        Align = UnityEngine.TextAnchor.LowerLeft,
                        Color = config.Colors.Text,
                        FontSize = statSize
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 0",
                        OffsetMin = $"{left} {bottom}",
                        OffsetMax = $"{left + valueX} {bottom + rowh}"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Parent = id,
                Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"{ColorTextRGB($"{(int)Math.Round((craftSpeed) * 100)}%", color)}",
                            Align = UnityEngine.TextAnchor.LowerLeft,
                            Color = config.Colors.Text,
                            FontSize = statSize
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{left+valueX} {bottom}",
                            OffsetMax = $"{left+valueX+100} {bottom + rowh}"
                        }
                    }
            });
            // Duplicate Chance
            bottom -= rowh;
            container.Add(new CuiElement
            {
                Parent = id,
                Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"{Lang("duplicate chance", basePlayer)}:",
                            Align = UnityEngine.TextAnchor.LowerLeft,
                            Color = config.Colors.Text,
                            FontSize = statSize
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{left} {bottom}",
                            OffsetMax = $"{left + valueX} {bottom + rowh}"
                        }
                    }
            });
            container.Add(new CuiElement
            {
                Parent = id,
                Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"{skills.GetDuplicateChance(category)}%",
                            Align = UnityEngine.TextAnchor.LowerLeft,
                            Color = config.Colors.Text,
                            FontSize = statSize
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{left+valueX} {bottom}",
                            OffsetMax = $"{left+valueX+100} {bottom + rowh}"
                        }
                    }
            });
            #endregion

            #region Track Button
            var trackW = 50;
            var trackH = 20;
            bool isTracked = TrackingManager.IsTracking(basePlayer, category);
            container.Add(new CuiElement
            {
                Parent = id,
                Name = $"{id}.track",
                Components = {
                    new CuiButtonComponent
                    {
                        Command = isTracked ? $"qc.untrack {Secret} {category.ID} {page}" : $"qc.track {Secret} {category.ID} {page}",
                        Color = isTracked ? "1 0 0 1" : "0 0 0 1" 
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "1 1",
                        AnchorMax = "1 1",
                        OffsetMin = $"{-padding - trackW} {-padding - trackH}",
                        OffsetMax = $"{-padding} {-padding}"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Parent = $"{id}.track",
                Components = {
                    new CuiTextComponent
                    {
                        Text = isTracked ? Lang("untrack", basePlayer) : Lang("track", basePlayer),
                        FontSize = 12,
                        Align = UnityEngine.TextAnchor.MiddleCenter,
                        Color = config.Colors.Text,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1",
                        OffsetMin = $"{3} {3}",
                        OffsetMax = $"{-3} {-3}"
                    }
                }
            });
            #endregion

            int btnW = 35;
            int btnH = 20;
            int btnX = 10;
            int btnY = 6;
            var btnUpDownX = -123;
            var btnUpY = 40;
            if (page > 0)
            {
                container.Add(new CuiElement
                {
                    Parent = id,
                    Name = $"{id}.btn.up",
                    Components =
                    {
                        new CuiButtonComponent
                        {
                            Command = $"qc.menu.category {Secret} {category.ID} {page-1}",
                            Color = "0 0 0 1"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "1 1",
                            AnchorMax = "1 1",
                            OffsetMin = $"{btnUpDownX-btnW} {btnUpY}",
                            OffsetMax = $"{btnUpDownX} {btnUpY+btnH}"
                        }
                    }
                });
                container.Add(new CuiElement
                {
                    Parent = $"{id}.btn.up",
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Png = ImageLibrary?.Call<string>("GetImage", $"qc.up"),
                            Color = config.Colors.Text
                        },
                        new CuiRectTransformComponent
                        {
                            OffsetMin = $"{btnX} {btnY}",
                            OffsetMax = $"{-btnX} {-btnY}"
                        }
                    }
                });
            }
            var btnDownY = 10;
            if (!maxed)
            {
                container.Add(new CuiElement
                {
                    Parent = id,
                    Name = $"{id}.btn.down",
                    Components =
                    {
                        new CuiButtonComponent
                        {
                            Command = $"qc.menu.category {Secret} {category.ID} {page+1}",
                            Color = "0 0 0 1",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "1 1",
                            AnchorMax = "1 1",
                            OffsetMin = $"{btnUpDownX-btnW} {btnDownY}",
                            OffsetMax = $"{btnUpDownX} {btnDownY+btnH}"
                        }
                    }
                });
                container.Add(new CuiElement
                {
                    Parent = $"{id}.btn.down",
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Png = ImageLibrary?.Call<string>("GetImage", $"qc.down"),
                            Color = config.Colors.Text
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1",
                            OffsetMin = $"{btnX} {btnY}",
                            OffsetMax = $"{-btnX} {-btnY}"
                        }
                    }
                });
            }
            return container;
        }
    }
}

namespace Oxide.Plugins
{
    partial class QualityCrafting : CovalencePlugin
    {
		object OnEntityTakeDamage(BasePlayer entity, HitInfo info)
		{
			foreach (Item item in entity.inventory.containerWear.itemList)
			{
				/* Protection increase by 1.5 */
				/* Scale by 1.5 - 1 = 0.5 */
				float modifier = 1f + QualityItemManager.GetItemQuality(item) * config.Qualities.Modifiers.Protection;
				info.damageTypes.ScaleAll(1f / modifier);
			}
			return null;
		}
	}
}

namespace Oxide.Plugins
{
    partial class QualityCrafting : CovalencePlugin
    {

        #region UI
        private static readonly string NOTIFICATION_ID = $"qc.notification";

        public void CreateProgressBar(BasePlayer basePlayer, List<CuiElement> collection, string id, string parent, string anchorMin, string anchorMax, string offsetMin, string offsetMax, float fadeOut, float fadeIn, float delay, string bgColor, string barColor, int oldLevel, int newLevel, uint xpGained, float oldPercent, float newPercent, string textColor, int textSize, bool isLevelUp, string glowElementId, float progressDelay = 0.25f, bool showXpGained = true, uint xp1 = 0, uint xp2 = 0, bool showTitle = false, string title = "")
        {
            var tracked = new List<CuiElement>();
            bool maxLevel = oldLevel >= 100;
            var transparent = "0 0 0 0";
            // Black bar
            tracked.Add(new CuiElement
            {
                Name = id,
                Parent = parent,
                FadeOut = fadeOut,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = maxLevel ? transparent : bgColor,
                        FadeIn = fadeIn,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = anchorMin,
                        AnchorMax = anchorMax,
                        OffsetMin = offsetMin,
                        OffsetMax = offsetMax
                    }
                }
            });
            // Old Bar
            var oldBarId = $"{id}.oldbar";
            var oldBarElement = new CuiElement
            {
                Name = oldBarId,
                Parent = id,
                //FadeOut = fadeOut,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = maxLevel ? transparent : barColor,
                        FadeIn = fadeIn,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = $"{oldPercent} 1",
                        OffsetMin = $"0 0",
                        OffsetMax = $"0 {-1}"
                    }
                }
            };
            tracked.Add(oldBarElement);
            int offSet = 1;
            string levelTextId = $"{id}.level";
            // Level Text
            var levelTextElement = new CuiElement
            {
                Name = levelTextId,
                Parent = id,
                //FadeOut = fadeOut,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = $"{(showTitle ? $"{title}\n" : "")}{oldLevel}",
                        FontSize = textSize,
                        Color = textColor,
                        Align = UnityEngine.TextAnchor.LowerLeft,
                        FadeIn = delay,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 1",
                        AnchorMax = $"0 1",
                        OffsetMin = $"0 {offSet}",
                        OffsetMax = $"200 25"
                    }
                }
            };
            tracked.Add(levelTextElement);
            // XP Text
            tracked.Add(new CuiElement
            {
                Name = $"{id}.xp",
                Parent = id,
                FadeOut = fadeOut,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = showXpGained ? $"+{xpGained} {Lang("xp", basePlayer)}" : $"{xp1}/{xp2} {Lang("xp", basePlayer)}",
                        FontSize = textSize,
                        Color = maxLevel ? transparent : textColor,
                        Align = UnityEngine.TextAnchor.LowerRight,
                        FadeIn = delay,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "1 1",
                        AnchorMax = $"1 1",
                        OffsetMin = $"-200 {offSet}",
                        OffsetMax = $"0 25"
                    }
                }
            });

            // New Bar
            var newBarId = $"{id}.newbar";
            var newBarElement = new CuiElement
            {
                Name = newBarId,
                Parent = id,
                FadeOut = fadeOut,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0",
                        FadeIn = delay,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = $"{(isLevelUp ? 1f : newPercent)} 1",
                        OffsetMin = $"0 0",
                        OffsetMax = $"0 {-1}"
                    }
                }
            };
            tracked.Add(newBarElement);
            collection.AddRange(tracked);
            PLUGIN.timer.In(progressDelay, () =>
            {
                CuiElementContainer temp = new CuiElementContainer();
                ((CuiImageComponent)newBarElement.Components[0]).Color = barColor;
                temp.Add(newBarElement);
                CuiHelper.DestroyUi(basePlayer, newBarId);
                CuiHelper.AddUi(basePlayer, temp);
            });


            // LevelUp
            if (isLevelUp)
            {
                tracked = new List<CuiElement>();
                var glowId = $"{id}.glow";
                PLUGIN.timer.In(delay + progressDelay, () =>
                {
                    PLUGIN.PlaySfx(basePlayer, PLUGIN.config.SFX.SkillLevelUp);
                    tracked.Add(new CuiElement
                    {
                        Name = glowId,
                        Parent = glowElementId,
                        FadeOut = 0.5f,
                        Components =
                        {
                            new CuiImageComponent
                            {
                                Color = "1 1 1 0.7",
                                FadeIn = 0.05f
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 0",
                                AnchorMax = "1 1"
                            }
                        }
                    });
                    // Add Tracked
                    var container = new CuiElementContainer();
                    container.AddRange(tracked);
                    CuiHelper.AddUi(basePlayer, container);
                    // Start Glow Destroy Timer
                    PLUGIN.timer.In(0.2f, () =>
                    {
                        CuiHelper.DestroyUi(basePlayer, glowId);
                    });
                    // Update
                    container = new CuiElementContainer();
                    // Update Level Text
                    CuiHelper.DestroyUi(basePlayer, levelTextId);
                    ((CuiTextComponent)levelTextElement.Components[0]).Text = $"{(showTitle ? $"{title}\n" : "")}{newLevel}";
                    levelTextElement.FadeOut = fadeOut;
                    container.Add(levelTextElement);
                    // Update Old Bar
                    CuiHelper.DestroyUi(basePlayer, oldBarId);
                    ((CuiRectTransformComponent)oldBarElement.Components[1]).AnchorMax = $"{0} 1";
                    container.Add(oldBarElement);
                    // Update New Bar
                    CuiHelper.DestroyUi(basePlayer, newBarId);
                    CuiHelper.AddUi(basePlayer, container);
                    PLUGIN.timer.In(0.6f, () =>
                    {
                        container = new CuiElementContainer();
                        ((CuiRectTransformComponent)newBarElement.Components[1]).AnchorMax = $"{newPercent} 1";
                        container.Add(newBarElement);
                        CuiHelper.AddUi(basePlayer, container);
                    });
                });
            }
        }

        private void ShowXpGainedNotification(BasePlayer basePlayer, GainedXPNotification notification)
        {
            var id = NOTIFICATION_ID;
            var container = new CuiElementContainer();
            var backgroundColor = PLUGIN.config.Colors.MenuBackground;
            var fadeOut = 0.6f;
            var fadeIn = 0.1f;
            var pause = /*config.Notifications.Pause*/ 2.85f;
            int x = /*config.Notifications.LevelUpItemNotification.X*/ 530;
            int y = PLUGIN.config.Notifications.LevelUpItemNotification.Y;
            int w = 200;
            int h = 42;
            var icon = notification.Icon;
            var padding = Styles.NotificationPadding;
            var textColor = PLUGIN.config.Colors.Text;
            //var qualityColor = QualityItemManager.GetColorByQuality(notification.Quality);
            var imgBgColor = "0 0 0 0.8";
            var barColor = PLUGIN.config.Colors.XPBar;
            var progressDelay = fadeIn + 0.75f;
            var isCategory = icon.StartsWith("qc.category");
            List<CuiElement> tracked = new List<CuiElement>();
            // Base
            tracked.Add(new CuiElement
            {
                Name = id,
                Parent = "Hud",
                FadeOut = fadeOut,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = backgroundColor,
                        FadeIn = fadeIn,
                        Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 0",
                        OffsetMin = $"{x} {y}",
                        OffsetMax = $"{x+w} {y+h}"
                    }
                }
            });
            // Image Background
            var imgBgId = $"{id}.img.bg";
            tracked.Add(new CuiElement
            {
                Name = imgBgId,
                Parent = id,
                FadeOut = fadeOut,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = imgBgColor,
                        FadeIn = fadeIn,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 0",
                        OffsetMin = $"{padding} {padding}",
                        OffsetMax = $"{h-padding} {h-padding}"
                    }
                }
            });
            // Image
            var imgP = 4;
            var imgId = $"{id}.img";
            if (isCategory)
            {
                tracked.Add(new CuiElement
                {
                    Name = imgId,
                    Parent = imgBgId,
                    FadeOut = fadeOut,
                    Components =
                        {
                            new CuiImageComponent
                            {
                                Png = PLUGIN.ImageLibrary?.Call<string>("GetImage", icon),
                                FadeIn = fadeIn,
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 0",
                                AnchorMax = "1 1",
                                OffsetMin = $"{imgP} {imgP}",
                                OffsetMax = $"{-imgP} {-imgP}"
                            }
                        }
                });
            }
            else
            {
                tracked.Add(new CuiElement
                {
                    Name = imgId,
                    Parent = imgBgId,
                    FadeOut = fadeOut,
                    Components =
                        {
                            new CuiRawImageComponent
                            {
                                Png = PLUGIN.ImageLibrary?.Call<string>("GetImage", icon),
                                FadeIn = fadeIn,
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 0",
                                AnchorMax = "1 1",
                                OffsetMin = $"{1} {1}",
                                OffsetMax = $"{-1} {-1}"
                            }
                        }
                });
            }
            // XP Bar;
            var barH = 8;
            var xpImgH = h - imgP - imgP;
            var barTxtSize = 9;
            var xpBlackBar1Id = $"{id}.blackbar.1";
            CreateProgressBar(basePlayer, tracked, xpBlackBar1Id, id, "0 1", "1 1", $"{xpImgH + padding} {-xpImgH}", $"{-padding} {-xpImgH + barH}", fadeOut, fadeIn, progressDelay, imgBgColor, barColor, notification.OldLevel, notification.NewLevel, notification.XPGained, notification.OldXP, notification.NewXP, textColor, barTxtSize, notification.IsLevelUp, id, 0.25f, true, 0, 0, true, notification.SkillDisplayName);

            container.AddRange(tracked);
            CuiHelper.DestroyUi(basePlayer, id);
            CuiHelper.AddUi(basePlayer, container);
            PLUGIN.PlaySfx(basePlayer, PLUGIN.config.SFX.ItemCraftedNormal);
            PLUGIN.timer.In(pause, () =>
            {
                foreach (var item in tracked)
                {
                    CuiHelper.DestroyUi(basePlayer, item.Name);
                }
            });
        }


        private void ShowItemCraftedNotification(BasePlayer basePlayer, ItemCraftedNotification notification)
        {
            var id = NOTIFICATION_ID;
            var container = new CuiElementContainer();
            var backgroundColor = PLUGIN.config.Colors.MenuBackground;
            var fadeOut = Styles.FadeOut;
            var fadeIn = Styles.FadeIn;
            var pause = 2.85f;
            int x = PLUGIN.config.Notifications.ItemCraftedNotification.X;
            int y = PLUGIN.config.Notifications.ItemCraftedNotification.Y;
            int w = 300;
            int h = 70;
            var icon = notification.Icon;
            var padding = Styles.NotificationPadding;
            var textColor = PLUGIN.config.Colors.Text;
            var qualityColor = QualityItemManager.GetColorByQuality(notification.Quality);
            var imgBgColor = "0 0 0 0.8";
            var itemImgBgColor = imgBgColor;
            var barColor = PLUGIN.config.Colors.XPBar;
            var progressDelay = fadeIn + 0.75f;
            List<CuiElement> tracked = new List<CuiElement>();

            // Base
            tracked.Add(new CuiElement
            {
                Name = id,
                Parent = "Hud",
                FadeOut = fadeOut,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = backgroundColor,
                        FadeIn = fadeIn,
                        Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = AnchorDefault,
                        AnchorMax = AnchorDefault,
                        OffsetMin = $"{x-GlobalOffset} {y}",
                        OffsetMax = $"{x+w-GlobalOffset} {y+h}"
                    }
                }
            });
            // Image Background
            var imgBgId = $"{id}.img.bg";
            tracked.Add(new CuiElement
            {
                Name = imgBgId,
                Parent = id,
                FadeOut = fadeOut,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = itemImgBgColor,
                        FadeIn = fadeIn,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 0",
                        OffsetMin = $"{padding} {padding}",
                        OffsetMax = $"{h-padding} {h-padding}"
                    }
                }
            });
            // Image
            var imgP = 4;
            var imgId = $"{id}.img";
            tracked.Add(new CuiElement
            {
                Name = imgId,
                Parent = imgBgId,
                FadeOut = fadeOut,
                Components =
                {
                    new CuiRawImageComponent
                    {
                        Png = PLUGIN.ImageLibrary?.Call<string>("GetImage", icon),
                        FadeIn = fadeIn,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1",
                        OffsetMin = $"{imgP} {imgP}",
                        OffsetMax = $"{-imgP} {-imgP}"
                    }
                }
            });
            // Quality
            var imgSize = 2f / 5f;
            if (notification.Quality > 0)
            {
                tracked.Add(new CuiElement
                {
                    Name = $"{imgId}.quality",
                    Parent = imgId,
                    FadeOut = fadeOut,
                    Components =
                        {
                            new CuiImageComponent
                            {
                                Png = PLUGIN.ImageLibrary?.Call<string>("GetImage", $"qc.star.{notification.Quality}"),
                                FadeIn = fadeIn,
                                Color = "1 1 0 0.9"
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = $"{1f-imgSize} {1f-imgSize}",
                                AnchorMax = $"1 1"
                            }
                        }
                });
            }
            // Text
            var textLength = 100;
            var textSize = 12;
            tracked.Add(new CuiElement
            {
                Name = $"{id}.text.1",
                Parent = id,
                FadeOut = fadeOut,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = $"{Lang("crafted", basePlayer)}\n{(ColorTextRGB(notification.SkillDisplayName, qualityColor))}",
                        Align = UnityEngine.TextAnchor.UpperLeft,
                        Color = textColor,
                        FontSize = textSize,
                        FadeIn = fadeIn,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 0",
                        OffsetMin = $"{h} {padding}",
                        OffsetMax = $"{h+textLength} {h-padding}"
                    }
                }
            });
            // Duplicate Text
            if (notification.IsDuplicated)
            {
                var dupeId = $"{id}.dupe.text";
                tracked.Add(new CuiElement
                {
                    Name = $"{id}.dupe.text",
                    Parent = id,
                    FadeOut = fadeOut,
                    Components =
                {
                    new CuiTextComponent
                    {
                        Text = $"{Lang("duplicated", basePlayer)}",
                        Align = UnityEngine.TextAnchor.LowerLeft,
                        Color = "0.5 0.8 1 1",
                        FontSize = textSize,
                        FadeIn = fadeIn,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 0",
                        OffsetMin = $"{h} {padding}",
                        OffsetMax = $"{h+textLength} {h-padding}"
                    }
                }
                });
            }
            // Left
            var leftStart = 0.5f;
            var leftId = $"{id}.left";
            tracked.Add(new CuiElement
            {
                Name = leftId,
                Parent = id,
                FadeOut = fadeOut,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0",
                        FadeIn = fadeIn
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = $"{leftStart} 0",
                        AnchorMax = "1 1",
                        OffsetMin = $"{padding} {padding}",
                        OffsetMax = $"{-padding} {-padding}"
                    }
                }
            });
            // Top
            var topId = $"{leftId}.top";
            var topH = 20;
            tracked.Add(new CuiElement
            {
                Name = topId,
                Parent = leftId,
                FadeOut = fadeOut,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0",
                        FadeIn = fadeIn
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 1",
                        AnchorMax = "1 1",
                        OffsetMin = $"{0} {-topH}",
                        OffsetMax = $"{0} {0}"
                    }
                }
            });
            // XP Image BG 1;
            var xpImgH = topH;
            var xpImgP1 = 2;
            var xpImg1BgId = $"{id}.xpimg1.bg";
            tracked.Add(new CuiElement
            {
                Name = xpImg1BgId,
                Parent = topId,
                FadeOut = fadeOut,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = imgBgColor,
                        FadeIn = fadeIn,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 1",
                        AnchorMax = "0 1",
                        OffsetMin = $"{0} {-xpImgH}",
                        OffsetMax = $"{xpImgH} {0}"
                    }
                }
            });
            // XP Image 1;
            tracked.Add(new CuiElement
            {
                Name = $"{id}.xpimg1",
                Parent = xpImg1BgId,
                FadeOut = fadeOut,
                Components =
                {
                    new CuiRawImageComponent
                    {
                        Png = PLUGIN.ImageLibrary?.Call<string>("GetImage", icon),
                        FadeIn = fadeIn,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1",
                        OffsetMin = $"{xpImgP1} {xpImgP1}",
                        OffsetMax = $"{-xpImgP1} {-xpImgP1}"
                    }
                }
            });
            // XP Black Bar 1;
            var barH = 8;
            var barTxtSize = 9;
            var xpBlackBar1Id = $"{id}.blackbar.1";
            CreateProgressBar(basePlayer, tracked, xpBlackBar1Id, topId, "0 1", "1 1", $"{xpImgH + padding} {-topH}", $"{0} {-topH + barH}", fadeOut, fadeIn, progressDelay, imgBgColor, barColor, notification.OldItemLevel, notification.NewItemLevel, notification.ItemXPGained, notification.OldItemXP, notification.NewItemXP, textColor, barTxtSize, notification.IsItemLevelup, topId, 0.25f);


            // Bottom
            var bottomId = $"{leftId}.bottom";
            var bottomH = topH;
            tracked.Add(new CuiElement
            {
                Name = bottomId,
                Parent = leftId,
                FadeOut = fadeOut,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0",
                        FadeIn = fadeIn
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 0",
                        OffsetMin = $"{0} {0}",
                        OffsetMax = $"{0} {bottomH}"
                    }
                }
            });

            var xpBlackBar2Id = $"{id}.blackbar.2";
            CreateProgressBar(basePlayer, tracked, xpBlackBar2Id, bottomId, "0 0", "1 0", $"{xpImgH + padding} {0}", $"{0} {barH}", fadeOut, fadeIn, progressDelay, imgBgColor, barColor, notification.OldCategoryLevel, notification.NewCategoryLevel, notification.CategoryXPGained, notification.OldCategoryXP, notification.NewCategoryXP, textColor, barTxtSize, notification.IsCategoryLevelup, bottomId, 0.45f);


            // XP Image BG 2;
            var xpImg2BgId = $"{id}.xpimg2.bg";
            var xpImgP2 = 4;
            tracked.Add(new CuiElement
            {
                Name = xpImg2BgId,
                Parent = bottomId,
                FadeOut = fadeOut,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = imgBgColor,
                        FadeIn = fadeIn,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 0",
                        OffsetMin = $"{0} {0}",
                        OffsetMax = $"{xpImgH} {xpImgH}"
                    }
                }
            });
            // XP Image 2;
            tracked.Add(new CuiElement
            {
                Name = $"{id}.xpimg2",
                Parent = xpImg2BgId,
                FadeOut = fadeOut,
                Components =
                {
                    new CuiImageComponent
                    {
                        Png = PLUGIN.ImageLibrary?.Call<string>("GetImage", $"qc.category.{notification.Category}"),
                        Color = "1 1 1 1",
                        FadeIn = fadeIn,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1",
                        OffsetMin = $"{xpImgP2} {xpImgP2}",
                        OffsetMax = $"{-xpImgP2} {-xpImgP2}"
                    }
                }
            });

            // Glow Element
            if (notification.IsRare)
            {
                var glowId = $"{id}.glow";
                tracked.Add(new CuiElement
                {
                    Name = glowId,
                    Parent = id,
                    FadeOut = 0.5f,
                    Components =
                {
                    new CuiImageComponent
                    {
                        Color = "1 1 1 0.7",
                        FadeIn = 0.05f
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                }
                });
                // Start Glow Destroy Timer
                PLUGIN.timer.In(0.2f, () =>
                {
                    CuiHelper.DestroyUi(basePlayer, glowId);
                });
            }


            container.AddRange(tracked);
            CuiHelper.DestroyUi(basePlayer, id);
            CuiHelper.AddUi(basePlayer, container);
            PLUGIN.PlaySfx(basePlayer, notification.IsRare ? PLUGIN.config.SFX.ItemCraftedRare : PLUGIN.config.SFX.ItemCraftedNormal);
            if (notification.IsDuplicated)
            {
                PLUGIN.PlaySfx(basePlayer, PLUGIN.config.SFX.ItemDuplicated);
            }
            PLUGIN.timer.In(pause, () =>
            {
                foreach (var item in tracked)
                {
                    CuiHelper.DestroyUi(basePlayer, item.Name);
                }
            });
        }
        #endregion
    }
}

namespace Oxide.Plugins
{
    partial class QualityCrafting : CovalencePlugin
    {
        public static class Styles
        {
            public static readonly float FadeIn = 0.1f;
            public static readonly float FadeOut = 0.6f;
            public static readonly float Pause = 2f;
            public static readonly string Material = "assets/content/materials/highlight.png";
            public static readonly int NotificationPadding = 8;
        }
    }
}

namespace Oxide.Plugins
{
	partial class QualityCrafting : CovalencePlugin
	{
		private readonly string TRACKING_HUD_ID = "qc.hud.tracking";

		public void DestroyTrackingHud(BasePlayer basePlayer)
        {
			CuiHelper.DestroyUi(basePlayer, TRACKING_HUD_ID);
        }

		public void ShowTrackingHud(BasePlayer basePlayer)
		{
			var category = TrackingManager.GetTrackedCategory(basePlayer);
            var skills = CraftingManager.GetSkills(basePlayer);
            var id = TRACKING_HUD_ID;
            if (category == null)
            {
				DestroyTrackingHud(basePlayer);
				return;
            }
            var x = config.HUD.TrackedSkill.X;
            var y = config.HUD.TrackedSkill.Y;
            var h = 40;
            var w = config.HUD.TrackedSkill.Size;
            var padding = 4;
            var icon = $"qc.category.{category.Name}";
            var imgBgColor = "0 0 0 0.8";
            var tracked = new List<CuiElement>();
            // Base
            tracked.Add(new CuiElement
            {
                Parent = "Hud",
                Name = id,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0.5 0.5 0.5 0.5"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = AnchorDefault,
                        AnchorMax = AnchorDefault,
                        OffsetMin = $"{x-GlobalOffset} {y}",
                        OffsetMax = $"{x+w-GlobalOffset} {y+h}"
                    }
                }
            });
            // Image Background
            var imgBgId = $"{id}.img.bg";
            tracked.Add(new CuiElement
            {
                Name = imgBgId,
                Parent = id,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = imgBgColor
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 0",
                        OffsetMin = $"{padding} {padding}",
                        OffsetMax = $"{h-padding} {h-padding}"
                    }
                }
            });
            // Image
            var imgP = 4;
            var imgId = $"{id}.img";
            tracked.Add(new CuiElement
            {
                Name = imgId,
                Parent = imgBgId,
                Components =
                {
                    new CuiImageComponent
                    {
                        Png = PLUGIN.ImageLibrary?.Call<string>("GetImage", icon)
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1",
                        OffsetMin = $"{imgP} {imgP}",
                        OffsetMax = $"{-imgP} {-imgP}"
                    }
                }
            });
            // Black bar
            var barH = 8;
            var barColor = config.Colors.XPBar;
            var blackBarId = $"{id}.blackbar";
            var xpProg = skills.GetLevelPercent(category);
            var level = skills.GetLevel(category);
            var isMaxLevel = level >= 100;
            var textSize = 10;
            var textColor = config.Colors.Text;
            var curLevelXp = level == 0 ? 0 : category.GetCategoryLevelXPReq(level);
            var xpAmt = skills.GetXP(category) - curLevelXp;
            var xpReq = category.GetCategoryLevelXPReq(level + 1) - curLevelXp;
            var transparent = "0 0 0 0";
            tracked.Add(new CuiElement
            {
                Name = blackBarId,
                Parent = id,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = isMaxLevel ? transparent : imgBgColor
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 0",
                        OffsetMin = $"{h + padding} {padding}",
                        OffsetMax = $"{-padding} {padding + barH}"
                    }
                }
            });
            // Green Bar
            tracked.Add(new CuiElement
            {
                Parent = blackBarId,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = isMaxLevel ? transparent: barColor
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = $"{xpProg} 1"
                    }
                }
            });
            // Level Text
            tracked.Add(new CuiElement
            {
                Parent = blackBarId,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = $"{category.DisplayName(basePlayer)}\n{level}",
                        FontSize = textSize,
                        Color = textColor,
                        Align = UnityEngine.TextAnchor.LowerLeft
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 1",
                        AnchorMax = $"1 1",
                        OffsetMin = $"{0} {2}",
                        OffsetMax = $"{0} {35}"
                    }
                }
            });
            // XP Text
            tracked.Add(new CuiElement
            {
                Parent = blackBarId,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = isMaxLevel ? Lang("max level", basePlayer) : $"{xpAmt}/{xpReq} {Lang("xp", basePlayer)}",
                        FontSize = textSize,
                        Color = textColor,
                        Align = UnityEngine.TextAnchor.LowerRight
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "1 1",
                        AnchorMax = $"1 1",
                        OffsetMin = $"{-50} {2}",
                        OffsetMax = $"{0} {35}"
                    }
                }
            });

            var container = new CuiElementContainer();
            container.AddRange(tracked);
            DestroyTrackingHud(basePlayer);
            CuiHelper.AddUi(basePlayer, container);
        }
	}
}

namespace Oxide.Plugins
{
    partial class QualityCrafting
    {

        private T LoadDataFile<T>(string fileName)
        {
            try
            {
                return Interface.Oxide.DataFileSystem.ReadObject<T>($"{Name}/{fileName}");
            }
            catch (Exception)
            {
                return default(T);
            }
        }

        private static string ColorToHex(string color)
        {
            var split = color.Split(' ');
            var r = (int) Math.Round(float.Parse(split[0]) * 255f);
            var g = (int)Math.Round(float.Parse(split[1]) * 255f);
            var b = (int)Math.Round(float.Parse(split[2]) * 255f);
            return "#" + r.ToString("X2") + g.ToString("X2") + b.ToString("X2");
        }

        private static string ColorTextHex(string text, string hexColor)
        {
            return $"<color={hexColor}>{text}</color>";
        }

        private static string ColorTextRGB(string text, string rgb)
        {
            return ColorTextHex(text, ColorToHex(rgb));
        }

        public string Offset(int x, int y)
        {
            return $"{x} {y}";
        }

        public int GlobalOffset = 640;
        public string AnchorDefault => "0.5 0";

        public string Anchor(float x, float y)
        {
            return $"{x} {y}";
        }

        private static string SetOpacity(string colorString, float opacity)
        {
            var split = colorString.Split(' ');
            split[3] = $"{opacity}";
            return string.Join(" ", split);
        }

        private void SaveDataFile<T>(string fileName, T data)
        {
            Interface.Oxide.DataFileSystem.WriteObject($"{Name}/{fileName}", data);
        }

        private void PlaySfx(BasePlayer player, string sound) => EffectNetwork.Send(new Effect(sound, player, 0, Vector3.zero, Vector3.forward), player.net.connection);

        public class SecurityCheck
        {
            public bool Success { get; set; }
            public string[] Args { get; set; }

            public SecurityCheck(string[] args)
            {
                Guid guidValue;
                if (args.Length > 0 && Guid.TryParse(args[0], out guidValue) && guidValue == PLUGIN.Secret)
                {
                    Success = true;
                    Args = args.Skip(1).ToArray();
                }
                else
                {
                    Success = false;
                    Args = args;
                }
            }
        }
    }
}

namespace Oxide.Plugins
{
    partial class QualityCrafting : CovalencePlugin
    {
        public class PlayerSkillSheet
        {
            // <SkillCategory.ID, xp>
            public Dictionary<int, uint> _categoryXP = new Dictionary<int, uint>();
            // <Item.id, xp>
            public Dictionary<int, uint> _itemXP = new Dictionary<int, uint>();

            private static int[] _ItemXpToLevelCache = null;

            private static int[] _CategoryXpToLevelCache = null;

            public PlayerSkillSheet()
            {
                foreach(SkillCategory category in SkillCategory.ALL)
                {
                    _categoryXP[category.ID] = 0;
                }
            }

            public PlayerSkillSheet SetLevel(Item item, int level)
            {
                var category = SkillCategory.GetByItem(item);
                var xp = category.GetItemLevelXPReq(level);
                _itemXP[item.info.itemid] = xp;
                return this;
            }

            public PlayerSkillSheet SetLevel(SkillCategory category, int level)
            {
                if (SkillCategory.IsCategoryEnabled(category))
                {
                    var xp = category.GetCategoryLevelXPReq(level);
                    _categoryXP[category.ID] = xp;
                }
                return this;
            }

            public List<int> GetCategoryItemIDs(SkillCategory category)
            {
                var list = new List<int>();
                foreach(var id in _itemXP.Keys)
                {
                    var item = ItemManager.CreateByItemID(id);
                    if (SkillCategory.GetByItem(item) == category)
                    {
                        list.Add(id);
                    }
                }
                return list;
            }

            public int GetLevel(Item item)
            {
                var xp = GetXP(item);
                return GetItemLevelFromXp(item, xp);
            }

            public int GetLevelFromItemId(int itemId)
            {
                var item = ItemManager.CreateByItemID(itemId);
                return GetLevel(item);
            }

            public int GetLevel(SkillCategory category)
            {
                if (!SkillCategory.IsCategoryEnabled(category))
                {
                    return 0;
                }
                var xp = GetXP(category);
                return GetLevelFromXp(category, xp);
            }

            public float GetCraftingSpeedMultiplier(SkillCategory category)
            {
                return !SkillCategory.IsCategoryEnabled(category) ? 1f : 1f + (GetLevel(category) * PLUGIN.config.Categories[category.Name.TitleCase()].PerkIncreasesPerLevel.CraftingSpeed);
            }

            public int GetDuplicateChance(SkillCategory category)
            {
                return !SkillCategory.IsCategoryEnabled(category) ? 0 : (int) Math.Floor(PLUGIN.config.Categories[category.Name.TitleCase()].PerkIncreasesPerLevel.DuplicateChance * GetLevel(category) * 100);
            }

            public PlayerSkillSheet GrantXP(SkillCategory category, uint xp)
            {
                _categoryXP[category.ID] += xp;
                return this;
            }

            public PlayerSkillSheet GrantXP(Item item, uint xp)
            {
                if (!_itemXP.ContainsKey(item.info.itemid))
                {
                    _itemXP[item.info.itemid] = xp;
                }
                else
                {
                    _itemXP[item.info.itemid] += xp;
                }
                return this;
            }

            public uint GetXP(SkillCategory category)
            {
                uint catXP = 0;
                if (SkillCategory.IsCategoryEnabled(category) && _categoryXP.TryGetValue(category.ID, out catXP))
                {
                    return catXP;
                }
                return 0;
            }

            public uint GetXP(Item item)
            {
                uint itemXP = 0;
                if (_itemXP.TryGetValue(item.info.itemid, out itemXP))
                {
                    return itemXP;
                }
                return 0;
            }

            public float GetLevelPercent(Item item)
            {
                var category = SkillCategory.GetByItem(item);
                if (!SkillCategory.IsCategoryEnabled(category))
                {
                    return 0;
                }
                int level = GetLevel(item);
                int nextLevel = level + 1;
                var req1 = level > 0 ? category.GetItemLevelXPReq(level) : 0;
                var req2 = category.GetItemLevelXPReq(nextLevel);
                var xp = GetXP(item);
                var xpProg = xp - req1;
                return Math.Max(0f, Math.Min(1f, (float)xpProg / (float)(req2 - req1)));
            }

            public float GetLevelPercent(SkillCategory category)
            {
                if (!SkillCategory.IsCategoryEnabled(category))
                {
                    return 0;
                }
                int level = GetLevel(category);
                int nextLevel = level + 1;
                var req1 = level > 0 ? category.GetCategoryLevelXPReq(level) : 0;
                var req2 = category.GetCategoryLevelXPReq(nextLevel);
                var xp = GetXP(category);
                var xpProg = xp - req1;
                return Math.Max(0f, Math.Min(1f, (float)xpProg / (float)(req2 - req1)));
            }

            private static int GetItemLevelFromXp(Item item, uint xp)
            {
                var category = SkillCategory.GetByItem(item);
                if (!SkillCategory.IsCategoryEnabled(category))
                {
                    return 0;
                }
                if (_ItemXpToLevelCache == null)
                {
                    _ItemXpToLevelCache = new int[category.GetItemLevelXPReq(100)];
                    for (int i = 0; i < 100; i++)
                    {
                        var minXp = (int)category.GetItemLevelXPReq(i);
                        var maxXp = (int)category.GetItemLevelXPReq(i + 1);
                        for (int j = minXp; j < maxXp; j++)
                        {
                            _ItemXpToLevelCache[j] = i;
                        }
                    }
                }
                if (xp >= _ItemXpToLevelCache.Length)
                {
                    return 100;
                }
                return _ItemXpToLevelCache[(int)xp];
            }

            private static int GetLevelFromXp(SkillCategory category, uint xp)
            {
                if (!SkillCategory.IsCategoryEnabled(category))
                {
                    return 0;
                }
                if (_CategoryXpToLevelCache == null)
                {
                    _CategoryXpToLevelCache = new int[category.GetCategoryLevelXPReq(100)];
                    for (int i = 0; i < 100; i++)
                    {
                        var minXp = category.GetCategoryLevelXPReq(i);
                        var maxXp = category.GetCategoryLevelXPReq(i + 1);
                        for (uint j = minXp; j < maxXp; j++)
                        {
                            _CategoryXpToLevelCache[j] = i;
                        }
                    }
                }
                if (xp >= _CategoryXpToLevelCache.Length)
                {
                    return 100;
                }
                return _CategoryXpToLevelCache[xp];
            }

            public override string ToString()
            {
                var sb = new StringBuilder();
                foreach (SkillCategory category in SkillCategory.ALL)
                {
                    sb.Append($"{category.Name}: {GetLevel(category)}; ");
                }
                return sb.ToString();
            }
        }
    }
}

namespace Oxide.Plugins
{
    partial class QualityCrafting : CovalencePlugin
    {
        public class SkillCategory
        {
            public SkillCategory(int id, string name, string defaultIcon)
            {
                this.ID = id;
                this.DefaultIcon = defaultIcon;
                this.Name = name;
            }

            public float? TemporaryMultiplier { get; set; } = null;

            private static List<uint> _itemLevelXpRequirements = null;
            private static List<uint> _categoryLevelXpRequirements = null;

            public static readonly SkillCategory GUNSMITHING = new SkillCategory(0, "gunsmithing", "https://i.imgur.com/BH0ndEH.png");
            public static readonly SkillCategory TOOLCRAFTING = new SkillCategory(1, "toolcrafting", "https://i.imgur.com/I0i8tBW.png");
            public static readonly SkillCategory TAILORING = new SkillCategory(2, "tailoring", "https://i.imgur.com/WlrTTKR.png");
            public static readonly SkillCategory BOWMAKING = new SkillCategory(3, "bowmaking", "https://i.imgur.com/NsBOZg1.png");
            public static readonly SkillCategory WEAPONSMITHING = new SkillCategory(4, "weaponsmithing", "https://i.imgur.com/1eAdvAq.png");
            public static readonly List<SkillCategory> ALL = new List<SkillCategory>()
            {
                GUNSMITHING,
                TOOLCRAFTING,
                TAILORING,
                BOWMAKING,
                WEAPONSMITHING
            };
            public int ID { get; private set; }
            public string DefaultIcon { get; private set; }
            public string Name { get; private set; }
            public string NameTitleCase
            {
                get
                {
                    return Name.TitleCase();
                }
            }
            public uint MinLevelXP { get; private set; }
            public uint MidLevelXP { get; private set; }
            public uint MaxLevelXP { get; private set; }
            public string DisplayName(BasePlayer basePlayer)
            {
                return PLUGIN.Lang(Name, basePlayer);
            }

            public static SkillCategory GetByName(string name)
            {
                var category = ALL.FirstOrDefault(x => x.Name == name);
                return category == null || !IsCategoryEnabled(category) ? null : category;
            }

            public static SkillCategory GetDefaultCategory()
            {
                foreach(var category in ALL.OrderBy(x => x.ID))
                {
                    if (IsCategoryEnabled(category))
                    {
                        return category;
                    }
                }
                return null;
            }

            public static SkillCategory GetByID(int ID)
            {
                var category = ALL[ID];
                return category == null || !IsCategoryEnabled(category) ? null : category;
            }

            public static SkillCategory GetByItemName(string itemDisplayName)
            {
                var itemDef = ItemManager.itemList.FirstOrDefault(x => x.displayName.translated.ToLower() == itemDisplayName.ToLower());
                return itemDef == null ? null : GetByItemDefinition(itemDef);
            }

            public static SkillCategory GetByItemDefinition(ItemDefinition itemDefinition)
            {
                if (itemDefinition == null)
                {
                    return null;
                }
                try
                {
                    var item = ItemManager.Create(itemDefinition);
                    if (item == null)
                    {
                        return null;
                    }
                    return GetByItem(item);
                }
                catch (Exception e)
                {
                    return null;
                }
            }

            public static SkillCategory GetByItem(Item item)
            {
                var heldEntity = item.GetHeldEntity();
                if (heldEntity == null && item.info.isWearable && item.info.category == ItemCategory.Attire)
                    return IsCategoryEnabled(TAILORING) ? SkillCategory.TAILORING : null;
                if (heldEntity == null)
                    return null;
                if (heldEntity is CompoundBowWeapon || heldEntity is BowWeapon || heldEntity is CrossbowWeapon)
                    return IsCategoryEnabled(BOWMAKING) ? SkillCategory.BOWMAKING : null;
                if (heldEntity is BaseProjectile || heldEntity.GetType().IsSubclassOf(typeof(BaseProjectile)) && item.info.category == ItemCategory.Weapon)
                    return IsCategoryEnabled(GUNSMITHING) ? SkillCategory.GUNSMITHING : null;
                if (heldEntity is BaseMelee || heldEntity.GetType().IsSubclassOf(typeof(BaseMelee)))
                    if (item.info.category == ItemCategory.Weapon)
                    {
                        return IsCategoryEnabled(WEAPONSMITHING) ? SkillCategory.WEAPONSMITHING : null;
                    }
                    else
                    {
                        return IsCategoryEnabled(TOOLCRAFTING) ? SkillCategory.TOOLCRAFTING : null;
                    }
                return null;
            }

            public static bool IsCategoryEnabled(SkillCategory category)
            {
                if (category == null)
                {
                    return false;
                }
                var nameTitleCase = category.Name.TitleCase();
                if (PLUGIN.config.Categories.ContainsKey(nameTitleCase))
                {
                    return PLUGIN.config.Categories[category.Name.TitleCase()].Enabled;
                }
                return false;
            }

            public float GetBaseCraftingSpeed()
            {
                return PLUGIN.config.Categories[NameTitleCase].BaseCraftingSpeed;
            }

            public float GetXpMultiplier()
            {
                return TemporaryMultiplier == null ? PLUGIN.config.Categories[NameTitleCase].XPMultiplier : TemporaryMultiplier.Value;
            }

            public uint GetItemLevelXPReq(int level)
            {
                if (level < 1 || level > 100)
                {
                    return 0;
                }
                if (_itemLevelXpRequirements == null)
                {
                    var baseXp = 15ul;
                    var growth = 0.85f;
                    _itemLevelXpRequirements = new List<uint>() { 0 };
                    for(int i = 1; i < 102; i++)
                    {
                        var value = (uint)(baseXp + Math.Pow(level - 1, growth)) + _itemLevelXpRequirements[i - 1];
                        _itemLevelXpRequirements.Add(value);
                    }
                }
                return _itemLevelXpRequirements[level];
            }

            public uint GetCategoryLevelXPReq(int level)
            {
                if (level < 1 || level > 100)
                {
                    return 0;
                }
                if (_categoryLevelXpRequirements == null)
                {
                    _categoryLevelXpRequirements = new List<uint>() { 0 };
                    for (int i = 1; i < 102; i++)
                    {
                        var value = (uint)Math.Round(0.04 * Math.Pow(i+1, 3) + 0.8 * Math.Pow(i+1, 2) + 2 * i+1);
                        _categoryLevelXpRequirements.Add(value);
                    }
                }
                return _categoryLevelXpRequirements[level];
            }
        }
    }
}

namespace Oxide.Plugins
{
    partial class QualityCrafting : CovalencePlugin
    {
        public static class CraftingManager
        {
            // <userIdString, SkillSheet>
            private static Dictionary<string, PlayerSkillSheet> _playerCraftingSkills = new Dictionary<string, PlayerSkillSheet>();

            public static void Clear()
            {
                _playerCraftingSkills.Clear();
            }

            public static void Clear(BasePlayer basePlayer)
            {
                _playerCraftingSkills.Remove(basePlayer.UserIDString);
            }

            public static PlayerSkillSheet GetSkills(BasePlayer basePlayer)
            {
                if (!_playerCraftingSkills.ContainsKey(basePlayer.UserIDString))
                {
                    _playerCraftingSkills[basePlayer.UserIDString] = new PlayerSkillSheet();
                }
                return _playerCraftingSkills[basePlayer.UserIDString];
            }

            public static List<LeaderboardRank> GetTopPlayerSkills(SkillCategory category, int skip = 0, int take = 25)
            {
                return _playerCraftingSkills
                    .Select(x => new LeaderboardRank { UserIdString = x.Key, Level = x.Value.GetLevel(category) })
                    .Where(x => !string.IsNullOrEmpty(x.UserDisplayName))
                    .OrderByDescending(x => x.Level)
                    .Skip(skip)
                    .Take(take)
                    .ToList();
            }

            public static List<CraftChance> GetQualityChances(int itemLevel)
            {
                return new List<CraftChance>
                {
                    new CraftChance{ Quality = 0, Percent = GetRelativeChanceOfQuality(0, itemLevel) },
                    new CraftChance{ Quality = 1, Percent = GetRelativeChanceOfQuality(1, itemLevel) },
                    new CraftChance{ Quality = 2, Percent = GetRelativeChanceOfQuality(2, itemLevel) },
                    new CraftChance{ Quality = 3, Percent = GetRelativeChanceOfQuality(3, itemLevel) },
                    new CraftChance{ Quality = 4, Percent = GetRelativeChanceOfQuality(4, itemLevel) },
                    new CraftChance{ Quality = 5, Percent = GetRelativeChanceOfQuality(5, itemLevel) }
                };
            }

            private static int GetRelativeChanceOfQuality(int quality, int itemLevel)
            {
                if (quality >= 5)
                {
                    return GetChanceOfQuality(quality, itemLevel);
                }
                return GetChanceOfQuality(quality, itemLevel) - GetChanceOfQuality(quality + 1, itemLevel);
            }

            private static int GetChanceOfQuality(int quality, int itemLevel)
            {
                int major = 4;
                int minor = 1;
                int step = 20;
                switch (quality)
                {
                    case 0:
                        return 100;
                    case 1:
                        return (Math.Min(step, itemLevel) * major) + Math.Min(step, Math.Max(0, (itemLevel - 20)) * minor);
                    case 2:
                        return (Math.Min(step, Math.Max(0, itemLevel - 20)) * major) + Math.Min(step, Math.Max(0, (itemLevel - 40)) * minor);
                    case 3:
                        return (Math.Min(step, Math.Max(0, itemLevel - 40)) * major) + Math.Min(step, Math.Max(0, (itemLevel - 60)) * minor);
                    case 4:
                        return (Math.Min(step, Math.Max(0, itemLevel - 60)) * major) + Math.Min(step, Math.Max(0, (itemLevel - 80)) * minor);
                    case 5:
                        return Math.Min(step, Math.Max(0, itemLevel - 80)) * major;
                    default:
                        return 0;
                }
            }

            public static int GetCraftedItemQuality(Item item, PlayerSkillSheet skills)
            {
                int itemLevel = skills.GetLevel(item);
                if (itemLevel == 0)
                {
                    return 0;
                }
                int roll = UnityEngine.Random.Range(1, 100);
                
                // roll for T5
                if (itemLevel > 80)
                {
                    var r = GetChanceOfQuality(5, itemLevel);
                    if (roll <= r)
                    {
                        return 5;
                    }
                }
                // roll for T4
                if (itemLevel > 60)
                {
                    var r = GetChanceOfQuality(4, itemLevel);
                    if (roll <= r)
                    {
                        return 4;
                    }
                }
                // roll for T3
                if (itemLevel > 40)
                {
                    var r = GetChanceOfQuality(3, itemLevel);
                    if (roll <= r)
                    {
                        return 3;
                    }
                }
                // roll for T2
                if (itemLevel > 20)
                {
                    var r = GetChanceOfQuality(2, itemLevel);
                    if (roll <= r)
                    {
                        return 2;
                    }
                }
                // roll for T1
                if (itemLevel > 0)
                {
                    var r = GetChanceOfQuality(1, itemLevel);
                    if (roll <= r)
                    {
                        return 1;
                    }
                }
                // roll for T0
                return 0;
            }

            public static void Load()
            {
                var all = PLUGIN.LoadDataFile<Dictionary<string, PlayerSkillSheet>>("Skills");
                if (all == null)
                {
                    all = new Dictionary<string, PlayerSkillSheet>();
                }
                _playerCraftingSkills = all;
            }

            public static void Save()
            {
                PLUGIN.SaveDataFile("Skills", _playerCraftingSkills);
            }
        }
    }
}

namespace Oxide.Plugins
{
    partial class QualityCrafting : CovalencePlugin
    {
        #region Notification Classes
        public enum NotificationType
        {
            ItemCrafted,
            GainedXP
        }
        public abstract class Notification
        {
            public abstract NotificationType Type { get; }
        }
        public class NotificationBundle
        {
            public List<Notification> Items { get; set; }
            public bool ContainsLevelup { get; set; }
        }
        public class GainedXPNotification : Notification
        {
            public override NotificationType Type { get; } = NotificationType.GainedXP;
            public string Icon { get; set; }
            public string SkillDisplayName { get; set; }
            public float OldXP { get; set; }
            public float NewXP { get; set; }
            public int OldLevel { get; set; }
            public int NewLevel { get; set; }
            public uint XPGained { get; set; }
            public bool IsLevelUp { get; set; }
        }
        public class ItemCraftedNotification : Notification
        {
            public override NotificationType Type { get; } = NotificationType.ItemCrafted;
            public string SkillDisplayName { get; set; }
            public string Icon { get; set; }
            public bool IsItem { get; set; }
            public int OldCategoryLevel { get; set; }
            public int NewCategoryLevel { get; set; }
            public int OldItemLevel { get; set; }
            public int NewItemLevel { get; set; }
            public float OldCategoryXP { get; set; }
            public float NewCategoryXP { get; set; }
            public float OldItemXP { get; set; }
            public float NewItemXP { get; set; }
            public bool IsCategoryLevelup { get; set; }
            public bool IsItemLevelup { get; set; }
            public uint CategoryXPGained { get; set; }
            public uint ItemXPGained { get; set; }
            public int Quality { get; set; }
            public string Category { get; set; }
            public bool IsRare { get; set; }
            public bool IsDuplicated { get; set; }

            public override string ToString()
            {
                return $"{SkillDisplayName}; {Icon}; {IsItem}; {OldCategoryLevel}; {NewCategoryLevel}; {OldCategoryXP}; {NewCategoryXP}; {IsCategoryLevelup}; {CategoryXPGained};";
            }
        }
        #endregion

        public static class NotificationManager
        {
            private static Dictionary<string, List<NotificationBundle>> PlayerNotifications = new Dictionary<string, List<NotificationBundle>>();

            public static void DestroyAllNotifications(BasePlayer basePlayer)
            {
                CuiHelper.DestroyUi(basePlayer, NOTIFICATION_ID);
                PLUGIN.timer.In(5, () =>
                {
                    if (basePlayer != null)
                    {
                        CuiHelper.DestroyUi(basePlayer, NOTIFICATION_ID);
                    }
                });
            }

            public static void AddNotifications(BasePlayer basePlayer, params Notification[] notifications)
            {
                var userIdString = basePlayer.UserIDString;
                if (!PlayerNotifications.ContainsKey(userIdString))
                {
                    PlayerNotifications.Add(userIdString, new List<NotificationBundle>());
                }
                var items = new List<Notification>();
                foreach(var notification in notifications)
                {
                    items.Add(notification);
                }
                PlayerNotifications[userIdString].Add(new NotificationBundle { Items = items });
                if (PlayerNotifications[userIdString].Count <= 1)
                {
                    ShowNotifications(basePlayer);
                }
            }

            private static void ShowNotifications(BasePlayer basePlayer)
            {
                string userIdString = basePlayer.UserIDString;
                if (PlayerNotifications.ContainsKey(userIdString) && PlayerNotifications[userIdString].Count > 0)
                {
                    var bundle = PlayerNotifications[userIdString][0];
                    float totalTime = 3.5f;
                    foreach (var item in bundle.Items)
                    {
                        if (item.Type == NotificationType.ItemCrafted && PLUGIN.config.Notifications.ItemCraftedNotification.Show)
                        {
                            var casted = (ItemCraftedNotification)item;
                            PLUGIN.ShowItemCraftedNotification(basePlayer, casted);
                        }
                        else if (item.Type == NotificationType.GainedXP && PLUGIN.config.Notifications.LevelUpItemNotification.Show)
                        {
                            var casted = (GainedXPNotification)item;
                            PLUGIN.ShowXpGainedNotification(basePlayer, casted);
                        }
                    }
                    PLUGIN.timer.In(totalTime, () =>
                    {
                        if (PlayerNotifications.ContainsKey(userIdString) && PlayerNotifications[userIdString].Count > 0)
                        {
                            PlayerNotifications[userIdString].RemoveAt(0);
                            ShowNotifications(basePlayer);
                        }
                    });
                }
            }
        }
    }
}

namespace Oxide.Plugins
{
    partial class QualityCrafting : CovalencePlugin
    {
        public static class QualityItemManager
        {
            public static QualityItem SetItemQuality(Item item, int quality, BasePlayer creator = null)
            {
                item.text = $"{quality}{(creator == null ? string.Empty : creator.UserIDString)}";
                return new QualityItem(item);
            }

            public static bool IsQualityItem(Item item)
            {
                return !string.IsNullOrEmpty(item.text);
            }

            public static QualityItem GetByItem(Item item)
            {
                return new QualityItem(item);
            }

            private static float GetModifier(int quality, float modifier)
            {
                return 1f + (modifier * quality);
            }

            public static float GetClothingStatResistance(BasePlayer basePlayer, Rust.DamageType dt, bool baseValues = false)
            {
                var total = 0f;
                foreach (Item item in basePlayer.inventory.containerWear.itemList)
                {
                    /* Protection increase by 1.5 */
                    /* Scale by 1.5 - 1 = 0.5 */
                    try
                    {
                        var value = item.info.ItemModWearable.protectionProperties.Get(dt);
                        if (value <= 0)
                        {
                            continue;
                        }
                        if (!baseValues)
                        {
                            int quality = QualityItemManager.GetItemQuality(item);
                            value += (quality * PLUGIN.config.Qualities.Modifiers.Protection);
                        }
                        total += value;
                    } catch(Exception) { continue; }
                }
                return total;
            }

            public static List<QualityItemStat> GetItemStats(Item item)
            {
                var list = new List<QualityItemStat>();
                var quality = GetItemQuality(item);
                var category = SkillCategory.GetByItem(item);
                var heldEntity = item.GetHeldEntity();
                if (heldEntity is BaseProjectile)
                {
                    list.Add(new QualityItemStat
                    {
                        StatName = "Damage",
                        PercentModified = PLUGIN.config.Qualities.Modifiers.ProjectileDamage * quality
                    });
                }
                if (heldEntity is BaseMelee)
                {
                    list.Add(new QualityItemStat
                    {
                        StatName = "Damage",
                        PercentModified = PLUGIN.config.Qualities.Modifiers.MeleeDamage * quality
                    });
                    list.Add(new QualityItemStat
                    {
                        StatName = "Gathering",
                        PercentModified = PLUGIN.config.Qualities.Modifiers.GatherRate * quality
                    });
                }
                if (heldEntity == null && item.info.isWearable)
                {
                    list.Add(new QualityItemStat
                    {
                        StatName = "Protection",
                        PercentModified = PLUGIN.config.Qualities.Modifiers.Protection * quality
                    });
                }
                if (item.hasCondition)
                {
                    list.Add(new QualityItemStat
                    {
                        StatName = "Durability",
                        PercentModified = PLUGIN.config.Qualities.Modifiers.Durability * quality
                    });
                }
                return list;
            }

            public static bool IsRareQuality(int quality, int level)
            {
                switch(quality)
                {
                    case 1:
                        return level <= 20;
                    case 2:
                        return level <= 40;
                    case 3:
                        return level <= 60;
                    case 4:
                        return level <= 80;
                    case 5:
                        return level <= 100;
                    default:
                        return false;
                }
            }

            private static HashSet<ulong> AuditedEntities = new HashSet<ulong>();

            public static void AuditQualityItem(ref Item item, BaseEntity heldEntity)
            {
                if (AuditedEntities.Contains(item.uid.Value))
                {
                    return;
                }
                var quality = GetItemQuality(item);
                var compareItem = ItemManager.CreateByItemID(item.info.itemid);
                if (heldEntity is BaseProjectile)
                {
                    var casted = (BaseProjectile)heldEntity;
                    var compareHeldEntity = (BaseProjectile)compareItem.GetHeldEntity();
                    var expected = compareHeldEntity.damageScale * GetModifier(quality, PLUGIN.config.Qualities.Modifiers.ProjectileDamage);
                    if (casted.damageScale != expected)
                    {
                        casted.damageScale = expected;
                    }
                }
                else if (heldEntity is BaseMelee)
                {
                    var casted = (BaseMelee)heldEntity;
                    var compareHeldEntity = (BaseMelee)compareItem.GetHeldEntity();
                    var gather = PLUGIN.config.Qualities.Modifiers.GatherRate;
                    // flesh
                    var expected = compareHeldEntity.gathering.Flesh.gatherDamage * GetModifier(quality, gather);
                    if (casted.gathering.Flesh.gatherDamage != expected)
                    {
                        casted.gathering.Flesh.gatherDamage = expected;
                    }
                    // ore
                    expected = compareHeldEntity.gathering.Ore.gatherDamage * GetModifier(quality, gather);
                    if (casted.gathering.Ore.gatherDamage != expected)
                    {
                        casted.gathering.Ore.gatherDamage = expected;
                    }
                    // tree
                    expected = compareHeldEntity.gathering.Tree.gatherDamage * GetModifier(quality, gather);
                    if (casted.gathering.Tree.gatherDamage != expected)
                    {
                        casted.gathering.Tree.gatherDamage = expected;
                    }
                    // melee
                    var melee = PLUGIN.config.Qualities.Modifiers.MeleeDamage;
                    foreach (DamageTypeEntry entry in casted.damageTypes)
                    {
                        var compareEntry = compareHeldEntity.damageTypes.First(x => x.type == entry.type);
                        expected = compareEntry.amount * GetModifier(quality, melee);
                        if (expected != entry.amount)
                        {
                            entry.amount = expected;
                        }
                    }
                }
                AuditedEntities.Add(item.uid.Value);
            }

            public static Item ApplyQualityModifiers(Item item, int quality, bool initial = true)
            {
                if (initial)
                {
                    item.maxCondition *= GetModifier(quality, PLUGIN.config.Qualities.Modifiers.Durability);
                    item.condition = item.maxCondition;
                }
                var heldEntity = item.GetHeldEntity();
                if (heldEntity is BaseProjectile)
                {
                    var casted = (BaseProjectile)heldEntity;
                    casted.damageScale *= GetModifier(quality, PLUGIN.config.Qualities.Modifiers.ProjectileDamage);
                }
                else if (heldEntity is BaseMelee)
                {
                    var casted = (BaseMelee)heldEntity;
                    var melee = PLUGIN.config.Qualities.Modifiers.MeleeDamage;
                    var gather = PLUGIN.config.Qualities.Modifiers.GatherRate;
                    casted.gathering.Flesh.gatherDamage *= GetModifier(quality, gather);
                    casted.gathering.Ore.gatherDamage *= GetModifier(quality, gather);
                    casted.gathering.Tree.gatherDamage *= GetModifier(quality, gather);
                    foreach (DamageTypeEntry entry in casted.damageTypes)
                    {
                        entry.amount *= GetModifier(quality, melee);
                    }
                }
                return item;
            }

            public static int GetItemQuality(Item item)
            {
                return GetByItem(item).Quality;
            }

            public static int GetWorkbenchLevel(Item item)
            {
                return ItemManager.bpList.Where(x => x.targetItem.shortname == item.info.shortname).FirstOrDefault().workbenchLevelRequired;
            }

            public static uint GetItemXpRate(Item item)
            {
                int wbLevel = GetWorkbenchLevel(item);
                switch(wbLevel)
                {
                    case 0: return 2;
                    case 1: return 8;
                    case 2: return 13;
                    case 3: return 50;
                }
                return 0;
            }

            public static string GetColorByQuality(int quality)
            {
                switch(quality)
                {
                    case 1:
                        return PLUGIN.config.Qualities.Tier1.Color;
                    case 2:
                        return PLUGIN.config.Qualities.Tier2.Color;
                    case 3:
                        return PLUGIN.config.Qualities.Tier3.Color;
                    case 4:
                        return PLUGIN.config.Qualities.Tier4.Color;
                    case 5:
                        return PLUGIN.config.Qualities.Tier5.Color;
                    default:
                        return PLUGIN.config.Qualities.Tier0.Color;
                }
            }
        }
    }
}

namespace Oxide.Plugins
{
    partial class QualityCrafting : CovalencePlugin
    {
        public static class TrackingManager
        {
            private static Dictionary<string, int> _playerTracking = new Dictionary<string, int>(); //userIdString: category

            public static void Track(BasePlayer basePlayer, SkillCategory category)
            {
                if (!_playerTracking.ContainsKey(basePlayer.UserIDString))
                {
                    _playerTracking[basePlayer.UserIDString] = category.ID;
                }
                else
                {
                    _playerTracking[basePlayer.UserIDString] = category.ID;
                }
            }

            public static SkillCategory GetTrackedCategory(BasePlayer basePlayer)
            {
                if (_playerTracking.ContainsKey(basePlayer.UserIDString))
                {
                    return SkillCategory.GetByID(_playerTracking[basePlayer.UserIDString]);
                }
                return null;
            }

            public static void Untrack(BasePlayer basePlayer)
            {
                _playerTracking.Remove(basePlayer.UserIDString);
            }

            public static bool IsTracking(BasePlayer basePlayer, SkillCategory category)
            {
                if (!_playerTracking.ContainsKey(basePlayer.UserIDString))
                {
                    return false;
                }
                return _playerTracking[basePlayer.UserIDString].Equals(category.ID);
            }

            public static void Load()
            {
                var all = PLUGIN.LoadDataFile<Dictionary<string, int>>("Tracking");
                if (all == null)
                {
                    all = new Dictionary<string, int>();
                }
                _playerTracking = all;
            }

            public static void Save()
            {
                PLUGIN.SaveDataFile("Tracking", _playerTracking);
            }
        }
    }
}

namespace Oxide.Plugins
{
    partial class QualityCrafting : CovalencePlugin
    {
        public class CommandInfo
        {
            public string Command { get; set; }
            public CommandArgument[] Arguments { get; set; } = new CommandArgument[0];
            public string Description { get; set; }
            public string Method { get; set; }
            public int Rank = 999;
            public string Permission
            {
                get
                {
                    return Permissions == null ? null : Permissions.FirstOrDefault();
                }
                set
                {
                    Permissions = new string[1] { value };
                }
            }
            public string[] Permissions { get; set; } = new string[0];
            public bool AdminOnly
            {
                get
                {
                    return Permissions.Any(x => x.Contains("admin"));
                }
            }

            public int RequiredArgCount { 
                get
                {
                    return Arguments.Where(x => !x.Optional).Count();
                } 
            }

            public int TotalArgCount
            {
                get
                {
                    return Arguments.Length;
                }
            }

            public string ArgString
            {
                get
                {
                    return $"{string.Join(" ", Arguments.Select(x => x.ToString()))}";
                }
            }

            public string Usage(IPlayer player, string prefix)
            {
                return PLUGIN.Lang("usage", player.Id, $"/{prefix} {Command} {ArgString}");
            }

            public void Execute(IPlayer player, string command, string[] args)
            {
                PLUGIN.Call(Method, player, command, args);
            }

            public ValidationResponse Validate(params string[] args)
            {
                if (args.Length < RequiredArgCount || args.Length > TotalArgCount)
                {
                    return new ValidationResponse(ValidationStatusCode.INVALID_LENGTH, RequiredArgCount, TotalArgCount);
                }
                int i = 0;
                foreach(var arg in args)
                {
                    var Argument = Arguments[i];
                    var resp = Argument.Validate(arg);
                    if (!resp.IsValid)
                    {
                        switch(resp.StatusCode)
                        {
                            case ValidationStatusCode.INVALID_VALUE:
                            case ValidationStatusCode.PLAYER_NOT_FOUND:
                                resp.SetData(arg);
                                break;
                        }
                        return resp;
                    }
                    i++;
                }
                return new ValidationResponse();
            }
        }

        public class CommandArgument
        {
            public static readonly CommandArgument PLAYER_NAME = new CommandArgument
            {
                Parameter = "player",
                Validate = (value) =>
                {
                    return BasePlayer.FindAwakeOrSleeping(value) == null ? new ValidationResponse(ValidationStatusCode.PLAYER_NOT_FOUND) : new ValidationResponse(ValidationStatusCode.SUCCESS);
                }
            };

            public string Parameter { get; set; }
            public bool Optional { get; set; } = false;
            public string[] AllowedValues
            {
                set
                {
                    Validate = (given) =>
                    {
                        var expected = value;
                        return expected.Any(x => x.ToLower() == given.ToLower()) ? new ValidationResponse() : new ValidationResponse(ValidationStatusCode.VALUE_NOT_ALLOWED, given, expected);
                    };
                }
            }
            public Func<string, ValidationResponse> Validate { get; set; } = ((value) => { return new ValidationResponse(); });

            public override string ToString()
            {
                return $"<{Parameter}{(Optional ? "?" : string.Empty)}>";
            }
        }

        public class ValidationResponse
        {
            public bool IsValid
            {
                get
                {
                    return StatusCode == ValidationStatusCode.SUCCESS;
                }
            }
            public ValidationStatusCode StatusCode { get; }
            public object[] Data { get; private set; } = new object[0];

            public ValidationResponse()
            {
                StatusCode = ValidationStatusCode.SUCCESS;
            }

            public ValidationResponse(ValidationStatusCode statusCode)
            {
                StatusCode = statusCode;
            }

            public ValidationResponse(ValidationStatusCode statusCode, params object[] data)
            {
                StatusCode = statusCode;
                Data = data;
            }

            public void SetData(params object[] data)
            {
                Data = data;
            }
        }

        public enum ValidationStatusCode
        {
            SUCCESS,
            INVALID_LENGTH,
            INVALID_VALUE,
            PLAYER_NOT_FOUND,
            VALUE_NOT_ALLOWED
        }
    }
}

namespace Oxide.Plugins
{
    partial class QualityCrafting : CovalencePlugin
    {
        public class LeaderboardRank
        {
            public string UserIdString { get; set; }

            public int Level { get; set; }

            [JsonIgnore]
            public string UserDisplayName
            {
                get
                {
                    return UserIdString == null ? string.Empty : BasePlayer.FindByID(ulong.Parse(UserIdString))?.displayName;
                }
            }
        }
    }
}

namespace Oxide.Plugins
{
    partial class QualityCrafting : CovalencePlugin
    {
        public class QualityItem
        {
            public QualityItem(Item item)
            {
                try
                {
                    string text = item.text;
                    if (string.IsNullOrEmpty(text))
                    {
                        Quality = 0;
                        UID = item.uid.Value;
                    }
                    else
                    {
                        Quality = int.Parse(text.Substring(0, 1));
                        if (text.Length > 1)
                        {
                            ulong uid = 0;
                            if (ulong.TryParse(text.Substring(1, text.Length - 1), out uid))
                            {
                                CreatorId = uid;
                            }
                        }
                    }
                } catch(Exception)
                {
                    Quality = 0;
                    UID = item.uid.Value;
                }
            }

            public ulong UID { get; private set; }
            public int Quality { get; private set; }
            public ulong? CreatorId { get; private set; } = null;

            [JsonIgnore]
            public bool HasCreator
            {
                get
                {
                    return CreatorId != null;
                }
            }

            [JsonIgnore]
            public string CreatorDisplayName
            {
                get
                {
                    return CreatorId == null ? string.Empty : BasePlayer.FindByID((ulong)CreatorId)?.displayName;
                }
            }
        }
    }
}

namespace Oxide.Plugins
{
    partial class QualityCrafting : CovalencePlugin
    {
        public class QualityItemStat
        {
            public string StatName { get; set; }
            public float PercentModified { get; set; }
        }
    }
}

namespace Oxide.Plugins
{
    partial class QualityCrafting : CovalencePlugin
    {
        public class CraftChance
        {
            public int Percent { get; set; }
            public int Quality { get; set; }
        }
    }
}


// --- End of file: QualityCrafting.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/quarry-manager ---
// --- Original File Path: Q/QuarryManager/QuarryManager.cs ---

/* 
 * TODO:
 * - Add clan support <- 2.0.4 (NEXT)
 * - Add friend support <- 2.0.4 (NEXT)
 * - Lock fuel tank, hopper/dispenser and quarry toggeling seperatly <- 2.0.5
 * - Quarry HP, repairs etc... <- 2.0.6
 * - Economics/RP support <- 2.0.6
 * - Discord support <- 2.0.7
 * - Proper help text if a player has a certain permission <- 2.0.8
 * - Quarry fuel consumption <- 2.0.8
 * - Static quarry team share support <- 2.0.9
 * - Static quarry friend share support <- 2.0.9
 * - Static quarry clan share support <- 2.0.9
 * - Static quarry added player support  <- 2.0.9
 * - More static quarry configuration options (like time until unlock after x amount of time, dome size etc.) <- 2.0.10
 * - Add chat icon <- 2.0.11
 * - Add UI <- 2.0.11
 * 
 * If you have suggestions my discord name is Enforcer#0696 or send it in the uMod help page :)
 */

using Newtonsoft.Json;
using Oxide.Core;
using Rust;
using System.Collections.Generic;
using System.Text;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Quarry Manager", "Enforcer", "2.0.3")]
    [Description("Manage a quarry that has been placed down")]
    class QuarryManager : RustPlugin
    {
        #region Fields 

        private static QuarryManager Instance { get; set; }

        public static List<StaticQuarry> staticQuarries = new List<StaticQuarry>();
        List<SphereEntity> sphereEntities = new List<SphereEntity>();

        StringBuilder addedPlayerList = new StringBuilder();

        bool teamAccess = false;
        bool addedPlayersAccess = false;

        static bool isStaticQuarryToggled { get; set; }
        static ulong staticQuarryToggler { get; set; }
        private static bool LockZone { get; set; }

        int count = 1;

        private const int layers = Layers.Mask.Default | Layers.Mask.Water | Layers.Solid;

        static MiningQuarry _quarry;

        #endregion

        #region Permissions

        // Permission to be able to use other commands
        private const string usePerm = "quarrymanager.use";

        // Permission for team sharing
        private const string teamLockPerm = "quarrymanager.teamshare";

        // Permission for individual player sharing
        private const string playerLockPerm = "quarrymanager.playershare";

        // Permission for players to be able to bypass the static quarry dome
        private const string allowBypassPerm = "quarrymanager.allowbypass";

        // Permission for admins
        private const string adminPerm = "quarrymanager.admin";

        #endregion

        #region Init

        private void OnServerInitialized()
        {
            // Register the permissions
            permission.RegisterPermission(usePerm, this);
            permission.RegisterPermission(teamLockPerm, this);
            permission.RegisterPermission(playerLockPerm, this);
            permission.RegisterPermission(allowBypassPerm, this);
            permission.RegisterPermission(adminPerm, this);

            // Add the command from the config
            cmd.AddChatCommand(config.commands.qmCommand, this, nameof(QuarryShareCommand));
        }

        private void Loaded()
        {
            // Load the data file
            LoadData();

            // Checks if static quarry is enabled before searching for the prefab (Searching through all entities is bad I will change that in the next update)
            if (config.shareSettings.staticQuarrySharing.enableStaticQuarryShare)
            {
                foreach (var entity in BaseNetworkable.serverEntities)
                {
                    FindStaticQuarry(entity);
                }
            }

            playerData = Interface.Oxide.DataFileSystem.ReadObject<PlayerData>(Name);

            Instance = this;

            LockZone = false;
            isStaticQuarryToggled = false;
        }

        void Unload()
        {
            // Destory all spheres and checks if static quarries are enabled (Again searching through alot of entities is bad I will change it in the next update)
            if (config.shareSettings.staticQuarrySharing.enableStaticQuarryShare)
            {
                foreach (var spheres in BaseNetworkable.serverEntities)
                {
                    var sphereE = spheres as SphereEntity;
                    if (sphereEntities.Contains(sphereE))
                    {
                        sphereE.Kill();
                    }
                }

                // Kills/destroys all existing static quarries
                foreach (var quarry in staticQuarries)
                {
                    if (staticQuarries.Contains(quarry))
                    {
                        StaticQuarry.Destroy(quarry);
                    }
                }
            }

            config = null;
        }

        void OnNewSave()
        {
            if (config.generalSettings.wipeDataOnNewSave)
            {
                WipeData();
            }
        }

        #endregion

        #region Config

        ConfigData config;
        private class ConfigData
        {
            [JsonProperty("General Settings")]
            public GeneralSettings generalSettings { get; set; }

            [JsonProperty("Commands")]
            public Commands commands { get; set; }

            [JsonProperty("Chat Settings")]
            public ChatSettings chatSettings { get; set; }

            [JsonProperty("Share Settings")]
            public ShareSettings shareSettings { get; set; }
        }

        public class GeneralSettings
        {
            [JsonProperty(PropertyName = "Wipe Data on new save")]
            public bool wipeDataOnNewSave { get; set; }
        }

        public class Commands
        {
            [JsonProperty(PropertyName = "Quarry Manager Command")]
            public string qmCommand { get; set; }
        }

        public class ChatSettings
        {
            [JsonProperty(PropertyName = "Chat prefix")]
            public string chatPrefix { get; set; }

            [JsonProperty(PropertyName = "Chat prefix colour")]
            public string chatPrefixColour { get; set; }

            [JsonProperty(PropertyName = "Chat icon")]
            public ulong chatIcon { get; set; }

            [JsonProperty("Quarry Share Messages")]
            public QuarryShareMessages quarryShareMessages { get; set; }

            [JsonProperty("RCON/Server Console Messages")]
            public ServerConsoleMessages serverConsoleMessages { get; set; }
        }

        public class QuarryShareMessages
        {
            [JsonProperty(PropertyName = "Print a message if team share is enabled")]
            public bool messageOnTeamShareEnabled { get; set; }

            [JsonProperty(PropertyName = "Print a message if team share is disabled")]
            public bool messageOnTeamShareDisabled { get; set; }

            [JsonProperty(PropertyName = "Print a message if a player is added to the share list")]
            public bool messageOnAddedToPlayerList { get; set; }

            [JsonProperty(PropertyName = "Print a message if a player is removed to the share list")]
            public bool messageOnRemovedFromPlayerList { get; set; }

            [JsonProperty(PropertyName = "Print a message if a player has activated a static quarry")]
            public bool messageOnStaticQuarryBeingUsed { get; set; }
        }

        public class ServerConsoleMessages
        {
            [JsonProperty(PropertyName = "Message the console if someone enables team share")]
            public bool messageRCONOnEnabledTeamShare { get; set; }

            [JsonProperty(PropertyName = "Message the console if someone disables team share")]
            public bool messageRCONOnDisableTeamShare { get; set; }

            [JsonProperty(PropertyName = "Message the console if someone is added to the share list")]
            public bool messageRCONOnAddedToShareList { get; set; }

            [JsonProperty(PropertyName = "Message the console if a player is removed to the share list")]
            public bool messageRCONOnRemovedToPlayerList { get; set; }

            [JsonProperty(PropertyName = "Message the console on static quarry lock activated")]
            public bool messageRCONOnStaticQuarryBeingUsed { get; set; }
        }

        public class ShareSettings
        {
            [JsonProperty(PropertyName = "Players can toggle other players quarries")]
            public bool canToggleQuarry { get; set; }

            [JsonProperty(PropertyName = "Lock quarry containers")]
            public bool canOpenQuarryContainers { get; set; }

            [JsonProperty("Team Sharing")]
            public TeamSharing teamSharing { get; set; }

            [JsonProperty("Individual Player Sharing")]
            public IndividualPlayerSharing individualPlayerSharing { get; set; }

            [JsonProperty("Static Quarry Sharing")]
            public StaticQuarrySharing staticQuarrySharing { get; set; }
        }

        public class TeamSharing
        {
            [JsonProperty(PropertyName = "Allow team to toggle the quarry")]
            public bool canTeamToggleQuarry { get; set; }

            [JsonProperty(PropertyName = "Allow team to open the quarries containers")]
            public bool canTeamOpenQuarry { get; set; }
        }

        public class IndividualPlayerSharing
        {
            [JsonProperty(PropertyName = "Allow added players to toggle the quarry")]
            public bool canAddedPlayersToggleQuarry { get; set; }

            [JsonProperty(PropertyName = "Allow added players to open the quarries containers")]
            public bool canAddedPlayersOpenQuarry { get; set; }

        }

        public class StaticQuarrySharing
        {
            [JsonProperty(PropertyName = "Enable static quarry lock")]
            public bool enableStaticQuarryShare { get; set; }

            [JsonProperty("Static Quarry Sharing")]
            public LocalSharing localSharing { get; set; }
        }

        public class LocalSharing
        {
            [JsonProperty(PropertyName = "If the player leaves the dome unlock the static quarry")]
            public bool unlockStaticQuarryOnExitDome { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                for (var i = 0; i < 3; i++) PrintError($"{Name}.json is corrupted! Recreating a new configuration");
                LoadDefaultConfig();
                return;
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData()
            {
                generalSettings = new GeneralSettings()
                {
                    wipeDataOnNewSave = true
                },

                commands = new Commands()
                {
                    qmCommand = "qm"
                },

                chatSettings = new ChatSettings()
                {
                    chatPrefix = "QuarryLocker >>",
                    chatPrefixColour = "#FF6A13",
                    chatIcon = 0,

                    quarryShareMessages = new QuarryShareMessages()
                    {
                        messageOnTeamShareEnabled = true,
                        messageOnTeamShareDisabled = true,
                        messageOnAddedToPlayerList = true,
                        messageOnRemovedFromPlayerList = true,
                        messageOnStaticQuarryBeingUsed = true
                    },

                    serverConsoleMessages = new ServerConsoleMessages()
                    {
                        messageRCONOnEnabledTeamShare = false,
                        messageRCONOnDisableTeamShare = false,
                        messageRCONOnAddedToShareList = false,
                        messageRCONOnRemovedToPlayerList = false,
                        messageRCONOnStaticQuarryBeingUsed = false
                    }
                },

                shareSettings = new ShareSettings()
                {
                    canToggleQuarry = false,
                    canOpenQuarryContainers = false,
                    teamSharing = new TeamSharing()
                    {
                        canTeamToggleQuarry = true,
                        canTeamOpenQuarry = true
                    },
                    individualPlayerSharing = new IndividualPlayerSharing()
                    {
                        canAddedPlayersToggleQuarry = true,
                        canAddedPlayersOpenQuarry = true
                    },

                    staticQuarrySharing = new StaticQuarrySharing()
                    {
                        enableStaticQuarryShare = false,

                        localSharing = new LocalSharing()
                        {
                            unlockStaticQuarryOnExitDome = false
                        }
                    }
                }
            };

            PrintError("Creating a new configuration file!");
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Data 


        private PlayerData playerData;
        public class PlayerData
        {
            public Dictionary<ulong, User> players = new Dictionary<ulong, User>();

            public User AddPlayer(ulong playerID, bool isTeamShareEnabled, Dictionary<ulong, string> addedPlayers)
            {
                User player = new User();
                players.Add(playerID, player);
                isTeamShareEnabled = player.EnabledTeamShare;
                addedPlayers = player.addedPlayers;
                return player;
            }
            public bool GetPlayer(ulong playerID)
            {
                if (players.ContainsKey(playerID))
                {
                    return true;
                }

                return false;
            }
        }

        public class User
        {
            public bool EnabledTeamShare;
            public Dictionary<ulong, string> addedPlayers = new Dictionary<ulong, string>();

        }

        void LoadData()
        {
            // If the data does not exist then just make a new one
            try
            {
                playerData = Interface.Oxide.DataFileSystem.ReadObject<PlayerData>(Name);
            }
            catch
            {
                Puts("QuarryManager.json was not found! Creating a new one.");
                playerData = new PlayerData();
            }
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, playerData);
        }

        private void WipeData()
        {
            if (playerData == null)
                return;
            
                PrintWarning("[QuarryManager]: QuarryManager.json has been wiped!");
                playerData.players.Clear();
            
        }

        #endregion

        #region Lang

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
                {
                    {"Info.Help", $"\n /{config.commands.qmCommand} h | help - Provides the following commands: \n /{config.commands.qmCommand} t | team - Enable/Disable quarry team share. \n /{config.commands.qmCommand} a | add - Adds a certain player that can access your quarry \n /{config.commands.qmCommand} r | remove - Removes a certain added player that can access your quarry \n /{config.commands.qmCommand} ra | removeall - Removes all added players that can access your quarry \n /{config.commands.qmCommand} l | list - Lists all added players that can access your quarry" },
                    {"Info.TeamSharingEnabled", "Your team can now access your quarry" },
                    {"Info.TeamSharingDisabled", "Your team can no longer access your quarry" },
                    {"Info.AddedPlayer", "{0} Can now access your quarries" },
                    {"Info.RemovedPlayer", "{0} Can no longer access your quarries" },
                    {"Info.RemovedAllPlayers", "No one can access your quarries that you have added" },
                    {"Info.NoAddedPlayers", "There are no players to list since you have not added any yet" },
                    {"Info.ListCurrentPlayers", "Players that are added that can access your quarries:\n{0}" },
                    {"Info.StaticQuarryActivated", "No one can access this quarry unless you leave the dome or the quarries fuel runs out" },
                    {"Info.MessageRconOnTeamShareEnabled", "{0}, enabled team share!"},
                    {"Info.MessageRconOnTeamShareDisabled", "{0}, disabled team share!"},
                    {"Info.MessageRconOnPlayerAdded", "{0}, added {1}"},
                    {"Info.MessageRconOnPlayerRemoved", "{0}, removed {1}"},
                    {"Info.MessageRconOnStaticQuarryActivated", "The static quarry has been activated at: {0} by {1}" },
                    {"Warning.NoPermission", "You don't have the required permissions to use this command" },
                    {"Warning.UnableToFindPlayer", "Unable to find the player!" },
                    {"Warning.UnableToAddSelf", "You cannot add yourself" },
                    {"Warning.UnableToAccessContainer", "You cannot access this quarry, since you are not authorized on it" },
                    {"Warning.UnableToToggleEngine", "You are unable able to toggle {0}'s quarry" },
                    {"Warning.NoTeamFound", "You cannot use this command since you don't have a team" },
                }, this, "en");
        }

        #endregion

        #region Helpers

        // Checks if player is an admin using a permission
        private bool IsAdmin(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, adminPerm))
                return true;

            return false;
        }

        private void Message(string message, BasePlayer player, params string[] args) => SendReply(player, lang.GetMessage($"<color={config.chatSettings.chatPrefixColour}>{config.chatSettings.chatPrefix}</color> {message}", this), args);

        private void MessageConsole(string message, params string[] args) => PrintWarning(lang.GetMessage($"{config.chatSettings.chatPrefix} {message}", this), args);

        #endregion

        #region Commands

        // The command that is listed in the config
        void QuarryShareCommand(BasePlayer bPlayer, string command, params string[] args)
        {
            // If the player just types /qm or the length is 0 meaning if it is not /qm add or something like that then send them a help message
            if (args == null || args.Length == 0)
            {
                // Checks if has permission
                if (!permission.UserHasPermission(bPlayer.UserIDString, usePerm))
                {
                    Message(lang.GetMessage("Warning.NoPermission", this, bPlayer.UserIDString), bPlayer);
                    return;
                }

                Message(lang.GetMessage("Info.Help", this, bPlayer.UserIDString), bPlayer);
                return;
            }

            // We don't want the player trying to toggle team share without a team (if you change the team sub command then make sure you change this)
            if (args.Contains("team") || args.Contains("t"))
            {
                // Checks if has permission
                if (!permission.UserHasPermission(bPlayer.UserIDString, teamLockPerm))
                {
                    Message(lang.GetMessage("Warning.NoPermission", this, bPlayer.UserIDString), bPlayer);
                    return;
                }

                // Checks they don't have a team
                if (bPlayer.currentTeam == 0)
                {
                    Message(lang.GetMessage("Warning.NoTeamFound", this, bPlayer.UserIDString), bPlayer);
                    return;
                }
            }

            switch (args[0].ToLower())
            {
                case "h":
                case "help":

                    // Checks if has permission
                    if (!permission.UserHasPermission(bPlayer.UserIDString, usePerm))
                    {
                        Message(lang.GetMessage("Warning.NoPermission", this, bPlayer.UserIDString), bPlayer);
                        return;
                    }

                    Message(lang.GetMessage("Info.Help", this, bPlayer.UserIDString), bPlayer);

                    return;

                // If you change the team commands (t or team) make sure you change the ones on line 541 as well if you don't then it will not work as intended
                case "t":
                case "team":

                    // Checks if has permission
                    if (!permission.UserHasPermission(bPlayer.UserIDString, teamLockPerm))
                    {
                        Message(lang.GetMessage("Warning.NoPermission", this, bPlayer.UserIDString), bPlayer);
                        return;
                    }

                    // Checks if the player is not in the data file
                    if (!playerData.GetPlayer(bPlayer.userID))
                    {
                        playerData.AddPlayer(bPlayer.userID, false, null);
                        SaveData();
                    }

                    // Checks if the player has enabled team share
                    if (playerData.players[bPlayer.userID].EnabledTeamShare)
                    {
                        if (config.chatSettings.quarryShareMessages.messageOnTeamShareEnabled)
                        {
                            Message(lang.GetMessage("Info.TeamSharingDisabled", this, bPlayer.UserIDString), bPlayer);
                        }

                        if (config.chatSettings.serverConsoleMessages.messageRCONOnEnabledTeamShare)
                        {
                            MessageConsole(lang.GetMessage("Info.MessageRconOnTeamShareDisabled", this, bPlayer.UserIDString), bPlayer.displayName);

                        }

                        playerData.players[bPlayer.userID].EnabledTeamShare = false;
                        SaveData();
                    }
                    else
                    {
                        // Now checks if the player has disabled team share
                        if (config.chatSettings.quarryShareMessages.messageOnTeamShareDisabled)
                        {
                            Message(lang.GetMessage("Info.TeamSharingEnabled", this, bPlayer.UserIDString), bPlayer);
                        }

                        if (config.chatSettings.serverConsoleMessages.messageRCONOnDisableTeamShare)
                        {
                            MessageConsole(lang.GetMessage("Info.MessageRconOnTeamShareEnabled", this, bPlayer.UserIDString), bPlayer.displayName);

                        }

                        playerData.players[bPlayer.userID].EnabledTeamShare = true;
                        SaveData();
                    }

                    return;

                case "a":
                case "add":

                    // Checks if has permission
                    if (!permission.UserHasPermission(bPlayer.UserIDString, playerLockPerm))
                    {
                        Message(lang.GetMessage("Warning.NoPermission", this, bPlayer.UserIDString), bPlayer);
                        return;
                    }

                    // Checks if the player is not in the data file
                    if (!playerData.GetPlayer(bPlayer.userID))
                    {
                        playerData.AddPlayer(bPlayer.userID, false, null);
                        SaveData();
                    }

                    // Checks if the player is trying to add 2 players. Eg: /qm add enforcer player1 <- Arg 2 (I will probably add the ability to add multiple players)
                    if (args.Length != 2)
                    {
                        Message(lang.GetMessage("Warning.UnableToFindPlayer", this, bPlayer.UserIDString), bPlayer);
                        return;
                    }

                    AddOrRemoveUser(bPlayer, true, false, args);

                    return;

                case "r":
                case "remove":

                    // Checks if has permission
                    if (!permission.UserHasPermission(bPlayer.UserIDString, playerLockPerm))
                    {
                        Message(lang.GetMessage("Warning.NoPermission", this, bPlayer.UserIDString), bPlayer);
                        return;
                    }

                    // Checks if the player is not in the data file
                    if (!playerData.GetPlayer(bPlayer.userID))
                    {
                        playerData.AddPlayer(bPlayer.userID, false, null);
                        SaveData();
                    }

                    // Checks if the player is trying to remove 2 players. Eg: /qm remove enforcer player1 <- Arg 2 (I will probably add the ability to remove multiple players)
                    if (args.Length != 2)
                    {
                        Message(lang.GetMessage("Warning.UnableToFindPlayer", this, bPlayer.UserIDString), bPlayer);
                        return;
                    }

                    AddOrRemoveUser(bPlayer, false, true, args);

                    return;

                case "ra":
                case "removeall":

                    // Checks if has permission
                    if (!permission.UserHasPermission(bPlayer.UserIDString, playerLockPerm))
                    {
                        Message(lang.GetMessage("Warning.NoPermission", this, bPlayer.UserIDString), bPlayer);
                        return;
                    }

                    // Checks if the player is not in the data file
                    if (!playerData.GetPlayer(bPlayer.userID))
                    {
                        playerData.AddPlayer(bPlayer.userID, false, null);
                        SaveData();
                    }

                    // If the player added no one then just return it
                    if (playerData.players[bPlayer.userID].addedPlayers.Count == 0)
                        return;
                    
                    // Clears the concurrent players
                    playerData.players[bPlayer.userID].addedPlayers.Clear();
                    addedPlayersAccess = false;

                    Message(lang.GetMessage("Info.RemovedAllPlayers", this, bPlayer.UserIDString), bPlayer);

                    SaveData();

                    return;

                case "l":
                case "list":

                    // Checks if has permission
                    if (!permission.UserHasPermission(bPlayer.UserIDString, playerLockPerm))
                    {
                        Message(lang.GetMessage("Warning.NoPermission", this, bPlayer.UserIDString), bPlayer);
                        return;
                    }

                    // Checks if the player is not in the data file
                    if (!playerData.GetPlayer(bPlayer.userID))
                    {
                        playerData.AddPlayer(bPlayer.userID, false, null);
                        SaveData();
                    }

                    // Again checking if the player has no one added and prints a message and returns
                    if (playerData.players[bPlayer.userID].addedPlayers.Count == 0)
                    {
                        Message(lang.GetMessage("Info.NoAddedPlayers", this, bPlayer.UserIDString), bPlayer);
                        return;
                    }

                    // Gets all added players and print it out. Count by index and if that player meets that index value then print their name
                    foreach (var addedPlayer in playerData.players[bPlayer.userID].addedPlayers)
                    {
                        addedPlayerList.Append($"{count}. {addedPlayer.Value}\n");
                        count++;
                    }

                    Message(lang.GetMessage("Info.ListCurrentPlayers", this, bPlayer.UserIDString), bPlayer, addedPlayerList.ToString());

                    return;

                    // This area is to check if the player did something like /qm test. Since the sub command test does not exist then just send them to this area 
                default:

                    // Checks if the player has the required permission
                    if (!permission.UserHasPermission(bPlayer.UserIDString, usePerm))
                    {
                        Message(lang.GetMessage("Warning.NoPermission", this, bPlayer.UserIDString), bPlayer);
                        return;
                    }

                    Message(lang.GetMessage("Info.Help", this, bPlayer.UserIDString), bPlayer);

                    return;
            }
        }

        #endregion

        #region Hooks 

        // Oxide hook to check if the player is able to loot the container of the quarry 
        object CanLootEntity(BasePlayer bPlayer, ResourceExtractorFuelStorage container)
        {
            // Checks if the quarry container id is equalled to 0 or the player is an admin
            if (container.OwnerID == 0 || IsAdmin(bPlayer))
                return null;

            if (container.OwnerID != bPlayer.userID)
            {
                if (!config.shareSettings.canOpenQuarryContainers)
                    return null;

                if(playerData.players.ContainsKey(container.OwnerID))
                {
                    teamAccess = playerData.players[container.OwnerID].EnabledTeamShare;

                    if (teamAccess)
                    {
                        if (config.shareSettings.teamSharing.canTeamOpenQuarry)
                        {
                            if (BasePlayer.FindAwakeOrSleeping(container.OwnerID.ToString()).currentTeam != bPlayer.currentTeam)
                                return true;

                            // Returning true does not allow them to loot the containers. Returning null allows them to loot the containers
                            if (playerData.players[container.OwnerID].EnabledTeamShare)
                            {
                                return null;
                            }
                            else
                            {
                                Message(lang.GetMessage("Warning.UnableToAccessContainer", this, bPlayer.UserIDString), bPlayer/*, config.chatsettings.chaticon*/);
                                return true;
                            }

                        }
                    }

                    if (!addedPlayersAccess)
                    {
                        if (playerData.players[container.OwnerID].addedPlayers.Count == 0)
                        {
                            addedPlayersAccess = false;
                        }
                        else
                        {
                            addedPlayersAccess = true;
                        }
                    }

                    if (addedPlayersAccess)
                    {
                        if (config.shareSettings.individualPlayerSharing.canAddedPlayersOpenQuarry)
                        {
                            if (playerData.players[container.OwnerID].addedPlayers.ContainsKey(bPlayer.userID))
                            {
                                return null;
                            }
                            else
                            {
                                Message(lang.GetMessage("Warning.UnableToAccessContainer", this, bPlayer.UserIDString), bPlayer/*, config.chatsettings.chaticon*/);
                                return true;
                            }
                        }
                    }
                }

                Message(lang.GetMessage("Warning.UnableToAccessContainer", this, bPlayer.UserIDString), bPlayer/*, config.chatsettings.chaticon*/);
                return true;
            }

            return null;
        }

        private void OnQuarryToggled(MiningQuarry quarry, BasePlayer bPlayer)
        {
            // Static quarry part

            // Checks if the quarry is static
            if (quarry.isStatic)
            {
                if (!LockZone)
                {
                    if (quarry.IsOn())
                    {
                        // Locks the zone using an ejector component (StaticQuarry) class
                        isStaticQuarryToggled = true;
                        staticQuarryToggler = bPlayer.userID;

                        LockZone = true;

                        if (config.chatSettings.quarryShareMessages.messageOnStaticQuarryBeingUsed)
                        {
                            Message(lang.GetMessage("Info.StaticQuarryActivated", this, bPlayer.UserIDString), bPlayer/*, config.chatsettings.chaticon*/);
                        }

                        if (config.chatSettings.serverConsoleMessages.messageRCONOnStaticQuarryBeingUsed)
                        {
                            MessageConsole(lang.GetMessage("Info.MessageRconOnStaticQuarryActivated", this, bPlayer.UserIDString), quarry.transform.position.ToString(), bPlayer.displayName);
                        }

                        return;
                    }
                }
            }
            else
            {
                // Normal quarry part

                if (config.shareSettings.canToggleQuarry)
                    return;

                if (quarry == null)
                    return;

                if (quarry.OwnerID == 0 || quarry.OwnerID == bPlayer.userID || IsAdmin(bPlayer))
                    return;

                // Had to do this part since people were able to loot the quarry some how for some reason. This just gets the item and checks if it inside the quarry
                var item = quarry.fuelStoragePrefab.instance.GetComponent<StorageContainer>().inventory.FindItemsByItemName("lowgradefuel");

                if (item == null)
                {
                    Message(lang.GetMessage("Warning.UnableToAccessContainer", this, bPlayer.UserIDString), bPlayer/*, config.chatsettings.chaticon*/);
                    return;
                }

                teamAccess = playerData.players[quarry.OwnerID].EnabledTeamShare;

                if (teamAccess)
                {
                    if (config.shareSettings.teamSharing.canTeamToggleQuarry)
                    {
                        // Checks if the player is inside the quarry owners team
                        if (BasePlayer.FindAwakeOrSleeping(quarry.OwnerID.ToString()).currentTeam == bPlayer.currentTeam)
                        {
                            if (playerData.players[quarry.OwnerID].EnabledTeamShare)
                                return;
                            else
                            {
                                quarry.SetOn(!quarry.IsOn());
                                Message(lang.GetMessage("Warning.UnableToAccessContainer", this, bPlayer.UserIDString), bPlayer/*, config.chatsettings.chaticon*/);
                            }
                        }
                    }
                }

                if (!addedPlayersAccess)
                {
                    if (playerData.players[quarry.OwnerID].addedPlayers.Count == 0)
                    {
                        addedPlayersAccess = false;
                    }
                    else
                    {
                        addedPlayersAccess = true;
                    }
                }

                if (addedPlayersAccess)
                {
                    if (config.shareSettings.individualPlayerSharing.canAddedPlayersToggleQuarry)
                    {
                        if (!playerData.players[quarry.OwnerID].addedPlayers.ContainsKey(bPlayer.userID))
                        {
                            quarry.SetOn(!quarry.IsOn());
                            Message(lang.GetMessage("Warning.UnableToAccessContainer", this, bPlayer.UserIDString), bPlayer/*, config.chatsettings.chaticon*/);
                        }
                        else
                        {
                            return;
                        }
                    }
                }

                quarry.SetOn(!quarry.IsOn());

                // There was a bug that could drain peoples fuel when toggled and so I just plus it so it does not happen. This is for someone who tries to access it without the correct conditions met
                item.amount++;
                Message(lang.GetMessage("Warning.UnableToAccessContainer", this, bPlayer.UserIDString), bPlayer/*, config.chatsettings.chaticon*/);
            }
        }

        #endregion

        #region Functions  

        // I will make this better and allow non caps. It is currently case sensitive
        public BasePlayer FindPlayer(string nameOrID)
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player.userID.ToString() == nameOrID)
                    return player;

                if (player.displayName == nameOrID)
                    return player;

                if (player.name.Contains(nameOrID))
                    return player;
            }

            return null;
        }

        // Adds or remove user
        private void AddOrRemoveUser(BasePlayer player, bool isAdding, bool isRemoving, string[] args)
        {
            var user = FindPlayer(args[1]);

            if (isAdding)
            {
                if (user.userID == player.userID)
                {
                    Message(lang.GetMessage("Warning.UnableToAddSelf", this, player.UserIDString), player);
                    return;
                }

                if (user == null)
                {
                    Message(lang.GetMessage("Warning.UnableToFindPlayer", this, player.UserIDString), player, user.displayName);
                    return;
                }

                if (playerData.players[player.userID].addedPlayers.ContainsKey(user.userID))
                {
                    Message(lang.GetMessage("Warning.AlreadyAdded", this, player.UserIDString), player, user.displayName);
                    return;
                }

                playerData.players[player.userID].addedPlayers.Add(user.userID, user.displayName);
                SaveData();

                if (config.chatSettings.quarryShareMessages.messageOnAddedToPlayerList)
                {
                    Message(lang.GetMessage("Info.AddedPlayer", this, player.UserIDString), player, user.displayName);
                }

                if (config.chatSettings.serverConsoleMessages.messageRCONOnAddedToShareList)
                {
                    MessageConsole(lang.GetMessage("Info.MessageRconOnPlayerAdded", this, player.UserIDString), player.displayName, user.displayName);
                }

                return;
            }

            if (isRemoving)
            {
                if (playerData.players[player.userID].addedPlayers.Count == 0)
                    return;

                if (!playerData.players[player.userID].addedPlayers.ContainsKey(user.userID))
                    return;

                playerData.players[player.userID].addedPlayers.Remove(user.userID);
                SaveData();

                if (config.chatSettings.quarryShareMessages.messageOnRemovedFromPlayerList)
                {
                    Message(lang.GetMessage("Info.RemovedPlayer", this, player.UserIDString), player, user.displayName);
                }

                if (config.chatSettings.serverConsoleMessages.messageRCONOnRemovedToPlayerList)
                {
                    MessageConsole(lang.GetMessage("Info.MessageRconOnPlayerRemoved", this, player.UserIDString), player.displayName, user.displayName);
                }

                return;
            }
        }

        // Random thing I made to check if the user is inside added players
        //private bool IsUserValid(BasePlayer player, string[] args)
        //{
        //    var user = FindPlayer(args[1]);

        //    if (playerData.players[player.userID].addedPlayers.ContainsKey(user.userID))
        //    {
        //        return true;
        //    }

        //    return false;
        //}

        // Gets the entity
        private static BaseEntity GetEntity(Collider collider)
        {
            var entity = collider.ToBaseEntity();

            while (entity != null && entity.HasParent() && !(entity is BaseMountable) && !(entity is BasePlayer))
            {
                entity = entity.GetParentEntity();
            }

            return entity;
        }

        // Credits to ZoneManager for some of this part
        public static Vector3 MoveLocation(Vector3 position, float distance, Vector3 target, float radius, float yAmount)
        {
            var location = ((position.XZ3D() - target.XZ3D()).normalized * (distance + radius)) + target;

            var y = TerrainMeta.HighestPoint.y + 300f;

            RaycastHit raycast;
            if (Physics.Raycast(new Ray(new Vector3(0f, y, 0f), Vector3.down), out raycast, 500, layers, QueryTriggerInteraction.Ignore))
            {
                location.y = raycast.point.y + yAmount;
            }
            else location.y = TerrainMeta.HeightMap.GetHeight(location) + yAmount;

            return location;
        }

        // Moves the player
        public static bool MovePlayer(BasePlayer bPlayer, Vector3 pos)
        {
            // Checks if the player is sleeping
            if (bPlayer.IsSleeping())
            {
                return false;
            }

            // Gets the move position
            var movePos = MoveLocation(bPlayer.transform.position, 5f, pos, 30f, 1f);

            // Checks if the player is flying
            if (bPlayer.IsFlying)
            {
                pos.y = bPlayer.transform.position.y;
            }

            // Teleports the player
            bPlayer.Teleport(movePos);
            bPlayer.SendNetworkUpdateImmediate();

            return true;
        }

        // Moves the mountable 
        public static bool MoveMountable(BaseMountable bMountable, Vector3 pos, float distance, float radius)
        {
            BaseVehicle vehicle = bMountable as BaseVehicle;
            var movePos = MoveLocation(bMountable.transform.position, distance, pos, radius, 10f);

            // Checks if vehicle is null or destoryed 
            if (vehicle == null || vehicle.IsDestroyed)
                return false;

            bMountable.transform.position = movePos;

            return true;
        }

        // A check to see if the static quarry contains fuel
        private static bool IsStaticQuarryContainsFuel(MiningQuarry quarry)
        {
            var fuelItem = quarry.fuelStoragePrefab.instance.GetComponent<StorageContainer>().inventory.FindItemsByItemName("lowgradefuel");

            if (quarry.isStatic)
            {
                if (fuelItem == null)
                    return false;

                return true;
            }

            return false;
        }


        #endregion

        #region Static Quarry

        // Finds the quarry
        void FindStaticQuarry(BaseNetworkable entity)
        {
            // Checks if entity is null
            if (entity == null)
                return;

            // Gets the component since BaseNetworkable does not have it 
            var quarry = entity.GetComponent<MiningQuarry>();

            // Checks if the quarry is a quarry. Probably should just do if(quarry) instead of that.
            if (quarry is MiningQuarry)
            {
                // Checks if the quarry is static
                if (quarry.isStatic)
                {
                    // Create a sphere. Will add an option in cofig to change how big it should be or if it should be enabled/disabled.
                    CreateSphere(entity.transform.position, 60f);

                    // Makes the collider. The reason it is 30 meters is because for some reason the collider was way out of where it should be (it was too big).
                    StaticQuarry.Init(entity.transform.position, 30f);
                }
            }
        }

        void CreateSphere(Vector3 spherePosition, float radius)
        {
            // Create sphere
            var sphere = GameManager.server.CreateEntity("assets/prefabs/visualization/sphere.prefab", spherePosition, Quaternion.identity) as SphereEntity;

            // Check if it is null 
            if (sphere == null)
                return;

            var sphereEntity = sphere.GetComponent<SphereEntity>();

            sphereEntity.currentRadius = radius;
            sphereEntity.lerpSpeed = 0f;

            // Spawn it
            sphere.Spawn();

            // Add it to the list
            sphereEntities.Add(sphere);
        }

        // Ejector component
        public class StaticQuarry : MonoBehaviour
        {
            private static StaticQuarry staticQuarry;
            private GameObject _gameObject;

            private float colRadius;

            // When creating a sphere and expecting something to happen it is not the actual sphere is it a collider. Below is how we make it

            // Credits to RaidableBases for Init()
            public static void Init(Vector3 position, float radius)
            {
                GameObject gameObject;

                if (staticQuarry == null)
                {
                    gameObject = new GameObject();

                    staticQuarry = gameObject.AddComponent<StaticQuarry>();
                    staticQuarry._gameObject = gameObject;
                }
                else
                {
                    gameObject = staticQuarry._gameObject;
                }

                // Sets the position
                gameObject.transform.position = staticQuarry._gameObject.transform.position = position;
                gameObject.layer = (int) Layer.Trigger;

                // Add a sphere colider to it 
                var col = gameObject.AddComponent<SphereCollider>();

                // Make sure the center of the collider is zero and is in the actual center
                col.center = Vector3.zero;

                // Set the radius 
                col.radius = staticQuarry.colRadius = radius;

                // Make it a trigger
                col.isTrigger = true;

                // Add the component to the static quarries list
                staticQuarries.Add(staticQuarry);
            }

            // Called when a player enters the collider
            private void OnTriggerEnter(Collider collider)
            {
                if (collider == null)
                    return;

                // Gets the collider
                var entity = GetEntity(collider);

                // Checks if the entity is a player 
                if (entity is BasePlayer)
                {
                    var bP = entity as BasePlayer;

                    if (IsBypassAllowed(bP))
                    {
                        return;
                    }

                    if (isStaticQuarryToggled)
                    {
                        // If the quarry toggler does not equal the player who is trying to enter steam ID then move the player but first check if the zone is locked 
                        if (staticQuarryToggler != bP.userID)
                        {
                            if (LockZone)
                            {
                                MovePlayer(bP, staticQuarry.gameObject.transform.position);

                                // Needed because sometimes the actual thing that we are trying to do does not happen on client
                                bP.SendNetworkUpdateImmediate();
                            }
                        }
                        else
                        {
                            return;
                        }
                    }
                }

                // Check if entity is a mountable
                if (entity is BaseMountable)
                {
                    var bM = entity as BaseMountable;

                    // Get the mounted player
                    var bPlayer = bM.GetMounted();
                    var mountedPlayer = new List<BasePlayer>();

                    // Adds the monuted player to the list above 
                    mountedPlayer.Add(bPlayer);

                    // Checks if the player is in the list
                    if (mountedPlayer.Contains(bPlayer))
                    {
                        // Check if the zone is locked meaning able to enter and wont push the player back
                        if (LockZone)
                        {
                            // Move and send an update 
                            MoveMountable(bM, staticQuarry.gameObject.transform.position, 5f, 30f);
                            bM.SendNetworkUpdateImmediate();
                        }
                    }
                    else
                    {
                        return;
                    }
                }
            }

            // Called when a player leaves the collider
            private void OnTriggerExit(Collider collider)
            {
                if (collider == null)
                    return;

                // Get the collider in this case static quarry
                var entity = GetEntity(collider);

                // Checks if the entity is a player. This part is pretty straight forward.
                if (entity is BasePlayer)
                {
                    var bP = entity as BasePlayer;

                    if (Instance.config.shareSettings.staticQuarrySharing.localSharing.unlockStaticQuarryOnExitDome)
                    {
                        if (staticQuarryToggler == bP.userID)
                        {
                            LockZone = false;
                            staticQuarryToggler = 0;
                        }
                        else
                        {
                            return;
                        }

                    }
                }

                if (entity is BaseMountable)
                {
                    var bM = entity as BaseMountable;
                    var bP = entity as BasePlayer;

                    var bPlayer = bM.GetMounted();
                    var mountedPlayer = new List<BasePlayer>();
                    mountedPlayer.Add(bPlayer);

                    if (bP.isMounted && entity is BaseMountable)
                    {
                        if (Instance.config.shareSettings.staticQuarrySharing.localSharing.unlockStaticQuarryOnExitDome)
                        {
                            if (!mountedPlayer.Contains(bP) && staticQuarryToggler != bP.userID)
                            {
                                LockZone = false;
                                staticQuarryToggler = 0;
                            }
                            else
                            {
                                return;
                            }
                        }
                    }
                }
            }

            // A bypass check. If those things in the return are true then allow them to bypass/go through the sphere.
            private bool IsBypassAllowed(BasePlayer player)
            {
                return Instance.permission.UserHasPermission(player.UserIDString, "quarrymanager.allowbypass") || player.limitNetworking;
            }
        }

        #endregion
    }
}

// --- End of file: QuarryManager.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/stash-warning ---
// --- Original File Path: S/StashWarning/StashWarning.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Stash Warning", "haggbart", "1.3.5")]
    [Description("Logs suspicious stash activity and reports to admins ingame and on discord")]
    internal class StashWarning : RustPlugin
    {
        [PluginReference] Plugin DiscordMessages;
        private const string WEBHOOK_URL = "Webhook URL";
        private const string MESSAGE = "Warning message";
        private const string NO_RECENT_WARNING = "No recent warning";
        private const string IGNORE_SAME_TEAM = "Ignore players in the same team";
        
        private string _webhookUrl;
        private bool _discordEnabled;
        private Vector3 position;
        private string message;
        
        protected override void LoadDefaultConfig()
        {
            Puts("Creating a new configuration file");
            Config[WEBHOOK_URL] = "";
            Config[IGNORE_SAME_TEAM] = true;
        }
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [MESSAGE] = "{0} ({1}) found a stash that belongs to {2} ({3}) in {4} {5}.",
                [NO_RECENT_WARNING] = "No recent warning. No location to teleport to."
            }, this);
        }
        
        private void Init()
        {
            _webhookUrl = Config[WEBHOOK_URL].ToString();
            if (!string.IsNullOrEmpty(_webhookUrl))
            {
                _discordEnabled = true;
            }
        }
        
        private void CanSeeStash(BasePlayer player, StashContainer stash)
        {
            if (stash.inventory.itemList.Count == 0 || player.userID == stash.OwnerID) return;

            
            if ((bool) Config[IGNORE_SAME_TEAM] && IsTeamMember(player, stash))
            {
                if (player.IsAdmin)
                {
                    SendReply(player, "sameteam: " + IsTeamMember(player, stash));
                }
                return;
            }
            
            IPlayer iPlayerOwner = covalence.Players.FindPlayerById(stash.OwnerID.ToString());
            AddWarning(player, iPlayerOwner);
            foreach (BasePlayer target in BasePlayer.activePlayerList.Where(x => x.IsAdmin))
            {
                SendReply(target, message, player);
            }
            LogToFile(string.Empty, message, this); 
            if (_discordEnabled)
                DiscordMessages?.Call("API_SendTextMessage", _webhookUrl, message);
        }

        private bool IsTeamMember(BasePlayer player, StashContainer stash)
        {
            if (!(bool)Config[IGNORE_SAME_TEAM]) return false;
            RelationshipManager.PlayerTeam team = RelationshipManager.ServerInstance.FindPlayersTeam(stash.OwnerID);
            
            if (team == null)
            {
                return false;
            }
            
            return team.teamID == player.currentTeam;
        }

        private void AddWarning(BasePlayer player, IPlayer iPlayerOwner, BasePlayer target = null)
        {
            position = player.transform.position;
            message = target == null ? lang.GetMessage(string.Format(MESSAGE), this) : lang.GetMessage(string.Format(MESSAGE), this, target.UserIDString);
            message = string.Format(message, player.displayName, player.userID, iPlayerOwner?.Name ?? "Unknown", iPlayerOwner?.Id ?? "Unknown", GridReference(position), position);
        }

        private static string GridReference(Vector3 pos)
        {
            int worldSize = ConVar.Server.worldsize;
            const float scale = 150f;
            float x = pos.x + worldSize/2f;
            float z = pos.z + worldSize/2f;
            var lat = (int)(x / scale);
            var latChar = (char)('A' + lat);
            var lon = (int)(worldSize/scale - z/scale);
            return $"{latChar}{lon}";
        }

        [ChatCommand("sw")] 
        private void TeleportLast(BasePlayer player)
        {
            if (!player.IsAdmin || !player.IsAlive()) return;
            if (message == null)
            {
                SendReply(player, lang.GetMessage(NO_RECENT_WARNING, this, player.UserIDString));
                return;
            }
            SendReply(player, message);
            player.Teleport(position);
        }
    }
}

// --- End of file: StashWarning.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/stack-size-controller ---
// --- Original File Path: S/StackSizeController/StackSizeController.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Stack Size Controller", "AnExiledDev/patched by chrome", "4.1.3")]
    [Description("Allows configuration of most items max stack size.")]
    class StackSizeController : CovalencePlugin
    {
        [PluginReference]
        Plugin AirFuel, GetToDaChoppa, VehicleVendorOptions;

        private const string _vanillaDefaultsUri = "https://raw.githubusercontent.com/AnExiledDev/StackSizeController/master/vanilla-defaults.json";

        private Configuration _config;
        private Dictionary<string, int> _vanillaDefaults;

        private readonly List<string> _ignoreList = new List<string>
        {
            "water",
            "water.salt",
            "cardtable",
            "hat.bunnyhat",
            "rustige_egg_e"
        };

        private void Init()
        {
            _config = Config.ReadObject<Configuration>();

            if (_config == null)
            {
                Log("Generating Default Config File.");

                LoadDefaultConfig();
            }

            DownloadVanillaDefaults();
            EnsureConfigIntegrity();

            AddCovalenceCommand("stacksizecontroller.setstack", nameof(SetStackCommand),
                "stacksizecontroller.setstack");
            AddCovalenceCommand("stacksizecontroller.setstackcat", nameof(SetStackCategoryCommand),
                "stacksizecontroller.setstackcat");
            AddCovalenceCommand("stacksizecontroller.setallstacks", nameof(SetAllStacksCommand),
                "stacksizecontroller.setallstacks");
            AddCovalenceCommand("stacksizecontroller.itemsearch", nameof(ItemSearchCommand),
                "stacksizecontroller.itemsearch");
            AddCovalenceCommand("stacksizecontroller.listcategories", nameof(ListCategoriesCommand),
                "stacksizecontroller.listcategories");
            AddCovalenceCommand("stacksizecontroller.listcategoryitems", nameof(ListCategoryItemsCommand),
                "stacksizecontroller.listcategoryitems");
            AddCovalenceCommand("stacksizecontroller.vd", nameof(GenerateVanillaStackSizeFileCommand),
                "stacksizecontroller.vd");
        }

        private void Unload()
        {
            if (_config.RevertStackSizesToVanillaOnUnload)
            {
                RevertStackSizes();
            }
        }

        #region Configuration

        private class Configuration
        {
            public bool RevertStackSizesToVanillaOnUnload = true;
            public bool AllowStackingItemsWithDurability = true;
            public bool HidePrefixWithPluginNameInMessages;

            public float GlobalStackMultiplier = 1;
            public Dictionary<string, float> CategoryStackMultipliers = GetCategoriesAndDefaults(1)
                .ToDictionary(k => k.Key,
                    k => Convert.ToSingle(k.Value));
            public Dictionary<string, float> IndividualItemStackMultipliers = new Dictionary<string, float>();

            public Dictionary<string, int> IndividualItemStackSize = new Dictionary<string, int>();

            public VersionNumber VersionNumber;
        }

        private static Dictionary<string, object> GetCategoriesAndDefaults(object defaultValue)
        {
            Dictionary<string, object> categoryDefaults = new Dictionary<string, object>();

            foreach (string category in Enum.GetNames(typeof(ItemCategory)))
            {
                categoryDefaults.Add(category, defaultValue);
            }

            return categoryDefaults;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        protected override void LoadDefaultConfig()
        {
            Configuration defaultConfig = GetDefaultConfig();
            defaultConfig.VersionNumber = Version;

            Config.WriteObject(defaultConfig);

            _config = Config.ReadObject<Configuration>();
        }

        private void EnsureConfigIntegrity()
        {
            Configuration configDefault = new Configuration();

            if (_config.CategoryStackMultipliers == null)
            {
                _config.CategoryStackMultipliers = configDefault.CategoryStackMultipliers;
            }

            if (_config.IndividualItemStackMultipliers == null)
            {
                _config.IndividualItemStackMultipliers = configDefault.IndividualItemStackMultipliers;
            }

            _config.VersionNumber = Version;
            SaveConfig();
        }

        private Configuration GetDefaultConfig()
        {
            return new Configuration();
        }

        private void UpdateIndividualItemStackMultiplier(int itemId, float multiplier)
        {
            if (_config.IndividualItemStackMultipliers.ContainsKey(itemId.ToString()))
            {
                _config.IndividualItemStackMultipliers[itemId.ToString()] = multiplier;

                SaveConfig();

                return;
            }

            _config.IndividualItemStackMultipliers.Add(ItemManager.itemDictionary[itemId].shortname, multiplier);

            SaveConfig();
        }

        private void UpdateIndividualItemStackMultiplier(string shortname, float multiplier)
        {
            if (_config.IndividualItemStackMultipliers.ContainsKey(shortname))
            {
                _config.IndividualItemStackMultipliers[shortname] = multiplier;

                SaveConfig();

                return;
            }

            _config.IndividualItemStackMultipliers.Add(shortname, multiplier);

            SaveConfig();
        }

        private void UpdateIndividualItemStackSize(int itemId, int stackLimit)
        {
            ItemDefinition item = ItemManager.FindItemDefinition(itemId);

            if (_config.IndividualItemStackSize.ContainsKey(item.shortname))
            {
                _config.IndividualItemStackSize[item.shortname] = stackLimit;

                SaveConfig();

                return;
            }

            _config.IndividualItemStackSize.Add(item.shortname, stackLimit);

            SaveConfig();
        }

        private void UpdateIndividualItemStackSize(string shortname, int stackLimit)
        {
            if (_config.IndividualItemStackSize.ContainsKey(shortname))
            {
                _config.IndividualItemStackSize[shortname] = stackLimit;

                SaveConfig();

                return;
            }

            _config.IndividualItemStackSize.Add(shortname, stackLimit);

            SaveConfig();
        }

        private void PopulateIndividualItemStackSize()
        {
            if (_config.IndividualItemStackSize.Count == 0)
            {
                Log($"Populating Individual Item Stack Sizes in configuration.");

                _config.IndividualItemStackSize = _vanillaDefaults;
            }
            else
            {
                foreach (ItemDefinition itemDefinition in ItemManager.GetItemDefinitions())
                {
                    if (!_config.IndividualItemStackSize.ContainsKey(itemDefinition.shortname))
                    {
                        Log($"Adding new item {itemDefinition.shortname} to IndividualItemStackSize in configuration.");

                        _config.IndividualItemStackSize.Add(itemDefinition.shortname, itemDefinition.stackable);
                    }
                }
            }

            SaveConfig();
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotEnoughArguments"] = "This command requires {0} arguments.",
                ["InvalidItemShortnameOrId"] =
                    "Item shortname or id is incorrect. Try stacksizecontroller.itemsearch [partial item name]",
                ["InvalidCategory"] = "Category not found. Try stacksizecontroller.listcategories",
                ["OperationSuccessful"] = "Operation completed successfully.",
            }, this);
        }

        private string GetMessage(string key)
        {
            return lang.GetMessage(key, this);
        }

        private string GetMessage(string key, string playerId)
        {
            if (_config.HidePrefixWithPluginNameInMessages || playerId == "server_console")
            {
                return lang.GetMessage(key, this, playerId);
            }

            return $"<color=#ff760d><b>[{nameof(StackSizeController)}]</b></color> " +
                   lang.GetMessage(key, this, playerId);
        }

        #endregion

        #region Hooks

        // Credit to WhiteThunder- https://github.com/AnExiledDev/StackSizeController/pull/7
        // Fix initial fuel amount for vendor-spawned helis since they use 20% of max stack size of low grade.
        private void OnEntitySpawned(Minicopter heli)
        {
            // Ignore if a known plugin is loaded that adjusts heli fuel.
            if (AirFuel != null || GetToDaChoppa != null || VehicleVendorOptions != null)
                return;

            // Must delay for vendor-spawned helis since the creatorEntity is set after spawn.
            NextTick(() =>
            {
                if (heli == null
                    // Make sure it's a vendor-spawned heli.
                    || !heli.IsSafe()
                    // Make sure the game hasn't changed unexpectedly.
                    || heli.StartingFuelUnits() != -1)
                    return;

                var fuelItem = (heli.GetFuelSystem() as EntityFuelSystem)?.GetFuelItem();
                if (fuelItem == null
                    // Ignore other types of fuel since they will have been placed by mods.
                    || fuelItem.info.shortname != "lowgradefuel"
                    // Ignore if the fuel amount is unexpected, since a mod likely adjusted it.
                    || fuelItem.amount != fuelItem.info.stackable / 5)
                    return;

                var hookResult = Interface.CallHook("OnVendorHeliFuelAdjust", heli);
                if (hookResult is bool && (bool)hookResult == false)
                    return;

                fuelItem.amount = 100;
                fuelItem.MarkDirty();
            });
        }

        int OnMaxStackable(Item item)
        {
            if (_vanillaDefaults == null)
            {
                return item.info.stackable;
            }

            return GetStackSize(item.info);
        }

        #endregion

        #region Commands

        private void SetStackCommand(IPlayer player, string command, string[] args)
        {
            if (args.Length != 2)
            {
                player.Reply(
                    string.Format(GetMessage("NotEnoughArguments", player.Id), 2));

                return;
            }

            ItemDefinition itemDefinition = ItemManager.FindItemDefinition(args[0]);
            string stackSizeString = args[1];

            if (itemDefinition == null)
            {
                player.Reply(GetMessage("InvalidItemShortnameOrId", player.Id));

                return;
            }

            if (stackSizeString.Substring(stackSizeString.Length - 1) == "x")
            {
                UpdateIndividualItemStackMultiplier(itemDefinition.itemid,
                    Convert.ToSingle(stackSizeString.TrimEnd('x')));
                SetStackSizes();
                player.Reply(GetMessage("OperationSuccessful", player.Id));

                return;
            }

            UpdateIndividualItemStackSize(itemDefinition.shortname, Convert.ToInt32(stackSizeString.TrimEnd('x')));

            SetStackSizes();

            player.Reply(GetMessage("OperationSuccessful", player.Id));
        }

        private void SetAllStacksCommand(IPlayer player, string command, string[] args)
        {
            if (args.Length != 1)
            {
                player.Reply(
                    string.Format(GetMessage("NotEnoughArguments", player.Id), 1));
            }

            foreach (string category in _config.CategoryStackMultipliers.Keys.ToList())
            {
                _config.CategoryStackMultipliers[category] = Convert.ToInt32(args[0]);
            }

            SaveConfig();
            SetStackSizes();

            player.Reply(GetMessage("OperationSuccessful", player.Id));
        }

        private void SetStackCategoryCommand(IPlayer player, string command, string[] args)
        {
            if (args.Length != 2)
            {
                player.Reply(
                    string.Format(GetMessage("NotEnoughArguments", player.Id), 2));
            }

            ItemCategory itemCategory = (ItemCategory)Enum.Parse(typeof(ItemCategory), args[0], true);

            _config.CategoryStackMultipliers[itemCategory.ToString()] = Convert.ToInt32(args[1].TrimEnd('x'));

            SaveConfig();
            SetStackSizes();

            player.Reply(GetMessage("OperationSuccessful", player.Id));
        }

        private void ItemSearchCommand(IPlayer player, string command, string[] args)
        {
            if (args.Length != 1)
            {
                player.Reply(
                    string.Format(GetMessage("NotEnoughArguments", player.Id), 1));
            }

            List<ItemDefinition> itemDefinitions = ItemManager.itemList.Where(itemDefinition =>
                    itemDefinition.displayName.english.Contains(args[0]) ||
                    itemDefinition.displayDescription.english.Contains(args[0]) ||
                    itemDefinition.shortname.Equals(args[0]) ||
                    itemDefinition.shortname.Contains(args[0]))
                .ToList();

            TextTable output = new TextTable();
            output.AddColumns("Unique Id", "Shortname", "Category", "Vanilla Stack", "Custom Stack");

            foreach (ItemDefinition itemDefinition in itemDefinitions)
            {
                output.AddRow(itemDefinition.itemid.ToString(), itemDefinition.shortname,
                    itemDefinition.category.ToString(), _vanillaDefaults[itemDefinition.shortname].ToString("N0"),
                    Mathf.Clamp(GetStackSize(itemDefinition), 0, int.MaxValue).ToString("N0"));
            }

            player.Reply(output.ToString());
        }

        private void ListCategoriesCommand(IPlayer player, string command, string[] args)
        {
            TextTable output = new TextTable();
            output.AddColumns("Category Name", "Items In Category");

            foreach (string category in Enum.GetNames(typeof(ItemCategory)))
            {
                output.AddRow(category, ItemManager.itemList.Where(x => x.category.ToString() == category).Count().ToString());
            }

            player.Reply(output.ToString());
        }

        private void ListCategoryItemsCommand(IPlayer player, string command, string[] args)
        {
            if (args.Length != 1)
            {
                player.Reply(string.Format(GetMessage("NotEnoughArguments", player.Id), 1));
            }

            ItemCategory itemCategory = (ItemCategory)Enum.Parse(typeof(ItemCategory), args[0]);

            TextTable output = new TextTable();
            output.AddColumns("Unique Id", "Shortname", "Category", "Vanilla Stack", "Custom Stack", "Multiplier");

            foreach (ItemDefinition itemDefinition in ItemManager.GetItemDefinitions()
                .Where(itemDefinition => itemDefinition.category == itemCategory))
            {
                output.AddRow(itemDefinition.itemid.ToString(), itemDefinition.shortname,
                    itemDefinition.category.ToString(), _vanillaDefaults[itemDefinition.shortname].ToString("N0"),
                    Mathf.Clamp(GetStackSize(itemDefinition), 0, int.MaxValue).ToString("N0"),
                    _config.CategoryStackMultipliers[itemDefinition.category.ToString()].ToString());
            }

            player.Reply(output.ToString());
        }

        #endregion

        #region Dev Use

        private void GenerateVanillaStackSizeFileCommand(IPlayer player, string command, string[] args)
        {
            GenerateVanillaStackSizeFile();
        }

        private void GenerateVanillaStackSizeFile()
        {
            RevertStackSizes();

            SortedDictionary<string, int> vanillaStackSizes = new SortedDictionary<string, int>();

            foreach (ItemDefinition itemDefinition in ItemManager.GetItemDefinitions())
            {
                vanillaStackSizes.Add(itemDefinition.shortname, itemDefinition.stackable);
            }

            Interface.Oxide.DataFileSystem.WriteObject(nameof(StackSizeController) + "_vanilla-defaults",
                vanillaStackSizes);

            SetStackSizes();

            Log("Vanilla stack sizes file updated. Custom stack sizes restored.");
        }

        #endregion

        #region Helpers

        private void DownloadVanillaDefaults()
        {
            Log($"Acquiring vanilla defaults file from official GitHub repo and overwriting; {_vanillaDefaultsUri}");

            try
            {
                webrequest.Enqueue(_vanillaDefaultsUri, null, SetVanillaDefaults, this, RequestMethod.GET);
            }
            catch (Exception ex)
            {
                LogError($"Exception encountered while attempting to get vanilla defaults: {ex}");
            }
        }

        private void SetVanillaDefaults(int code, string response)
        {
            if (code != 200 || response == null)
            {
                LogWarning($"Unable to get result from GitHub, code {code}. If you don't have a vanilla defaults datafile, the plugin will throw errors. " +
                    $"Reloading should resolve this unless there is something preventing downloads from external sites.");
                LogWarning("If the issue persists, check the uMod forums for StackSizeController for a manual fix.");

                return;
            }

            _vanillaDefaults = JsonConvert.DeserializeObject<Dictionary<string, int>>(response);

            Interface.Oxide.DataFileSystem.WriteObject(nameof(StackSizeController) +
                    "_vanilla-defaults", _vanillaDefaults);

            // TODO: Consider refactoring workflow to avoid ambiguity
            PopulateIndividualItemStackSize();
            SetStackSizes();
        }

        private int GetVanillaStackSize(ItemDefinition itemDefinition)
        {
            return _vanillaDefaults.ContainsKey(itemDefinition.shortname)
                ? _vanillaDefaults[itemDefinition.shortname]
                : itemDefinition.stackable;
        }

        private int GetStackSize(int itemId)
        {
            return GetStackSize(ItemManager.FindItemDefinition(itemId));
        }

        private int GetStackSize(ItemDefinition itemDefinition)
        {
            try
            {
                if (_ignoreList.Contains(itemDefinition.shortname))
                {
                    return GetVanillaStackSize(itemDefinition);
                }

                int stackable = GetVanillaStackSize(itemDefinition);

                // Individual Limit set by shortname
                if (_config.IndividualItemStackSize.ContainsKey(itemDefinition.shortname))
                {
                    stackable = _config.IndividualItemStackSize[itemDefinition.shortname];
                }

                // Individual Multiplier set by shortname
                if (_config.IndividualItemStackMultipliers.ContainsKey(itemDefinition.shortname))
                {
                    return Mathf.RoundToInt(stackable * _config.IndividualItemStackMultipliers[itemDefinition.shortname]);
                }

                // Individual Multiplier set by item id
                if (_config.IndividualItemStackMultipliers.ContainsKey(itemDefinition.itemid.ToString()))
                {
                    return Mathf.RoundToInt(stackable * _config.IndividualItemStackMultipliers[itemDefinition.itemid.ToString()]);
                }

                // Category stack multiplier defined
                if (_config.CategoryStackMultipliers.ContainsKey(itemDefinition.category.ToString()) &&
                    _config.CategoryStackMultipliers[itemDefinition.category.ToString()] > 1.0f)
                {
                    return Mathf.RoundToInt(
                        stackable * _config.CategoryStackMultipliers[itemDefinition.category.ToString()]);
                }

                return Mathf.RoundToInt(stackable * _config.GlobalStackMultiplier);
            }
            catch (Exception ex)
            {
                LogError("Exception encountered during GetStackSize. Item: " + itemDefinition.shortname + " Ex:" + ex.ToString());

                return GetVanillaStackSize(itemDefinition);
            }
        }

        private void SetStackSizes()
        {
            foreach (ItemDefinition itemDefinition in ItemManager.GetItemDefinitions())
            {
                if (itemDefinition.condition.enabled && !_config.AllowStackingItemsWithDurability)
                {
                    itemDefinition.stackable = Mathf.Clamp(GetVanillaStackSize(itemDefinition), 1, int.MaxValue);

                    continue;
                }

                if (_ignoreList.Contains(itemDefinition.shortname))
                {
                    continue;
                }

                itemDefinition.stackable = Mathf.Clamp(GetStackSize(itemDefinition), 1, int.MaxValue);
            }
        }

        private void RevertStackSizes()
        {
            Log("Reverting stack sizes to vanilla defaults.");

            foreach (ItemDefinition itemDefinition in ItemManager.GetItemDefinitions())
            {
                if (itemDefinition.condition.enabled && !_config.AllowStackingItemsWithDurability)
                {
                    continue;
                }

                if (_ignoreList.Contains(itemDefinition.shortname))
                {
                    continue;
                }

                itemDefinition.stackable = Mathf.Clamp(GetVanillaStackSize(itemDefinition), 1, int.MaxValue);
            }
        }

        #endregion
    }
}

// --- End of file: StackSizeController.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/storage-upgrade ---
// --- Original File Path: S/StorageUpgrade/StorageUpgrade.cs ---

using System;
using System.Collections.Generic;
using Network;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using UnityEngine;

/*
 * Rewritten from scratch and maintained to present by VisEntities
 * Originally created by Orange, up to version 1.5.1
 */

namespace Oxide.Plugins
{
    [Info("Storage Upgrade", "VisEntities", "2.1.0")]
    [Description("Hit storage with a hammer to boost its capacity.")]

    public class StorageUpgrade : RustPlugin
    {
        #region 3rd Party Dependencies

        [PluginReference]
        private readonly Plugin Economics, ServerRewards;

        #endregion 3rd Party Dependencies

        #region Fields

        private static StorageUpgrade _plugin;
        private static Configuration _config;

        private const string FX_UPGRADE = "assets/prefabs/misc/easter/painted eggs/effects/gold_open.prefab";
        private const string FX_UPGRADE_2 = "assets/prefabs/missions/effects/mission_objective_complete.prefab";

        #endregion Fields

        #region Configuration

        private class Configuration
        {
            [JsonProperty("Version")]
            public string Version { get; set; }

            [JsonProperty("Non Upgradeable Containers")]
            public string[] NonUpgradeableContainers { get; set; }

            [JsonProperty("Profiles")]
            public Dictionary<string, ProfileConfig> Profiles { get; set; }

            [JsonIgnore]
            public HashSet<string> permissions { get; set; } = new HashSet<string>();

            public void InitializeProfiles()
            {
                foreach (var keyValuePair in Profiles)
                {
                    string permissionSuffix = keyValuePair.Key;
                    ProfileConfig profile = keyValuePair.Value;

                    string permission = profile.ConstructPermission(permissionSuffix);
                    if (!permissions.Add(permission))
                        continue;

                    profile.RegisterPermission(permission);
                    profile.InitializeCurrencies();
                }
            }

            public ProfileConfig GetProfileForPlayer(BasePlayer player)
            {
                foreach (ProfileConfig profile in Profiles.Values)
                    if (PermissionUtil.VerifyHasPermission(player, profile.Permission))
                        return profile;

                return null;
            }
        }

        private class ProfileConfig
        {
            [JsonProperty("Enabled")]
            public bool Enabled { get; set; }

            [JsonProperty("Expand Storage By")]
            public int ExpandStorageBy { get; set; }

            [JsonProperty("Container Shortnames")]
            public string[] ContainerShortnames { get; set; }

            [JsonProperty("Upgrade Cost")]
            public List<CurrencyConfig> UpgradeCost { get; set; }

            [JsonIgnore]
            public string Permission { get; set; }

            public string ConstructPermission(string permissionSuffix)
            {
                return string.Join(".", nameof(StorageUpgrade), permissionSuffix).ToLower();
            }

            public void RegisterPermission(string permission)
            {
                Permission = permission;
                _plugin.permission.RegisterPermission(Permission, _plugin);
            }

            public void InitializeCurrencies()
            {
                foreach (CurrencyConfig currency in UpgradeCost)
                {
                    currency.CreatePaymentGateway();
                }
            }

            public List<CurrencyConfig> GetUpgradeCost()
            {
                List<CurrencyConfig> cost = new List<CurrencyConfig>();

                foreach (var currency in UpgradeCost)
                {
                    if (currency.Enabled && currency.Valid)
                        cost.Add(currency);
                }

                return cost;
            }
        }

        private class CurrencyConfig
        {
            [JsonProperty("Name")]
            public string Name { get; set; }

            [JsonProperty("Enabled")]
            public bool Enabled { get; set; }

            [JsonProperty("Amount")]
            public int Amount { get; set; }

            [JsonIgnore]
            private bool _itemHasBeenValidated;

            [JsonIgnore]
            private ItemDefinition _itemDefinition;

            [JsonIgnore]
            public IPaymentGateway PaymentGateway;

            [JsonIgnore]
            public PaymentGatewayType PaymentGatewayType;

            [JsonIgnore]
            public bool Valid
            {
                get
                {
                    if (PaymentGateway != null && PaymentGateway.Valid && PaymentGatewayType != PaymentGatewayType.Unknown)
                        return true;

                    return false;
                }
            }

            [JsonIgnore]
            public ItemDefinition ItemDefinition
            {
                get
                {
                    if (!_itemHasBeenValidated)
                    {
                        ItemDefinition matchedItemDefinition = ItemManager.FindItemDefinition(Name);
                        if (matchedItemDefinition != null)
                            _itemDefinition = matchedItemDefinition;
                        else
                            return null;

                        _itemHasBeenValidated = true;
                    }

                    return _itemDefinition;
                }
            }

            public void CreatePaymentGateway()
            {
                if (string.IsNullOrEmpty(Name))
                    return;

                if (Name.Contains("coin"))
                {
                    PaymentGateway = CoinPaymentGateway.Instance;
                    PaymentGatewayType = PaymentGatewayType.Coin;
                }
                else if (Name.Contains("point"))
                {
                    PaymentGateway = PointPaymentGateway.Instance;
                    PaymentGatewayType = PaymentGatewayType.Point;
                }
                else if (ItemDefinition != null)
                {
                    PaymentGateway = new ItemPaymentGateway(ItemDefinition.itemid);
                    PaymentGatewayType = PaymentGatewayType.Item;
                }
                else
                {
                    PaymentGateway = null;
                    PaymentGatewayType = PaymentGatewayType.Unknown;
                }
            }

            public bool CanPlayerPay(BasePlayer player)
            {
                return PaymentGateway.Get(player) >= Amount;
            }

            public void DeductFromPlayer(BasePlayer player)
            {
                PaymentGateway.Deduct(player, Amount);
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();

            if (string.Compare(_config.Version, Version.ToString()) < 0)
                UpdateConfig();

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config, true);
        }

        private void UpdateConfig()
        {
            PrintWarning("Config changes detected! Updating...");

            Configuration defaultConfig = GetDefaultConfig();

            if (string.Compare(_config.Version, "1.0.0") < 0)
                _config = defaultConfig;

            PrintWarning("Config update complete! Updated from version " + _config.Version + " to " + Version.ToString());
            _config.Version = Version.ToString();
        }

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                Version = Version.ToString(),
                NonUpgradeableContainers = new string[]
                {
                    "vending.machine",
                    "furnace",
                    "furnace.large",
                    "legacyfurnace",
                    "electric.igniter",
                    "workbench1",
                    "workbench2",
                    "workbench3",
                    "box.repair.bench",
                    "research.table",
                    "campfire",
                    "water.barrel",
                    "fishtrophy",
                    "huntingtrophylarge",
                    "skull.trophy",
                    "huntingtrophysmall",
                    "small.oil.refinery",
                    "recycler_static",
                    "dropbox",
                },
                Profiles = new Dictionary<string, ProfileConfig>
                {
                    ["basic"] = new ProfileConfig
                    {
                        Enabled = true,
                        ExpandStorageBy = 2,
                        ContainerShortnames = new string[]
                        {
                            "planter.large.deployed",
                            "railroadplanter.deployed",
                            "bathtub.planter.deployed",
                            "planter.small.deployed",
                            "minecart.planter.deployed",
                            "fridge.deployed",
                            "composter",
                            "box.wooden.large",
                            "woodbox_deployed",
                            "small_stash_deployed"
                        },
                        UpgradeCost = new List<CurrencyConfig>
                        {
                            new CurrencyConfig
                            {
                                Enabled = true,
                                Name = "wood",
                                Amount = 100
                            },
                            new CurrencyConfig
                            {
                                Enabled = true,
                                Name = "metal.fragments",
                                Amount = 100
                            }
                        }
                    },
                    ["vip"] = new ProfileConfig
                    {
                        Enabled = true,
                        ExpandStorageBy = 6,
                        ContainerShortnames = new string[]
                        {
                            "planter.large.deployed",
                            "railroadplanter.deployed",
                            "bathtub.planter.deployed",
                            "planter.small.deployed",
                            "minecart.planter.deployed",
                            "fridge.deployed",
                            "composter",
                            "box.wooden.large",
                            "woodbox_deployed",
                            "small_stash_deployed"
                        },
                        UpgradeCost = new List<CurrencyConfig>
                        {
                            new CurrencyConfig
                            {
                                Enabled = false,
                                Name = "coin",
                                Amount = 1000
                            },
                            new CurrencyConfig
                            {
                                Enabled = false,
                                Name = "point",
                                Amount = 1000
                            }
                        }
                    }
                }
            };
        }

        #endregion Configuration

        #region Oxide Hooks

        private void Init()
        {
            _plugin = this;
            _config.InitializeProfiles();
        }

        private void Unload()
        {
            _config = null;
            _plugin = null;
        }

        private void OnHammerHit(BasePlayer player, HitInfo hitInfo)
        {
            if (player == null || hitInfo == null || !player.serverInput.IsDown(BUTTON.FIRE_SECONDARY))
                return;

            StorageContainer container = hitInfo.HitEntity as StorageContainer;
            if (container == null || _config.NonUpgradeableContainers.Contains(container.ShortPrefabName) || hitInfo.HitEntity is BaseOven)
            {
                SendReplyToPlayer(player, Lang.CannotUpgrade);
                return;
            }

            ProfileConfig profile = _config.GetProfileForPlayer(player);
            if (profile == null || !profile.Enabled || !profile.ContainerShortnames.Contains(container.ShortPrefabName))
            {
                SendReplyToPlayer(player, Lang.NoPermissionOrCannotUpgrade);
                return;
            }

            int currentCapacity = container.inventory.capacity;
            if (currentCapacity >= 48)
            {
                SendReplyToPlayer(player, Lang.AlreadyAtMaxCapacity);
                return;
            }

            List<CurrencyConfig> upgradeCost = profile.GetUpgradeCost();
            foreach (CurrencyConfig currency in upgradeCost)
            {
                int playerBalance = currency.PaymentGateway.Get(player);
                if (playerBalance < currency.Amount)
                {
                    int shortfall = currency.Amount - playerBalance;
                    SendReplyToPlayer(player, Lang.NeedMoreToUpgrade, shortfall, currency.Name);
                    return;
                }
            }

            foreach (CurrencyConfig currency in upgradeCost)
            {
                currency.DeductFromPlayer(player);
            }

            int newCapacity = Math.Min(currentCapacity + profile.ExpandStorageBy, 48);
            container.inventory.capacity = newCapacity;

            SendReplyToPlayer(player, Lang.UpgradedFromTo, currentCapacity, newCapacity);

            RunEffect(FX_UPGRADE, container.transform.position + new Vector3(0.0f, 1.0f, 0.5f), Vector3.up);
            RunEffect(FX_UPGRADE, container.transform.position + new Vector3(0.0f, 1.0f, -0.5f), Vector3.up);
            RunEffect(FX_UPGRADE, container.transform.position + new Vector3(-0.5f, 1.0f, 0.0f), Vector3.up);
            RunEffect(FX_UPGRADE, container.transform.position + new Vector3(0.5f, 1.0f, 0.0f), Vector3.up);

            RunEffect(FX_UPGRADE_2, player, boneId: 698017942);
        }

        #endregion Oxide Hooks

        #region Payment Gateways

        // The following PaymentGateway implementation was inspired by WhiteThunder.
        private enum PaymentGatewayType
        {
            Item,
            Coin,
            Point,
            Unknown
        }

        private interface IPaymentGateway
        {
            bool Valid { get; }

            int Get(BasePlayer player);

            void Give(BasePlayer player, int amount);

            void Deduct(BasePlayer player, int amount);
        }

        private class ItemPaymentGateway : IPaymentGateway
        {
            private int _itemId;

            public ItemPaymentGateway(int itemId)
            {
                _itemId = itemId;
            }

            public bool Valid
            {
                get { return true; }
            }

            public int Get(BasePlayer player)
            {
                return player.inventory.GetAmount(_itemId);
            }

            public void Give(BasePlayer player, int amount)
            {
                player.GiveItem(ItemManager.CreateByItemID(_itemId, amount));
                player.Command("note.inv", _itemId, +amount);
            }

            public void Deduct(BasePlayer player, int amount)
            {
                player.inventory.Take(null, _itemId, amount);
                player.Command("note.inv", _itemId, -amount);
            }
        }

        private class CoinPaymentGateway : IPaymentGateway
        {
            private static readonly CoinPaymentGateway _instance = new CoinPaymentGateway();

            private Plugin _economicsPlugin
            {
                get { return _plugin.Economics; }
            }

            public bool Valid
            {
                get { return VerifyPluginBeingLoaded(_economicsPlugin); }
            }

            public static CoinPaymentGateway Instance
            {
                get { return _instance; }
            }

            private CoinPaymentGateway() { }

            public int Get(BasePlayer player)
            {
                return Convert.ToInt32(_economicsPlugin.Call("Balance", player.userID));
            }

            public void Give(BasePlayer player, int amount)
            {
                _economicsPlugin.Call("Deposit", player.userID, Convert.ToDouble(amount));
            }

            public void Deduct(BasePlayer player, int amount)
            {
                _economicsPlugin.Call("Withdraw", player.userID, Convert.ToDouble(amount));
            }
        }

        private class PointPaymentGateway : IPaymentGateway
        {
            private static readonly PointPaymentGateway _instance = new PointPaymentGateway();

            private Plugin _serverRewardsPlugin
            {
                get { return _plugin.ServerRewards; }
            }

            public bool Valid
            {
                get { return VerifyPluginBeingLoaded(_serverRewardsPlugin); }
            }

            public static PointPaymentGateway Instance
            {
                get { return _instance; }
            }

            private PointPaymentGateway() { }

            public int Get(BasePlayer player)
            {
                return Convert.ToInt32(_serverRewardsPlugin.Call("CheckPoints", player.userID));
            }

            public void Give(BasePlayer player, int amount)
            {
                _serverRewardsPlugin.Call("AddPoints", player.userID, amount);
            }

            public void Deduct(BasePlayer player, int amount)
            {
                _serverRewardsPlugin.Call("TakePoints", player.userID, amount);
            }
        }

        #endregion Payment Gateways

        #region Utility Classes

        private static class PermissionUtil
        {
            public static bool VerifyHasPermission(BasePlayer player, string permissionName)
            {
                return _plugin.permission.UserHasPermission(player.UserIDString, permissionName);
            }
        }

        #endregion Utility Classes

        #region Helper Functions

        private static void RunEffect(string prefab, Vector3 worldPosition = default(Vector3), Vector3 worldDirection = default(Vector3), Connection effectRecipient = null, bool sendToAll = false)
        {
            Effect.server.Run(prefab, worldPosition, worldDirection, effectRecipient, sendToAll);
        }

        private static void RunEffect(string prefab, BaseEntity entity, uint boneId = 0, Vector3 localPosition = default(Vector3), Vector3 localDirection = default(Vector3), Connection effectRecipient = null, bool sendToAll = false)
        {
            Effect.server.Run(prefab, entity, boneId, localPosition, localDirection, effectRecipient, sendToAll);
        }

        private static bool VerifyPluginBeingLoaded(Plugin plugin)
        {
            return plugin != null && plugin.IsLoaded ? true : false;
        }

        #endregion Helper Functions

        #region Localization

        private class Lang
        {
            public const string CannotUpgrade = "CannotUpgrade";
            public const string NoPermissionOrCannotUpgrade = "NoPermissionOrCannotUpgrade";
            public const string AlreadyAtMaxCapacity = "AlreadyAtMaxCapacity";
            public const string NeedMoreToUpgrade = "NeedMoreToUpgrade";
            public const string UpgradedFromTo = "UpgradedFromTo";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.CannotUpgrade] = "This container cannot be upgraded.",
                [Lang.NoPermissionOrCannotUpgrade] = "You don't have permission or this container cannot be upgraded.",
                [Lang.AlreadyAtMaxCapacity] = "This container is already at maximum capacity.",
                [Lang.NeedMoreToUpgrade] = "You need <color=#FFA500>{0}</color> more <color=#FFA500>{1}</color> to upgrade.",
                [Lang.UpgradedFromTo] = "Container upgraded from <color=#FFA500>{0}</color> to <color=#FFA500>{1}</color> slots."
            }, this, "en");
        }

        private void SendReplyToPlayer(BasePlayer player, string messageKey, params object[] args)
        {
            string message = lang.GetMessage(messageKey, this, player.UserIDString);
            if (args.Length > 0)
                message = string.Format(message, args);

            SendReply(player, message);
        }

        #endregion Localization
    }
}

// --- End of file: StorageUpgrade.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/stash-blocker ---
// --- Original File Path: S/StashBlocker/StashBlocker.cs ---

using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Plugins;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Stash Blocker", "Orange/Dana", "1.1.0")]
    [Description("Restricts the placement of stash containers.")]
    public class StashBlocker : RustPlugin
    {
        #region Fields

        private Configuration config { get; set; }

        private const string permissionIgnore = "stashblocker.ignore";
        private const string stashPrefab = "assets/prefabs/deployable/small stash/small_stash_deployed.prefab";

        #endregion

        #region Configuration

        private class Configuration
        {
            [JsonProperty(PropertyName = "Cannot Place Overall")]
            public bool CannotPlaceOverall { get; set; }

            [JsonProperty(PropertyName = "Cannot Place Outside Building Privilege Range")]
            public bool CannotPlaceOutsideBuildingPrivilegeRange { get; set; }

            [JsonProperty(PropertyName = "Cannot Place Nearby Entity")]
            public bool CannotPlaceNearbyEntity { get; set; }

            [JsonProperty(PropertyName = "Entity Detection Radius")]
            public float EntityDetectionRadius { get; set; }

            [JsonProperty(PropertyName = "Entities")]
            public List<string> Entities { get; set; }

            [JsonProperty(PropertyName = "Send Game Tip")]
            public bool SendGameTip { get; set; }

            [JsonProperty(PropertyName = "Game Tip Show Duration")]
            public float GameTipShowDuration { get; set; }
        }

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                CannotPlaceOverall = false,
                CannotPlaceOutsideBuildingPrivilegeRange = true,
                CannotPlaceNearbyEntity = false,
                EntityDetectionRadius = 2f,
                Entities = new List<string>()
                {
                    "sleepingbag_leather_deployed",
                    "small_stash_deployed"
                },
                SendGameTip = true,
                GameTipShowDuration = 3f,
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<Configuration>();

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config, true);
        }

        #endregion

        #region Oxide Hooks

        private void Init()
        {
            permission.RegisterPermission(permissionIgnore, this);
        }

        /// <summary>
        /// Hook: Called when the player tries to build or deploy something.
        /// </summary>
        /// <param name="planner"> The building planner held by the player. </param>
        /// <param name="construction"> Contains information about construction that's being built. </param>
        /// <param name="target"></param>
        /// <returns> Returning true or false overrides default behavior. </returns>
        private object CanBuild(Planner planner, Construction construction, Construction.Target target)
        {
            // Obtain the deploying player from the planner.
            BasePlayer ownerPlayer = planner?.GetOwnerPlayer();
            if (ownerPlayer == null)
                return null;

            // Skip if the construction being built isn't a stash container.
            if (construction.fullName != stashPrefab)
                return null;

            if (HasPermission(ownerPlayer, permissionIgnore))
                return null;

            // Proceed if 'CannotPlaceOverall' is enabled.
            if (config.CannotPlaceOverall)
            {
                // Block building.
                SendMessage(ownerPlayer, Message.CannotPlaceOverall);
                return true;
            }

            // Proceed if the player isn't building authorized and 'CannotPlaceOutsideBuildingPrivilegeRange' is enabled.
            if (config.CannotPlaceOutsideBuildingPrivilegeRange && !ownerPlayer.IsBuildingAuthed())
            {
                // Block building.
                SendMessage(ownerPlayer, Message.CannotPlaceBuildingPrivilege);
                return true;
            }

            // Obtain the deploying position of the stash container.
            Vector3 stashPosition = target.entity?.transform ? target.GetWorldPosition() : target.position;
            // Proceed if the position where the stash is to be built is nearby one of the blacklisted entities and 'CannotPlaceNearbyEntity' is enabled.
            if (config.CannotPlaceNearbyEntity && config.Entities.Count > 0 && HasEntityNearby(stashPosition))
            {
                // Block building.
                SendMessage(ownerPlayer, Message.CannotPlaceNearbyEntity);
                return true;
            }

            // Allow building.
            return null;
        }

        #endregion

        #region Functions

        /// <summary>
        /// Determines whether the given position is found nearby other entities.
        /// </summary>
        /// <param name="position"> The given world position of the entity. </param>
        /// <returns> </returns>
        private bool HasEntityNearby(Vector3 position)
        {
            // Capture all entities within range and save them to the declared entities list.
            List<BaseEntity> nearbyEntities = Pool.GetList<BaseEntity>();
            Vis.Entities(position, config.EntityDetectionRadius, nearbyEntities, LayerMask.GetMask("Construction", "Deployable", "Deployed"), QueryTriggerInteraction.Ignore);

            // Proceed if the entities list isn't empty.
            if (nearbyEntities.Any())
            {
                foreach (BaseEntity entity in nearbyEntities)
                {
                    if (config.Entities.Contains(entity.ShortPrefabName))
                    {
                        Pool.FreeList(ref nearbyEntities);
                        return true;
                    }
                }
            }

            Pool.FreeList(ref nearbyEntities);
            return false;
        }

        #endregion

        #region Helper Functions

        private void SendGameTip(BasePlayer player, string message)
        {
            if (player != null)
            {
                message = Formatter.ToPlaintext(message);

                player.Command("gametip.showgametip", message);
                timer.Once(config.GameTipShowDuration, () => player?.Command("gametip.hidegametip"));
            }
        }

        private bool HasPermission(BasePlayer player, string permissionName)
        {
            return permission.UserHasPermission(player.UserIDString, permissionName);
        }

        #endregion

        #region Localization

        private class Message
        {
            public const string CannotPlaceOverall = "CannotPlace.Overall";
            public const string CannotPlaceBuildingPrivilege = "CannotPlace.BuildingPrivilege";
            public const string CannotPlaceNearbyEntity = "CannotPlace.NearbyEntity";
        }

        /// <summary>
        /// Registers and populates the language file with the default messages.
        /// </summary>
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Message.CannotPlaceOverall] = "Placing stashes is prohibited",
                [Message.CannotPlaceBuildingPrivilege] = "Cannot place stash outside building privilege range",
                [Message.CannotPlaceNearbyEntity] = "Cannot place stash too close to constructions or deployables",
            }, this, "en");
        }

        /// <summary>
        /// Gets the localized and translated message from the localization file.
        /// </summary>
        /// <param name="messageKey"> The message key. </param>
        /// <param name="playerId"> To obtain the selected language of the player. </param>
        /// <param name="args"> Any additional arguments given in the message. </param>
        /// <returns> The localized message for the stated key. </returns>
        private string GetMessage(string messageKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(messageKey, this, playerId), args);
        }

        /// <summary>
        /// Sends the localized and formatted message to the specified player.
        /// </summary>
        /// <param name="player"> The player to whom the message is to be sent. </param>
        /// <param name="messageKey"> The message key. </param>
        /// <param name="args"> Any additional arguments given in the message. </param>
        private void SendMessage(BasePlayer player, string messageKey, object[] args = null)
        {
            string message = GetMessage(messageKey, player.UserIDString);
            if (args != null && args.Length > 0)
                message = string.Format(message, args);

            SendReply(player, message);

            if (config.SendGameTip)
                SendGameTip(player, message);
        }

        #endregion
    }
}

// --- End of file: StashBlocker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/supply-signal-alerts ---
// --- Original File Path: S/SupplySignalAlerts/SupplySignalAlerts.cs ---

using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Supply Signal Alerts", "LaserHydra", "3.0.1", ResourceId = 933)]
    internal class SupplySignalAlerts : RustPlugin
    {
        private void Init()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Supply Signal Thrown"] = "<color=orange>{player}</color> has thrown a supply signal at <color=orange>{position}</color>",
                ["Position Format"] = "( X: {x}, Y: {y}, Z: {z} )"
            }, this);
        }

        private void OnExplosiveDropped(BasePlayer player, BaseEntity entity) => OnExplosiveThrown(player, entity);

        private void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
        {
            if (!(entity is SupplySignal))
                return;

            timer.Once(2.8f, () =>
            {
                var position = lang.GetMessage("Position Format", this, player.UserIDString)
                    .Replace("{x}", entity.transform.position.x.ToString("##.0"))
                    .Replace("{y}", entity.transform.position.y.ToString("##.0"))
                    .Replace("{z}", entity.transform.position.z.ToString("##.0"));

                var message = lang.GetMessage("Supply Signal Thrown", this, player.UserIDString)
                    .Replace("{player}", player.displayName)
                    .Replace("{position}", position);

                PrintToChat(message);
                Puts(message);
            });
        }
    }
}

// --- End of file: SupplySignalAlerts.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/sam-site-range ---
// --- Original File Path: S/SAMSiteRange/SAMSiteRange.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("SAM Site Range", "nivex", "1.2.8")]
    [Description("Modifies SAM site range.")]
    internal class SAMSiteRange : RustPlugin
    {
        #region Oxide Hooks

        private void Init()
        {
            foreach (var perm in config.permissions.Keys)
            {
                if (!permission.PermissionExists(perm))
                {
                    permission.RegisterPermission(perm, this);
                }
            }
        }

        private object OnSamSiteTargetScan(SamSite ss, List<SamSite.ISamSiteTarget> result)
        {
            if (GetSamSiteScanRange(ss, out var vehicleRange, out var missileRange))
            {
                if (!ss.IsInDefenderMode())
                {
                    AddVehicleTargetSet(ss, result, vehicleRange);
                }
                AddMLRSRockets(ss, result, missileRange);
                return true;
            }
            return null;
        }

        private void AddVehicleTargetSet(SamSite ss, List<SamSite.ISamSiteTarget> allTargets, float scanRadius)
        {
            if (SamSite.ISamSiteTarget.serverList.Count == 0)
            {
                return;
            }
            foreach (SamSite.ISamSiteTarget server in SamSite.ISamSiteTarget.serverList)
            {
                if (!(server is MLRSRocket) && server is BaseEntity entity && !entity.IsDestroyed && Vector3.Distance(entity.CenterPoint(), ss.eyePoint.transform.position) < scanRadius)
                {
                    allTargets.Add(server);
                }
            }
        }

        private void AddMLRSRockets(SamSite ss, List<SamSite.ISamSiteTarget> allTargets, float scanRadius)
        {
            if (MLRSRocket.serverList.Count == 0)
            {
                return;
            }
            foreach (MLRSRocket server in MLRSRocket.serverList)
            {
                if (server != null && !server.IsDestroyed && Vector3.Distance(server.transform.position, ss.transform.position) < scanRadius)
                {
                    allTargets.Add(server);
                }
            }
        }

        #endregion Oxide Hooks

        #region Methods

        [PluginReference] Core.Plugins.Plugin RaidableBases;

        private bool RaidableTerritory(BaseEntity entity) => RaidableBases != null && Convert.ToBoolean(RaidableBases?.Call("HasEventEntity", entity));

        private bool GetSamSiteScanRange(SamSite ss, out float vehicleRange, out float missileRange)
        {
            if (ss != null && !ss.IsDestroyed)
            {
                if (ss.OwnerID == 0 || ss.staticRespawn)
                {
                    vehicleRange = config.staticVehicleRange;
                    missileRange = config.staticMissileRange;
                    return !RaidableTerritory(ss);
                }
                if (ss.OwnerID.IsSteamId() && GetPermissionSettings(ss.OwnerID.ToString(), out var permissionSettings))
                {
                    vehicleRange = permissionSettings.vehicleScanRadius;
                    missileRange = permissionSettings.missileScanRadius;
                    return true;
                }
            }
            vehicleRange = missileRange = 0f;
            return false;
        }

        private bool GetPermissionSettings(string playerId, out PermissionSettings permissionSettings)
        {
            int priority = 0;
            permissionSettings = null;
            foreach (var (perm, settings) in config.permissions)
            {
                if (settings.priority >= priority && permission.UserHasPermission(playerId, perm))
                {
                    priority = settings.priority;
                    permissionSettings = settings;
                }
            }
            return permissionSettings != null;
        }

        #endregion Methods

        #region ConfigurationFile

        private ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Static SamSite Vehicle Scan Range")]
            public float staticVehicleRange = 150f;

            [JsonProperty(PropertyName = "Static SamSite Missile Scan Range")]
            public float staticMissileRange = 225f;

            [JsonProperty(PropertyName = "Permissions", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, PermissionSettings> permissions = new()
            {
                ["samsiterange.use"] = new()
                {
                    priority = 0,
                    vehicleScanRadius = 200f,
                    missileScanRadius = 275f,
                },
                ["samsiterange.vip"] = new()
                {
                    priority = 1,
                    vehicleScanRadius = 250f,
                    missileScanRadius = 325f,
                }
            };
        }

        private class PermissionSettings
        {
            public int priority;
            public float vehicleScanRadius;
            public float missileScanRadius;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            config = new();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion ConfigurationFile
    }
}

// --- End of file: SAMSiteRange.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/skip-night-ui ---
// --- Original File Path: S/SkipNightUI/SkipNightUI.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("SkipNightUI", "k1lly0u", "0.1.2", ResourceId = 2506)]
    class SkipNightUI : RustPlugin
    {
        #region Fields
        [PluginReference]
        Plugin ImageLibrary;

        private List<ulong> votesReceived = new List<ulong>();

        private bool voteOpen;
        private bool isWaiting;
        private bool isILReady;
        private int timeRemaining;
        private int requiredVotes;
        private Timer voteTimer;
        private Timer timeMonitor;
        #endregion

        #region UI
        public class UI
        {
            static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool useCursor = false)
            {
                var NewElement = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                            CursorEnabled = useCursor
                        },
                        new CuiElement().Parent = "Overlay",
                        panelName
                    }
                };
                return NewElement;
            }
            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel, CuiHelper.GetGuid());
            }
            static public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel, CuiHelper.GetGuid());

            }
            static public void LoadImage(ref CuiElementContainer container, string panel, string png, string aMin, string aMax)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent {Png = png },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                });
            }
            public static string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.TrimStart('#');
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }
        }
        #endregion

        #region UI Creation
        private const string Main = "SNUIMain";
       
        private void CreateTimeUI()
        {
            UICreator uiConfig = configData.PanelTypes[configData.UIConfig];

            var element = UI.CreateElementContainer(Main, "0 0 0 0", $"{uiConfig.Size.XMin / 100} {uiConfig.Size.YMin / 100}", $"{uiConfig.Size.XMax / 100} {uiConfig.Size.YMax / 100}");
            foreach (var panel in uiConfig.PanelElements)
                UI.CreatePanel(ref element, Main, string.IsNullOrEmpty(panel.Color) ? "0 0 0 0" : UI.Color(panel.Color, panel.Alpha), $"{panel.Size.XMin / 100} {panel.Size.YMin / 100}", $"{panel.Size.XMax / 100} {panel.Size.YMax / 100}");

            foreach (var image in uiConfig.ImageElements)
            {
                string imageId = GetImage(image.URL);
                UI.LoadImage(ref element, Main, imageId, $"{image.Size.XMin / 100} {image.Size.YMin / 100}", $"{image.Size.XMax / 100} {image.Size.YMax / 100}");
            }

            foreach (var label in uiConfig.TextElements)
            {
                string text = label.Text.Text;
                if (!string.IsNullOrEmpty(label.Text.Color))
                    text = $"<color={label.Text.Color}>{text}</color>";
                UI.CreateLabel(ref element, Main, "", text, label.Text.Size, $"{label.Size.XMin / 100} {label.Size.YMin / 100}", $"{label.Size.XMax / 100} {label.Size.YMax / 100}", ParseAnchor(label.Text.Alignment));
            }

            var percentVotes = System.Convert.ToDouble((float)votesReceived.Count / (float)requiredVotes);
            var percentTime = System.Convert.ToDouble((float)timeRemaining / (float)configData.Options.Duration);
            var time = GetFormatTime();

            foreach(var bar in uiConfig.VoteProgress)
            {                
                switch (ParseType(bar.Type))
                {
                    case ProgressType.Solid:
                        {
                            var yMaxVotes = (bar.Size.XMin / 100) + (((bar.Size.XMax - bar.Size.XMin) / 100) * percentVotes);
                            UI.CreatePanel(ref element, Main, string.IsNullOrEmpty(bar.Color) ? "0 0 0 0" : UI.Color(bar.Color, bar.Alpha), $"{bar.Size.XMin / 100} {bar.Size.YMin / 100}", $"{yMaxVotes} {bar.Size.YMax / 100}");
                        }
                        break;
                    case ProgressType.Graphic:
                        {
                            var yMaxVotes = (bar.Size.XMin / 100) + (((bar.Size.XMax - bar.Size.XMin) / 100) * percentVotes);
                            string imageId = GetImage(bar.URL);
                            UI.LoadImage(ref element, Main, imageId, $"{bar.Size.XMin / 100} {bar.Size.YMin / 100}", $"{yMaxVotes} {bar.Size.YMax / 100}");
                        }
                        break;
                    case ProgressType.Text:
                        UI.CreateLabel(ref element, Main, "", bar.Text.Text.Replace("{currentAmount}", votesReceived.Count().ToString()).Replace("{requiredAmount}", requiredVotes.ToString()), bar.Text.Size, $"{bar.Size.XMin / 100} {bar.Size.YMin / 100}", $"{bar.Size.XMax / 100} {bar.Size.YMax / 100}", ParseAnchor(bar.Text.Alignment));
                        break;
                    default:
                        break;
                }
            }
            foreach (var bar in uiConfig.TimeProgress)
            {
                switch (ParseType(bar.Type))
                {
                    case ProgressType.Solid:
                        {
                            var yMaxRemaining = ((bar.Size.XMax / 100) * percentTime);
                            UI.CreatePanel(ref element, Main, string.IsNullOrEmpty(bar.Color) ? "0 0 0 0" : UI.Color(bar.Color, bar.Alpha), $"{bar.Size.XMin / 100} {bar.Size.YMin / 100}", $"{yMaxRemaining} {bar.Size.YMax / 100}");
                        }
                        break;
                    case ProgressType.Graphic:
                        {
                            var yMaxRemaining = ((bar.Size.XMax / 100) * percentTime);
                            string imageId = GetImage(bar.URL);
                            UI.LoadImage(ref element, Main, imageId, $"{bar.Size.XMin / 100} {bar.Size.YMin / 100}", $"{yMaxRemaining} {bar.Size.YMax / 100}");
                        }
                        break;
                    case ProgressType.Text:
                        if (!string.IsNullOrEmpty(bar.Text.Color))
                            time = $"<color={bar.Text.Color}>{time}</color>";
                        UI.CreateLabel(ref element, Main, "", time, bar.Text.Size, $"{bar.Size.XMin / 100} {bar.Size.YMin / 100}", $"{bar.Size.XMax / 100} {bar.Size.YMax / 100}", ParseAnchor(bar.Text.Alignment));
                        break;
                    default:
                        break;
                }
            }

            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Main);
                CuiHelper.AddUi(player, element);
            }
        }

        private void RefreshAllUI()
        {
            if (voteOpen)
                CreateTimeUI();
            else
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    CuiHelper.DestroyUi(player, Main);
                }
            }
        }
        #endregion

        #region Oxide Hooks
        void Loaded()
        {
            lang.RegisterMessages(Messages, this);
            permission.RegisterPermission("skipnightui.admin", this);
        }
        void OnServerInitialized()
        {
            LoadVariables();
            votesReceived = new List<ulong>();
            requiredVotes = 0;
            voteOpen = false;
            timeRemaining = 0;
            LoadImages();            
        }
        void OnPlayerDisconnected(BasePlayer player) => CuiHelper.DestroyUi(player, Main);
        void Unload()
        {
            if (voteTimer != null)
                voteTimer.Destroy();

            foreach (var player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, Main);
        }
        #endregion

        #region Functions
        private void OpenVote()
        {
            var required = BasePlayer.activePlayerList.Count * (configData.Options.Percentage / 100);
            if (required < 1) required = 1;
            requiredVotes = Convert.ToInt32(required);
            voteOpen = true;
            Print("commandSyn");
            VoteTimer();
        }
        private void VoteTimer()
        {
            timeRemaining = configData.Options.Duration;
            voteTimer = timer.Repeat(1, timeRemaining, () =>
            {
                RefreshAllUI();
                timeRemaining--;
                switch (timeRemaining)
                {
                    case 0:
                        TallyVotes();
                        return;
                    case 240:
                    case 180:
                    case 120:
                    case 60:
                    case 30:
                        MessageAll();
                        break;
                    default:
                        break;
                }
            });
        }
        private void MessageAll()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player != null)
                {
                    if (!AlreadyVoted(player))
                        Reply(player, "commandSyn");
                }
            }
        }
        private string GetFormatTime()
        {
            var time = timeRemaining;
            double minutes = Math.Floor((double)(time / 60));
            time -= (int)(minutes * 60);
            return string.Format("{0:00}:{1:00}", minutes, time);
        }
        private void CheckTime()
        {
            if (!voteOpen)
            {
                if (isWaiting)
                {
                    timeMonitor = timer.Once(20, () => CheckTime());
                    return;
                }

                if ((TOD_Sky.Instance.Cycle.Hour >= configData.Options.Open && TOD_Sky.Instance.Cycle.Hour < 24) || (TOD_Sky.Instance.Cycle.Hour >= 0 && TOD_Sky.Instance.Cycle.Hour < configData.Options.Set))
                    OpenVote();
                else timeMonitor = timer.Once(20, () => CheckTime());
            }
            else
            {
                if (TOD_Sky.Instance.Cycle.Hour >= configData.Options.Set && TOD_Sky.Instance.Cycle.Hour < configData.Options.Open)
                    VoteEnd(false);
            }
        }
        private void TallyVotes()
        {
            if (votesReceived.Count >= requiredVotes)
                VoteEnd(true);
            else VoteEnd(false);
        }
        private void VoteEnd(bool success)
        {
            foreach (var player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, Main);
            voteOpen = false;
            requiredVotes = 0;
            voteTimer.Destroy();
            votesReceived.Clear();
            timeRemaining = 0;

            if (success)
            {            
                TOD_Sky.Instance.Cycle.Hour = configData.Options.Set;
                TOD_Sky.Instance.Cycle.Day = TOD_Sky.Instance.Cycle.Day + 1;
                Print("votingSuccessful");
            }
            else Print("votingUnsuccessful");
            isWaiting = true;
            timer.In(600, () => isWaiting = false);
            CheckTime();
        }
        
        private bool AlreadyVoted(BasePlayer player) => votesReceived.Contains(player.userID);

        private void AddImage(string fileName)
        {
            var url = fileName;
            if (!url.StartsWith("http") && !url.StartsWith("www"))
                url = $"file://{Interface.Oxide.DataDirectory}{Path.DirectorySeparatorChar}SkipNightUI{Path.DirectorySeparatorChar}Images{Path.DirectorySeparatorChar}{fileName}.png";
            ImageLibrary?.Call("AddImage", url, fileName, 0);
        }
        private string GetImage(string fileName, ulong skin = 0)
        {
            string imageId = (string)ImageLibrary.Call("GetImage", fileName, skin);
            if (!string.IsNullOrEmpty(imageId))
                return imageId;
            return string.Empty;
        }
        private void LoadImages()
        {
            if (string.IsNullOrEmpty(configData.UIConfig))
            {
                PrintError("You must set the \"UI Configuration Name\" in your config. Unable to continue!");
                Interface.Oxide.UnloadPlugin(Title);
                return;
            }
            if (!configData.PanelTypes.ContainsKey(configData.UIConfig))
            {
                PrintError("Invalid \"UI Configuration Name\" set in your config. Unable to continue!");
                Interface.Oxide.UnloadPlugin(Title);
                return;
            }            

            Dictionary<string, string> newLoadOrder = new Dictionary<string, string>();
            UICreator uiConfig = configData.PanelTypes[configData.UIConfig];

            foreach (var element in uiConfig.ImageElements)
            {
                if (!string.IsNullOrEmpty(element.URL) && !newLoadOrder.ContainsKey(element.URL))
                    newLoadOrder.Add(element.URL, element.URL);
            }
            foreach (var element in uiConfig.TimeProgress)
            {
                if (!string.IsNullOrEmpty(element.URL) && !newLoadOrder.ContainsKey(element.URL))
                    newLoadOrder.Add(element.URL, element.URL);
            }
            foreach (var element in uiConfig.VoteProgress)
            {
                if (!string.IsNullOrEmpty(element.URL) && !newLoadOrder.ContainsKey(element.URL))
                    newLoadOrder.Add(element.URL, element.URL);
            }

            if (newLoadOrder.Count > 0)
            {
                if (!ImageLibrary)
                {
                    PrintError("Image Library is not installed. It is required to load the images. Unable to continue!");
                    Interface.Oxide.UnloadPlugin(Title);
                    return;
                }

                ImageLibrary.Call("ImportImageList", Title, newLoadOrder);
            }

            BeginUICreation();
        }

        private void BeginUICreation()
        {
            if (!(bool)ImageLibrary?.Call("IsReady"))
            {
                PrintWarning("Waiting for ImageLibrary to finish image processing!");
                timer.In(60, BeginUICreation);
                return;
            }
            isILReady = true;
            CheckTime();
        }

        TextAnchor ParseAnchor(string anchor)
        {
            TextAnchor textAnchor;
            try
            {
                textAnchor = (TextAnchor)Enum.Parse(typeof(TextAnchor), anchor);
            }
            catch
            {
                textAnchor = TextAnchor.MiddleCenter;
            }
            return textAnchor;
        }
        ProgressType ParseType(string type)
        {
            ProgressType textAnchor;
            try
            {
                textAnchor = (ProgressType)Enum.Parse(typeof(ProgressType), type);
            }
            catch
            {
                textAnchor = ProgressType.Solid;
            }
            return textAnchor;
        }
        #endregion

        #region ChatCommands
        [ChatCommand("voteday")]
        private void cmdVoteDay(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 0)
            {
                if (voteOpen)
                {
                    if (!AlreadyVoted(player))
                    {
                        votesReceived.Add(player.userID);
                        Reply(player, "voteSuccess");
                        if (votesReceived.Count >= requiredVotes)
                            VoteEnd(true);
                        return;
                    }
                }
                else Reply(player, "noVote");
            }
            else
            {
                if (!permission.UserHasPermission(player.UserIDString, "skipnightui.admin")) return;
                switch (args[0].ToLower())
                {
                    case "open":
                        if (!voteOpen)
                            OpenVote();
                        else Reply(player, "alreadyOpen");
                        return;
                    case "close":
                        if (voteOpen)
                            VoteEnd(false);
                        else Reply(player, "noVote");
                        return;
                    default:
                        Reply(player, "invalidSyntax");
                        break;
                }
            }
        }
        #endregion

        #region UI Creator
        enum ProgressType { Solid, Graphic, Text }
        class UICreator
        {
            [JsonProperty(PropertyName = "Main Container Size")]
            public UISize Size { get; set; }
            [JsonProperty(PropertyName = "Panel Elements")]
            public List<UIPanel> PanelElements { get; set; }
            [JsonProperty(PropertyName = "Text Elements")]
            public List<UIText> TextElements { get; set; }
            [JsonProperty(PropertyName = "Image Elements")]
            public List<UIImage> ImageElements { get; set; }
            [JsonProperty(PropertyName = "Vote Progress Elements")]
            public List<UIProgress> VoteProgress { get; set; }
            [JsonProperty(PropertyName = "Time Progress Elements")]
            public List<UIProgress> TimeProgress { get; set; }
        }
        class UISize
        {
            [JsonProperty(PropertyName = "Horizontal Start")]
            public float XMin { get; set; }
            [JsonProperty(PropertyName = "Horizontal End")]
            public float XMax { get; set; }
            [JsonProperty(PropertyName = "Vertical Start")]
            public float YMin { get; set; }
            [JsonProperty(PropertyName = "Vertical End")]
            public float YMax { get; set; }
        }
        class UIPanel
        {
            public UISize Size { get; set; }
            [JsonProperty(PropertyName = "Background Color (Hex)")]
            public string Color { get; set; }
            [JsonProperty(PropertyName = "Background Alpha")]
            public float Alpha { get; set; }
        }
        class UIText
        {
            public UISize Size { get; set; }
            public TextComponent Text { get; set; }
        }
        class UIImage
        {
            public UISize Size { get; set; }
            [JsonProperty(PropertyName = "URL or Image filename")]
            public string URL { get; set; }
        }
        class UIProgress
        {
            public UISize Size { get; set; }
            [JsonProperty(PropertyName = "Progress Type")] // (Solid, Graphic, Text)
            public string Type { get; set; }
            [JsonProperty(PropertyName = "URL or Image filename (Graphic)")]
            public string URL { get; set; }
            [JsonProperty(PropertyName = "Bar Color (Solid)")]
            public string Color { get; set; }
            [JsonProperty(PropertyName = "Bar Alpha (Solid)")]
            public float Alpha { get; set; }
            [JsonProperty(PropertyName = "Text Options (Text)")]
            public TextComponent Text { get; set; }
        }
        class TextComponent
        {
            [JsonProperty(PropertyName = "Alignment")] // (LowerCenter, LowerLeft, LowerRight, MiddleCenter, MiddleLeft, MiddleRight, UpperCenter, UpperLeft, UpperRight)
            public string Alignment { get; set; }
            [JsonProperty(PropertyName = "Color (Hex)")]
            public string Color { get; set; }
            public string Text { get; set; }            
            [JsonProperty(PropertyName = "Size")]
            public int Size { get; set; }
        }
        #endregion

        #region Config        
        private ConfigData configData;
        class Colors
        {
            public string Primary { get; set; }
            public string Secondary { get; set; }            
        }
        class Options
        {
            [JsonProperty(PropertyName = "Required vote percentage")]
            public float Percentage { get; set; }
            [JsonProperty(PropertyName = "Time the vote will open")]
            public float Open { get; set; }
            [JsonProperty(PropertyName = "Time to set on successful vote")]
            public float Set { get; set; }
            [JsonProperty(PropertyName = "Duration the vote will be open")]
            public int Duration { get; set; }
        }
        class ConfigData
        {
            [JsonProperty(PropertyName = "UI Configuration Name")]
            public string UIConfig { get; set; }
            [JsonProperty(PropertyName = "UI Configurations")]
            public Dictionary<string, UICreator> PanelTypes { get; set; }
            [JsonProperty(PropertyName = "Message Colors")]
            public Colors Colors { get; set; }
            [JsonProperty(PropertyName = "Options")]
            public Options Options { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                Colors = new Colors
                {
                    Primary = "#ce422b",
                    Secondary = "#939393"
                },
                Options = new Options
                {
                    Percentage = 40f,
                    Open = 18f,
                    Set = 8f,
                    Duration = 240
                },
                PanelTypes = new Dictionary<string, UICreator>
                {
                    #region DayVoteUI
                    ["Design_1"] = new UICreator
                    {
                        Size = new UISize
                        {
                            XMin = 37.5f,
                            XMax = 62.5f,
                            YMin = 93f,
                            YMax = 98f
                        },
                        ImageElements = new List<UIImage> { },
                        PanelElements = new List<UIPanel>
                        {
                            new UIPanel
                            {
                                Alpha = 0.7f,
                                Color = "#4c4c4c",
                                Size = new UISize
                                {
                                    XMax = 100,
                                    XMin = 0,
                                    YMax = 100,
                                    YMin = 0
                                }
                            }
                        },
                        TextElements = new List<UIText>
                        {
                            new UIText
                            {
                                Size = new UISize
                                {
                                    XMin = 2,
                                    XMax = 100,
                                    YMin = 0f,
                                    YMax = 100
                                },
                                Text = new TextComponent
                                {
                                    Alignment = TextAnchor.MiddleLeft.ToString(),
                                    Color = "#ce422b",
                                    Size = 15,
                                    Text = "Skip Night"
                                }
                            }
                        },
                        TimeProgress = new List<UIProgress>
                        {
                            new UIProgress
                            {
                                Alpha = 0f,
                                Color = string.Empty,
                                Size = new UISize
                                {
                                    XMin = 80,
                                    XMax = 95,
                                    YMin = 10,
                                    YMax = 90
                                },
                                Text = new TextComponent
                                {
                                    Alignment = TextAnchor.MiddleRight.ToString(),
                                    Color = string.Empty,
                                    Size = 14,
                                    Text = string.Empty
                                },
                                Type = ProgressType.Text.ToString(),
                                URL = string.Empty
                            }
                        },
                        VoteProgress = new List<UIProgress>
                        {
                            new UIProgress
                            {
                                Alpha = 1f,
                                Color = "#EBB146",
                                Size = new UISize
                                {
                                    XMin = 25f,
                                    XMax = 80f,
                                    YMin = 15f,
                                    YMax = 85f
                                },
                                Type = ProgressType.Solid.ToString(),
                                Text = null,
                                URL = string.Empty
                            },
                            new UIProgress
                            {
                                Alpha = 0f,
                                Color = string.Empty,
                                Size = new UISize
                                {
                                    XMin = 25f,
                                    XMax = 80f,
                                    YMin = 15f,
                                    YMax = 85f
                                },
                                Type = ProgressType.Text.ToString(),
                                Text = new TextComponent
                                {
                                    Alignment = TextAnchor.MiddleCenter.ToString(),
                                    Color = string.Empty,
                                    Size = 14,
                                    Text = "{currentAmount} / {requiredAmount}"
                                },
                                URL = string.Empty
                            }
                        }
                    },
                    #endregion

                    #region GUI SkipNight
                    ["Design_2"] = new UICreator
                    {
                        Size = new UISize
                        {
                            XMin = 40,
                            XMax = 60,
                            YMin = 85,
                            YMax = 95
                        },
                        ImageElements = new List<UIImage>
                        {
                            new UIImage
                            {
                                Size = new UISize
                                {
                                    XMin =7,
                                    XMax = 13.5f,
                                    YMin = 10,
                                    YMax = 33
                                },
                                URL = "https://www.chaoscode.io/oxide/Images/timericon.png"
                            }
                        },
                        PanelElements = new List<UIPanel>
                        {
                            new UIPanel
                            {
                                Alpha = 0.85f,
                                Color = "#191919",
                                Size = new UISize
                                {
                                    XMin = 0,
                                    XMax = 100,
                                    YMin = 0,
                                    YMax = 100
                                }
                            }
                        },
                        TextElements = new List<UIText>
                        {
                            new UIText
                            {
                                Size = new UISize
                                {
                                    XMin = 20,
                                    XMax = 80,
                                    YMin = 70,
                                    YMax = 96
                                },
                                Text = new TextComponent
                                {
                                    Alignment = TextAnchor.MiddleCenter.ToString(),
                                    Color = "#C4FF00",
                                    Size = 14,
                                    Text = "Skip the Night"
                                }                                
                            }
                        },
                        TimeProgress = new List<UIProgress>
                        {
                            new UIProgress
                            {
                                Alpha = 0f,
                                Color = string.Empty,
                                Size = new UISize
                                {
                                    XMin = 20,
                                    XMax = 90,
                                    YMin = 15,
                                    YMax = 28
                                },
                                Text = null,
                                Type = ProgressType.Graphic.ToString(),
                                URL = "https://www.chaoscode.io/oxide/Images/progressbar.png"
                            }
                        },
                        VoteProgress = new List<UIProgress>
                        {
                            new UIProgress
                            {
                                Alpha = 1f,
                                Color = "#4ca5ff",
                                Size = new UISize
                                {
                                    XMin = 5,
                                    XMax = 95,
                                    YMin = 40,
                                    YMax = 68
                                },
                                Text = null,
                                Type = ProgressType.Solid.ToString(),
                                URL = string.Empty
                            },
                            new UIProgress
                            {
                                Alpha = 0f,
                                Color = string.Empty,
                                Size = new UISize
                                {
                                    XMin = 5,
                                    XMax = 95,
                                    YMin = 40,
                                    YMax = 68
                                },
                                Type = ProgressType.Text.ToString(),
                                Text = new TextComponent
                                {
                                    Alignment = TextAnchor.MiddleCenter.ToString(),
                                    Color = string.Empty,
                                    Size = 14,
                                    Text = "{currentAmount} / {requiredAmount}"
                                },
                                URL = string.Empty
                            }
                        }
                        
                    },
                    #endregion

                    #region Bar Design
                    ["Design_3"] = new UICreator
                    {
                        Size = new UISize
                        {
                            XMin = 40,
                            XMax = 60,
                            YMin = 90,
                            YMax = 98
                        },
                        ImageElements = new List<UIImage>
                        {
                            new UIImage
                            {
                                Size = new UISize
                                {
                                    XMin =75,
                                    XMax = 98f,
                                    YMin = 5,
                                    YMax = 95
                                },
                                URL = "https://images.vexels.com/media/users/3/132347/isolated/preview/be0aa6f53b4ac58a4a3612d6dc7a7854-stopwatch-timer-icon-by-vexels.png"
                            }
                        },
                        PanelElements = new List<UIPanel>
                        {
                            new UIPanel
                            {
                                Alpha = 0.85f,
                                Color = "#191919",
                                Size = new UISize
                                {
                                    XMin = 0,
                                    XMax = 72,
                                    YMin = 55,
                                    YMax = 100
                                }
                            },
                            new UIPanel
                            {
                                Alpha = 0.85f,
                                Color = "#191919",
                                Size = new UISize
                                {
                                    XMin = 73.25f,
                                    XMax = 100,
                                    YMin = 0,
                                    YMax = 100
                                }
                            },
                            new UIPanel
                            {
                                Alpha = 0.85f,
                                Color = "#191919",
                                Size = new UISize
                                {
                                    XMin = 0,
                                    XMax = 72,
                                    YMin = 0,
                                    YMax = 50
                                }
                            }
                        },
                        TextElements = new List<UIText>
                        {
                            new UIText
                            {
                                Size = new UISize
                                {
                                    XMin = 0,
                                    XMax = 72,
                                    YMin = 55,
                                    YMax = 100
                                },
                                Text = new TextComponent
                                {
                                    Alignment = TextAnchor.MiddleCenter.ToString(),
                                    Color = "#ce422b",
                                    Size = 14,
                                    Text = "Skip night by typing /voteday"
                                }
                            }
                        },
                        TimeProgress = new List<UIProgress>
                        {
                            new UIProgress
                            {
                                Alpha = 0f,
                                Color = string.Empty,
                                Size = new UISize
                                {
                                    XMin = 73,
                                    XMax = 100,
                                    YMin = 0,
                                    YMax = 100
                                },
                                Text = new TextComponent
                                {
                                    Alignment = TextAnchor.MiddleCenter.ToString(),
                                    Color = string.Empty,
                                    Size = 16,
                                    Text = string.Empty
                                },
                                Type = ProgressType.Text.ToString(),
                                URL = ""
                            }
                        },
                        VoteProgress = new List<UIProgress>
                        {
                            new UIProgress
                            {
                                Alpha = 1f,
                                Color = "#585858",
                                Size = new UISize
                                {
                                    XMin = 2,
                                    XMax = 70,
                                    YMin = 5,
                                    YMax = 45
                                },
                                Text = null,
                                Type = ProgressType.Solid.ToString(),
                                URL = string.Empty
                            },
                            new UIProgress
                            {
                                Alpha = 0f,
                                Color = string.Empty,
                                Size = new UISize
                                {
                                    XMin = 2,
                                    XMax = 70,
                                    YMin = 5,
                                    YMax = 45
                                },
                                Type = ProgressType.Text.ToString(),
                                Text = new TextComponent
                                {
                                    Alignment = TextAnchor.MiddleCenter.ToString(),
                                    Color = string.Empty,
                                    Size = 14,
                                    Text = "{currentAmount} / {requiredAmount}"
                                },
                                URL = string.Empty
                            }
                        }
                    }
                    #endregion
                },
                UIConfig = "Design_3"
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Localization
        void Reply(BasePlayer player, string langKey) => SendReply(player, msg(langKey, player.UserIDString).Replace("{main}", $"<color={configData.Colors.Primary}>").Replace("{msg}", $"<color={configData.Colors.Secondary}>").Replace("{percent}", (configData.Options.Percentage).ToString()));
        void Print(string langKey) => PrintToChat(msg(langKey).Replace("{main}", $"<color={configData.Colors.Primary}>").Replace("{msg}", $"<color={configData.Colors.Secondary}>").Replace("{percent}", (configData.Options.Percentage).ToString()));
        string msg(string key, string playerId = "") => lang.GetMessage(key, this, playerId);
        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            {"voteSuccess", "{msg}You have voted to skip night!</color>" },
            {"noVote", "{msg}There is not currently a vote open!</color>" },
            {"alreadyOpen", "{msg}The is already a vote in progress!</color>" },
            {"invalidSyntax", "{msg}Invalid Syntax! -</color> {main}/voteday open</color>{msg} || </color> {main}/voteday close</color>" },
            {"votingSuccessful", "{main}Voting was successful!</color>{msg} Skipping night</color>" } ,
            {"votingUnsuccessful", "{main}Voting was not successful!</color>{msg} Nighttime inbound</color>" },
            {"commandSyn", "{msg}Type </color>{main}/voteday</color>{msg} now if you want to skip the night!\n-- Requires </color>{main}{percent}%</color>{msg} of the players to vote</color>" },
            {"skipNight", "Skip Night" }
        };
        #endregion
    }
}

// --- End of file: SkipNightUI.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/scientist-bleed ---
// --- Original File Path: S/ScientistBleed/ScientistBleed.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using System.Collections.Generic;
using Random = Oxide.Core.Random;

namespace Oxide.Plugins
{
    [Info("Scientist Bleed", "birthdates", "1.0.0")]
    [Description("Scientist shots now make you bleed")]
    public class ScientistBleed : RustPlugin
    {
        #region Variables

        #endregion

        #region Hooks
        private void Init()
        {
            LoadConfig();
        }

        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (!info.hasDamage) return null;
            var p = entity as BasePlayer;
            if (p == null || info.Initiator == null)
            {
                return null;
            }

            var sci = info.Initiator as NPCPlayer;
            if (sci == null)
            {
                return null;
            }
            var bone = info.boneName;

            var itemName = sci.GetHeldEntity().GetItem().info.shortname;
            Bleed bleed;
            if (!_config.bleeds.TryGetValue(itemName, out bleed))
            {
                bleed = _config.defaultBleed;
            }
            try
            {
                p.metabolism.bleeding.value += Random.Range(bleed.minBleed, bleed.maxBleed);
                Interface.CallHook("OnRunPlayerMetabolism", p.metabolism);
            }
            catch
            {
                PrintError("You have your bleed minimum is higher than your maximum!");
            }
            return null;
        }
        #endregion

        #region Configuration & Language
        public ConfigFile _config;

        public class Bleed
        {
            public float minBleed;
            public float maxBleed;
        }

        public class ConfigFile
        {
            [JsonProperty("Indiviual Item Bleeds (Item shortnames)")]
            public Dictionary<string, Bleed> bleeds;
            [JsonProperty("Default Bleed for any item not found")]
            public Bleed defaultBleed;
            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile()
                {
                    bleeds = new Dictionary<string, Bleed>
                    {
                        {"shotgun.spas12", new Bleed
                        {
                            minBleed = 5f,
                            maxBleed = 6f
                        }}
                    },
                    defaultBleed = new Bleed
                    {
                        minBleed = 3f,
                        maxBleed = 5f
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if (_config == null)
            {
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }
        #endregion
    }
}
//Generated with birthdates' Plugin Maker


// --- End of file: ScientistBleed.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/sign-artist ---
// --- Original File Path: S/SignArtist/SignArtist.cs ---

// Reference: System.Drawing
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Plugins.SignArtistClasses;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.IO;
using System.Linq;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;
using UnityEngine.Networking;
using Color = System.Drawing.Color;
using Graphics = System.Drawing.Graphics;
using Steamworks;

namespace Oxide.Plugins
{
    [Info("Sign Artist", "Whispers88", "1.4.1")]
    [Description("Allows players with the appropriate permission to import images from the internet on paintable objects")]

    /*********************************************************************************
     * This plugin was originally created by Bombardir and then maintained by Nogrod.
     * It was rewritten from scratch by Mughisi on January 12th, 2018.
     *********************************************************************************/

    internal class SignArtist : RustPlugin
    {
        private Dictionary<ulong, float> cooldowns = new Dictionary<ulong, float>();
        private GameObject imageDownloaderGameObject;
        private ImageDownloader imageDownloader;
        SignArtistConfig Settings { get; set; }
        Dictionary<string, ImageSize> ImageSizePerAsset { get; set; }

        Dictionary<ulong, string> SkiniconUrls = new Dictionary<ulong, string>();

        private const string ItemIconUrl = "https://www.rustedit.io/images/imagelibrary/{0}.png";


        /// <summary>
        /// Plugin configuration
        /// </summary>
        public class SignArtistConfig
        {
            [JsonProperty(PropertyName = "Time in seconds between download requests (0 to disable)")]
            public int Cooldown { get; set; }

            [JsonProperty(PropertyName = "Maximum concurrent downloads")]
            public int MaxActiveDownloads { get; set; }

            [JsonProperty(PropertyName = "Maximum distance from the sign")]
            public int MaxDistance { get; set; }

            [JsonProperty(PropertyName = "Maximum filesize in MB")]
            public float MaxSize { get; set; }

            [JsonProperty(PropertyName = "Enforce JPG file format")]
            public bool EnforceJpeg { get; set; }

            [JsonProperty(PropertyName = "JPG image quality (0-100)")]
            public int Quality
            {
                get
                {
                    return quality;
                }
                set
                {
                    // Validate the value, it can't be less than 0 and not more than 100.
                    if (value >= 0 && value <= 100)
                    {
                        quality = value;
                    }
                    else
                    {
                        // Set the quality to a default value of 85% when an invalid value was specified.
                        quality = value > 100 ? 100 : 85;
                    }
                }
            }

            [JsonProperty("Enable logging file")]
            public bool FileLogging { get; set; }

            [JsonProperty("Enable logging console")]
            public bool ConsoleLogging { get; set; }

            [JsonProperty("Enable discord logging")]
            public bool Discordlogging { get; set; }

            [JsonProperty("Discord Webhook")]
            public string DiscordWebhook { get; set; }

            [JsonProperty("Avatar URL")]
            public string AvatarUrl { get; set; }

            [JsonProperty("Discord Username")]
            public string DiscordUsername { get; set; }


            [JsonIgnore]
            public float MaxFileSizeInBytes
            {
                get
                {
                    return MaxSize * 1024 * 1024;
                }
            }

            private int quality = 85;

            /// <summary>
            /// Creates a default configuration file
            /// </summary>
            /// <returns>Default config</returns>
            public static SignArtistConfig DefaultConfig()
            {
                return new SignArtistConfig
                {
                    Cooldown = 0,
                    MaxSize = 1,
                    MaxDistance = 3,
                    MaxActiveDownloads = 5,
                    EnforceJpeg = false,
                    Quality = 85,
                    FileLogging = false,
                    ConsoleLogging = false,
                    Discordlogging = false,
                    DiscordWebhook = "",
                    AvatarUrl = "https://i.imgur.com/dH7V1Dh.png",
                    DiscordUsername = "Sign Artist"
                };
            }
        }

        /// <summary>
        /// A type used to request new images to download.
        /// </summary>
        private class DownloadRequest
        {
            public BasePlayer Sender { get; }
            public IPaintableEntity Sign { get; }
            public string Url { get; set; }
            public bool Raw { get; }
            public bool Hor { get; }
            public uint TextureIndex { get; }

            /// <summary>
            /// Initializes a new instance of the <see cref="DownloadRequest" ></see> class.
            /// </summary>
            /// <param name="url">The URL to download the image from. </param>
            /// <param name="player">The player that requested the download. </param>
            /// <param name="sign">The sign to add the image to. </param>
            /// <param name="raw">Should the image be stored with or without conversion to jpeg. </param>
            public DownloadRequest(string url, BasePlayer player, IPaintableEntity sign, bool raw, bool hor, uint textureIndex)
            {
                Url = url;
                Sender = player;
                Sign = sign;
                Raw = raw;
                Hor = hor;
                TextureIndex = textureIndex;
            }
        }

        /// <summary>
        /// A type used to request new images to be restored.
        /// </summary>
        private class RestoreRequest
        {
            public BasePlayer Sender { get; }
            public IPaintableEntity Sign { get; }
            public bool Raw { get; }
            public uint TextureIndex { get; }

            /// <summary>
            /// Initializes a new instance of the <see cref="RestoreRequest" ></see> class.
            /// </summary>
            /// <param name="player">The player that requested the restore. </param>
            /// <param name="sign">The sign to restore the image from. </param>
            /// <param name="raw">Should the image be stored with or without conversion to jpeg. </param>
            public RestoreRequest(BasePlayer player, IPaintableEntity sign, bool raw, uint textureIndex)
            {
                Sender = player;
                Sign = sign;
                Raw = raw;
                TextureIndex = textureIndex;
            }
        }

        /// <summary>
        /// A type used to determine the size of the image for a sign
        /// </summary>
        public class ImageSize
        {
            public int Width { get; }
            public int Height { get; }
            public int ImageWidth { get; }
            public int ImageHeight { get; }

            /// <summary>
            /// Initializes a new instance of the <see cref="ImageSize" ></see> class.
            /// </summary>
            /// <param name="width">The width of the canvas and the image. </param>
            /// <param name="height">The height of the canvas and the image. </param>
            public ImageSize(int width, int height) : this(width, height, width, height)
            {
            }

            /// <summary>
            /// Initializes a new instance of the <see cref="ImageSize" ></see> class.
            /// </summary>
            /// <param name="width">The width of the canvas. </param>
            /// <param name="height">The height of the canvas. </param>
            /// <param name="imageWidth">The width of the image. </param>
            /// <param name="imageHeight">The height of the image. </param>
            public ImageSize(int width, int height, int imageWidth, int imageHeight)
            {
                Width = width;
                Height = height;
                ImageWidth = imageWidth;
                ImageHeight = imageHeight;
            }
        }


        #region Image Download Behaviour
        /// <summary>
        /// UnityEngine script to be attached to a GameObject to download images and apply them to signs.
        /// </summary>
        private class ImageDownloader : MonoBehaviour
        {
            private byte activeDownloads;
            private byte activeRestores;
            private readonly SignArtist signArtist = (SignArtist)Interface.Oxide.RootPluginManager.GetPlugin(nameof(SignArtist));
            private readonly Queue<DownloadRequest> downloadQueue = new Queue<DownloadRequest>();
            private readonly Queue<RestoreRequest> restoreQueue = new Queue<RestoreRequest>();

            /// <summary>
            /// Queue a new image to download and add to a sign
            /// </summary>
            /// <param name="url">The URL to download the image from. </param>
            /// <param name="player">The player that requested the download. </param>
            /// <param name="sign">The sign to add the image to. </param>
            /// <param name="raw">Should the image be stored with or without conversion to jpeg. </param>
            public void QueueDownload(string url, BasePlayer player, IPaintableEntity sign, uint textureIndex, bool raw, bool hor = false)
            {
                // Check if there is already a request for this sign and show an error if there is.
                bool existingRequest = downloadQueue.Any(request => request.Sign == sign) || restoreQueue.Any(request => request.Sign == sign);
                if (existingRequest)
                {
                    signArtist.SendMessage(player, "ActionQueuedAlready");

                    return;
                }

                // Instantiate a new DownloadRequest and add it to the queue.
                downloadQueue.Enqueue(new DownloadRequest(url, player, sign, raw, hor, textureIndex));

                // Attempt to start the next download.
                StartNextDownload();
            }

            /// <summary>
            /// Attempts to restore a sign.
            /// </summary>
            /// <param name="player">The player that requested the restore. </param>
            /// <param name="sign">The sign to restore the image from. </param>
            /// <param name="raw">Should the image be stored with or without conversion to jpeg. </param>
            public void QueueRestore(BasePlayer player, IPaintableEntity sign, bool raw, uint textureIndex)
            {
                // Check if there is already a request for this sign and show an error if there is.
                bool existingRequest = downloadQueue.Any(request => request.Sign == sign) || restoreQueue.Any(request => request.Sign == sign);
                if (existingRequest)
                {
                    signArtist.SendMessage(player, "ActionQueuedAlready");

                    return;
                }

                // Instantiate a new RestoreRequest and add it to the queue.
                restoreQueue.Enqueue(new RestoreRequest(player, sign, raw, textureIndex));

                // Attempt to start the next restore.
                StartNextRestore();
            }

            /// <summary>
            /// Starts the next download if available.
            /// </summary>
            /// <param name="reduceCount"></param>
            private void StartNextDownload(bool reduceCount = false)
            {
                // Check if we need to reduce the active downloads counter after a succesful or failed download.
                if (reduceCount)
                {
                    activeDownloads--;
                }

                // Check if we don't have the maximum configured amount of downloads running already.
                if (activeDownloads >= signArtist.Settings.MaxActiveDownloads)
                {
                    return;
                }

                // Check if there is still an image in the queue.
                if (downloadQueue.Count <= 0)
                {
                    return;
                }

                // Increment the active downloads by 1 and start the download process.
                activeDownloads++;
                StartCoroutine(DownloadImage(downloadQueue.Dequeue()));
            }

            /// <summary>
            /// Starts the next restore if available.
            /// </summary>
            /// <param name="reduceCount"></param>
            private void StartNextRestore(bool reduceCount = false)
            {
                // Check if we need to reduce the active restores counter after a succesful or failed restore.
                if (reduceCount)
                {
                    activeRestores--;
                }

                // Check if we don't have the maximum configured amount of restores running already.
                if (activeRestores >= signArtist.Settings.MaxActiveDownloads)
                {
                    return;
                }

                // Check if there is still an image in the queue.
                if (restoreQueue.Count <= 0)
                {
                    return;
                }

                // Increment the active restores by 1 and start the restore process.
                activeRestores++;
                StartCoroutine(RestoreImage(restoreQueue.Dequeue()));
            }

            /// <summary>
            /// Downloads the image and adds it to the sign.
            /// </summary>
            /// <param name="request">The requested <see cref="DownloadRequest"></see> instance. </param>
            private IEnumerator DownloadImage(DownloadRequest request)
            {
                if (ItemManager.itemDictionaryByName.ContainsKey(request.Url))
                {
                    request.Url = string.Format(ItemIconUrl, request.Url);
                }

                UnityWebRequest www = UnityWebRequest.Get(request.Url);

                yield return www.SendWebRequest();

                // Verify that there is a valid reference to the plugin from this class.
                if (signArtist == null)
                {
                    throw new NullReferenceException("signArtist");
                }

                // Verify that the webrequest was succesful.
                if (www.isNetworkError || www.isHttpError)
                {
                    // The webrequest wasn't succesful, show a message to the player and attempt to start the next download.
                    signArtist.SendMessage(request.Sender, "WebErrorOccurred", www.error);
                    www.Dispose();
                    StartNextDownload(true);
                    yield break;
                }

                // Verify that the file doesn't exceed the maximum configured filesize.
                if (www.downloadedBytes > signArtist.Settings.MaxFileSizeInBytes)
                {
                    // The file is too large, show a message to the player and attempt to start the next download.
                    signArtist.SendMessage(request.Sender, "FileTooLarge", signArtist.Settings.MaxSize);
                    www.Dispose();
                    StartNextDownload(true);
                    yield break;
                }

                // Get the bytes array for the image from the webrequest and lookup the target image size for the targeted sign.
                byte[] imageBytes;

                if (request.Raw)
                {
                    imageBytes = www.downloadHandler.data;
                }
                else
                {
                    imageBytes = GetImageBytes(www);
                }

                ImageSize size = GetImageSizeFor(request.Sign);

                // Verify that we have image size data for the targeted sign.
                if (size == null)
                {
                    // No data was found, show a message to the player and print a detailed message to the server console and attempt to start the next download.
                    signArtist.SendMessage(request.Sender, "ErrorOccurred");
                    signArtist.PrintWarning($"Couldn't find the required image size for {request.Sign.PrefabName}, please report this in the plugin's thread.");
                    StartNextDownload(true);
                    www.Dispose();
                    yield break;
                }

                RotateFlipType rotation = RotateFlipType.RotateNoneFlipNone;
                if (request.Hor)
                {
                    rotation = RotateFlipType.RotateNoneFlipX;
                }

                object rotateObj = Interface.Call("GetImageRotation", request.Sign.Entity);
                if (rotateObj is RotateFlipType)
                {
                    rotation = (RotateFlipType)rotateObj;
                }

                // Get the bytes array for the resized image for the targeted sign.
                byte[] resizedImageBytes = imageBytes.ResizeImage(size.Width, size.Height, size.ImageWidth, size.ImageHeight, signArtist.Settings.EnforceJpeg && !request.Raw, rotation);
                // Verify that the resized file doesn't exceed the maximum configured filesize.
                if (resizedImageBytes.Length > signArtist.Settings.MaxFileSizeInBytes)
                {
                    // The file is too large, show a message to the player and attempt to start the next download.
                    signArtist.SendMessage(request.Sender, "FileTooLarge", signArtist.Settings.MaxSize);
                    www.Dispose();
                    StartNextDownload(true);

                    yield break;
                }

                // Ensure the texture id array is initialized to avoid errors.
                request.Sign.EnsureInitialized();

                // Check if the sign already has a texture assigned at the specified index.
                uint existingTextureId = request.Sign.TextureIds[request.TextureIndex];
                if (existingTextureId != 0)
                {
                    // A texture was already assigned, remove this file to make room for the new one.
                    FileStorage.server.Remove(existingTextureId, FileStorage.Type.png, request.Sign.NetId);
                }

                uint textureId = FileStorage.server.Store(resizedImageBytes, FileStorage.Type.png, request.Sign.NetId, request.TextureIndex);

                // Create the image on the filestorage and send out a network update for the sign.
                request.Sign.SetImage(request.TextureIndex, textureId);
                request.Sign.SendNetworkUpdate();

                // Notify the player that the image was loaded.
                signArtist.SendMessage(request.Sender, "ImageLoaded");

                // Call the Oxide hook 'OnSignUpdated' to notify other plugins of the update event.
                Interface.Oxide.CallHook("OnSignUpdated", request.Sign.Entity, request.Sender);

                if (request.Sender != null)
                {
                    // Check if logging to console is enabled.
                    if (signArtist.Settings.ConsoleLogging)
                    {
                        // Console logging is enabled, show a message in the server console.
                        signArtist.Puts(signArtist.GetTranslation("LogEntry"), request.Sender.displayName,
                            request.Sender.userID, textureId, request.Sign.ShortPrefabName, request.Url);
                    }

                    // Check if logging to file is enabled.
                    if (signArtist.Settings.FileLogging)
                    {
                        // File logging is enabled, add an entry to the logfile.
                        signArtist.LogToFile("log",
                            string.Format(signArtist.GetTranslation("LogEntry"), request.Sender.displayName,
                                request.Sender.userID, textureId, request.Sign.ShortPrefabName,
                                request.Url), signArtist);
                    }

                    if (signArtist.Settings.Discordlogging)
                    {
                        // Discord logging is enabled, add an entry to the logfile.
                        StartCoroutine(LogToDiscord(request));
                    }
                }
                // Attempt to start the next download.
                StartNextDownload(true);
                www.Dispose();

            }

            private IEnumerator LogToDiscord(DownloadRequest request)
            {
                BasePlayer player = request.Sender;
                IPaintableEntity sign = request.Sign;
                var msg = DiscordMessage(ConVar.Server.hostname, player.displayName, player.UserIDString, sign.ShortPrefabName, request.Url, sign.Entity.transform.position.ToString());
                string jsonmsg = JsonConvert.SerializeObject(msg);
                UnityWebRequest wwwpost = new UnityWebRequest(signArtist.Settings.DiscordWebhook, "POST");
                byte[] jsonToSend = new System.Text.UTF8Encoding().GetBytes(jsonmsg.ToString());
                wwwpost.uploadHandler = (UploadHandler)new UploadHandlerRaw(jsonToSend);
                wwwpost.SetRequestHeader("Content-Type", "application/json");
                yield return wwwpost.SendWebRequest();

                if (wwwpost.isNetworkError || wwwpost.isHttpError)
                {
                    signArtist.PrintError(wwwpost.error);
                    signArtist.PrintError(jsonmsg);
                    yield break;
                }
                wwwpost.Dispose();
            }

            private Message DiscordMessage(string servername, string playername, string userid, string itemname, string imgurl, string location)
            {
                string steamprofile = "https://steamcommunity.com/profiles/" + userid;
                var fields = new List<Message.Fields>()
                {
                    new Message.Fields("Player: " + playername, $"[{userid}]({steamprofile})", true),
                    new Message.Fields("Entity", itemname, true),
                    new Message.Fields("Image Url", imgurl, false),
                    new Message.Fields("Teleport position", "teleportpos " + location.Replace(" ", string.Empty), false)
                };
                var footer = new Message.Footer($"Logged @{DateTime.UtcNow:dd/MM/yy HH:mm:ss}");
                var image = new Message.Image(imgurl);
                var embeds = new List<Message.Embeds>()
                {
                    new Message.Embeds("Server - " + servername, "A sign has been updated" , fields, footer, image)
                };
                Message msg = new Message(signArtist.Settings.DiscordUsername, signArtist.Settings.AvatarUrl, embeds);
                return msg;
            }


            /// <summary>
            /// Restores the image and adds it to the sign again.
            /// </summary>
            /// <param name="request">The requested <see cref="RestoreRequest"></see> instance. </param>
            /// <returns></returns>
            private IEnumerator RestoreImage(RestoreRequest request)
            {
                // Verify that there is a valid reference to the plugin from this class.
                if (signArtist == null)
                {
                    throw new NullReferenceException("signArtist");
                }

                byte[] imageBytes;

                uint textureId = request.Sign.TextureIds[request.TextureIndex];

                // Check if the sign already has a texture assigned to it.
                if (textureId == 0)
                {
                    // No texture was previously assigned, show a message to the player.
                    signArtist.SendMessage(request.Sender, "RestoreErrorOccurred");
                    StartNextRestore(true);

                    yield break;
                }

                // Cache the byte array of the currently stored file.
                imageBytes = FileStorage.server.Get(textureId, FileStorage.Type.png, request.Sign.NetId);
                ImageSize size = GetImageSizeFor(request.Sign);

                // Verify that we have image size data for the targeted sign.
                if (size == null)
                {
                    // No data was found, show a message to the player and print a detailed message to the server console and attempt to start the next download.
                    signArtist.SendMessage(request.Sender, "ErrorOccurred");
                    signArtist.PrintWarning($"Couldn't find the required image size for {request.Sign.PrefabName}, please report this in the plugin's thread.");
                    StartNextRestore(true);

                    yield break;
                }

                // Remove the texture from the FileStorage.
                FileStorage.server.Remove(textureId, FileStorage.Type.png, request.Sign.NetId);

                // Get the bytes array for the resized image for the targeted sign.
                byte[] resizedImageBytes = imageBytes.ResizeImage(size.Width, size.Height, size.ImageWidth, size.ImageHeight, signArtist.Settings.EnforceJpeg && !request.Raw);

                // Create the image on the filestorage and send out a network update for the sign.
                request.Sign.SetImage(request.TextureIndex, FileStorage.server.Store(resizedImageBytes, FileStorage.Type.png, request.Sign.NetId));
                request.Sign.SendNetworkUpdate();

                // Notify the player that the image was loaded.
                signArtist.SendMessage(request.Sender, "ImageRestored");

                // Call the Oxide hook 'OnSignUpdated' to notify other plugins of the update event.
                Interface.Oxide.CallHook("OnSignUpdated", request.Sign.Entity, request.Sender);

                // Attempt to start the next download.
                StartNextRestore(true);
            }

            /// <summary>
            /// Gets the target image size for a <see cref="Signage"></see>.
            /// </summary>
            /// <param name="signage"></param>
            private ImageSize GetImageSizeFor(IPaintableEntity signage)
            {
                if (signArtist.ImageSizePerAsset.ContainsKey(signage.ShortPrefabName))
                {
                    return signArtist.ImageSizePerAsset[signage.ShortPrefabName];
                }

                return null;
            }

            /// <summary>
            /// Converts the <see cref="Texture2D"></see> from the webrequest to a <see cref="byte"></see> array.
            /// </summary>
            /// <param name="www">The completed webrequest. </param>
            private byte[] GetImageBytes(UnityWebRequest www)
            {
                Texture2D texture = new Texture2D(2, 2);
                texture.LoadImage(www.downloadHandler.data);

                byte[] image;

                if (texture.format == TextureFormat.ARGB32 && !signArtist.Settings.EnforceJpeg)
                {
                    image = texture.EncodeToPNG();
                }
                else
                {
                    image = texture.EncodeToJPG(signArtist.Settings.Quality);
                }

                DestroyImmediate(texture);

                return image;
            }
        }

        #endregion Image Download Behaviour
        private interface IPaintableEntity
        {
            BaseEntity Entity { get; }
            string PrefabName { get; }
            string ShortPrefabName { get; }
            NetworkableId NetId { get; }
            int TextureCount { get; }
            uint[] TextureIds { get; }

            void SendNetworkUpdate();
            void SetImage(uint textureIndex, uint id);
            bool CanUpdate(BasePlayer player);
            void EnsureInitialized();
        }

        private abstract class BasePaintableEntity : IPaintableEntity
        {
            public BaseEntity Entity { get; }
            public string PrefabName { get; }
            public string ShortPrefabName { get; }
            public NetworkableId NetId { get; }
            public virtual int TextureCount => 1;
            public abstract uint[] TextureIds { get; }

            protected BasePaintableEntity(BaseEntity entity)
            {
                Entity = entity;
                PrefabName = Entity.PrefabName;
                ShortPrefabName = Entity.ShortPrefabName;
                NetId = Entity.net.ID;
            }

            public abstract bool CanUpdate(BasePlayer player);
            public abstract void SetImage(uint textureIndex, uint id);
            public virtual void EnsureInitialized() { }

            public void SendNetworkUpdate()
            {
                Entity.SendNetworkUpdate();
            }
        }

        private class PaintableSignage : BasePaintableEntity, IPaintableEntity
        {
            public Signage Sign { get; set; }
            public override int TextureCount => Sign.TextureCount;
            public override uint[] TextureIds => Sign.GetTextureCRCs();

            public PaintableSignage(Signage sign) : base(sign)
            {
                Sign = sign;
            }

            public override void SetImage(uint textureIndex, uint id)
            {
                Sign.EnsureInitialized();
                Sign.textureIDs[textureIndex] = id;
            }

            public override bool CanUpdate(BasePlayer player)
            {
                return Sign.CanUpdateSign(player);
            }

            public override void EnsureInitialized()
            {
                Sign.EnsureInitialized();
            }
        }

        private class PaintableFrame : BasePaintableEntity, IPaintableEntity
        {
            public PhotoFrame Sign { get; set; }
            public override uint[] TextureIds => Sign.GetTextureCRCs();

            public PaintableFrame(PhotoFrame sign) : base(sign)
            {
                Sign = sign;
            }

            public override void SetImage(uint textureIndex, uint id)
            {
                Sign._overlayTextureCrc = id;
            }

            public override bool CanUpdate(BasePlayer player)
            {
                return Sign.CanUpdateSign(player);
            }
        }

        private class PaintablePumpkin : BasePaintableEntity, IPaintableEntity
        {
            public CarvablePumpkin Pumpkin { get; set; }
            public override uint[] TextureIds => Pumpkin.textureIDs;

            public PaintablePumpkin(CarvablePumpkin pumpkin) : base(pumpkin)
            {
                Pumpkin = pumpkin;
            }

            public override void SetImage(uint textureIndex, uint id)
            {
                EnsureInitialized();
                Pumpkin.textureIDs[textureIndex] = id;
            }

            public override bool CanUpdate(BasePlayer player)
            {
                return Pumpkin.CanUpdateSign(player);
            }

            public override void EnsureInitialized()
            {
                int size = Mathf.Max(Pumpkin.paintableSources.Length, 1);
                if (Pumpkin.textureIDs == null || Pumpkin.textureIDs.Length != size)
                {
                    Array.Resize(ref Pumpkin.textureIDs, size);
                }
            }
        }


        #region Init
        /// <summary>
        /// Oxide hook that is triggered when the plugin is loaded.
        /// </summary>
        ///
        private void Init()
        {
            // Register all the permissions used by the plugin
            permission.RegisterPermission("signartist.file", this);
            permission.RegisterPermission("signartist.ignorecd", this);
            permission.RegisterPermission("signartist.ignoreowner", this);
            permission.RegisterPermission("signartist.raw", this);
            permission.RegisterPermission("signartist.restore", this);
            permission.RegisterPermission("signartist.restoreall", this);
            permission.RegisterPermission("signartist.text", this);
            permission.RegisterPermission("signartist.url", this);

            AddCovalenceCommand("sil", "SilCommand");
            AddCovalenceCommand("silt", "SiltCommand");
            AddCovalenceCommand("sili", "SilItemCommand");
            AddCovalenceCommand("silrestore", "RestoreCommand");

            // Initialize the dictionary with all paintable object assets and their target sizes
            ImageSizePerAsset = new Dictionary<string, ImageSize>
            {
                // Picture Frames
                ["sign.pictureframe.landscape"] = new ImageSize(256, 128), // Landscape Picture Frame
                ["sign.pictureframe.portrait"] = new ImageSize(128, 256),  // Portrait Picture Frame
                ["sign.pictureframe.tall"] = new ImageSize(128, 512),      // Tall Picture Frame
                ["sign.pictureframe.xl"] = new ImageSize(512, 512),        // XL Picture Frame
                ["sign.pictureframe.xxl"] = new ImageSize(1024, 512),      // XXL Picture Frame

                // Wooden Signs
                ["sign.small.wood"] = new ImageSize(128, 64),              // Small Wooden Sign
                ["sign.medium.wood"] = new ImageSize(256, 128),            // Wooden Sign
                ["sign.large.wood"] = new ImageSize(256, 128),             // Large Wooden Sign
                ["sign.huge.wood"] = new ImageSize(512, 128),              // Huge Wooden Sign

                // Banners
                ["sign.hanging.banner.large"] = new ImageSize(64, 256),    // Large Banner Hanging
                ["sign.pole.banner.large"] = new ImageSize(64, 256),       // Large Banner on Pole

                // Hanging Signs
                ["sign.hanging"] = new ImageSize(128, 256),                // Two Sided Hanging Sign
                ["sign.hanging.ornate"] = new ImageSize(256, 128),         // Two Sided Ornate Hanging Sign

                // Town Signs
                ["sign.post.single"] = new ImageSize(128, 64),             // Single Sign Post
                ["sign.post.double"] = new ImageSize(256, 256),            // Double Sign Post
                ["sign.post.town"] = new ImageSize(256, 128),              // One Sided Town Sign Post
                ["sign.post.town.roof"] = new ImageSize(256, 128),         // Two Sided Town Sign Post

                // Photo Frames
                ["photoframe.large"] = new ImageSize(320, 240),
                ["photoframe.portrait"] = new ImageSize(320, 384),
                ["photoframe.landscape"] = new ImageSize(320, 240),

                // Neon Signs
                ["sign.neon.xl.animated"] = new ImageSize(256, 256),
                ["sign.neon.xl"] = new ImageSize(256, 256),
                ["sign.neon.125x215.animated"] = new ImageSize(128, 256),
                ["sign.neon.125x215"] = new ImageSize(128, 256),
                ["sign.neon.125x125"] = new ImageSize(128, 128),

                // Other paintable assets
                ["spinner.wheel.deployed"] = new ImageSize(512, 512, 285, 285), // Spinning Wheel
                ["carvable.pumpkin"] = new ImageSize(64, 128),
            };
        }

        private void GetSteamworksImages()
        {
            foreach (InventoryDef item in Steamworks.SteamInventory.Definitions)
            {
                string shortname = item.GetProperty("itemshortname");
                if (item == null || string.IsNullOrEmpty(shortname))
                    continue;

                if (item.Id < 100)
                    continue;

                ulong workshopid;
                if (!ulong.TryParse(item.GetProperty("workshopid"), out workshopid))
                    continue;

                if (string.IsNullOrEmpty(item.IconUrl)) continue;
                SkiniconUrls[workshopid] = item.IconUrl;
            }
        }

        /// <summary>
        /// Oxide hook that is triggered to automatically load the configuration file.
        /// </summary>
        protected override void LoadConfig()
        {
            base.LoadConfig();
            Settings = Config.ReadObject<SignArtistConfig>();
            SaveConfig();
        }

        /// <summary>
        /// Oxide hook that is triggered to automatically load the default configuration file when no file exists.
        /// </summary>
        protected override void LoadDefaultConfig()
        {
            Settings = SignArtistConfig.DefaultConfig();
        }

        /// <summary>
        /// Oxide hook that is triggered to save the configuration file.
        /// </summary>
        protected override void SaveConfig()
        {
            Config.WriteObject(Settings);
        }

        /// <summary>
        /// Oxide hook that is triggered when the server has fully initialized.
        /// </summary>
        private void OnServerInitialized()
        {
            // Create a new GameObject and attach the UnityEngine script to it for handling the image downloads.
            imageDownloaderGameObject = new GameObject("ImageDownloader");
            imageDownloader = imageDownloaderGameObject.AddComponent<ImageDownloader>();
            if ((Steamworks.SteamInventory.Definitions?.Length ?? 0) == 0)
            {
                PrintWarning("Waiting for Steamworks to update item definitions....");
                Steamworks.SteamInventory.OnDefinitionsUpdated += GetSteamworksImages;
            }
            else GetSteamworksImages();
        }

        /// <summary>
        /// Oxide hook that is triggered when the plugin is unloaded.
        /// </summary>
        private void Unload()
        {
            // Destroy the created GameObject and cleanup.
            UnityEngine.Object.Destroy(imageDownloaderGameObject);
            imageDownloader = null;
            cooldowns = null;

            Steamworks.SteamInventory.OnDefinitionsUpdated -= GetSteamworksImages;
        }

        /// <summary>
        /// Handles the /sil command.
        /// </summary>
        /// <param name="iplayer">The player that has executed the command. </param>
        /// <param name="command">The name of the command that was executed. </param>
        /// <param name="args">All arguments that were passed with the command. </param>
        ///
        #endregion Init

        #region Localization
        /// <summary>
        /// Oxide hook that is triggered automatically after it has been loaded to initialize the messages for the Lang API.
        /// </summary>
        protected override void LoadDefaultMessages()
        {
            // Register all messages used by the plugin in the Lang API.
            lang.RegisterMessages(new Dictionary<string, string>
            {
                // Messages used throughout the plugin.
                ["WebErrorOccurred"] = "Failed to download the image! Error {0}.",
                ["FileTooLarge"] = "The file exceeds the maximum file size of {0}Mb.",
                ["ErrorOccurred"] = "An unknown error has occured, if this error keeps occuring please notify the server admin.",
                ["RestoreErrorOccurred"] = "Can't restore the sign because no texture is assigned to it.",
                ["DownloadQueued"] = "Your image was added to the download queue!",
                ["RestoreQueued"] = "Your sign was added to the restore queue!",
                ["RestoreBatchQueued"] = "You added all {0} signs to the restore queue!",
                ["ImageLoaded"] = "The image was succesfully loaded to the sign!",
                ["ImageRestored"] = "The image was succesfully restored for the sign!",
                ["LogEntry"] = "Player `{0}` (SteamId: {1}) loaded {2} into {3} from {4}",
                ["NoSignFound"] = "Unable to find a sign! Make sure you are looking at one and that you are not too far away from it.",
                ["Cooldown"] = "You can't use the command yet! Remaining cooldown: {0}.",
                ["SignNotOwned"] = "You can't change this sign as it is protected by a tool cupboard.",
                ["NoItemHeld"] = "You're not holding an item.",
                ["ActionQueuedAlready"] = "An action has already been queued for this sign, please wait for this action to complete.",
                ["SyntaxSilCommand"] = "Syntax error!\nSyntax: /sil <url> [raw]",
                ["SyntaxSilCommandMulti"] = "Syntax error!\nSyntax: /sil <1-{0}> <url> [raw]",
                ["SyntaxSiltCommand"] = "Syntax error!\nSyntax: /silt <message> [<fontsize:number>] [<color:hex value>] [<bgcolor:hex value>] [raw]",
                ["SyntaxSiltCommandMulti"] = "Syntax error!\nSyntax: /silt <1-{0}> <message> [<fontsize:number>] [<color:hex value>] [<bgcolor:hex value>] [raw]",
                ["SyntaxSiliCommandMulti"] = "Syntax error!\nSyntax: /sili <1-{0}>",
                ["NoPermission"] = "You don't have permission to use this command.",
                ["NoPermissionFile"] = "You don't have permission to use images from the server's filesystem.",
                ["NoPermissionRaw"] = "You don't have permission to use raw images, loading normally instead.",
                ["NoPermissionRestoreAll"] = "You don't have permission to use restore all signs at once.",

                // Cooldown formatting 'translations'.
                ["day"] = "day",
                ["days"] = "days",
                ["hour"] = "hour",
                ["hours"] = "hours",
                ["minute"] = "minute",
                ["minutes"] = "minutes",
                ["second"] = "second",
                ["seconds"] = "seconds",
                ["and"] = "and"
            }, this);
        }
        #endregion Localization

        #region Commands
        [Command("sil"), Permission("signartist.url")]
        private void SilCommand(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;

            // Verify if the player has permission to use this command.
            if (!HasPermission(player, "signartist.url"))
            {
                // The player doesn't have permission to use this command, show an error message.
                SendMessage(player, "NoPermission");

                return;
            }

            // Verify that the command isn't on cooldown for the user.
            if (HasCooldown(player))
            {
                // The command is still on cooldown for the player, show an error message.
                SendMessage(player, "Cooldown", FormatCooldown(GetCooldown(player)));

                return;
            }

            // Check if the player is looking at a sign.
            IPaintableEntity sign;
            if (!IsLookingAtSign(player, out sign))
            {
                // The player isn't looking at a sign or is too far away from it, show an error message.
                SendMessage(player, "NoSignFound");

                return;
            }

            uint textureIndex = 0;
            if (sign.TextureCount > 1)
            {
                // Verify if the correct syntax is used for animated Neon Signs.
                if (!HasValidIndexArg(args, sign, out textureIndex))
                {
                    // Invalid syntax was used, show an error message to the player.
                    SendMessage(player, "SyntaxSilCommandMulti", sign.TextureCount);

                    return;
                }

                // Remove the index argument so the rest of the command handling can ignore it.
                args = args.Skip(1).ToArray();
            }

            // Verify if the correct syntax is used.
            if (args.Length < 1)
            {
                // Invalid syntax was used, show an error message to the player.
                if (sign.TextureCount > 1)
                {
                    SendMessage(player, "SyntaxSilCommandMulti", sign.TextureCount);
                }
                else
                {
                    SendMessage(player, "SyntaxSilCommand");
                }

                return;
            }

            // Check if the player is able to update the sign.
            if (!CanChangeSign(player, sign))
            {
                // The player isn't able to update the sign, show an error message.
                SendMessage(player, "SignNotOwned");

                return;
            }

            // Check if the player wants to add the image from the server's filesystem and has the permission to do so.
            if (args[0].StartsWith("file://") && !HasPermission(player, "signartist.file"))
            {
                // The player doesn't have permission for this, show an error message.
                SendMessage(player, "NoPermissionFile");

                return;
            }

            // Check if the player wants to add the image as a raw image and has the permission to do so.
            bool raw = args.Length > 1 && args[1].Equals("raw", StringComparison.OrdinalIgnoreCase);
            if (raw && !HasPermission(player, "signartist.raw"))
            {
                // The player doesn't have permission for this, show a message and disable raw.
                SendMessage(player, "NoPermissionRaw");
                raw = false;
            }

            // This sign pastes in reverse, so we'll check and set a var to flip it
            bool hor = sign.ShortPrefabName == "sign.hanging";

            // Notify the player that it is added to the queue.
            SendMessage(player, "DownloadQueued");

            // Queue the download of the specified image.
            imageDownloader.QueueDownload(args[0], player, sign, textureIndex, raw, hor);

            // Call external hook
            Interface.Oxide.CallHook("OnImagePost", player, args[0], raw, sign.Entity, textureIndex);

            // Set the cooldown on the command for the player if the cooldown setting is enabled.
            SetCooldown(player);
        }

        [Command("sili"), Permission("signartist.url")]
        private void SilItemCommand(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            if (!HasPermission(player, "signartist.url"))
            {
                SendMessage(player, "NoPermission");
                return;
            }

            if (HasCooldown(player))
            {
                SendMessage(player, "Cooldown", FormatCooldown(GetCooldown(player)));
                return;
            }

            IPaintableEntity sign;
            if (!IsLookingAtSign(player, out sign))
            {
                SendMessage(player, "NoSignFound");
                return;
            }

            if (!CanChangeSign(player, sign))
            {
                SendMessage(player, "SignNotOwned");
                return;
            }

            Item held = player.GetActiveItem();
            if (held == null)
            {
                SendMessage(player, "NoItemHeld");
                return;
            }

            uint textureIndex = 0;
            if (sign.TextureCount > 1)
            {
                // Verify if the correct syntax is used for animated Neon Signs.
                if (!HasValidIndexArg(args, sign, out textureIndex))
                {
                    // Invalid syntax was used, show an error message to the player.
                    SendMessage(player, "SyntaxSiliCommandMulti", sign.TextureCount);

                    return;
                }

                // Remove the index argument so the rest of the command handling can ignore it.
                args = args.Skip(1).ToArray();
            }

            string shortname = held.info.shortname;

            bool hor = sign.ShortPrefabName == "sign.hanging";

            SendMessage(player, "DownloadQueued");
            bool defaultskin = false;
            if (args.Length == 1 && args[0] == "default") defaultskin = true;
            if (held.skin != 0uL && !defaultskin)
            {
                string url;
                if (SkiniconUrls.TryGetValue(held.skin, out url))
                {
                    shortname = url;
                }
                else
                {
                    ServerMgr.Instance.StartCoroutine(DownloadWorkshopskin(held, sign, hor, textureIndex));
                    return;
                }
            }

            imageDownloader.QueueDownload(shortname, player, sign, textureIndex, false, hor);

            Interface.Oxide.CallHook("OnImagePost", player, shortname, false, sign.Entity, textureIndex);

            SetCooldown(player);
        }

        private const string FindWorkshopSkinUrl = "https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/v1/";

        private IEnumerator DownloadWorkshopskin(Item held, IPaintableEntity sign, bool hor, uint textureIndex)
        {
            BasePlayer player = held.GetOwnerPlayer();
            WWWForm form = new WWWForm();
            form.AddField("itemcount", "1");
            form.AddField("publishedfileids[0]", held.skin.ToString());
            UnityWebRequest www = UnityWebRequest.Post(FindWorkshopSkinUrl, form);
            yield return www.SendWebRequest();
            string url = "";
            // Verify that the webrequest was succesful.
            if (www.isNetworkError || www.isHttpError)
            {
                // The webrequest wasn't succesful, show a message to the player and attempt to start the next download.
                PrintError(www.error.ToString());
                url = held.info.shortname;
            }
            var json = JsonConvert.DeserializeObject<GetPublishedFileDetailsClass>(www.downloadHandler.text);
            url = json.response.publishedfiledetails[0].preview_url;
            imageDownloader.QueueDownload(url, player, sign, textureIndex, false, hor);

            Interface.Oxide.CallHook("OnImagePost", player, url, false, sign.Entity, textureIndex);

            SetCooldown(player);
        }

        /// <summary>
        /// Handles the /silt command
        /// </summary>
        /// <param name="iplayer">The player that has executed the command. </param>
        /// <param name="command">The name of the command that was executed. </param>
        /// <param name="args">All arguments that were passed with the command. </param>
        [Command("silt"), Permission("signartist.text")]
        private void SiltCommand(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;

            // Verify if the player has permission to use this command.
            if (!HasPermission(player, "signartist.text"))
            {
                // The player doesn't have permission to use this command, show an error message.
                SendMessage(player, "NoPermission");

                return;
            }

            // Verify that the command isn't on cooldown for the user.
            if (HasCooldown(player))
            {
                // The command is still on cooldown for the player, show an error message.
                SendMessage(player, "Cooldown", FormatCooldown(GetCooldown(player)));

                return;
            }

            // Check if the player is looking at a sign.
            IPaintableEntity sign;
            if (!IsLookingAtSign(player, out sign))
            {
                // The player isn't looking at a sign or is too far away from it, show an error message.
                SendMessage(player, "NoSignFound");

                return;
            }

            uint textureIndex = 0;
            if (sign.TextureCount > 1)
            {
                // Verify if the correct syntax is used for animated Neon Signs.
                if (!HasValidIndexArg(args, sign, out textureIndex))
                {
                    // Invalid syntax was used, show an error message to the player.
                    SendMessage(player, "SyntaxSiltCommandMulti", sign.TextureCount);

                    return;
                }

                // Remove the index argument so the rest of the command handling can ignore it.
                args = args.Skip(1).ToArray();
            }

            // Verify if the correct syntax is used.
            if (args.Length < 1)
            {
                // Invalid syntax was used, show an error message to the player.
                if (sign.TextureCount > 1)
                {
                    SendMessage(player, "SyntaxSiltCommandMulti", sign.TextureCount);
                }
                else
                {
                    SendMessage(player, "SyntaxSiltCommand");
                }

                return;
            }

            // Check if the player is able to update the sign.
            if (!CanChangeSign(player, sign))
            {
                // The player isn't able to update the sign, show an error message.
                SendMessage(player, "SignNotOwned");

                return;
            }

            // Build the URL for the /silt command
            string message = args[0].EscapeForUrl();
            int fontsize = 80;
            string color = "000";
            string bgcolor = "0FFF";
            string format = "png32";

            // Replace the default fontsize if the player specified one.
            if (args.Length > 1)
            {
                int.TryParse(args[1], out fontsize);
            }

            // Replace the default color if the player specified one.
            if (args.Length > 2)
            {
                color = args[2].Trim(' ', '#');
            }

            // Replace the default color if the player specified one.
            if (args.Length > 3)
            {
                bgcolor = args[3].Trim(' ', '#');
            }

            // Check if the player wants to add the image as a raw image and has the permission to do so.
            bool raw = args.Length > 4 && args[4].Equals("raw", StringComparison.OrdinalIgnoreCase);
            if (raw && !HasPermission(player, "signartist.raw"))
            {
                // The player doesn't have permission for this, show a message and disable raw.
                SendMessage(player, "NoPermissionRaw");
                raw = false;
            }

            // Correct the format if required
            if (Settings.EnforceJpeg)
            {
                format = "jpg";
            }

            // Get the size for the image
            ImageSize size = null;
            if (ImageSizePerAsset.ContainsKey(sign.ShortPrefabName))
            {
                size = ImageSizePerAsset[sign.ShortPrefabName];
            }

            // Verify that we have image size data for the targeted sign.
            if (size == null)
            {
                // No data was found, show a message to the player and print a detailed message to the server console and attempt to start the next download.
                SendMessage(player, "ErrorOccurred");
                PrintWarning($"Couldn't find the required image size for {sign.PrefabName}, please report this in the plugin's thread.");

                return;
            }

            // Combine all the values into the url;
            string url = $"http://assets.imgix.net/~text?fm={format}&txtalign=middle,center&txtsize={fontsize}&txt={message}&w={size.ImageWidth}&h={size.ImageHeight}&txtclr={color}&bg={bgcolor}";

            // Notify the player that it is added to the queue.
            SendMessage(player, "DownloadQueued");

            // This sign pastes in reverse, so we'll check and set a var to flip it
            bool hor = sign.ShortPrefabName == "sign.hanging";

            // Queue the download of the specified image.
            imageDownloader.QueueDownload(url, player, sign, textureIndex, raw, hor);

            // Call external hook
            Interface.Oxide.CallHook("OnImagePost", player, url, raw, sign.Entity, textureIndex);

            // Set the cooldown on the command for the player if the cooldown setting is enabled.
            SetCooldown(player);
        }

        /// <summary>
        /// Handles the /silrestore command
        /// </summary>
        /// <param name="iplayer">The player that has executed the command. </param>
        /// <param name="command">The name of the command that was executed. </param>
        /// <param name="args">All arguments that were passed with the command. </param>
        [Command("silrestore"), Permission("signartist.raw")]
        private void RestoreCommand(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            // Verify if the player has permission to use this command.
            if (!HasPermission(player, "signartist.restore"))
            {
                // The player doesn't have permission to use this command, show an error message.
                SendMessage(player, "NoPermission");

                return;
            }

            // Check if the user wants to restore the sign or signs as raw images and has the permission to do so
            bool raw = string.IsNullOrEmpty(args.FirstOrDefault(s => s.Equals("raw", StringComparison.OrdinalIgnoreCase)));
            if (raw && !HasPermission(player, "signartist.raw"))
            {
                // The player doesn't have permission for this, show a message and disable raw.
                SendMessage(player, "NoPermissionRaw");
                raw = false;
            }

            // Check if the user wants to restore all signs and has the permission to do so.
            bool all = args.Any(s => s.Equals("all", StringComparison.OrdinalIgnoreCase));
            if (all && !HasPermission(player, "signartist.restoreall"))
            {
                // The player doesn't have permission for this, show a message and disable raw.
                SendMessage(player, "NoPermissionRestoreAll");

                return;
            }

            // Check if the player is looking at a sign if not all signs should be restored.
            if (!all)
            {
                IPaintableEntity sign;
                if (!IsLookingAtSign(player, out sign))
                {
                    // The player isn't looking at a sign or is too far away from it, show an error message.
                    SendMessage(player, "NoSignFound");

                    return;
                }

                // Notify the player that it is added to the queue.
                SendMessage(player, "RestoreQueued");

                if (sign.TextureIds == null)
                    return;

                // Queue the restore of all images on the specified sign.
                for (uint textureIndex = 0; textureIndex < sign.TextureCount; textureIndex++)
                {
                    if (sign.TextureIds[textureIndex] == 0)
                        continue;

                    imageDownloader.QueueRestore(player, sign, raw, textureIndex);
                }

                return;
            }

            // The player wants to restore all signs.
            Signage[] allSigns = UnityEngine.Object.FindObjectsOfType<Signage>();

            // Notify the player that they were added to the queue
            SendMessage(player, "RestoreBatchQueued", allSigns.Length);

            // Queue every sign to be restored.
            foreach (Signage signEntity in allSigns)
            {
                IPaintableEntity sign = new PaintableSignage(signEntity);
                if (sign.TextureIds == null)
                    continue;

                for (uint textureIndex = 0; textureIndex < sign.TextureCount; textureIndex++)
                {
                    if (sign.TextureIds[textureIndex] == 0)
                        continue;

                    imageDownloader.QueueRestore(player, sign, raw, textureIndex);
                }
            }
        }

        #endregion Commands

        #region Methods
        /// <summary>
        /// Check if the given <see cref="BasePlayer"></see> is able to use the command.
        /// </summary>
        /// <param name="player">The player to check. </param>
        private bool HasCooldown(BasePlayer player)
        {
            // Check if cooldown is enabled.
            if (Settings.Cooldown <= 0)
            {
                return false;
            }

            // Check if cooldown is ignored for the player.
            if (HasPermission(player, "signartist.ignorecd"))
            {
                return false;
            }

            // Make sure there is an entry for the player in the dictionary.
            if (!cooldowns.ContainsKey(player.userID))
            {
                cooldowns.Add(player.userID, 0);
            }

            // Check if the command is on cooldown or not.
            return Time.realtimeSinceStartup - cooldowns[player.userID] < Settings.Cooldown;
        }

        /// <summary>
        /// Returns the cooldown in seconds for the given <see cref="BasePlayer"></see>.
        /// </summary>
        /// <param name="player">The player to obtain the cooldown of. </param>
        private float GetCooldown(BasePlayer player)
        {
            return Settings.Cooldown - (Time.realtimeSinceStartup - cooldowns[player.userID]);
        }

        /// <summary>
        /// Sets the last use for the cooldown handling of the command for the given <see cref="BasePlayer"></see>.
        /// </summary>
        /// <param name="player">The player to put the command on cooldown for. </param>
        private void SetCooldown(BasePlayer player)
        {
            // Check if cooldown is enabled.
            if (Settings.Cooldown <= 0)
            {
                return;
            }

            // Check if cooldown is ignored for the player.
            if (HasPermission(player, "signartist.ignorecd"))
            {
                return;
            }

            // Make sure there is an entry for the player in the dictionary.
            if (!cooldowns.ContainsKey(player.userID))
            {
                cooldowns.Add(player.userID, 0);
            }

            // Set the last use
            cooldowns[player.userID] = Time.realtimeSinceStartup;
        }

        /// <summary>
        /// Returns a formatted string for the given cooldown.
        /// </summary>
        /// <param name="seconds">The cooldown in seconds. </param>
        private string FormatCooldown(float seconds)
        {
            // Create a new TimeSpan from the remaining cooldown.
            TimeSpan t = TimeSpan.FromSeconds(seconds);
            List<string> output = new List<string>();

            // Check if it is more than a single day and add it to the result.
            if (t.Days >= 1)
            {
                output.Add($"{t.Days} {(t.Days > 1 ? "days" : "day")}");
            }

            // Check if it is more than an hour and add it to the result.
            if (t.Hours >= 1)
            {
                output.Add($"{t.Hours} {(t.Hours > 1 ? "hours" : "hour")}");
            }

            // Check if it is more than a minute and add it to the result.
            if (t.Minutes >= 1)
            {
                output.Add($"{t.Minutes} {(t.Minutes > 1 ? "minutes" : "minute")}");
            }

            // Check if there is more than a second and add it to the result.
            if (t.Seconds >= 1)
            {
                output.Add($"{t.Seconds} {(t.Seconds > 1 ? "seconds" : "second")}");
            }

            // Format the result and return it.
            return output.Count >= 3 ? output.ToSentence().Replace(" and", ", and") : output.ToSentence();
        }

        /// <summary>
        /// Checks if the <see cref="BasePlayer"></see> is looking at a valid <see cref="Signage"></see> object.
        /// </summary>
        /// <param name="player">The player to check. </param>
        /// <param name="sign">When this method returns, contains the <see cref="Signage"></see> the player contained in <paramref name="player" /> is looking at, or null if the player isn't looking at a sign. </param>
        private bool IsLookingAtSign(BasePlayer player, out IPaintableEntity sign)
        {
            RaycastHit hit;
            sign = null;

            // Get the object that is in front of the player within the maximum distance set in the config.
            //if (Physics.Raycast(player.eyes.HeadRay(), out hit))//, Settings.MaxDistance))
            if (Physics.Raycast(player.eyes.HeadRay(), out hit, Settings.MaxDistance, Physics.DefaultRaycastLayers, QueryTriggerInteraction.Ignore))
            {
                // Attempt to grab the Signage entity, if there is none this will set the sign to null,
                // otherwise this will set it to the sign the player is looking at.
                BaseEntity entity = hit.GetEntity();
                if (entity is Signage)
                {
                    sign = new PaintableSignage(entity as Signage);
                }
                else if (entity is PhotoFrame)
                {
                    sign = new PaintableFrame(entity as PhotoFrame);
                }
                else if (entity is CarvablePumpkin)
                {
                    sign = new PaintablePumpkin(entity as CarvablePumpkin);
                }
            }

            // Return true or false depending on if we found a sign.
            return sign != null;
        }

        /// <summary>
        /// Checks if the commands arguments include a valid texture index for the specified sign.
        /// </summary>
        /// <param name="args">The arguments to check. </param>
        /// <param name="sign">The sign to check. </param>
        /// <param name="textureIndex">The 0-based texture index derived from the arguments. </param>
        /// <returns>true if the arguments contained a valid texture index, else false. </returns>
        private bool HasValidIndexArg(string[] args, IPaintableEntity sign, out uint textureIndex)
        {
            textureIndex = 1;
            if (args.Length < 1
                || !uint.TryParse(args[0], out textureIndex)
                || textureIndex < 1
                || textureIndex > sign.TextureCount)
            {
                return false;
            }

            // Convert human-friendly index to computer-friendly index.
            textureIndex--;

            return true;
        }

        /// <summary>
        /// Checks if the <see cref="BasePlayer"></see> is allowed to change the drawing on the <see cref="Signage"></see> object.
        /// </summary>
        /// <param name="player">The player to check. </param>
        /// <param name="sign">The sign to check. </param>
        /// <returns></returns>
        private bool CanChangeSign(BasePlayer player, IPaintableEntity sign)
        {
            return sign.CanUpdate(player) || HasPermission(player, "signartist.ignoreowner");
        }

        /// <summary>
        /// Checks if the given <see cref="BasePlayer"></see> has the specified permission.
        /// </summary>
        /// <param name="player">The player to check a permission on. </param>
        /// <param name="perm">The permission to check for. </param>
        private bool HasPermission(BasePlayer player, string perm)
        {
            return permission.UserHasPermission(player.UserIDString, perm);
        }

        /// <summary>
        /// Send a formatted message to a single player.
        /// </summary>
        /// <param name="player">The player to send the message to. </param>
        /// <param name="key">The key of the message from the Lang API to get the message for. </param>
        /// <param name="args">Any amount of arguments to add to the message. </param>
        private void SendMessage(BasePlayer player, string key, params object[] args)
        {
            if (player == null) return;
            player.ChatMessage(string.Format(GetTranslation(key, player), args));
        }

        /// <summary>
        /// Gets the message for a specific player from the Lang API.
        /// </summary>
        /// <param name="key">The key of the message from the Lang API to get the message for. </param>
        /// <param name="player">The player to get the message for. </param>
        /// <returns></returns>
        private string GetTranslation(string key, BasePlayer player = null)
        {
            return lang.GetMessage(key, this, player?.UserIDString);
        }
        #endregion Methods

        #region Steam Workshop API Class

        public class GetPublishedFileDetailsClass
        {
            public Response response { get; set; }
        }

        public class Response
        {
            public int result { get; set; }
            public int resultcount { get; set; }
            public Publishedfiledetail[] publishedfiledetails { get; set; }
        }

        public class Publishedfiledetail
        {
            public string publishedfileid { get; set; }
            public int result { get; set; }
            public string creator { get; set; }
            public int creator_app_id { get; set; }
            public int consumer_app_id { get; set; }
            public string filename { get; set; }
            public int file_size { get; set; }
            public string preview_url { get; set; }
            public string hcontent_preview { get; set; }
            public string title { get; set; }
            public string description { get; set; }
            public int time_created { get; set; }
            public int time_updated { get; set; }
            public int visibility { get; set; }
            public int banned { get; set; }
            public string ban_reason { get; set; }
            public int subscriptions { get; set; }
            public int favorited { get; set; }
            public int lifetime_subscriptions { get; set; }
            public int lifetime_favorited { get; set; }
            public int views { get; set; }
            public Tag[] tags { get; set; }
        }

        public class Tag
        {
            public string tag { get; set; }
        }

        #endregion Steam Workshop API Class

        #region Discord Class
        public class Message
        {
            public string username { get; set; }
            public string avatar_url { get; set; }
            public List<Embeds> embeds { get; set; }

            public class Fields
            {
                public string name { get; set; }
                public string value { get; set; }
                public bool inline { get; set; }
                public Fields(string name, string value, bool inline)
                {
                    this.name = name;
                    this.value = value;
                    this.inline = inline;
                }
            }

            public class Footer
            {
                public string text { get; set; }
                public Footer(string text)
                {
                    this.text = text;
                }
            }

            public class Image
            {
                public string url { get; set; }
                public Image(string url)
                {
                    this.url = url;
                }
            }

            public class Embeds
            {
                public string title { get; set; }
                public string description { get; set; }
                public Image image { get; set; }
                public List<Fields> fields { get; set; }
                public Footer footer { get; set; }
                public Embeds(string title, string description, List<Fields> fields, Footer footer, Image image)
                {
                    this.title = title;
                    this.description = description;
                    this.image = image;
                    this.fields = fields;
                    this.footer = footer;
                }
            }

            public Message(string username, string avatar_url, List<Embeds> embeds)
            {
                this.username = username;
                this.avatar_url = avatar_url;
                this.embeds = embeds;
            }
        }

        #endregion

        #region Public Helpers
        // This can be Call(ed) by other plugins to put text on a sign
        [HookMethod("API_SignText")]
        public void API_SignText(BasePlayer player, Signage sign, string message, int fontsize = 30, string color = "FFFFFF", string bgcolor = "000000", uint textureIndex = 0)
        {
            //Puts($"signText called with {message}");
            string format = "png32";

            ImageSize size = null;
            if (ImageSizePerAsset.ContainsKey(sign.ShortPrefabName))
            {
                size = ImageSizePerAsset[sign.ShortPrefabName];
            }

            // Combine all the values into the url;
            string url = $"http://assets.imgix.net/~text?fm={format}&txtalign=middle,center&txtsize={fontsize}&txt={message}&w={size.ImageWidth}&h={size.ImageHeight}&txtclr={color}&bg={bgcolor}";
            imageDownloader.QueueDownload(url, player, new PaintableSignage(sign), textureIndex, false);
        }

        [HookMethod("API_SkinSign")]
        public void API_SkinSign(BasePlayer player, Signage sign, string url, bool raw = false, uint textureIndex = 0)
        {
            if (sign == null)
            {
                PrintWarning("Signage is null in API call");
                return;
            }

            if (string.IsNullOrEmpty(url))
            {
                PrintWarning("Url is empty in API call");
                return;
            }

            // This sign pastes in reverse, so we'll check and set a var to flip it
            bool hor = sign.ShortPrefabName == "sign.hanging" ? true : false;

            // Queue the download of the specified image.
            imageDownloader.QueueDownload(url, player, new PaintableSignage(sign), textureIndex, raw, hor);
        }

        [HookMethod("API_SkinPhotoFrame")]
        public void API_SkinPhotoFrame(BasePlayer player, PhotoFrame sign, string url, bool raw = false)
        {
            if (sign == null)
            {
                PrintWarning("PhotoFrame is null in API call");
                return;
            }

            if (string.IsNullOrEmpty(url))
            {
                PrintWarning("Url is empty in API call");
                return;
            }

            // Queue the download of the specified image.
            imageDownloader.QueueDownload(url, player, new PaintableFrame(sign), 0, raw, false);
        }

        [HookMethod("API_SkinPumpkin")]
        public void API_SkinPumpkin(BasePlayer player, CarvablePumpkin sign, string url, bool raw = false)
        {
            if (sign == null)
            {
                PrintWarning("CarvablePumpkin is null in API call");
                return;
            }

            if (string.IsNullOrEmpty(url))
            {
                PrintWarning("Url is empty in API call");
                return;
            }

            // Queue the download of the specified image.
            imageDownloader.QueueDownload(url, player, new PaintablePumpkin(sign), 0, raw, false);
        }


        //TODO add image byte[] api
        #endregion

    }

    namespace SignArtistClasses
    {
        /// <summary>
        /// Extension class with extension methods used by the <see cref="SignArtist"></see> plugin.
        /// </summary>
        public static class Extensions
        {
            /// <summary>
            /// Resizes an image from the <see cref="byte"></see> array to a new image with a specific width and height.
            /// </summary>
            /// <param name="bytes">Source image. </param>
            /// <param name="width">New image canvas width. </param>
            /// <param name="height">New image canvas height. </param>
            /// <param name="targetWidth">New image width. </param>
            /// <param name="targetHeight">New image height. </param>
            /// <param name="enforceJpeg"><see cref="bool"></see> value, true to save the images as JPG, false for PNG. </param>
            /// <param name="rotation"></param>
            public static byte[] ResizeImage(this byte[] bytes, int width, int height, int targetWidth, int targetHeight, bool enforceJpeg, RotateFlipType rotation = RotateFlipType.RotateNoneFlipNone)
            {
                byte[] resizedImageBytes;

                using (MemoryStream originalBytesStream = new MemoryStream(), resizedBytesStream = new MemoryStream())
                {
                    // Write the downloaded image bytes array to the memorystream and create a new Bitmap from it.
                    originalBytesStream.Write(bytes, 0, bytes.Length);
                    Bitmap image = new Bitmap(originalBytesStream);

                    if (rotation != RotateFlipType.RotateNoneFlipNone)
                    {
                        image.RotateFlip(rotation);
                    }

                    // Check if the width and height match, if they don't we will have to resize this image.
                    if (image.Width != targetWidth || image.Height != targetHeight)
                    {
                        // Create a new Bitmap with the target size.
                        Bitmap resizedImage = new Bitmap(width, height);

                        // Draw the original image onto the new image and resize it accordingly.
                        using (System.Drawing.Graphics graphics = System.Drawing.Graphics.FromImage(resizedImage))
                        {
                            graphics.DrawImage(image, new Rectangle(0, 0, targetWidth, targetHeight));
                        }

                        TimestampImage(resizedImage);

                        // Save the bitmap to a MemoryStream as either Jpeg or Png.
                        if (enforceJpeg)
                        {
                            resizedImage.Save(resizedBytesStream, ImageFormat.Jpeg);
                        }
                        else
                        {
                            resizedImage.Save(resizedBytesStream, ImageFormat.Png);
                        }

                        // Grab the bytes array from the new image's MemoryStream and dispose of the resized image Bitmap.
                        resizedImageBytes = resizedBytesStream.ToArray();
                        resizedImage.Dispose();
                    }
                    else
                    {
                        TimestampImage(image);
                        // The image has the correct size so we can just return the original bytes without doing any resizing.
                        resizedImageBytes = bytes;
                    }

                    // Dispose of the original image Bitmap.
                    image.Dispose();
                }

                // Return the bytes array.
                return resizedImageBytes;
            }

            /// <summary>
            /// Resize the image to the specified width and height.
            /// </summary>
            /// <param name="image">The image to resize.</param>
            /// <param name="width">The width to resize to.</param>
            /// <param name="height">The height to resize to.</param>
            /// <returns>The resized image.</returns>
            private static Bitmap ResizeImage(Image image, int width, int height)
            {
                Rectangle destRect = new Rectangle(0, 0, width, height);
                Bitmap destImage = new Bitmap(width, height);

                destImage.SetResolution(image.HorizontalResolution, image.VerticalResolution);

                using (Graphics graphics = System.Drawing.Graphics.FromImage(destImage))
                {
                    graphics.CompositingMode = CompositingMode.SourceCopy;
                    graphics.CompositingQuality = CompositingQuality.HighQuality;
                    graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
                    graphics.SmoothingMode = SmoothingMode.HighQuality;
                    graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

                    using (ImageAttributes wrapMode = new ImageAttributes())
                    {
                        wrapMode.SetWrapMode(System.Drawing.Drawing2D.WrapMode.TileFlipXY);
                        graphics.DrawImage(image, destRect, 0, 0, image.Width, image.Height, GraphicsUnit.Pixel, wrapMode);
                    }
                }

                return destImage;
            }

            private static void TimestampImage(Bitmap image)
            {
                //Rust images are crc and if we have the same image it is deleted from the file storage
                //Here we changed the last few pixels of the image with colors based off the current milliseconds since wipe
                //This will generate a unique image every time and allow us to use the same image multiple times
                Color pixel = Color.FromArgb(UnityEngine.Random.Range(0, 256), UnityEngine.Random.Range(0, 256), UnityEngine.Random.Range(0, 256), UnityEngine.Random.Range(0, 256));
                image.SetPixel(image.Width - 1, image.Height - 1, pixel);
            }

            private static int GetValueAtIndex(byte[] bytes, int index)
            {

                if (index >= bytes.Length)
                {
                    return 0;
                }

                return Convert.ToInt32(bytes[index]);

            }

            /// <summary>
            /// Converts a string to its escaped representation for the image placeholder text value.
            /// </summary>
            /// <param name="stringToEscape">The string to escape.</param>
            public static string EscapeForUrl(this string stringToEscape)
            {
                // Escape initial values.
                stringToEscape = Uri.EscapeDataString(stringToEscape);

                // Convert \r\n, \r and \n into linebreaks.
                stringToEscape = stringToEscape.Replace("%5Cr%5Cn", "%5Cn").Replace("%5Cr", "%5Cn").Replace("%5Cn", "%0A");

                // Return the converted message
                return stringToEscape;
            }
        }
    }
}

// --- End of file: SignArtist.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/stack-multiplier ---
// --- Original File Path: S/StackMultiplier/StackMultiplier.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Stack Multiplier", "Ryz0r/UNKN0WN", "1.0.4")]
    [Description("Allows you to multiply all items stack size by a multiplier, except those in the blocked config list.")]
    public class StackMultiplier : CovalencePlugin
    {
        private Configuration _config;
        private readonly Dictionary<string, int> _defaultSizes = new Dictionary<string, int>();
        private int _multiplier = 1;
        private const string UsePerm = "stackmultiplier.use";
        
        #region Configuration
        private class Configuration
        {
            [JsonProperty(PropertyName = "Stack Multi")] public int Stackmulti = 3;
            [JsonProperty(PropertyName = "BlockedList", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> BlockedList = new List<string>() { "hammer" };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("A new configuration file is being generated.");
            _config = new Configuration();
        }
		
		
        protected override void SaveConfig() => Config.WriteObject(_config);
        #endregion
        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CurrStack"] = "The current stack size is {0}x.",
                ["ArgOver"] = "You have provided too many arguments. Try: stackmultiplier.multiply 2 for 2x stacks.",
                ["ArgOverReset"] = "You have provided too many arguments.",
                ["NotInt"] =  "That is not a valid integer.",
                ["BlockedItems"] = "Stack size set was blocked for items in config: {0}.",
                ["StackReset"] = "All stacks have been reset.",
                ["NoPerms"] = "You lack the permissions to use this command."
                
            }, this);
        }
        #endregion
        #region Initialization Stuff
        private void Init()
        {
            permission.RegisterPermission(UsePerm, this);
        }

        private void OnServerInitialized()
        {
            foreach (var gameitem in ItemManager.itemList)
            {
                _defaultSizes.Add(gameitem.shortname, gameitem.stackable);
                if (gameitem.condition.enabled && gameitem.condition.max > 0)
                {
                    continue;
                }

                if (gameitem.isWearable == true)
                {
                    continue;
                }

                if (!_config.BlockedList.Contains(gameitem.shortname))
                {
                    _multiplier = _config.Stackmulti;

                    ChangeSize(gameitem, _multiplier);
                }
                
            }

        }

        void Unload()
        {
            ResetStacks();
            
        }
        #endregion
        
        [Command("stackmultiplier.multiply")]
        private void MultiplyCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(UsePerm))
            {
                player.Reply(lang.GetMessage("NoPerms", this, player.Id));
                return;
            }
            
            if (args.Length == 0)
            {
                player.Reply(String.Format(lang.GetMessage("CurrStack", this, player.Id), _multiplier.ToString()));
                return;
            }

            if (args.Length > 2)
            {
                player.Reply(lang.GetMessage("ArgOver", this, player.Id));
                return;
            }

            int localMultiplier;
            if (int.TryParse(args[0], out localMultiplier))
            {
                _multiplier = localMultiplier;
                foreach(var gameitem in ItemManager.itemList)
                {
                    if (gameitem.condition.enabled && gameitem.condition.max > 0)
                    {
                        continue;
                    }

                    if (gameitem.isWearable == true)
                    {
                        continue;
                    }

                    if (!_config.BlockedList.Contains(gameitem.shortname))
                    {
                        ChangeSize(gameitem, _multiplier);
                    }
                }
                
                player.Reply(String.Format(lang.GetMessage("BlockedItems", this, player.Id), String.Join(", ", _config.BlockedList)));
                player.Reply(String.Format(lang.GetMessage("CurrStack", this, player.Id), _multiplier.ToString()));
            }
            else
            {
                player.Reply(lang.GetMessage("NotInt", this, player.Id));
            }
        }
        
        [Command("stackmultiplier.reset")]
        private void ResetCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(UsePerm))
            {
                player.Reply(lang.GetMessage("NoPerms", this, player.Id));
                return;
            }
            
            if (args.Length > 0)
            {
                player.Reply(lang.GetMessage("ArgOverReset", this, player.Id));
                return;
            }

            ResetStacks();
            player.Reply(lang.GetMessage("StackReset", this));
        }

        private void ChangeSize(ItemDefinition gameitem, int multiplier)
        {
            gameitem.stackable = _defaultSizes[gameitem.shortname] * _multiplier;
        }

        private void ResetStacks()
        {
            foreach (var gameitem in ItemManager.itemList)
            {
                gameitem.stackable = _defaultSizes[gameitem.shortname];
            }
            
            _multiplier = 1;
        }
    }
}

// --- End of file: StackMultiplier.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/safe-traps ---
// --- Original File Path: S/SafeTraps/SafeTraps.cs ---

using System.Collections.Generic;
using System;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("SafeTraps", "Jake_Rich", "1.0.1")]
    [Description("Players won't trigger their own traps")]

    public class SafeTraps : RustPlugin
    {
        public JSONFile<ConfigData> _settingsFile;
        public ConfigData Settings { get { return _settingsFile.Instance; } }


        void Loaded()
        {
            //Dont create empty config files
            if (typeof(ConfigData).GetFields(System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic).Length > 0)
            {
                _settingsFile = new JSONFile<ConfigData>($"{Name}", ConfigLocation.Config, extension: ".cfg");
            }
        }

        public class ConfigData
        {
            public float SafeTime = 60;
            public bool UsePermissions = false;
        }

        public class EntityInfo
        {
            public ulong TrapOwner;
            public DateTime LastArmedTime = DateTime.UtcNow;
        }

        #region Entity Info

        private Dictionary<ulong, EntityInfo> _entityInfo = new Dictionary<ulong, EntityInfo>();

        public EntityInfo GetEntityInfo(BaseNetworkable entity)
        {
            EntityInfo info;
            if (!_entityInfo.TryGetValue(entity.net.ID.Value, out info))
            {
                info = new EntityInfo();
                _entityInfo.Add(entity.net.ID.Value, info);
            }
            return info;
        }

        #endregion

        #region Hooks

        //Landmine or bear trap
        object OnTrapTrigger(BaseEntity trap, GameObject go)
        {
            var player = go.GetComponent<BasePlayer>();
            if (player == null)
            {
                return null;
            }
            var info = GetEntityInfo(trap);
            if (Settings.SafeTime > 0 && DateTime.UtcNow.Subtract(info.LastArmedTime).TotalSeconds > Settings.SafeTime)
            {
                return null;
            }
            if (info.TrapOwner == 0)
            {
                if (player.userID == trap.OwnerID)
                {
                    return false;
                }
                return null;
            }
            if (player.userID == info.TrapOwner)
            {
                return false;
            }
            return null;
        }

        //Bear trap
        void OnTrapArm(BearTrap trap, BasePlayer player)
        {
            var info = GetEntityInfo(trap);
            info.TrapOwner = player.userID;
            info.LastArmedTime = DateTime.UtcNow;
        }

        void OnEntityBuilt(Planner planner, GameObject obj)
        {
            var player = planner.GetOwnerPlayer();
            var entity = obj.GetComponent<BaseEntity>();
            if (entity == null || player == null)
            {
                return;
            }
            if (entity is Landmine || entity is BearTrap)
            {
                var data = GetEntityInfo(entity);
                data.LastArmedTime = DateTime.UtcNow;
                data.TrapOwner = player.userID;
            }
        }

        #endregion

        #region Configuration Files

        public enum ConfigLocation
        {
            Data = 0,
            Config = 1,
            Logs = 2,
            Plugins = 3,
            Lang = 4,
            Custom = 5,
        }

        public class JSONFile<Type> where Type : class
        {
            private DynamicConfigFile _file;
            public string _name { get; set; }
            public Type Instance { get; set; }
            private ConfigLocation _location { get; set; }
            private string _path { get; set; }

            public JSONFile(string name, ConfigLocation location = ConfigLocation.Data, string path = null, string extension = ".json")
            {
                _name = name.Replace(".json", "");
                _location = location;
                switch (location)
                {
                    case ConfigLocation.Data:
                        {
                            _path = $"{Oxide.Core.Interface.Oxide.DataDirectory}/{name}{extension}";
                            break;
                        }
                    case ConfigLocation.Config:
                        {
                            _path = $"{Oxide.Core.Interface.Oxide.ConfigDirectory}/{name}{extension}";
                            break;
                        }
                    case ConfigLocation.Logs:
                        {
                            _path = $"{Oxide.Core.Interface.Oxide.LogDirectory}/{name}{extension}";
                            break;
                        }
                    case ConfigLocation.Lang:
                        {
                            _path = $"{Oxide.Core.Interface.Oxide.LangDirectory}/{name}{extension}";
                            break;
                        }
                    case ConfigLocation.Custom:
                        {
                            _path = $"{path}/{name}{extension}";
                            break;
                        }
                }
                _file = new DynamicConfigFile(_path);
                _file.Settings = new JsonSerializerSettings() { ReferenceLoopHandling = ReferenceLoopHandling.Ignore };
                Init();
            }

            public virtual void Init()
            {
                Load();
                Save();
                Load();
            }

            public virtual void Load()
            {

                if (!_file.Exists())
                {
                    Save();
                }
                Instance = _file.ReadObject<Type>();
                if (Instance == null)
                {
                    Instance = Activator.CreateInstance<Type>();
                    Save();
                }
                return;
            }

            public virtual void Save()
            {
                _file.WriteObject(Instance);
                return;
            }

            public virtual void Reload()
            {
                Load();
            }

            private void Unload(Plugin sender, PluginManager manager)
            {

            }
        }

        #endregion
    }
}

// --- End of file: SafeTraps.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/save-my-name ---
// --- Original File Path: S/SaveMyName/SaveMyName.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Save my Name", "MikeLitoris", "0.0.5")]
    [Description("Allows saving of your name for online and offline protection")]
    class SaveMyName : RustPlugin
    {
        private ConfigData configData;
        private const string savemyname = "SaveMyName.use";
        private const string savemynameadmin = "SaveMyName.admin";

        class ConfigData
        {
            [JsonProperty(PropertyName = "Admins can bypass the name-restrictions")]
            public bool IgnoreAdmins { get; set; }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["blockedname"] = "The name youre trying to connect with has been blocked, please switch and reconnect - Or visit the Discord if you feel this is unjust",
                ["clearedname"] = " has been removed from the saved names",
                ["nofoundmame"] = " No saved name found, use /savemyname to save current name",
                ["savedname"] = " Has been saved!",


            }, this);
        }

        private bool LoadConfigVariables()
        {
            try
            {
                configData = Config.ReadObject<ConfigData>();
            }
            catch
            {
                return false;
            }
            SaveConfig(configData);
            return true;
        }
        void Init()
        {

            permission.RegisterPermission(savemyname, this);
            permission.RegisterPermission(savemynameadmin, this);
            if (!LoadConfigVariables())
            {
                Puts("Config File issue detected");
                LoadDefaultConfig();
                return;
            }
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Creating new config");
            configData = new ConfigData { IgnoreAdmins = true };
            SaveConfig(configData);
        }

        void SaveConfig(ConfigData config)
        {
            Config.WriteObject(config, true);
        }

        class SavedNames
        {
            public ulong SteamID { get; set; }
            public string Name { get; set; }
            public DateTime Timestamp { get; set; }
        }

        StoredData storedData;

        class StoredData
        {
          public List<SavedNames> savedNames  = new List<SavedNames>();
        }
        
        void Loaded()
        {
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>("SaveMyName");
            Interface.Oxide.DataFileSystem.WriteObject("SaveMyName", storedData);
        }

        void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("SaveMyName", storedData);
        }

        void OnPlayerConnected(BasePlayer player)
        {
           if(player != null)
            { 
                foreach (var storedname in storedData.savedNames)
                {
                    if (configData.IgnoreAdmins)
                    {
                        if (player.displayName == storedname.Name && player.userID != storedname.SteamID && permission.UserHasPermission(storedname.SteamID.ToString(), savemyname) == true && player.IsAdmin == false)
                        {
                            player.Kick(lang.GetMessage("blockedname", this));
                        }
                    }
                    else
                    {
                        if (player.displayName == storedname.Name && player.userID != storedname.SteamID && permission.UserHasPermission(storedname.SteamID.ToString(), savemyname) == true)
                        {
                            player.Kick(lang.GetMessage("blockedname", this));
                        }
                    }
                }
            }
        }

        void OnUserNameUpdated(string id, string oldName, string newName)
        {
            BasePlayer player = BasePlayer.FindAwakeOrSleeping(id);
            if(player != null)
            {                           
                foreach (var storedname in storedData.savedNames)
                {
                    if (configData.IgnoreAdmins)
                    { 
                        if (newName == storedname.Name && ulong.Parse(id) != storedname.SteamID && permission.UserHasPermission(storedname.SteamID.ToString(), savemyname) == true && player.IsAdmin == false)// && player.IsAdmin == false)
                        {                        
                            player.Kick(lang.GetMessage("blockedname", this));
                        }
                    }
                    else
                    {
                        if (newName == storedname.Name && ulong.Parse(id) != storedname.SteamID && permission.UserHasPermission(storedname.SteamID.ToString(), savemyname) == true)
                        {
                            player.Kick(lang.GetMessage("blockedname", this));
                        }
                    }
                }
            }
        }

        [ChatCommand("clearmyname")]
        void ClearName(BasePlayer player, string command, string[] args)
        {
            if(player != null)
            {           
                if (permission.UserHasPermission(player.UserIDString, savemyname))
                {
                    try
                    {
                        SavedNames savedName = storedData.savedNames.Find(x => x.SteamID == player.userID);
                        storedData.savedNames.Remove(savedName);
                        SendReply(player, savedName.Name + lang.GetMessage("clearedname", this));
                        Puts(savedName.Name + lang.GetMessage("clearedname", this));
                        SaveData();
                    }
                    catch (System.Exception)
                    {
                        SendReply(player, lang.GetMessage("nofoundname", this));
                    }
                }
            }
        }

        [ChatCommand("savemyname")]
        void SaveName(BasePlayer player, string command, string[] args)
        {
            if (player != null)
            {               
                if (permission.UserHasPermission(player.UserIDString, savemyname))
                {
                    if (storedData.savedNames.Find(x => x.SteamID == player.userID) != null)
                    {
                        SavedNames savedName = storedData.savedNames.Find(x => x.SteamID == player.userID);
                        savedName.Name = player.displayName;
                        savedName.Timestamp = DateTime.Now;
                        SaveData();
                        SendReply(player, player.displayName + lang.GetMessage("savedname", this));
                        Puts(player.displayName + lang.GetMessage("savedname", this));
                    }
                    else
                    {
                        SavedNames saved = new SavedNames { SteamID = player.userID, Name = player.displayName, Timestamp = DateTime.Now };
                        storedData.savedNames.Add(saved);
                        SaveData();
                        Puts(player.displayName + lang.GetMessage("savedname", this));
                        SendReply(player, player.displayName + lang.GetMessage("savedname", this));
                    }
                }
            }
            
        }
        [ConsoleCommand("savednames")]
        void SavedNamesListCon()
        {
            string line = "\n";
            foreach (var sn in storedData.savedNames)
            {
                line += $"[{sn.SteamID}] {sn.Name}\n";
            }
            Puts(line);
        }

        [ChatCommand("savednames")]
        void SavedNamesList(BasePlayer player, string command, string[] args)
        {
            if (player != null)
            {
                if (permission.UserHasPermission(player.UserIDString, savemynameadmin))
                {
                    string line = "";
                    foreach (var sn in storedData.savedNames)
                    {
                        line += $"[{sn.SteamID}] {sn.Name}\n";
                    }
                    SendReply(player, line);

                }
            }
        }
    }
}

// --- End of file: SaveMyName.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/stationary-crafting ---
// --- Original File Path: S/StationaryCrafting/StationaryCrafting.cs ---

using System.Collections.Generic;

namespace Oxide.Plugins
{
	[Info("Stationary Crafting", "NubbbZ", "1.0.2")]
	[Description("Craft only when standing next to a workbench")]
	class StationaryCrafting : CovalencePlugin
	{
		#region Variables
		HashSet<ulong> InWorkbenchRadius = new HashSet<ulong>();
		#endregion

		#region Setup
		protected override void LoadDefaultConfig()
		{
			LogWarning("Creating a new configuration file");
			Config["ShowMessages"] = false;
		}

		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["inofrange"] = "Stay in the workbench radius, or your crafting queue will be canceled!",
				["outofrange"] = "You cant craft if you arent in workbench radius!",
				["canceled"] = "You have left the workbench range so your crafting queue was canceled!"
			}, this);
		}
		#endregion

		#region Hooks
		private void OnEntityEnter(TriggerWorkbench triggerWorkbench, BasePlayer player)
		{
			InWorkbenchRadius.Add(player.userID);

			if ((bool)Config["ShowMessages"] == true)
			{
				player.IPlayer.Reply(lang.GetMessage("inofrange", this, player.IPlayer.Id));
			}
		}

		bool CanCraft(ItemCrafter itemCrafter, ItemBlueprint bp, int amount)
		{
			BasePlayer player = itemCrafter.GetComponent<BasePlayer>();

			if (InWorkbenchRadius.Contains(player.userID) == false)
			{
				if ((bool)Config["ShowMessages"] == true)
				{
					player.IPlayer.Reply(lang.GetMessage("outofrange", this, player.IPlayer.Id));
				}
				return false;
			}
			return true;
		}

		private void OnEntityLeave(TriggerWorkbench triggerWorkbench, BasePlayer player)
		{
			InWorkbenchRadius.Remove(player.userID);
			if ((bool)Config["ShowMessages"] == true)
			{
				player.IPlayer.Reply(lang.GetMessage("canceled", this, player.IPlayer.Id));
			}
			player.inventory.crafting.CancelAll(true);
		}
		#endregion
	}
}


// --- End of file: StationaryCrafting.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/sign-tracker ---
// --- Original File Path: S/SignTracker/SignTracker.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("SignTracker", "DNARust/Wulf/lukespragg", "3.0.0")]
    [Description("Track who last updated a sign with name and Steam ID, and optional logging")]

    class SignTracker : CovalencePlugin
    {
        #region Initialization

        readonly Dictionary<uint, string> signs = new Dictionary<uint, string>();
        DynamicConfigFile storedData;

        const string permUse = "signtracker.use";
        
        bool logUpdates;

        protected override void LoadDefaultConfig()
        {
            // Options
            Config["Log Sign Updates (true/false)"] = logUpdates = GetConfig("Log Sign Updates (true/false)", true);

            SaveConfig();
        }

        void OnServerInitialized()
        {
            LoadDefaultConfig();
            LoadDefaultMessages();
            permission.RegisterPermission(permUse, this);
            storedData = Interface.Oxide.DataFileSystem.GetDatafile("SignTracker");
            foreach (var pair in storedData)
                signs.Add(uint.Parse(pair.Key), pair.Value.ToString());
        }

        #endregion

        #region Localization

        void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LastUpdated"] = "Sign was last updated by {0} ({2}) on {1}",
                ["NoInformation"] = "No information available for this sign",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["SignUpdated"] = "Sign {0} by {1} updated on {2} by {3} ({4})"
            }, this);

            // French
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LastUpdated"] = "Signe a t actualise par {0} ({2}) sur {1}",
                ["NoInformation"] = "Aucune information disponible pour ce signe",
                ["NotAllowed"] = "Vous ntes pas autoris  utiliser la commande {0}",
                ["SignUpdated"] = "Signe de {0} de {1} {2} mis  jour par {3} ({4})"
            }, this, "fr");

            // German
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LastUpdated"] = "Zeichen wurde geaendert von {0} ({2}) auf {1}",
                ["NoInformation"] = "Keine Informationen fr dieses Zeichen verfgbar",
                ["NotAllowed"] = "Sie sind nicht berechtigt, verwenden Sie den Befehl '{0}'",
                ["SignUpdated"] = "Melden Sie {0} von {1} {2} von {3} ({4}) aktualisiert"
            }, this, "de");

            // Russian
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LastUpdated"] = "    {0} ({2})  {1}",
                ["NoInformation"] = "    ",
                ["NotAllowed"] = "   {0}",
                ["SignUpdated"] = " {0}  {1}   {2} {3} ({4})"
            }, this, "ru");

            // Spanish
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LastUpdated"] = "Muestra la ltima actualizacin por {0} ({2}) en {1}",
                ["NoInformation"] = "No hay informacin disponible para este signo",
                ["NotAllowed"] = "No se permite utilizar el comando '{0}'",
                ["SignUpdated"] = "Firmar {0} {1} {2} actualizada por {3} ({4})"
            }, this, "es");
        }

        #endregion

        #region Chat Command

        [Command("sign")]
        void SignCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permUse))
            {
                player.Reply(Lang("NotAllowed", player.Id, command));
                return;
            }

            RaycastHit hit;
            var basePlayer = player.Object as BasePlayer;
            if (basePlayer == null || !Physics.Raycast(basePlayer.eyes.HeadRay(), out hit, 2.0f)) return;

            var sign = hit.transform.GetComponentInParent<Signage>() as BaseEntity;
            if (sign == null) return;

            if (signs.ContainsKey(sign.net.ID))
            {
                var value = signs[sign.net.ID].Split(',');
                player.Reply(Lang("LastUpdated", player.Id, value[0], value[2], value[1]));
            }
            else player.Reply(Lang("NoInformation", player.Id));
        }

        #endregion

        #region Sign Storage

        private void OnSignUpdated(BaseEntity sign, BasePlayer player)
        {
            if (signs.ContainsKey(sign.net.ID))
                signs[sign.net.ID] = $"{player.displayName}, {player.userID}, {DateTime.Now}";
            else
                signs.Add(sign.net.ID, $"{player.displayName}, {player.userID}, {DateTime.Now}");

            if (logUpdates) Log(Lang("SignUpdated", null, sign.net.ID, sign.OwnerID, DateTime.Now, player.displayName, player.userID));
        }

        void SaveSignData()
        {
            storedData.Clear();
            foreach (var signea in signs) storedData[signea.Key.ToString()] = signea.Value;
            Interface.Oxide.DataFileSystem.SaveDatafile("SignTracker");
        }

        void OnServerShutdown() => SaveSignData();

        void OnServerSave() => SaveSignData();

        void Unload() => SaveSignData();

        private void OnNewSave(string filename)
        {
            PrintWarning("Map wipe detected! Resetting all sign data.");

            signs.Clear();
            SaveSignData();
        }
        #endregion

        #region Helpers

        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        void Log(string text) => LogToFile("updates", text, this);

        #endregion
    }
}

// --- End of file: SignTracker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/starter-money ---
// --- Original File Path: S/StarterMoney/StarterMoney.cs ---

using Oxide.Core;
using System;
using Newtonsoft.Json;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;

// Cash System support implemented by misticos

namespace Oxide.Plugins
{
    [Info("Starter Money", "Tricky", "1.1.0")]
    [Description("Customizes the starting balance of players with perms")]
    public class StarterMoney : CovalencePlugin
    {
        #region Plugin References
        [PluginReference]
        private Plugin Economics, ServerRewards, CashSystem;
        #endregion

        #region Config
        Configuration config;

        class Configuration
        {
            [JsonProperty(PropertyName = "Clear Data On New Save (Rust)")]
            public bool ClearData = false;

            [JsonProperty(PropertyName = "Use Economics")]
            public bool Economics = true;

            [JsonProperty(PropertyName = "Use Server Rewards")]
            public bool ServerRewards = false;

            [JsonProperty(PropertyName = "Use Cash System")]
            public bool CashSystem = false;

            [JsonProperty(PropertyName = "Cash System Currency")]
            public string CashSystemCurrency = "$";

            [JsonProperty(PropertyName = "Permissions", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, double> Permissions = new Dictionary<string, double>
            {
                {"startermoney.default", 10 },
                {"startermoney.vip", 20 },
                {"startermoney.god", 30 }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) throw new Exception();
            }
            catch
            {
                Config.WriteObject(config, false, $"{Interface.Oxide.ConfigDirectory}/{Name}.jsonError");
                PrintError("The configuration file contains an error and has been replaced with a default config.\n" +
                           "The error configuration file was saved in the .jsonError extension");
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Data
        private Data data;

        private class Data
        {
            public List<string> Players = new List<string>();
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, data);
        #endregion

        #region Oxide Hooks
        private void Init()
        {
            data = Interface.Oxide.DataFileSystem.ReadObject<Data>(Name);

            config.Permissions.Keys.ToList().ForEach(perm =>
            {
                if (!permission.PermissionExists(perm, this))
                    permission.RegisterPermission(perm, this);
            });
        }

        private void Loaded()
        {
            if (config.Economics && Economics == null)
                PrintWarning("Economics is enabled but not loaded!");

            if (config.ServerRewards && ServerRewards == null)
                PrintWarning("Server Rewards is enabled but not loaded!");

            if (config.CashSystem && CashSystem == null)
                PrintWarning("Cash System is enabled but not loaded!");
        }

        private void OnServerSave() => SaveData();

        private void Unload() => SaveData();

        private void OnUserConnected(IPlayer player)
        {
            if (data.Players.Contains(player.Id))
                return;

            config.Permissions.ToList().ForEach(perm =>
            {
                if (!player.HasPermission(perm.Key))
                    return;

                if (config.Economics && Economics)
                    TryGiveEconomics(player, perm.Value);

                if (config.ServerRewards && ServerRewards)
                    TryGiveRP(player, Convert.ToInt32(perm.Value));

                if (config.CashSystem && CashSystem)
                    TryGiveCS(player, perm.Value);
            });
        }

        private void OnNewSave()
        {
            if (!config.ClearData)
                return;

            data.Players.Clear();
        }
        #endregion

        #region Core
        private void TryGiveEconomics(IPlayer player, double amount)
        {
            if (Economics.Call<bool>("Deposit", player.Id, amount))
                data.Players.Add(player.Id);
        }

        private void TryGiveRP(IPlayer player, int amount)
        {
            if (ServerRewards.Call<bool>("AddPoints", player.Id, amount))
                data.Players.Add(player.Id);
        }

        private void TryGiveCS(IPlayer player, double amount)
        {
            if (CashSystem.Call<bool>("AddTransaction", ulong.Parse(player.Id), config.CashSystemCurrency, amount, "Starter Money"))
                data.Players.Add(player.Id);
        }
        #endregion
    }
}

// --- End of file: StarterMoney.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/sky-turrets ---
// --- Original File Path: S/SkyTurrets/SkyTurrets.cs ---

using Facepunch;
using Rust;
using System;
using System.Globalization;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Sky Turrets", "Xavier", "3.0.6")]
    [Description("Allows auto turrets and SAM sites to target patrol helicopters and chinooks")]
    public class SkyTurrets : RustPlugin
    {
        static SkyTurrets plugin;
        const string skyturretperms = "skyturrets.use";
        private DynamicConfigFile data;
        private StoredData storedData;
   
        private List<ulong> turretIDs = new List<ulong>();
        private List<ulong> PoweredTurretIDs = new List<ulong>();
        private List<ulong> samIDs = new List<ulong>();
   
        private class StoredData
        {
            public List<ulong> turretIDs = new List<ulong>();
            public List<ulong> PoweredTurretIDs = new List<ulong>();
            public List<ulong> samIDs = new List<ulong>();
        }
   
        private void SaveData()
        {
            storedData.turretIDs = turretIDs;
            storedData.PoweredTurretIDs = PoweredTurretIDs;
            storedData.samIDs = samIDs;
            data.WriteObject(storedData);
            Puts(lang.GetMessage("Saving", this));
        }

        private bool ConfigChanged;
   
        bool PowerlessTurrets = true;
        float AirTargetRadius = 150f;
        bool NeedsPerms = true;
        int SamSiteAttackDistance = 300;
        float CheckForTargetEveryXSeconds = 5f;
   
        BUTTON PowerButton = BUTTON.FIRE_THIRD;
        string Button ="FIRE_THIRD";
   
        void LoadVariables()
        {
            AirTargetRadius = Convert.ToSingle(GetConfig("Settings", "Patrol Helicopter max target distance", "150"));
            PowerlessTurrets = Convert.ToBoolean(GetConfig("Settings","Turrets need power? (Uses Button to power on/off)", "true"));
            NeedsPerms = Convert.ToBoolean(GetConfig("Settings","Needs permissions - (skyturrets.use)", "true"));
            Button = Convert.ToString(GetConfig("Settings","Default Power Button", "FIRE_THIRD"));
  
            SamSiteAttackDistance = Convert.ToInt32(GetConfig("Settings", "SamSite distance to start targetting", "300"));
            CheckForTargetEveryXSeconds = Convert.ToSingle(GetConfig("Settings", "SamSite Frequency Check for Patrol Helicopters in Seconds", "5"));

            if (ConfigChanged)
            {
                PrintWarning(lang.GetMessage("ConfigChanged", this));
                SaveConfig();
            }
            else
            {
                ConfigChanged = false;
                return;
            }
        }
   
        #region Config Reader
   
        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                ConfigChanged = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                ConfigChanged = true;
            }
            return value;
        }
   
        #endregion
   
        protected override void LoadDefaultConfig()
        {
            LoadVariables();
        }
   
        void Init()
        {
            LoadVariables();
            permission.RegisterPermission(skyturretperms, this);
  
            data = Interface.Oxide.DataFileSystem.GetFile(Name);
  
            try
            {
                storedData = data.ReadObject<StoredData>();
                samIDs = storedData.samIDs;
                turretIDs = storedData.turretIDs;
                PoweredTurretIDs = storedData.PoweredTurretIDs;
            }
            catch
            {
                storedData = new StoredData();
            }
  
            plugin = this;
        }
   
        private void OnServerSave() => SaveData();
   
        void Unload()
        {
            foreach (var autoturret in UnityEngine.Object.FindObjectsOfType<AutoTurret>())
            {
                var at = autoturret.GetComponent<AntiHeli>();
                if (at)
                {
                    at.UnloadDestroy();
                    if (autoturret.IsOnline())
                    {
                        autoturret.SetIsOnline(false);
                        autoturret.SendNetworkUpdateImmediate();
                    }
                }
            }
  
            foreach (var sam in UnityEngine.Object.FindObjectsOfType<SamSite>())
            {
                var ss = sam.GetComponent<HeliTargeting>();
                if (ss)
                {
                    ss.UnloadDestroy();
                    sam.UpdateHasPower(0, 1);
                    sam.SendNetworkUpdateImmediate();
                }
            }
  
            SaveData();
            plugin = null;
        }
   
        void OnServerInitialized()
        {
            foreach (var autoturret in UnityEngine.Object.FindObjectsOfType<AutoTurret>())
            {
                if (turretIDs.Contains(autoturret.net.ID))
                {
                    autoturret.gameObject.AddComponent<AntiHeli>();
                    if (PoweredTurretIDs.Contains(autoturret.net.ID))
                    {
                        autoturret.SetIsOnline(true);
                        autoturret.SendNetworkUpdateImmediate();
                    }
                }    
            }
  
            foreach (var sam in UnityEngine.Object.FindObjectsOfType<SamSite>())
            {
                if (samIDs.Contains(sam.net.ID))
                {
                    sam.gameObject.AddComponent<HeliTargeting>();
                }
            }
        }
   
        #region PlayerInput
        void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (!PowerlessTurrets)
                TurretInput(input, player);
        }

        public void TurretInput(InputState input, BasePlayer player)
        {
            BUTTON.TryParse(Button, out PowerButton);
  
            if (input.WasJustPressed(PowerButton))
            {    
                RaycastHit hit;
                if (Physics.SphereCast(player.eyes.position, 0.5f, Quaternion.Euler(player.serverInput.current.aimAngles) * Vector3.forward, out hit))
                {
                    AutoTurret autoturret = hit.GetEntity()?.GetComponent<AutoTurret>();
                    SamSite samsite = hit.GetEntity()?.GetComponent<SamSite>();

                    if (autoturret != null)
                    {
                        var at = autoturret.GetComponent<AntiHeli>();
                        if (!at) return;

                        if (hit.distance >= 1.5) return;

                        if (autoturret.IsOnline() && autoturret.IsAuthed(player))
                        {
                            autoturret.SetIsOnline(false);
                            PoweredTurretIDs.Remove(autoturret.net.ID);
                        }
                        else
                        {
                            autoturret.SetIsOnline(true);
                            PoweredTurretIDs.Add(autoturret.net.ID);
                        }
                        autoturret.SendNetworkUpdateImmediate();
                    }

                    if (samsite != null)
                    {
                        var ss = samsite.GetComponent<HeliTargeting>();
                        if (!ss) return;
    
                        if (hit.distance >= 1.5) return;

                        if (samsite.IsPowered())
                        {
                            samsite.UpdateHasPower(0, 1);
                        }
                        else
                        {
                            samsite.UpdateHasPower(25, 1);
                        }
                        samsite.SendNetworkUpdateImmediate();
                    }
                }
            }
        }
  
        #endregion
  
        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"ConfigChanged", "Your configuration has changed"},
                {"Saving", "Data saved successfully"},
            }, this);
        }
        #endregion
   
        #region Hooks
        void OnEntitySpawned(AutoTurret turret)
        {
            if (turret.OwnerID != 0)
            {
                if (IsAllowed(turret))
                {
                    turret.gameObject.AddComponent<AntiHeli>();
                    turretIDs.Add(turret.net.ID);
                }
            }
        }
   
        void OnEntityKill(AutoTurret turret)
        {
            if (turret.OwnerID == 0) return;
  
            if (turretIDs.Contains(turret.net.ID))
            {
                turretIDs.Remove(turret.net.ID);
            }
  
            if (PoweredTurretIDs.Contains(turret.net.ID))
            {
                PoweredTurretIDs.Remove(turret.net.ID);
            }
        }
   
        void OnEntitySpawned(SamSite entity)
        {
            if (entity.OwnerID == 0) return;
  
            if (SamIsAllowed(entity))
            {
                entity.gameObject.AddComponent<HeliTargeting>();
                samIDs.Add(entity.net.ID);
            }
        }
   
        void OnEntityKill(SamSite entity)
        {
            samIDs.Remove(entity.net.ID);
        }
        #endregion
   
        #region Functions
        private static BasePlayer FindOwner(string nameOrId)
        {
            foreach (var activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.UserIDString == nameOrId)
                    return activePlayer;
                if (activePlayer.displayName.Contains(nameOrId, CompareOptions.OrdinalIgnoreCase))
                    return activePlayer;
            }
            return null;
        }
   
        private bool IsAllowed(AutoTurret turret)
        {
            var player = FindOwner(turret.OwnerID.ToString());
            bool hasPermission = permission.UserHasPermission(player.UserIDString, skyturretperms);
  
            if (!NeedsPerms)
                return true;
            else
                return hasPermission;
        }
   
        private bool SamIsAllowed(SamSite sam)
        {
            var player = FindOwner(sam.OwnerID.ToString());
            bool hasPermission = permission.UserHasPermission(player.UserIDString, skyturretperms);
  
            if (!NeedsPerms)
                return true;
            else
                return hasPermission;
        }
        #endregion
   
        #region MonoBehaviour
        private class AntiHeli : MonoBehaviour
        {
            private AutoTurret turret;
            private BaseEntity entity;
            private BaseCombatEntity target;
  
            private void Awake()
            {
                turret = gameObject.GetComponent<AutoTurret>();
                entity = gameObject.GetComponent<BaseEntity>();
 
                var collider = entity.gameObject.AddComponent<SphereCollider>();
                collider.gameObject.layer = (int)Layer.Reserved1;
                collider.radius = plugin.AirTargetRadius;
                collider.isTrigger = true;
            }

            private void FixedUpdate()
            {
                if (target != null  && turret.IsOnline())
                {
                    turret.target = target;
                    turret.UpdateFacingToTarget();
                }
                else
                {
                    target = null;
                    turret.target = null;
                }
            }
  
            private void OnTriggerEnter(Collider col)
            {
                if (col.name == "patrol_helicopter" || col.name == "ch47_collider_front_motor")
                {
                    BaseCombatEntity heli = col.GetComponentInParent<BaseCombatEntity>();
                    target = heli;
                }
            }

            private void OnTriggerStay(Collider col)
            {
                if (col.name == "patrol_helicopter" || col.name == "ch47_collider_front_motor")
                {
                    BaseCombatEntity heli = col.GetComponentInParent<BaseCombatEntity>();
                    target = heli;
                }    
            }

            private void OnTriggerExit(Collider col)
            {
                if (col.name == "patrol_helicopter" || col.name == "ch47_collider_front_motor")
                {
                    turret.target = null;
                    target = null;
                }
            }
  
            public void UnloadDestroy()
            {
                target = null;
                turret.target = null;
                Destroy(this);
            }
  
            public void Destroy()
            {
                if (plugin.turretIDs.Contains(turret.net.ID))
                    plugin.turretIDs.Remove(turret.net.ID);
            }
        }
   
        private class HeliTargeting : MonoBehaviour
        {
            private SamSite samsite;
            private BaseEntity entity;
  
            private void Awake()
            {
                entity = gameObject.GetComponent<BaseEntity>();
                samsite = entity.GetComponent<SamSite>();
                samsite.UpdateHasPower(25, 1);
                samsite.SendNetworkUpdateImmediate();
                InvokeRepeating("FindTargets", plugin.CheckForTargetEveryXSeconds, 1.0f);
            }
  
            internal void FindTargets()
            {
                if (!samsite.IsPowered()) return;
 
                if (samsite.currentTarget.IsUnityNull<SamSite.ISamSiteTarget>())
                {
                    List<SamSite.ISamSiteTarget> nearby = Pool.GetList<SamSite.ISamSiteTarget>();
                    Vis.Entities(samsite.eyePoint.transform.position, plugin.SamSiteAttackDistance, nearby);

                    SamSite.ISamSiteTarget currentTarget1 = null;

                    foreach (SamSite.ISamSiteTarget currentTarget2 in nearby)
                    {
                        string prefabname = ((BaseCombatEntity) currentTarget2)?.PrefabName ?? string.Empty;
                        if (string.IsNullOrEmpty(prefabname)) return;
    
                        if (currentTarget2.CenterPoint().y >= samsite.eyePoint.transform.position.y && currentTarget2.IsVisible(samsite.eyePoint.transform.position, plugin.SamSiteAttackDistance * 2f)  && prefabname.Contains("patrolhelicopter.prefab") || prefabname.Contains("ch47scientists.entity.prefab") || prefabname.Contains("cargo_plane.prefab"))
                            currentTarget1 = currentTarget2;

                        Pool.FreeList<SamSite.ISamSiteTarget>(ref nearby);
                    }

                    samsite.currentTarget = currentTarget1;
                }
 
                if (!samsite.currentTarget.IsUnityNull<SamSite.ISamSiteTarget>())
                {
                    float distance = Vector3.Distance(samsite.transform.position, ((BaseCombatEntity) samsite.currentTarget).transform.position);
                    if (distance <= plugin.SamSiteAttackDistance)
                    {
                        samsite.InvokeRandomized(new Action(samsite.WeaponTick), 0.0f, 0.5f, 0.2f);
                    }
                    else if (distance > plugin.SamSiteAttackDistance)
                    {
                        samsite.currentTarget = null;
                        samsite.CancelInvoke(new Action(samsite.WeaponTick));
                    }
                }
            }

            public void UnloadDestroy()
            {
                Destroy(this);    
            }
  
            public void Destroy()
            {
                if (plugin.samIDs.Contains(samsite.net.ID))
                    plugin.samIDs.Remove(samsite.net.ID);
                CancelInvoke("FindTargets");
            }
        }
        #endregion
    }
}


// --- End of file: SkyTurrets.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/signal-cooldown ---
// --- Original File Path: S/SignalCooldown/SignalCooldown.cs ---

using UnityEngine;
using System.Collections.Generic;
using System;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Signal Cooldown", "Vliek", "1.0.32", ResourceId = 2805)]
    [Description("Add a cooldown to supply signals to avoid that players are going to leave from rage.")]
    class SignalCooldown : RustPlugin
    {
        private bool Changed;
        private bool refundSignal;
        private int timeCooldown;
        private string cooldownPerm;
        private ulong messageIcon;
        private int authLevel;

        public List<ulong> signalCooldown = new List<ulong>();
        public Dictionary<ulong, float> lastRun = new Dictionary<ulong, float>();

        string GetLang(string msg, string userID) => lang.GetMessage(msg, this, userID);

        protected override void LoadDefaultConfig()
        {
            Puts("Creating a new config file.");
            Config.Clear();
            LoadVariables();
        }
        private void LoadVariables()
        {
            refundSignal = Convert.ToBoolean(GetConfig("Settings", "Refund signal", true));
            timeCooldown = Convert.ToInt32(GetConfig("Settings", "Cooldown in seconds", 300));
            cooldownPerm = Convert.ToString(GetConfig("Settings", "Ignore cooldown permission", "signalcooldown.ignore"));
            messageIcon = Convert.ToUInt64(GetConfig("Settings", "Icon for message", 0));
            authLevel = Convert.ToInt32(GetConfig("Settings", "Auth level admin commands", 1));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["cooldownActive"] = "<color=#b7b7b7>Supplysignal cooldown active, wait {0} seconds till you can throw a signal again.</color>",
                ["cooldownOver"] = "<color=#b7b7b7>You are able to throw a supplysignal again.</color>",
                ["noPermission"] = "<color=#b7b7b7>You don't have the required auth level to run this command.</color>",
                ["manualReset"] = "<color=#b7b7b7>All supplysignal cooldowns have been manually reset.</color>"
            }, this);
        }

        private void Init()
        {
            LoadVariables();
            permission.RegisterPermission(cooldownPerm, this);
        }

        public bool HasSignalCooldown(ulong userId)
        {
            if (signalCooldown.Contains(userId))
            {
                return true;
            }
            return false;
        }

        private void OnExplosiveDropped(BasePlayer player, BaseEntity entity) => OnExplosiveThrown(player, entity);

        private void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
        {
            if (entity.ShortPrefabName != "grenade.supplysignal.deployed")
                return;
            if (!permission.UserHasPermission(player.UserIDString, cooldownPerm))
            {
                if (signalCooldown.Contains(player.userID))
                {
                    float difference = (lastRun[player.userID] + timeCooldown) - UnityEngine.Time.time;
                    float finaldifference = Mathf.Round(difference);
                    entity.Kill();
                    Player.Message(player, GetLang("cooldownActive", player.UserIDString), null, messageIcon, finaldifference);
                    if (refundSignal)
                    {
                        Item item = ItemManager.CreateByName("supply.signal", 1, entity.skinID);
                        if (item != null)
                        {
                            player.inventory.GiveItem(item, player.inventory.containerBelt);
                        }
                    }
                    return;
                }

                signalCooldown.Add(player.userID);
                lastRun.Add(player.userID, UnityEngine.Time.time);
                timer.Once(timeCooldown, () =>
                {
                    signalCooldown.Remove(player.userID);
                    lastRun.Remove(player.userID);
                    Player.Message(player, GetLang("cooldownOver", player.UserIDString), null, messageIcon);
                });
                //Puts("Signal cooldown started on " + player.displayName);
                return;
            }
            return;
        }

        [ChatCommand("signalreset")]
        private void ResetTimeCMD(BasePlayer player, string command, string[] args)
        {
            if (player.Connection.authLevel < authLevel)
            {
                Player.Message(player, GetLang("noPermission", player.UserIDString), null, messageIcon);
                return;
            }
            Player.Message(player, GetLang("manualReset", player.UserIDString), null, messageIcon);
            Reset();
        }

        void Reset()
        {
            signalCooldown.Clear();
            lastRun.Clear();
            Puts("All cooldowns have been manually reset.");
        }
    }
}

// --- End of file: SignalCooldown.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/storage-monitor-control ---
// --- Original File Path: S/StorageMonitorControl/StorageMonitorControl.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Storage Monitor Control", "WhiteThunder", "1.2.1")]
    [Description("Allows storage monitors to be deployed to more container types.")]
    internal class StorageMonitorControl : CovalencePlugin
    {
        #region Fields

        private const string PermissionAll = "storagemonitorcontrol.owner.all";
        private const string PermissionEntityFormat = "storagemonitorcontrol.owner.{0}";

        private const string StorageMonitorBoneName = "storagemonitor";

        private WaitWhile WaitWhileSaving = new WaitWhile(() => SaveRestore.IsSaving);

        private HashSet<StorageMonitor> _quarryMonitors = new HashSet<StorageMonitor>();

        private Coroutine _saveRoutine;
        private Configuration _config;

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(PermissionAll, this);

            _config.Init(this);

            Unsubscribe(nameof(OnEntitySpawned));
        }

        private void OnServerInitialized()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var container = entity as StorageContainer;
                if (container != null)
                {
                    OnEntitySpawned(container);
                    continue;
                }

                var storageMonitor = entity as StorageMonitor;
                if (storageMonitor != null)
                {
                    var parentQuarry = storageMonitor.GetParentEntity() as MiningQuarry;
                    if (parentQuarry != null)
                        ReparentToClosestQuarryStorage(storageMonitor, parentQuarry);

                    OnEntitySpawned(storageMonitor);
                    continue;
                }
            }

            Subscribe(nameof(OnEntitySpawned));
        }

        private void Unload()
        {
            if (_saveRoutine != null)
            {
                ServerMgr.Instance.StopCoroutine(_saveRoutine);
            }

            ReparentMonitorsToQuarry();
        }

        private void OnServerSave()
        {
            _saveRoutine = ServerMgr.Instance.StartCoroutine(ReparentWhileSaving());
        }

        private void OnEntitySpawned(StorageContainer container)
        {
            if (container == null || NativelySupportsStorageMonitor(container))
                return;

            container.isMonitorable = ShouldEnableMonitoring(container);
        }

        private void OnEntitySpawned(StorageMonitor storageMonitor)
        {
            var parentContainer = storageMonitor.GetParentEntity() as StorageContainer;
            if (parentContainer == null || NativelySupportsStorageMonitor(parentContainer))
                return;

            var containerConfig = _config.GetContainerConfig(parentContainer);
            if (containerConfig == null || !containerConfig.Enabled)
                return;

            if (IsQuarryStorage(parentContainer))
            {
                _quarryMonitors.Add(storageMonitor);
            }

            var transform = storageMonitor.transform;

            if (transform.localPosition != containerConfig.Position
                || transform.localEulerAngles != containerConfig.RotationAngles)
            {
                transform.localPosition = containerConfig.Position;
                transform.localEulerAngles = containerConfig.RotationAngles;
                storageMonitor.InvalidateNetworkCache();
                storageMonitor.SendNetworkUpdate_Position();
            }
        }

        private void OnEntityKill(StorageMonitor storageMonitor)
        {
            _quarryMonitors.Remove(storageMonitor);
        }

        #endregion

        #region Helper Methods

        private static bool NativelySupportsStorageMonitor(BaseEntity entity)
        {
            return entity.model != null
                && entity.FindBone(StorageMonitorBoneName) != entity.model.rootBone;
        }

        private static bool IsQuarryStorage(StorageContainer storageContainer, out MiningQuarry quarry)
        {
            // Ignore if the parent has saving enabled, in case a plugin added other containers to quarries.
            if (storageContainer.enableSaving)
            {
                quarry = null;
                return false;
            }

            quarry = storageContainer.GetParentEntity() as MiningQuarry;
            return quarry != null;
        }

        private static bool IsQuarryStorage(StorageContainer storageContainer)
        {
            MiningQuarry quarry;
            return IsQuarryStorage(storageContainer, out quarry);
        }

        private bool ShouldEnableMonitoring(StorageContainer container)
        {
            var containerConfig = _config.GetContainerConfig(container);
            if (containerConfig == null || !containerConfig.Enabled)
                return false;

            if (!ContainerOwnerHasPermission(container, containerConfig))
                return false;

            return true;
        }

        private bool ContainerOwnerHasPermission(BaseEntity entity, ContainerConfig containerConfig)
        {
            if (!containerConfig.RequirePermission)
                return true;

            if (entity.OwnerID == 0)
                return false;

            var ownerIdString = entity.OwnerID.ToString();

            return permission.UserHasPermission(ownerIdString, PermissionAll)
                || permission.UserHasPermission(ownerIdString, containerConfig.Permission);
        }

        private void ReparentMonitorsToQuarry()
        {
            foreach (var storageMonitor in _quarryMonitors)
            {
                var parentContainer = storageMonitor.GetParentEntity() as StorageContainer;
                if (parentContainer == null)
                    continue;

                MiningQuarry quarry;
                if (IsQuarryStorage(parentContainer, out quarry))
                {
                    storageMonitor.SetParent(quarry, worldPositionStays: true);
                }
            }
        }

        private void ReparentToClosestQuarryStorage(StorageMonitor storageMonitor, MiningQuarry quarry)
        {
            var transform = storageMonitor.transform;

            var fuelStorage = quarry.fuelStoragePrefab.instance as StorageContainer;
            var fuelStorageSqrDistance = fuelStorage != null
                ? (fuelStorage.transform.position - transform.position).sqrMagnitude
                : float.PositiveInfinity;

            var outputStorage = quarry.hopperPrefab.instance as StorageContainer;
            var outputStorageSqrDistance = outputStorage != null
                ? (outputStorage.transform.position - transform.position).sqrMagnitude
                : float.PositiveInfinity;

            StorageContainer newStorageParent = null;
            if (fuelStorageSqrDistance < outputStorageSqrDistance)
            {
                newStorageParent = fuelStorage;
            }
            else if (outputStorageSqrDistance < fuelStorageSqrDistance)
            {
                newStorageParent = outputStorage;
            }

            if (newStorageParent != null)
            {
                storageMonitor.SetParent(newStorageParent, worldPositionStays: true);
                newStorageParent.SetSlot(BaseEntity.Slot.StorageMonitor, storageMonitor);

                // TODO: Handle onItemAddedToStack and onItemRemovedFromStack
                newStorageParent.inventory.onItemAddedRemoved -= storageMonitor._onItemAddedRemoved;
                newStorageParent.inventory.onItemAddedRemoved += storageMonitor._onItemAddedRemoved;
            }
        }

        private void ReparentMonitorsToQuarryContainers()
        {
            foreach (var storageMonitor in _quarryMonitors)
            {
                var quarry = storageMonitor.GetParentEntity() as MiningQuarry;
                if (quarry == null)
                    continue;

                ReparentToClosestQuarryStorage(storageMonitor, quarry);
            }
        }

        private IEnumerator ReparentWhileSaving()
        {
            TrackStart();
            ReparentMonitorsToQuarry();
            TrackEnd();

            yield return WaitWhileSaving;

            TrackStart();
            ReparentMonitorsToQuarryContainers();
            TrackEnd();
        }

        #endregion

        #region Configuration

        private class Configuration : BaseConfiguration
        {
            [JsonProperty("Containers")]
            public Dictionary<string, ContainerConfig> Containers = new Dictionary<string, ContainerConfig>()
            {
                ["bbq.deployed"] = new ContainerConfig { Position = new Vector3(0.1f, 0, 0.3f), RotationAngles = new Vector3(0, 90, 0) },
                ["coffinstorage"] = new ContainerConfig { Position = new Vector3(-1.15f, 0.196f, 0), RotationAngles = new Vector3(90, 0, 90) },
                ["composter"] = new ContainerConfig { Position = new Vector3(0, 1.54f, 0.4f) },
                ["crudeoutput"] = new ContainerConfig { Position = new Vector3(-0.4f, 0, 2.5f), RotationAngles = new Vector3(0, 90, 0) },
                ["dropbox.deployed"] = new ContainerConfig { Position = new Vector3(0.3f, 0.545f, -0.155f), RotationAngles = new Vector3(0, 184, 0) },
                ["electricfurnace.deployed"] = new ContainerConfig { Position = new Vector3(-0.135f, 1.135f, 0.14f) },
                ["fridge.deployed"] = new ContainerConfig { Position = new Vector3(-0.2f, 1.995f, 0.2f), RotationAngles = new Vector3(0, 10, 0) },
                ["fuelstorage"] = new ContainerConfig { Position = new Vector3(-1.585f, -0.034f, 0) },
                ["furnace"] = new ContainerConfig { Position = new Vector3(0, 1.53f, 0.05f) },
                ["furnace.large"] = new ContainerConfig { Position = new Vector3(0.31f, 0.748f, -1.9f), RotationAngles = new Vector3(0, 190, 0) },
                ["guntrap.deployed"] = new ContainerConfig { Position = new Vector3(0, 0.032f, -0.3f), RotationAngles = new Vector3(0, 180, 0) },
                ["hitchtrough.deployed"] = new ContainerConfig { Position = new Vector3(-0.82f, 0.65f, 0.215f) },
                ["hopperoutput"] = new ContainerConfig { Position = new Vector3(-0.71f, -0.02f, 1.25f) },
                ["locker.deployed"] = new ContainerConfig { Position = new Vector3(-0.67f, 2.238f, 0.04f), RotationAngles = new Vector3(0, 10, 0) },
                ["mailbox.deployed"] = new ContainerConfig { Position = new Vector3(0f, 1.327f, 0.21f) },
                ["mixingtable.deployed"] = new ContainerConfig { Position = new Vector3(-0.9f, 0, 0) },
                ["planter.small.deployed"] = new ContainerConfig { Position = new Vector3(-1.22f, 0.482f, 0.3f) },
                ["planter.large.deployed"] = new ContainerConfig { Position = new Vector3(-1.22f, 0.482f, 1.22f) },
                ["refinery_small_deployed"] = new ContainerConfig { Position = new Vector3(0, 2.477f, 0), RotationAngles = new Vector3(0, 180, 0) },
                ["survivalfishtrap.deployed"] = new ContainerConfig { Position = new Vector3(0, 0.4f, -0.6f) },
                ["woodbox_deployed"] = new ContainerConfig { Position = new Vector3(-0.24f, 0.55f, 0.14f), RotationAngles = new Vector3(0, 10, 0) },
            };

            public void Init(StorageMonitorControl plugin)
            {
                foreach (var entry in Containers)
                {
                    entry.Value.Init(plugin, entry.Key);
                }
            }

            public ContainerConfig GetContainerConfig(StorageContainer container)
            {
                ContainerConfig containerConfig;
                return Containers.TryGetValue(container.ShortPrefabName, out containerConfig)
                    ? containerConfig
                    : null;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class ContainerConfig
        {
            [JsonProperty("Enabled")]
            public bool Enabled = false;

            [JsonProperty("Require permission")]
            public bool RequirePermission = false;

            [JsonProperty("RequirePermission")]
            private bool DeprecatedRequirePermission { set { RequirePermission = value; } }

            [JsonProperty("Position")]
            public Vector3 Position;

            [JsonProperty("Rotation angles", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public Vector3 RotationAngles;

            [JsonProperty("RotationAngle")]
            public float DeprecatedRotationAngle { set { RotationAngles = new Vector3(0, value, 0); } }

            public string Permission;

            public void Init(StorageMonitorControl plugin, string entityName)
            {
                if (string.IsNullOrWhiteSpace(entityName))
                    return;

                Permission = string.Format(PermissionEntityFormat, entityName)
                    // Make the permission name less redundant
                    .Replace(".deployed", string.Empty)
                    .Replace("_deployed", string.Empty)
                    .Replace(".entity", string.Empty);;

                plugin.permission.RegisterPermission(Permission, plugin);
            }
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #region Configuration Helpers

        private class BaseConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion
    }
}


// --- End of file: StorageMonitorControl.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/shrinking-radiation-zones ---
// --- Original File Path: S/ShrinkingRadZone/ShrinkingRadZone.cs ---

using System.Collections.Generic;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Shrinking Radiation Zone", "k1lly0u", "0.1.5")]
    [Description("Create shrinking radiation zones for BR style events")]
    class ShrinkingRadZone : RustPlugin
    {
        #region Fields
        private Hash<string, ShrinkZone> activeZones = new Hash<string, ShrinkZone>();
        
        private const string SPHERE_ENTITY = "assets/prefabs/visualization/sphere.prefab";
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            permission.RegisterPermission("shrinkingradzone.use", this);
            lang.RegisterMessages(messages, this);
        }

        private void Unload()
        {
            ShrinkZone[] shrinkZones = UnityEngine.Object.FindObjectsOfType<ShrinkZone>();
            for (int i = 0; i < shrinkZones?.Length ; i++)
            {
                UnityEngine.Object.Destroy(shrinkZones[i]);
            }

            Configuration = null;
        }
        #endregion

        #region API
        private string CreateShrinkZone(Vector3 position, float radius, float time)
        {           
            string zoneId = CuiHelper.GetGuid();
            ShrinkZone zone = new GameObject().AddComponent<ShrinkZone>();
            activeZones[zoneId] = zone;
            zone.CreateZones(zoneId, position, radius, time);            
            return zoneId;
        }

        private void ToggleZoneShrink(string id)
        {
            ShrinkZone shrinkZone;
            if (activeZones.TryGetValue(id, out shrinkZone))            
                shrinkZone.ToggleShrinking();            
        }

        private void DestroyShrinkZone(string id)
        {
            ShrinkZone shrinkZone;
            if (activeZones.TryGetValue(id, out shrinkZone))
            {
                UnityEngine.Object.Destroy(shrinkZone);
                activeZones.Remove(id);
            }
        }
        #endregion

        #region Classes
        private class ShrinkZone : MonoBehaviour
        {
            private string zoneId;
            private float initialRadius;
            private float modifiedRadius;
            private float targetRadius;

            private float timeToTake;
            private float timeTaken;

            private SphereEntity[] innerSpheres;
            private SphereEntity[] outerSpheres;

            private SphereCollider innerCollider;

            private TriggerRadiation radiation;

            private void Awake()
            {
                gameObject.layer = (int)Layer.Reserved1;
                gameObject.name = "ShrinkZone";
                enabled = false;

                targetRadius = Configuration.FinalZoneSize;
                timeToTake = Configuration.ShrinkTime;
                timeTaken = 0;
            }

            private void OnDestroy()
            {
                foreach (BaseEntity entity in radiation.entityContents)
                    entity.LeaveTrigger(radiation);

                foreach (SphereEntity entity in innerSpheres)
                    entity.Kill();

                foreach (SphereEntity entity in outerSpheres)
                    entity.Kill();

                Destroy(gameObject);
            }

            private void Update()
            {                
                timeTaken = timeTaken + UnityEngine.Time.deltaTime;
                float single = Mathf.InverseLerp(0f, timeToTake, timeTaken);

                modifiedRadius = initialRadius * (1 - single);

                foreach (SphereEntity innerSphere in innerSpheres)
                {
                    innerSphere.currentRadius = (initialRadius * 2) * (1 - single);

                    innerSphere.SendNetworkUpdateImmediate();
                }

                innerCollider.radius = modifiedRadius;

                if (modifiedRadius <= targetRadius)
                {
                    enabled = false;
                    Interface.CallHook("OnRadiationZoneShrunk", zoneId);                    
                }
            }

            private void OnTriggerEnter(Collider obj)
            {
                BasePlayer player = obj?.GetComponentInParent<BasePlayer>();
                if (player != null)
                {
                    player.LeaveTrigger(radiation);
                }
            }

            private void OnTriggerExit(Collider obj)
            {
                BasePlayer player = obj?.GetComponentInParent<BasePlayer>();
                if (player != null)
                {
                    player.EnterTrigger(radiation);
                }
            }

            public void CreateZones(string zoneId, Vector3 position, float initialRadius, float timeToTake)
            {
                transform.position = position;

                this.zoneId = zoneId;
                this.initialRadius = initialRadius;
                this.timeToTake = timeToTake;

                innerSpheres = new SphereEntity[Configuration.DomeShade];
                outerSpheres = new SphereEntity[Configuration.DomeShade];

                for (int i = 0; i < Configuration.DomeShade; i++)
                {
                    SphereEntity innerSphere = (SphereEntity)GameManager.server.CreateEntity(SPHERE_ENTITY, position, Quaternion.identity, true);
                    innerSphere.currentRadius = initialRadius * 2;
                    innerSphere.lerpSpeed = 0;
                    innerSphere.enableSaving = false;
                    innerSphere.Spawn();

                    innerSpheres[i] = innerSphere;
                }                

                innerCollider = gameObject.AddComponent<SphereCollider>();
                innerCollider.isTrigger = true;
                innerCollider.radius = initialRadius;

                for (int i = 0; i < Configuration.DomeShade; i++)
                {
                    SphereEntity outerSphere = (SphereEntity)GameManager.server.CreateEntity(SPHERE_ENTITY, position, Quaternion.identity, true);
                    outerSphere.currentRadius = (initialRadius * 2) + Configuration.RadiationBuffer;
                    outerSphere.lerpSpeed = 0;
                    outerSphere.enableSaving = false;
                    outerSphere.Spawn();
                    
                    if (i == 0)
                    {
                        SphereCollider outerCollider = outerSphere.gameObject.AddComponent<SphereCollider>();
                        outerCollider.isTrigger = true;
                        outerCollider.radius = 0.5f;

                        radiation = outerSphere.gameObject.AddComponent<TriggerRadiation>();
                        radiation.RadiationAmountOverride = Configuration.RadiationStrength;
                        radiation.interestLayers = 131072;
                        radiation.enabled = true;
                    }

                    outerSpheres[i] = outerSphere;
                }                

                enabled = true;
            }

            public void ToggleShrinking() => enabled = !enabled;
        }
        #endregion

        #region Commands
        [ChatCommand("shrink")]
        private void cmdShrink(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin && !permission.UserHasPermission(player.UserIDString, "shrinkingradzone.use"))
                return;

            if (args.Length == 0)
            {
                SendReply(player, $"<color=#00CC00>{Title}</color>  <color=#939393>v</color><color=#00CC00>{Version}</color> <color=#939393>-</color> <color=#00CC00>{Author}</color>");
                SendReply(player, msg("/shrink on me - Starts a shrinking rad zone on your position", player.UserIDString));
                SendReply(player, msg("/shrink on <x> <z> - Starts a shrinking rad zone on the specified position", player.UserIDString));
                SendReply(player, msg("/shrink stop - Destroys all active zones", player.UserIDString));
                SendReply(player, msg("/shrink buffer <## value> - Set the radiation buffer size", player.UserIDString));
                SendReply(player, msg("/shrink startsize <## value> - Set the initial zone size", player.UserIDString));
                SendReply(player, msg("/shrink endsize <## value> - Set the final zone size", player.UserIDString));
                SendReply(player, msg("/shrink strength <## value> - Set the radiation strength (rads per second)", player.UserIDString));
                SendReply(player, msg("/shrink time <## value>  - Set the time it takes to shrink (in seconds)", player.UserIDString));
                return;
            }

            switch (args[0].ToLower())
            {
                case "on":
                    if (args.Length >= 2)
                    {
                        object position = null;
                        if (args[1].ToLower() == "me")                        
                            position = player.transform.position; 
                        else if (args.Length > 2)
                        {
                            float x;
                            float z;
                            if (float.TryParse(args[1], out x) && float.TryParse(args[2], out z))
                            {
                                Vector3 temp = new Vector3(x, 0, z);
                                float height = TerrainMeta.HeightMap.GetHeight((Vector3)temp);
                                position = new Vector3(x, height, z);
                            }
                        }                       
                        if (position is Vector3)
                        {
                            CreateShrinkZone((Vector3) position, Configuration.InitialZoneSize, Configuration.ShrinkTime);
                            SendReply(player, "Zone Created!");
                            return;
                        }                        
                    }
                    else
                    {
                        SendReply(player, "/shrink on me\n/shrink on <x> <z>");
                        return;
                    }
                    return;

                case "stop":
                    foreach (KeyValuePair<string, ShrinkZone> zone in activeZones)
                    {
                        UnityEngine.Object.DestroyImmediate(zone.Value.gameObject);
                        Interface.CallHook("RadzoneEnd", zone.Key);
                    }
                    activeZones.Clear();
                    SendReply(player, msg("All zones destroyed"));
                    return;

                case "buffer":
                    if (args.Length == 2)
                    {
                        float value;
                        if (float.TryParse(args[1], out value))
                        {
                            Configuration.RadiationBuffer = value;
                            SaveConfig();
                            SendReply(player, string.Format(msg("Radiation buffer set to : {0}", player.UserIDString), value));                            
                        }
                        else SendReply(player, msg("You must enter a number value", player.UserIDString));
                    }
                    else SendReply(player, msg("/shrink buffer <##>", player.UserIDString));
                    return;

                case "startsize":
                    if (args.Length == 2)
                    {
                        float value;
                        if (float.TryParse(args[1], out value))
                        {
                            Configuration.InitialZoneSize = value;
                            SaveConfig();
                            SendReply(player, string.Format(msg("Initial size set to : {0}", player.UserIDString), value));
                        }
                        else SendReply(player, msg("You must enter a number value", player.UserIDString));
                    }
                    else SendReply(player, msg("/shrink startsize <##>", player.UserIDString));
                    return;

                case "endsize":
                    if (args.Length == 2)
                    {
                        float value;
                        if (float.TryParse(args[1], out value))
                        {
                            Configuration.FinalZoneSize = value;
                            SaveConfig();
                            SendReply(player, string.Format(msg("Final size set to : {0}", player.UserIDString), value));
                        }
                        else SendReply(player, msg("You must enter a number value", player.UserIDString));
                    }
                    else SendReply(player, msg("/shrink endsize <##>", player.UserIDString));
                    return;

                case "strength":
                    if (args.Length == 2)
                    {
                        float value;
                        if (float.TryParse(args[1], out value))
                        {
                            Configuration.RadiationStrength = value;
                            SaveConfig();
                            SendReply(player, string.Format(msg("Radiation strength set to : {0}", player.UserIDString), value));
                        }
                        else SendReply(player, msg("You must enter a number value", player.UserIDString));
                    }
                    else SendReply(player, msg("/shrink strength <##>", player.UserIDString));
                    return;

                case "time":
                    if (args.Length == 2)
                    {
                        float value;
                        if (float.TryParse(args[1], out value))
                        {
                            Configuration.ShrinkTime = value;
                            SaveConfig();
                            SendReply(player, string.Format(msg("Shrink time set to : {0}", player.UserIDString), value));
                        }
                        else SendReply(player, msg("You must enter a number value", player.UserIDString));
                    }
                    else SendReply(player, msg("/shrink time <##>", player.UserIDString));
                    return;

                default:
                    break;
            }
        }
        [ConsoleCommand("shrink")]
        private void ccmdShrink(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
                return;

            if (arg.Args.Length == 0)
            {
                SendReply(arg, $"{Title}  v{Version} - {Author}");
                SendReply(arg, "shrink on <x> <z> - Starts a shrinking rad zone on the specified position");
                SendReply(arg, "shrink stop - Destroys all active zones");
                SendReply(arg, "shrink buffer <## value> - Set the radiation buffer size");
                SendReply(arg, "shrink startsize <## value> - Set the initial zone size");
                SendReply(arg, "shrink endsize <## value> - Set the final zone size");
                SendReply(arg, "shrink strength <## value> - Set the radiation strength (rads per second)");
                SendReply(arg, "shrink time <## value>  - Set the time it takes to shrink (in seconds)");
                return;
            }

            switch (arg.Args[0].ToLower())
            {
                case "on":
                    if (arg.Args.Length >= 2)
                    {
                        object position = null;
                        if (arg.Args.Length > 2)
                        {
                            float x;
                            float z;
                            if (float.TryParse(arg.Args[1], out x) && float.TryParse(arg.Args[2], out z))
                            {
                                Vector3 temp = new Vector3(x, 0, z);
                                float height = TerrainMeta.HeightMap.GetHeight((Vector3)temp);
                                position = new Vector3(x, height, z);
                            }
                        }
                        if (position is Vector3)
                        {
                            CreateShrinkZone((Vector3)position, Configuration.InitialZoneSize, Configuration.ShrinkTime);
                            SendReply(arg, "Zone Created!");
                            return;
                        }
                    }
                    else
                    {
                        SendReply(arg, "/shrink on me\n/shrink on <x> <z>");
                        return;
                    }
                    return;

                case "stop":
                    foreach (var zone in activeZones)
                    {
                        UnityEngine.Object.DestroyImmediate(zone.Value.gameObject);
                        Interface.CallHook("RadzoneEnd", zone.Key);
                    }

                    activeZones.Clear();
                    SendReply(arg, msg("All zones destroyed"));
                    return;

                case "buffer":
                    if (arg.Args.Length == 2)
                    {
                        float value;
                        if (float.TryParse(arg.Args[1], out value))
                        {
                            Configuration.RadiationBuffer = value;
                            SaveConfig();
                            SendReply(arg, string.Format(msg("Radiation buffer set to : {0}"), value));
                        }
                        else SendReply(arg, msg("You must enter a number value"));
                    }
                    else SendReply(arg, msg("shrink buffer <##>"));
                    return;

                case "startsize":
                    if (arg.Args.Length == 2)
                    {
                        float value;
                        if (float.TryParse(arg.Args[1], out value))
                        {
                            Configuration.InitialZoneSize = value;
                            SaveConfig();
                            SendReply(arg, string.Format(msg("Initial size set to : {0}"), value));
                        }
                        else SendReply(arg, msg("You must enter a number value"));
                    }
                    else SendReply(arg, msg("shrink startsize <##>"));
                    return;

                case "endsize":
                    if (arg.Args.Length == 2)
                    {
                        float value;
                        if (float.TryParse(arg.Args[1], out value))
                        {
                            Configuration.FinalZoneSize = value;
                            SaveConfig();
                            SendReply(arg, string.Format(msg("Final size set to : {0}"), value));
                        }
                        else SendReply(arg, msg("You must enter a number value"));
                    }
                    else SendReply(arg, msg("shrink endsize <##>"));
                    return;

                case "strength":
                    if (arg.Args.Length == 2)
                    {
                        float value;
                        if (float.TryParse(arg.Args[1], out value))
                        {
                            Configuration.RadiationStrength = value;
                            SaveConfig();
                            SendReply(arg, string.Format(msg("Radiation strength set to : {0}"), value));
                        }
                        else SendReply(arg, msg("You must enter a number value"));
                    }
                    else SendReply(arg, msg("shrink strength <##>"));
                    return;

                case "time":
                    if (arg.Args.Length == 2)
                    {
                        float value;
                        if (float.TryParse(arg.Args[1], out value))
                        {
                            Configuration.ShrinkTime = value;
                            SaveConfig();
                            SendReply(arg, string.Format(msg("Shrink time set to : {0}"), value));
                        }
                        else SendReply(arg, msg("You must enter a number value"));
                    }
                    else SendReply(arg, msg("shrink time <##>"));
                    return;

                default:
                    break;
            }
        }
        #endregion

        #region Config        
        private static ConfigData Configuration;

        private class ConfigData
        {
            public float RadiationBuffer { get; set; }
            public float FinalZoneSize { get; set; }
            public float InitialZoneSize { get; set; }
            public float ShrinkTime { get; set; }
            public float RadiationStrength { get; set; }
            public int DomeShade { get; set; }
            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Configuration = Config.ReadObject<ConfigData>();

            if (Configuration.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(Configuration, true);
        }

        protected override void LoadDefaultConfig() => Configuration = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                FinalZoneSize = 20,
                InitialZoneSize = 150,
                RadiationBuffer = 50,
                RadiationStrength = 40,
                ShrinkTime = 120,
                DomeShade = 4,
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(Configuration, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            if (Configuration.Version < new VersionNumber(0, 1, 4))
                Configuration.DomeShade = 4;

            Configuration.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion

        #region Localization
        private string msg(string key, string playerId = null) => lang.GetMessage(key, this, playerId);

        private Dictionary<string, string> messages = new Dictionary<string, string>
        {
            {"Radiation strength set to : {0}","Radiation strength set to : {0}" },
            {"You must enter a number value","You must enter a number value" },
            {"Shrink time set to : {0}","Shrink time set to : {0}" },
            {"Final size set to : {0}","Final size set to : {0}" },
            {"Initial size set to : {0}","Initial size set to : {0}" },
            {"Radiation buffer set to : {0}","Radiation buffer set to : {0}" },
            {"Zone Created!","Zone Created!" },
            {"/shrink on me - Starts a shrinking rad zone on your position","/shrink on me - Starts a shrinking rad zone on your position" },
            {"/shrink on <x> <z> - Starts a shrinking rad zone on the specified position","/shrink on <x> <z> - Starts a shrinking rad zone on the specified position" },
            {"/shrink buffer <## value> - Set the radiation buffer size","/shrink buffer <## value> - Set the radiation buffer size" },
            {"/shrink startsize <## value> - Set the initial zone size","/shrink startsize <## value> - Set the initial zone size" },
            {"/shrink endsize <## value> - Set the final zone size","/shrink endsize <## value> - Set the final zone size" },
            {"/shrink strength <## value> - Set the radiation strength (rads per second)","/shrink strength <## value> - Set the radiation strength (rads per second)" },
            {"/shrink time <## value>  - Set the time it takes to shrink (in seconds)","/shrink time <## value>  - Set the time it takes to shrink (in seconds)" },
            {"All zones destroyed","All zones destroyed" }
        };
        #endregion
    }
}


// --- End of file: ShrinkingRadZone.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/strike-system ---
// --- Original File Path: S/StrikeSystem/StrikeSystem.cs ---

using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using System.Linq;
using System;

namespace Oxide.Plugins
{
    [Info("StrikeSystem", "LaserHydra", "2.1.3", ResourceId = 1276)]
    [Description("Strike players & time-ban players with a specific amount of strikes")]
    class StrikeSystem : CovalencePlugin
    {
        static List<Player> Players = new List<Player>();

        [PluginReference("EnhancedBanSystem")]
        Plugin EBS;

        #region Classes

        class Player
        {
            public string steamId = "0";
            public string name = "unkown";
            public string lastStrike = "not striked yet";
            public int strikes = 0;
            public int activeStrikes = 0;

            public Player()
            {
            }

            internal Player(IPlayer player)
            {
                this.steamId = player.Id;
                this.name = player.Name;
            }

            internal void Update(IPlayer player) => this.name = player.Name;
            
            internal static Player Get(IPlayer player)
            {
                return Players.Find((p) =>
                {
                    if (p.steamId == player.Id)
                        return true;
                    else
                        return false;
                });
            }

            public override bool Equals(object obj)
            {
                if (obj is Player && ((Player) obj).steamId == this.steamId)
                    return true;

                return false;
            }

            public override int GetHashCode() => Convert.ToInt32(steamId);
        }

        #endregion
        
        #region Plugin General

        ////////////////////////////////////////
        ///     Plugin Related Hooks
        ////////////////////////////////////////

        void Loaded()
        {
            LoadConfig();
            LoadMessages();
            LoadData(ref Players);

            RegisterPerm("admin");

            foreach (IPlayer player in players.Connected)
                if (Player.Get(player) == null)
                {
                    Players.Add(new Player(player));
                    SaveData(ref Players);
                }
                else
                    Player.Get(player).Update(player);
        }

        ////////////////////////////////////////
        ///     Config & Message Loading
        ////////////////////////////////////////

        new void LoadConfig()
        {
            SetConfig("Settings", "Strikes Until Ban", 3);
            SetConfig("Settings", "Permanent Ban", false);
            SetConfig("Settings", "Ban Time in Seconds", 86400);

            SaveConfig();
        }

        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"No Permission", "You don't have permission to use this command."},
                {"Striked", "{player} has been striked. Reason: {reason}"},
                {"Banned", "{player} was banned due too many strikes. Reason: {reason}"},
                {"Can Not Join", "You were banned due too many strikes. Reason: {reason}"},
                {"True Or False", "{arg} must be 'true' or 'false'!"},
                {"Invalid Number", "{arg} must be a valid number!"},
                {"Reset", "{player}'s strikes were reset."},
                {"Removed", "Removed {amount} strikes from {player}"},
                {"Wiped", "Strikes were been wiped!"},
                {"Fully Wiped", "All data was wiped!"}
            }, this);
        }

        protected override void LoadDefaultConfig() => PrintWarning("Generating new config file...");
        #endregion

        #region Commands

        [Command("strike")]
        void cmdStrike(IPlayer player, string cmd, string[] args)
        {
            if(args.Length == 0)
            {
                if (HasPerm(player.Id, "admin"))
                    player.Reply("<color=#C4FF00>/strike <player> [reason]</color> strike player" + Environment.NewLine +
                                            "<color=#C4FF00>/strike reset <player> [only Active Strikes: true/false]</color> reset players strikes" + Environment.NewLine +
                                            "<color=#C4FF00>/strike remove <player> [amount] [only Active Strikes: true/false]</color> remove strikes of a player " + Environment.NewLine +
                                            "<color=#C4FF00>/strike info [player]</color> get strike info about a player" + Environment.NewLine +
                                            "<color=#C4FF00>/strike wipe [only Active Strikes: true/false]</color> wipe all strikes" + Environment.NewLine +
                                            "<color=#C4FF00>/strike wipefull</color> wipe all data");
                else
                    player.Reply("<color=#C4FF00>/strike info</color> get your strike info");

                return;
            }

            switch(args[0].ToLower())
            {
                case "reset":
                    if (!HasPerm(player.Id, "admin"))
                        return;

                    if(args.Length != 2 && args.Length != 3)
                    {
                        player.Reply("Syntax: /strike reset <player> [only Active Strikes: true/false]");
                        return;
                    }

                    IPlayer resetTarget = GetPlayer(args[1], player);

                    if (resetTarget == null)
                        return;

                    Player resetPl = Player.Get(resetTarget);

                    if(resetPl == null)
                    {
                        Players.Add(new Player(resetTarget));
                        SaveData(ref Players);

                        resetPl = Player.Get(resetTarget);
                    }

                    bool resetOnlyActive = true;

                    if(args.Length == 3)
                    {
                        try
                        {
                            resetOnlyActive = Convert.ToBoolean(args[2]);
                        }
                        catch(FormatException)
                        {
                            player.Reply(GetMsg("True Or False", player.Id));
                            return;
                        }
                    }

                    resetPl.activeStrikes = 0;

                    if(!resetOnlyActive)
                    {
                        resetPl.strikes = 0;
                        resetPl.lastStrike = "not striked yet";
                    }

                    SaveData(ref Players);

                    player.Reply(GetMsg("Reset", player.Id).Replace("{player}", resetTarget.Name));

                    break;

                case "remove":
                    if (!HasPerm(player.Id, "admin"))
                        return;

                    if (args.Length != 2 && args.Length != 3 && args.Length != 4)
                    {
                        player.Reply("Syntax: /strike remove <player> [amount] [only Active Strikes: true/false]");
                        return;
                    }

                    IPlayer removeTarget = GetPlayer(args[1], player);

                    if (removeTarget == null)
                        return;

                    Player removePl = Player.Get(removeTarget);

                    if (removePl == null)
                    {
                        Players.Add(new Player(removeTarget));
                        SaveData(ref Players);

                        removePl = Player.Get(removeTarget);
                    }

                    int removeAmount = 1;

                    if (args.Length >= 3)
                    {
                        try
                        {
                            removeAmount = Convert.ToInt32(args[2]);
                        }
                        catch (FormatException)
                        {
                            player.Reply(GetMsg("Invalid Number", player.Id));
                            return;
                        }
                    }

                    bool removeOnlyActive = true;

                    if (args.Length == 4)
                    {
                        try
                        {
                            removeOnlyActive = Convert.ToBoolean(args[3]);
                        }
                        catch (FormatException)
                        {
                            player.Reply(GetMsg("True Or False", player.Id).Replace("{arg}", "[only Active Strikes: true/false]"));
                            return;
                        }
                    }

                    removePl.activeStrikes -= removeAmount;

                    if (!removeOnlyActive)
                        removePl.strikes -= removeAmount;

                    SaveData(ref Players);

                    player.Reply(GetMsg("Removed", player.Id).Replace("{player}", removeTarget.Name).Replace("{amount}", removeAmount.ToString()));

                    break;

                case "info":
                    if (!HasPerm(player.Id, "admin"))
                    {
                        Player pl = Player.Get(player);

                        if (pl == null)
                        {
                            Players.Add(new Player(player));
                            SaveData(ref Players);

                            pl = Player.Get(player);
                        }

                        player.Reply($"<color=#C4FF00>Last Strike</color>: {pl.lastStrike}" + Environment.NewLine +
                                                $"<color=#C4FF00>Active Strikes</color>: {pl.activeStrikes}" + Environment.NewLine +
                                                $"<color=#C4FF00>Total Strikes</color>: {pl.strikes}");
                    }
                    else
                    {
                        if (args.Length != 1 && args.Length != 2)
                        {
                            player.Reply("Syntax: /strike info [player]");
                            return;
                        }

                        if(args.Length == 1)
                        {
                            Player pl = Player.Get(player);

                            if (pl == null)
                            {
                                Players.Add(new Player(player));
                                SaveData(ref Players);

                                pl = Player.Get(player);
                            }

                            player.Reply($"<color=#C4FF00>Last Strike</color>: {pl.lastStrike}" + Environment.NewLine +
                                                    $"<color=#C4FF00>Active Strikes</color>: {pl.activeStrikes}" + Environment.NewLine +
                                                    $"<color=#C4FF00>Total Strikes</color>: {pl.strikes}");
                        }
                        else
                        {
                            IPlayer infoTarget = GetPlayer(args[1], player);

                            if (infoTarget == null)
                                return;

                            Player infoPl = Player.Get(infoTarget);

                            if (infoPl == null)
                            {
                                Players.Add(new Player(infoTarget));
                                SaveData(ref Players);

                                infoPl = Player.Get(infoTarget);
                            }

                            player.Reply($"<color=#C4FF00>Last Strike</color>: {infoPl.lastStrike}" + Environment.NewLine +
                                                    $"<color=#C4FF00>Active Strikes</color>: {infoPl.activeStrikes}" + Environment.NewLine +
                                                    $"<color=#C4FF00>Total Strikes</color>: {infoPl.strikes}");
                        }
                    }
                    break;

                case "wipe":
                    if (!HasPerm(player.Id, "admin"))
                        return;

                    if (args.Length != 1 && args.Length != 2)
                    {
                        player.Reply("Syntax: /strike wipe [only Active Strikes: true/false]");
                        return;
                    }

                    bool wipeOnlyActive = true;

                    if (args.Length == 2)
                    {
                        try
                        {
                            wipeOnlyActive = Convert.ToBoolean(args[1]);
                        }
                        catch (FormatException)
                        {
                            player.Reply(GetMsg("True Or False", player.Id));
                            return;
                        }
                    }

                    foreach (Player pl in Players)
                    {
                        pl.activeStrikes = 0;
                        
                        if(!wipeOnlyActive)
                        {
                            pl.strikes = 0;
                            pl.lastStrike = "not striked yet";
                        }
                    }

                    SaveData(ref Players);

                    player.Reply(GetMsg("Wiped", player.Id));
                    break;

                case "wipefull":
                    if (!HasPerm(player.Id, "admin"))
                        return;

                    Players.Clear();
                    SaveData(ref Players);

                    player.Reply(GetMsg("Fully Wiped", player.Id));
                    break;

                default:
                    if (!HasPerm(player.Id, "admin"))
                        return;

                    IPlayer strikePlayer = GetPlayer(args[0], player);

                    if (strikePlayer == null)
                        return;

                    StrikePlayer(strikePlayer, args.Length == 2 ? args[1] : "none");
                    break;
            }
        }

        #endregion

        #region Subject Related

        void StrikePlayer(IPlayer player, string reason = "none")
        {
            Player pl = Player.Get(player);

            if (pl == null)
            {
                Players.Add(new Player(player));
                SaveData(ref Players);

                pl = Player.Get(player);
            }

            pl.strikes++;
            pl.activeStrikes++;
            pl.lastStrike = DateTime.Now.ToString();
            
            pl.Update(player);

            server.Broadcast(GetMsg("Striked", player.Id).Replace("{player}", player.Name).Replace("{reason}", reason));

            if (ReachedMaxStrikes(player))
                BanPlayer(player, reason);
        }

        bool ReachedMaxStrikes(IPlayer player)
        {
            Player pl = Player.Get(player);
            int maxStrikes = GetConfig(3, "Settings", "Strikes Until Ban");

            if (pl == null)
                return false;
            else
                return (pl.activeStrikes >= maxStrikes);
        }

        
        void BanPlayer(IPlayer player, string reason = "none")
        {
            if (EBS == null)
            {
                PrintError($"Failed to ban player {player.Name} ! EnhancedBanSystem was not found! It is needed for this plugin to work!");
                return;
            }

            int banTime = GetConfig(3, "Settings", "Ban Time in Seconds");

            EBS.Call("Ban", player, player.Id, GetMsg("Can Not Join", player.Id).Replace("{reason}", reason), banTime);

            server.Broadcast(GetMsg("Banned", player.Id).Replace("{player}", player.Name).Replace("{reason}", reason));
        }

        #endregion

        #region General Methods

        ////////////////////////////////////////
        ///     Player Finding
        ////////////////////////////////////////

        IPlayer GetPlayer(string searchedPlayer, IPlayer player)
        {
            foreach (IPlayer current in players.Connected)
                if (current.Name.ToLower() == searchedPlayer.ToLower())
                    return current;

            List<IPlayer> foundPlayers =
                (from current in players.Connected
                 where current.Name.ToLower().Contains(searchedPlayer.ToLower())
                 select current).ToList();

            switch (foundPlayers.Count)
            {
                case 0:
                    player.Reply("The player can not be found.");
                    break;

                case 1:
                    return foundPlayers[0];

                default:
                    List<string> playerNames = (from current in foundPlayers select current.Name).ToList();
                    string players = ListToString(playerNames, 0, ", ");
                    player.Reply("Multiple matching players found: \n" + players);
                    break;
            }

            return null;
        }

        ////////////////////////////////////////
        ///     Converting
        ////////////////////////////////////////

        string ListToString<T>(List<T> list, int first, string seperator) => string.Join(seperator, (from item in list select item.ToString()).Skip(first).ToArray());

        ////////////////////////////////////////
        ///     Config Related
        ////////////////////////////////////////

        void SetConfig(params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList();
            stringArgs.RemoveAt(args.Length - 1);

            if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args);
        }

        T GetConfig<T>(T defaultVal, params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList();
            if (Config.Get(stringArgs.ToArray()) == null)
            {
                PrintError($"The plugin failed to read something from the config: {ListToString(stringArgs, 0, "/")}{Environment.NewLine}Please reload the plugin and see if this message is still showing. If so, please post this into the support thread of this plugin.");
                return defaultVal;
            }

            return (T)Convert.ChangeType(Config.Get(stringArgs.ToArray()), typeof(T));
        }

        ////////////////////////////////////////
        ///     Data Related
        ////////////////////////////////////////

        void LoadData<T>(ref T data, string filename = "?") => data = Core.Interface.Oxide.DataFileSystem.ReadObject<T>(filename == "?" ? this.Title : filename);

        void SaveData<T>(ref T data, string filename = "?") => Core.Interface.Oxide.DataFileSystem.WriteObject(filename == "?" ? this.Title : filename, data);

        ////////////////////////////////////////
        ///     Message Related
        ////////////////////////////////////////

        string GetMsg(string key, object userID = null) => lang.GetMessage(key, this, userID == null ? null : userID.ToString());

        ////////////////////////////////////////
        ///     Permission Related
        ////////////////////////////////////////

        void RegisterPerm(params string[] permArray)
        {
            string perm = ListToString(permArray.ToList(), 0, ".");

            permission.RegisterPermission($"{PermissionPrefix}.{perm}", this);
        }

        bool HasPerm(object uid, params string[] permArray)
        {
            string perm = ListToString(permArray.ToList(), 0, ".");

            return permission.UserHasPermission(uid.ToString(), $"{PermissionPrefix}.{perm}");
        }

        string PermissionPrefix
        {
            get
            {
                return this.Title.Replace(" ", "").ToLower();
            }
        }

        #endregion
    }
}

// --- End of file: StrikeSystem.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/sleep ---
// --- Original File Path: S/Sleep/Sleep.cs ---

using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Sleep", "Wulf/lukespragg", "0.2.0", ResourceId = 1156)]
    [Description("Allows players with permission to get a well-rested sleep")]
    public class Sleep : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Cure while sleeping (true/false)")]
            public bool CureWhileSleeping;

            [JsonProperty(PropertyName = "Heal while sleeping (true/false)")]
            public bool HealWhileSleeping;

            [JsonProperty(PropertyName = "Restore while sleeping (true/false)")]
            public bool RestoreWhileSleeping;

            [JsonProperty(PropertyName = "Curing rate (0 - 100)")]
            public int CuringRate;

            [JsonProperty(PropertyName = "Healing rate (0 - 100)")]
            public int HealingRate;

            [JsonProperty(PropertyName = "Restoration rate (0 - 100)")]
            public int RestorationRate;

            public static Configuration DefaultConfig()
            {
                return new Configuration
                {
                    CureWhileSleeping = false,
                    HealWhileSleeping = true,
                    RestoreWhileSleeping = true,
                    CuringRate = 5,
                    HealingRate = 5,
                    RestorationRate = 5
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config?.HealWhileSleeping == null) SaveConfig();
            }
            catch
            {
                LogWarning($"Could not read oxide/config/{Name}.json, creating new config file");
            }
            LoadDefaultConfig();
        }

        protected override void LoadDefaultConfig() => config = Configuration.DefaultConfig();

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Localization

        private new void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Command"] = "sleep",
                ["Dirty"] = "You seem to be a bit dirty, go take a dip!",
                ["Hungry"] = "You seem to be a bit hungry, eat something",
                ["NotAllowed"] = "You can't go to sleep right now",
                ["Restored"] = "You have awaken restored and rested!",
                ["Thirsty"] = "You seem to be a bit thirsty, drink something!"
            }, this);
        }

        #endregion

        #region Initialization

        private readonly Dictionary<string, Timer> sleepTimers = new Dictionary<string, Timer>();
        private const string permAllow = "sleep.allow";

        private void Init()
        {
            AddCommandAliases("Command", "SleepCommand");

            permission.RegisterPermission(permAllow, this);
        }

        #endregion

        #region Restoration

        private void Restore(BasePlayer player)
        {
            var bleeding = player.metabolism.bleeding.value;
            var calories = player.metabolism.calories.value;
            var comfort = player.metabolism.comfort.value;
            var heartRate = player.metabolism.heartrate.value;
            var poison = player.metabolism.poison.value;
            var radLevel = player.metabolism.radiation_level.value;
            var radPoison = player.metabolism.radiation_poison.value;
            var temperature = player.metabolism.temperature.value;

            if (config.CureWhileSleeping)
            {
                if (poison > 0) poison = poison - (poison / config.CuringRate);
                if (radLevel > 0) radLevel = radLevel - (radLevel / config.CuringRate);
                if (radPoison > 0) radPoison = radPoison - (radPoison / config.CuringRate);
            }

            if (config.HealWhileSleeping)
            {
                if (bleeding.Equals(1)) bleeding = 0;
                if (player.health < 100) player.health = player.health + (player.health / config.HealingRate);
            }

            if (config.RestoreWhileSleeping)
            {
                if (calories < 1000) calories = calories - (calories / config.RestorationRate);
                if (comfort < 0.5) comfort = comfort + (comfort / config.RestorationRate);
                if (heartRate > 0.5) heartRate = heartRate + (heartRate / config.RestorationRate);
                if (temperature < 20) temperature = temperature + (temperature / config.RestorationRate);
                else temperature = temperature - (temperature / config.RestorationRate);
            }
        }

        private void OnPlayerSleepEnded(BasePlayer basePlayer)
        {
            if (sleepTimers.ContainsKey(basePlayer.UserIDString)) sleepTimers[basePlayer.UserIDString].Destroy();

            var player = players.FindPlayerById(basePlayer.UserIDString);
            if (player == null) return;

            Message(player, "Restored");
            if (basePlayer.metabolism.calories.value < 40) Message(player, "YouAreHungry");
            if (basePlayer.metabolism.dirtyness.value > 0) Message(player, "YouAreDirty");
            if (basePlayer.metabolism.hydration.value < 40) Message(player, "YouAreThirsty");
        }

        #endregion

        #region Command

        private void SleepCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAllow))
            {
                Message(player, "NotAllowed");
                return;
            }

            var basePlayer = player.Object as BasePlayer;
            basePlayer?.StartSleeping();

            sleepTimers[player.Id] = timer.Every(10f, () =>
            {
                if (!player.IsSleeping)
                {
                    sleepTimers[player.Id].Destroy();
                    return;
                }

                Restore(basePlayer);
            });

            Message(player, "WentToSleep");
        }

        #endregion

        #region Helpers

        private void AddCommandAliases(string key, string command)
        {
            foreach (var language in lang.GetLanguages(this))
            {
                var messages = lang.GetMessages(language, this);
                foreach (var message in messages.Where(m => m.Key.StartsWith(key))) AddCovalenceCommand(message.Value, command);
            }
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private void Message(IPlayer player, string key, params object[] args) => player.Reply(Lang(key, player.Id, args));

        #endregion
    }
}

// --- End of file: Sleep.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/sleep-protection ---
// --- Original File Path: S/SleepProtection/SleepProtection.cs ---

using System;
using System.Diagnostics;
using Newtonsoft.Json;

namespace Oxide.Plugins;

[Info("Sleep Protection", "Notchu", "1.0.5")]
[Description("Protect players while sleeping")]
public class SleepProtection : CovalencePlugin
{

    private class Configuration
    {
        [JsonProperty("trigger animal on sleeping player")]
        public bool TriggerAnimalOnPlayer { get; set; } = false;
        
        [JsonProperty("trigger npc player on sleeping player")]
        public bool TriggerNpcOnPlayer { get; set; } = false;

        [JsonProperty("remove sleeping players from animal targeting")]
        public bool RemoveTargetFromAnimal { get; set; } = true;

        [JsonProperty("remove sleeping players from npc players targeting")]
        public bool RemoveTargetFromNpcPlayer { get; set; } = true;

        [JsonProperty("cancel damage to sleeping player")]
        public bool CancelDamageFromPlayersToSleepers { get; set; } = true;

        [JsonProperty("cancel looting of sleeping player")]
        public bool CancelLootingSleepers { get; set; } = true;
    }
    private Configuration _config;

    protected override void LoadConfig()
    {
        base.LoadConfig();
        try
        {
            _config = Config.ReadObject<Configuration>();
            if (_config == null) throw new Exception();
            SaveConfig();
        }
        catch
        {
            PrintError("Your configuration file contains an error. Using default configuration values.");
            LoadDefaultConfig();
        }
    }

    protected override void SaveConfig() => Config.WriteObject(_config);

    protected override void LoadDefaultConfig() => _config = new Configuration();

    void Init()
    {
        permission.RegisterPermission("sleepprotection.use", this);
        permission.RegisterPermission("sleepprotection.ignore", this);
        if (!_config.CancelLootingSleepers)
        {
            Unsubscribe(nameof(CanLootPlayer));
        }

        if (!_config.RemoveTargetFromAnimal && !_config.CancelDamageFromPlayersToSleepers)
        {
            Unsubscribe(nameof(OnEntityTakeDamage));
        } 
    }
    
    object OnNpcTarget(BaseEntity npc, BasePlayer player)
    {
        if (!player.IsSleeping()) return null;
        
        switch (npc)
        {
            case HumanNPC humanNpc:
                
                if (_config.TriggerNpcOnPlayer && !_config.RemoveTargetFromNpcPlayer)
                    return null;

                if (!CheckPermission(player.UserIDString))
                    return null;
                
                if (_config.RemoveTargetFromNpcPlayer)
                    RemovePlayerFromTarget(humanNpc.Brain.Events, player);
      
                if (!_config.TriggerNpcOnPlayer)
                    return false;
         
                return null;

            case BaseAnimalNPC animalNpc:
                if (_config.TriggerAnimalOnPlayer && !_config.RemoveTargetFromAnimal)
                    return null;

                if (!CheckPermission(player.UserIDString))
                    return null;

                if (_config.RemoveTargetFromAnimal)
                    RemovePlayerFromTarget(animalNpc.brain.Events, player);

                if (!_config.TriggerAnimalOnPlayer)
                    return false;

                return null;
            default:
                return null;
        }
    }


    object OnEntityTakeDamage(BasePlayer player, HitInfo info)
    {
        if (!player.IsSleeping()) return null;

        switch (info.Initiator)
        {
            case BaseAnimalNPC animal:
                if (!CheckPermission(player.UserIDString)) return null;
                
                RemovePlayerFromTarget(animal.brain.Events, player);
                return false;
            case BasePlayer initiator:
                if (!_config.CancelDamageFromPlayersToSleepers || !CheckPermission(player.UserIDString)) return null;
                
                if (CheckPermission(initiator.UserIDString, "ignore"))
                    return null;

                return false;
            default:
                return null;
        }
    }
    
    object CanLootPlayer(BasePlayer target, BasePlayer looter)
    {
        if (target.IsSleeping() && CheckPermission(target.UserIDString) 
                                && !CheckPermission(looter.UserIDString, "ignore")) return false;
        
        return null;
    }
    
    void RemovePlayerFromTarget(AIEvents events, BasePlayer player)
    {
        for (int i = 0; i < 8; i++)
        {
            var entity = events.Memory.Entity.Get(i);
            if (entity != player) continue;
            events.Memory.Entity.Remove(i);
        }
    }
    bool CheckPermission(string playerId, string type = "use")
    {
        return permission.UserHasPermission(playerId, $"sleepprotection.{type}");
    }
}

// --- End of file: SleepProtection.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/scheduled-building ---
// --- Original File Path: S/ScheduledBuilding/ScheduledBuilding.cs ---

using System.Collections.Generic;
using System.Collections;
using Newtonsoft.Json;
using UnityEngine;
using Oxide.Core;
using System;

namespace Oxide.Plugins
{

	[Info("Scheduled Building", "5Dev24", "1.0.1")]
	[Description("Spawns prefabs on timers")]
	public class ScheduledBuilding : RustPlugin
	{

		private const string GetPositionPermission = "scheduledbuilding.getposition";
		private const string CreateNewPrefabPermission = "scheduledbuilding.createprefab";
		private Coroutine routine;
		private ConfigData data;

		#region Hooks

		private void Init()
		{
			this.permission.RegisterPermission(ScheduledBuilding.GetPositionPermission, this);
			this.permission.RegisterPermission(ScheduledBuilding.CreateNewPrefabPermission, this);
		}

		private void OnServerInitialized()
		{
			this.timer.Once(1f, this.StartRoutine);
		}

		private void Unload()
		{
			if (this.routine != null)
			{
				ServerMgr.Instance?.StopCoroutine(this.routine);

				foreach (ConfigData.PrefabData prefab in this.data.Prefabs)
					if (prefab.Name != null)
					{
						GameObject found = GameObject.Find(prefab.Name);
						if (found != null)
							GameObject.Destroy(found);
					}

				this.routine = null;
			}
		}

		#endregion

		#region Commands

		[ChatCommand("getposition")]
		private void GetPositionCommand(BasePlayer player, string cmd, string[] args)
		{
			if (!this.HasPermission(player, ScheduledBuilding.GetPositionPermission))
				SendReply(player, this.lang.GetMessage("No Permission", this, player.UserIDString));
			else
			{
				Vector3 position = player.transform.position;
				Quaternion rotation = player.eyes.rotation;
				SendReply(player, this.lang.GetMessage("Position Format", this, player.UserIDString)
					.Replace("{x1}", position.x.ToString()).Replace("{y1}", position.y.ToString())
					.Replace("{z1}", position.z.ToString()).Replace("{x2}", rotation.x.ToString())
					.Replace("{y2}", rotation.y.ToString()).Replace("{z2}", rotation.z.ToString())
					.Replace("{w2}", rotation.w.ToString())); // Nasty
			}
		}

		[ChatCommand("createprefab")]
		private void CreatePrefabCommand(BasePlayer player, string cmd, string[] args)
		{
			if (!this.HasPermission(player, ScheduledBuilding.CreateNewPrefabPermission))
				SendReply(player, this.lang.GetMessage("No Permission", this, player.UserIDString));
			else
			{
				Vector3 position = player.transform.position;
				Quaternion rotation = player.eyes.rotation;

				List<ConfigData.PrefabData> prefabsList = new List<ConfigData.PrefabData>(this.data.Prefabs);
				prefabsList.Add(new ConfigData.PrefabData
				{
					Location = position,
					Rotation = rotation
				});
				ConfigData.PrefabData[] prefabs = prefabsList.ToArray();
				prefabsList = null;

				Config.WriteObject(new ConfigData
				{
					Prefabs = prefabs
				}, true);

				SendReply(player, this.lang.GetMessage("Created Prefab", this, player.UserIDString)
					.Replace("{x}", position.x.ToString()).Replace("{y}", position.y.ToString())
					.Replace("{z}", position.y.ToString()));
			}
		}

		[ChatCommand("showprefabs")]
		private void ShowPrefabsCommand(BasePlayer player, string cmd, string[] args)
		{
			if (!player.IsAdmin)
				SendReply(player, this.lang.GetMessage("No Permission", this, player.UserIDString));
			else
			{
				foreach (ConfigData.PrefabData prefab in this.data.Prefabs)
					player.SendConsoleCommand("ddraw.sphere", 30, UnityEngine.Color.cyan, prefab.Location, 1f);

				SendReply(player, this.lang.GetMessage("Shown Prefabs", this, player.UserIDString));
			}
		}

		#endregion

		#region Routine

		private void StartRoutine()
		{
			if (this.routine == null)
				this.routine = ServerMgr.Instance?.StartCoroutine(Spawn());
		}

		private IEnumerator Spawn()
		{
			if (this.data == null || this.data.Prefabs == null || this.data.Prefabs.Length == 0)
				yield break;

			while (this.IsLoaded)
			{
				foreach (ConfigData.PrefabData prefab in this.data.Prefabs)
				{
					if (prefab.Prefab == null)
						continue;

					long now = Now();
					if (prefab.NextSpawnAt > now)
						continue;

					if (prefab.PreviousCheck && prefab.Name != null)
					{
						GameObject foundObject = GameObject.Find(prefab.Name);
						if (foundObject != null)
							continue;
					}

					object hook = Interface.CallHook("CanSpawnScheduledPrefab", prefab.Location, prefab.Rotation, prefab.Prefab, prefab.Interval, prefab.PreviousCheck, prefab.ShouldSave);
					if (hook is bool && !((bool) hook))
						continue;

					GameObject obj = GameManager.server.CreatePrefab(prefab.Prefab, prefab.Location, prefab.Rotation);
					if (obj == null)
					{
						yield return new WaitForEndOfFrame();
						continue;
					}

					string name = $"{obj.GetInstanceID()}-prefab";
					prefab.Name = name;
					obj.name = name;

					BaseEntity entity = obj.GetComponent<BaseEntity>();

					if (entity != null)
					{
						entity.EnableSaving(prefab.ShouldSave);
						entity.Spawn();
						entity.UpdateNetworkGroup();
						entity.SendNetworkUpdateImmediate(true);
					}

					Interface.CallHook("SpawnedScheduledPrefab", obj, entity);
	
					prefab.NextSpawnAt = now + prefab.Interval;
					yield return new WaitForEndOfFrame();
				}

				yield return new WaitForSeconds(0.25f);
			}
		}

		#endregion

		#region Configuration

		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				{"No Permission", "You don't have permission to use this command"},
				{"Position Format", "You're at {x1} {y1} {z1} looking {x2} {y2} {z2} {w2}"},
				{"Created Prefab", "Added new, empty prefab to config at {x} {y} {z}"},
				{"Shown Prefabs", "All prefabs are now shown around the map for the next 30 seconds"}
			}, this, "en");

			lang.RegisterMessages(new Dictionary<string, string>
			{
				{"No Permission", "Vous n'tes pas authoris  utiliser cette commande"},
				{"Position Format", "Vous tes  {x1} {y1} {z1} en regardant {x2} {y2} {z2} {w2}"},
				{"Created Prefab", "Ajout d'un nouveau prfabriqu vide  la configuration  {x} {y} {z}"},
				{"Shown Prefabs", "Tous les prfabriqus sont maintenant affichs sur la carte pendant les 30 prochaines seconds"}
			}, this, "fr");
		}

		protected override void LoadConfig()
		{
			base.LoadConfig();
			this.data = Config.ReadObject<ConfigData>();
		}

		protected override void LoadDefaultConfig()
		{
			ConfigData cfg = new ConfigData();
			Config.WriteObject(cfg, true);
			this.data = cfg;
		}

		internal class ConfigData
		{
			internal class PrefabData
			{
				[JsonConverter(typeof(Converter))]
				public Vector3 Location = Vector3.zero;

				[JsonConverter(typeof(Converter))]
				public Quaternion Rotation = Quaternion.identity;

				public string Prefab = null;

				[JsonProperty("Spawn rate (in seconds)")]
				public uint Interval = 3600;

				[JsonProperty("Check for previous")]
				public bool PreviousCheck = true;

				[JsonProperty("Should save")]
				public bool ShouldSave = false;

				[JsonIgnore]
				public long NextSpawnAt = -1;

				[JsonIgnore]
				public string Name = null;
			}

			public PrefabData[] Prefabs = new PrefabData[0];

			public string Version = "1.0.0";
		}

		#endregion

		#region Converters

		private class Converter : JsonConverter
		{
			public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
			{
				if (reader.TokenType != JsonToken.String)
					return null;

				if (objectType == typeof(Vector3))
				{
					string[] splits = reader.Value.ToString().Split(' ');
					float[] xyz = new float[3];
					for (int i = 0; i < 3; i++)
						if (!float.TryParse(splits[i], out xyz[i]))
							return Vector3.zero;

					return new Vector3(xyz[0], xyz[1], xyz[2]);
				}
				else if (objectType == typeof(Quaternion))
				{
					string[] splits = reader.Value.ToString().Split(' ');
					float[] xyzw = new float[4];
					for (int i = 0; i < 4; i++)
						if (!float.TryParse(splits[i], out xyzw[i]))
							return Quaternion.identity;

					return new Quaternion(xyzw[0], xyzw[1], xyzw[2], xyzw[3]);
				}

				return null;
			}

			public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
			{
				if (value is Vector3)
				{
					Vector3 vector = (Vector3) value;
					writer.WriteValue($"{vector.x} {vector.y} {vector.z}");
				}
				else if (value is Quaternion)
				{
					Quaternion rotation = (Quaternion) value;
					writer.WriteValue($"{rotation.x} {rotation.y} {rotation.z} {rotation.w}");
				}
			}

			public override bool CanConvert(Type objectType) =>
				objectType == typeof(Vector3) || objectType == typeof(Quaternion);
		}

		#endregion

		#region Helpers

		private long Now() => DateTimeOffset.Now.ToUnixTimeSeconds();

		private bool HasPermission(BasePlayer player, string permission) =>
			player.IsAdmin || this.permission.UserHasPermission(player.UserIDString, permission);

		#endregion

	}
}

// --- End of file: ScheduledBuilding.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/skin-shop ---
// --- Original File Path: S/SkinShop/SkinShop.cs ---

// Requires: MemoryCache

using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using JetBrains.Annotations;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Random = System.Random;

namespace Oxide.Plugins
{
    [Info("Skin Shop", "Rustoholics", "0.5.2")]
    [Description("A GUI skin shop to allow players to buy custom skins")]
    
    public class SkinShop : CovalencePlugin
    {
        #region  Dependencies

        [PluginReference]
        private MemoryCache MemoryCache;

        [PluginReference] private Plugin ImageLibrary, Economics, ServerRewards;
        
        #endregion

        #region Variables
        private string _downloadJsonUrl = "https://www.dropbox.com/s/vyrq104kzxxomo1/database.json?dl=1";
        
        private Dictionary<string, WorkshopResult> _cache = new Dictionary<string, WorkshopResult>();

        private Dictionary<string, GuiHelper> _skinGui = new Dictionary<string, GuiHelper>();
        
        private Dictionary<string, List<WorkShopItem>> _ownedItems = new Dictionary<string, List<WorkShopItem>>();

        private Dictionary<string, WorkShopItem> _skinDatabase = new Dictionary<string, WorkShopItem>();

        private List<string> _needsWriting = new List<string>();

        private const string welcomePackPermission = "skinshop.welcomepack";
        private const string adminPermission = "skinshop.admin";
        private const string blacklistPermission = "skinshop.blacklist";
        private const string useSkinshopPermission = "skinshop.use";
        private const string vipPermissions = "skinshop.vip";

        private bool _categoryIconsLoaded = false;

        /* DO NOT EDIT THIS LIST, if you want to change the category menu display, then edit the language file instead */
        private static SortedDictionary<string, string> _categories = new SortedDictionary<string, string>
        {
            {"Bandana","mask.bandana"},
            {"Balaclava","mask.balaclava"},
            {"Beenie Hat","hat.beenie"},
            {"Burlap Shoes","burlap.shoes"},
            {"Burlap Shirt","burlap.shirt"},
            {"Burlap Pants","burlap.trousers"},
            {"Burlap Headwrap","burlap.headwrap"},
            {"Bucket Helmet","bucket.helmet"},
            {"Boonie Hat","hat.boonie"},
            {"Cap","hat.cap"},
            {"Collared Shirt","shirt.collared"},
            {"Coffee Can Helmet","coffeecan.helmet"},
            {"Deer Skull Mask","deer.skull.mask"},
            {"Hide Skirt","attire.hide.skirt"},
            {"Hide Shirt","attire.hide.vest"},
            {"Hide Pants","attire.hide.pants"},
            {"Hide Shoes","attire.hide.boots"},
            {"Hide Halterneck","attire.hide.helterneck"},
            {"Hoodie","hoodie"},
            {"Hide Poncho","attire.hide.poncho"},
            {"Leather Gloves","burlap.gloves"},
            {"Long TShirt","tshirt.long"},
            {"Metal Chest Plate","metal.plate.torso"},
            {"Metal Facemask","metal.facemask"},
            {"Miner Hat","hat.miner"},
            {"Pants","pants"},
            {"Roadsign Vest","roadsign.jacket"},
            {"Roadsign Pants","roadsign.kilt"},
            {"Riot Helmet","riot.helmet"},
            {"Snow Jacket","jacket.snow"},
            {"Shorts","pants.shorts"},
            {"Tank Top","shirt.tanktop"},
            {"TShirt","tshirt"},
            {"Vagabond Jacket","jacket"},
            {"Work Boots","shoes.boots"},
            {"AK47","rifle.ak"},
            {"Bolt Rifle","rifle.bolt"},
            {"Bone Club","bone.club"},
            {"Bone Knife","knife.bone"},
            {"Crossbow","crossbow"},
            {"Hunting Bow","bow.hunting"},
            {"Double Barrel Shotgun","shotgun.double"},
            {"Eoka Pistol","pistol.eoka"},
            {"F1 Grenade","grenade.f1"},
            {"Longsword","longsword"},
            {"Mp5","smg.mp5"},
            {"Pump Shotgun","shotgun.pump"},
            {"Rock","rock"},
            {"Salvaged Hammer","hammer.salvaged"},
            {"Salvaged Icepick","icepick.salvaged"},
            {"Satchel Charge","explosive.satchel"},
            {"Semi-Automatic Pistol","pistol.semiauto"},
            {"Stone Hatchet","stonehatchet"},
            {"Stone Pick Axe","stone.pickaxe"},
            {"Sword","salvaged.sword"},
            {"Thompson","smg.thompson"},
            {"Hammer","hammer"},
            {"Hatchet","hatchet"},
            {"Pick Axe","pickaxe"},
            {"Revolver","pistol.revolver"},
            {"Rocket Launcher","rocket.launcher"},
            {"Semi-Automatic Rifle","rifle.semiauto"},
            {"Waterpipe Shotgun","shotgun.waterpipe"},
            {"Custom SMG","smg.2"},
            {"Python","pistol.python"},
            {"LR300","rifle.lr300"},
            {"Combat Knife","knife.combat"},
            {"Armored Door","door.hinged.toptier"},
            {"Concrete Barricade","barricade.concrete"},
            {"Large Wood Box","box.wooden.large"},
            {"Reactive Target","target.reactive"},
            {"Sandbag Barricade","barricade.sandbags"},
            {"Sleeping Bag","sleepingbag"},
            {"Sheet Metal Door","door.hinged.metal"},
            {"Water Purifier","water.purifier"},
            {"Wood Storage Box","box.wooden"},
            {"Wooden Door","door.hinged.wood"},
            {"Acoustic Guitar","fun.guitar"},
            {"Rug","rug"},
            {"Bearskin Rug","rug.bear"},
            {"Sheet Metal Double Door","door.double.hinged.metal"},
            {"Wooden Double Door","door.double.hinged.wood"},
            {"Armored Double Door","door.double.hinged.toptier"},
            {"Garage Door","wall.frame.garagedoor"},
            {"L96","rifle.l96"},
            {"M249","lmg.m249"},
            {"M39","rifle.m39"},
            {"Table","table"},
            {"Chair","chair"},
            {"Locker","locker"},
            {"Furnace","furnace"},
            {"Vending Machine", "vending.machine"}
        };

        #endregion
        
        #region Config
        private Configuration _config;
        protected override void SaveConfig() => Config.WriteObject(_config);
        protected override void LoadDefaultConfig() => _config = new Configuration();

        private class Configuration
        {
            [JsonProperty(PropertyName = "LogLevel (debug | info | none)")]
            public string LogLevel = "info";

            public bool SkinsPacksEnabled = true;

            public Dictionary<int, SkinPack> SkinPacks = new Dictionary<int, SkinPack>
            {
                {
                    0, new SkinPack
                    {
                        SkinId = 2631235609,
                        NumberOfSkins = 3,
                        ImageUrl =
                            "https://steamuserimages-a.akamaihd.net/ugc/1765966378913384293/506A7A4ADA3C8C6B9729700BB21E0AB6F156E9B4/",
                        PackName = "Bronze Skin Pack",
                        Price = 1000
                    }
                },
                {
                    1, new SkinPack
                    {
                        SkinId = 2631961805,
                        NumberOfSkins = 6,
                        ImageUrl =
                            "https://steamuserimages-a.akamaihd.net/ugc/1765966378917593382/7E8B5C1F34440329A4C993B6E751609A148045B3/",
                        PackName = "Gold Skin Pack",
                        Price = 1500
                    }
                }
            };

            [JsonProperty(PropertyName =
                "Give Welcome Skin Pack index to new players ([0,0] would give 2 of the first packs, empty [] for disable)")]
            public int[] GiveWelcomePacks = new int[] {0};

            public bool EnabledCategoryIcons = true;

            public ulong[] BlackListedSkins = {0};

            public string[] HideCategories = { };

            public double DefaultSkinPrice = 1000;

            public double[] VipDiscounts = {10d, 20d};

            public double DefaultInstantPricePrice = 50;
            
            [JsonProperty(PropertyName = "Show the category selection page as the shop landing page")]
            public bool ShowCategorySelectLanding = true;
            [JsonProperty(PropertyName = "Default category to show (if category selection landing page is false)")]
            public string DefaultCategory = "AK47";

            [JsonProperty(PropertyName = "Currency Plugin (can be 'Economics' or 'ServerRewards')")]
            public string CurrencyPlugin = "Economics";
            
            public ulong[] HumanNpcIds = {0};

            [JsonProperty(PropertyName = "Convert all Wrapped Gifts to Skin Pack")]
            public bool ConvertGiftsToPacks = false;

            public bool AutomaticallyRemoveMissingImages = true;

            public string SkinPackImageUrl = "https://rustoholics.com/img/skinpackopen4.png";

            public string SearchIconUrl = "https://www.iconsdb.com/icons/preview/white/search-3-xxl.png";
            public string BlacklistIconUrl = "https://www.iconsdb.com/icons/preview/white/trash-2-xxl.png";

            public string DiscordApiKey = "";

            public string DiscordChannelId = "";
            
            public Dictionary<string, string> Color = new Dictionary<string, string>
            {
                {"Red", "0.85 0.33 0.25"},
                {"Green","0.42 0.55 0.22"},
                {"Yellow","0.82 0.53 0.13"},
                {"Blue", "0.22 0.35 0.55"},
                {"Grey","0.2 0.2 0.2"},
                {"White","1.0 1.0 1.0"}
            };

            public bool LoadSkinsFromDatabase = true;
            public bool EnableCaching = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();

                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }
        #endregion
        
        #region Language
        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        
        protected override void LoadDefaultMessages()
        {
            var phrases = new Dictionary<string, string>
            {
                ["DiscordOpenPackMessage"] = ":gift: ({0:HH:mm}) **{1}** has opened a {2}",
                ["GuiCloseButton"] = "(X) Close",
                ["GuiTitleOpenSkinPack"] = "Open Skin Pack",
                ["GuiButtonViewAllMySkins"] = "View All My Skins",
                ["WithdrawCoinsFailed"] = "We could not collect enough coins to buy this item",
                ["NotEnoughCoinsToBuy"] = "You need {0} to buy this item!",
                ["NoRoomInInventory"] = "You do not have any room in your inventory to buy this pack",
                ["GuiButtonSkinEquipped"] = " Equipped",
                ["GuiButtonSkinUnequipped"] = "Unequipped",
                ["GuiButtonBuyNow"] = "Buy Now: {0} coins",
                ["GuiButtonBuyNowShort"] = "Buy Now: {0}",
                ["GuiTitleSkinShop"] = "Skin Shop",
                ["GuiButtonSelectCategory"] = "Select Category",
                ["GuiButtonSkinPacks"] = "Skin Packs",
                ["GuiButtonMySkins"] = "My Skins",
                ["CommandDatabaseBuilding"] = "Starting database building, but it could take a while",
                ["AccessDenied"] = "Access Denied",
                ["InstantSellDescription"] = "You can sell  this \n skin instantly for {0} coins",
                ["InvalidPlayer"] = "Invalid Player",
                ["ItemNotFound"] = "Item Not Found",
                ["ItemSold"] = "Skin has been sold for {0} coins",
                ["PluginNotInstalled"] = "The {0} plugin is not installed",
                ["SavingDataMessage"] = "Saving Skin Data: {0} players",
                ["ButtonSell"] = "Sell",
                ["ButtonSellNow"] = "Sell Now",
                ["SkinDatabaseLoaded"] = "Skin database loaded with {0} skins",
                ["FilesNotFound"] = "Files not found (probably directory not created yet",
                ["UserIDMatchNotFound"] = "No UID match found in filename",
                ["SkinsLoadedForUser"] = "Loading skins for user {0}",
                ["DownloadFailed"] = "Download of JSON database failed: {0}",
                ["DownloadEmpty"] = "Downloaded Database JSON was empty",
                ["MissingImage"] = "There was a missing image {0}",
                ["ItemDeleted"] = "Item {0} has been deleted from the skin database",
                ["IconsLoaded"] = "{0} category icons loaded",
                ["DatabaseBuildCompleted"] = "Database build has been completed",
                ["DatabaseCategoryCompleted"] = "{0} single category build has been completed!",
                ["DatabasePageDone"] = "{0} ({1}): Page {2}",
                ["DatabaseCategoryPageDone"] = "{0}: Page {1}",
                ["InstantSell"] = "Instant Sell",
                ["ButtonApply"] = "Apply",
                ["ItemNoSkin"] = "This {0} does not have a custom skin",
                ["NotLookingAtItem"] = "You are not looking at any item",
                ["SkinIdIs"] = "This skin ID for this {0} is {1}",
                ["SkinBlackListed"] = "Skin for {0} has been blacklisted",
                ["MustLookAtCustomSkin"] = "You must look at an item with a custom skin",
                ["InvalidSkinId"] = "Invalid Skin ID"
            };
            foreach (var cat in _categories)
            {
                phrases[cat.Value] = cat.Key;
            }
            lang.RegisterMessages(phrases, this);
        }
        
        #endregion
        
        #region Objects

        public class GuiOptions
        {
            public bool ShowCategories = false;
            public bool ShowSkinPacks = false;
            public string ShowSkinProfile = "";
        }
        
        public class SkinPack
        {
            public ulong SkinId;
            public string ImageUrl;
            public int NumberOfSkins = 3;
            public string PackName = "Skin Pack";
            public double Price = 1000;
            public ulong[] PossibleSkinIds = Array.Empty<ulong>();
            public string[] PossibleSkinCategories = Array.Empty<string>();
        }

        public class WorkshopResult
        {
            private List<WorkShopItem> Items = new List<WorkShopItem>();

            public int Page = 1;
            public int TotalResults;
            public int TotalPages => (int) Math.Ceiling(TotalResults / Convert.ToDouble(PerPage));
            public int PerPage = 18;
            public List<string> Categories = new List<string>();
            public string Search = "";
            public string OwnerId = "";
            
            public string Url { get { return GetUrl();} }

            public List<WorkShopItem> GetItems()
            {
                return Items;
            }

            public void RemoveOwner()
            {
                OwnerId = "";
            }

            public void AddItem(WorkShopItem item)
            {
                Items.Add(item);
            }

            public string GetUrl()
            {
                var url = "https://steamcommunity.com/workshop/browse/?appid=252490";
                foreach (var c in Categories)
                {
                    url += "&requiredtags[]="+(Uri.EscapeDataString(c));
                }

                if (!string.IsNullOrEmpty(Search))
                {
                    url += "&searchtext=" + (Uri.EscapeDataString(Search));
                }
                url += "&p="+Convert.ToString(Page)+"&numperpage=" + Convert.ToString(PerPage);
                return url;
            }

            public void LoadOwned(Dictionary<string, List<WorkShopItem>> allOwned)
            {
                if (OwnerId == "" || !allOwned.ContainsKey(OwnerId)) return;

                var query = allOwned[OwnerId].Where(i => i.Title.IndexOf(Search, 0, StringComparison.CurrentCultureIgnoreCase) >= 0 || i.Shortname.IndexOf(Search, 0, StringComparison.CurrentCultureIgnoreCase) >= 0);
                
                Items = new List<WorkShopItem>();
                foreach (var i in query.OrderBy(i => i.Shortname).Skip((Page-1) * PerPage).Take(PerPage))
                {
                    Items.Add(i);
                }
                TotalResults = allOwned[OwnerId].Count;
            }

            public void LoadOwned(Dictionary<string, List<WorkShopItem>> allOwned, string itemId)
            {
                if (OwnerId == "" || !allOwned.ContainsKey(OwnerId)) return;

                foreach (var i in allOwned[OwnerId])
                {
                    if (i.Id == itemId)
                    {
                        Items.Add(i);
                        TotalResults = 1;
                        return;
                    }
                }
            }

            public string Escape()
            {
                return Uri.EscapeDataString(JsonConvert.SerializeObject(this));
            }
        }
        
        public class WorkShopItem
        {
            public string Title;
            public string Description;
            public string Image;
            public string Id;
            public double Price;
            public string Category;
            public bool Wrapped = true;
            public bool Equipped = false;
            public string Shortname => _categories[Category];

            public double GetPrice(double defaultPrice, double discount)
            {
                var p = Price;
                if (p <= 0)
                {
                    p = defaultPrice;
                }
                
                return p * ((100-discount) / 100);
            }

            public double GetInstantSellPrice(double defaultPrice)
            {
                return defaultPrice;
            }

            public string Escape()
            {
                return Uri.EscapeDataString(JsonConvert.SerializeObject(this));
            }
                
        }
        
        

        
        #endregion
        
        #region Hooks

        private bool? CanStackItem(Item original, Item target)
        {
            if (IsSkinPack(original) || IsSkinPack(target))
            {
                return false;
            }
            return null;
        }
        
        ItemContainer.CanAcceptResult? CanAcceptItem(ItemContainer container, Item item, int targetPos)
        {
            if (IsSkinPack(container.parent)) return ItemContainer.CanAcceptResult.CannotAccept;
            
            return null;
        }

        private void OnServerInitialized()
        { 
            if (ImageLibrary == null || !ImageLibrary.IsLoaded)
            {
                LogError("ImageLibrary Plugin is required, get it at https://umod.org");
            }
            if (!HasEconomicsPlugin())
            {
                LogError("Economics or ServerRewards Plugin is required, get it at https://umod.org");
            }

            for (var x = 0; x < _config.VipDiscounts.Length; x++)
            {
                permission.RegisterPermission(vipPermissions+(x+1).ToString(), this);
            }
            
            if (ImageLibrary == null || !ImageLibrary.IsLoaded) return;
            
            if (!ImageLibrary.Call<bool>("HasImage", _config.SearchIconUrl, (ulong) 0))
            {
                ImageLibrary.Call<bool>("AddImage", _config.SearchIconUrl,
                    _config.SearchIconUrl, (ulong) 0);
                
                ImageLibrary.Call<bool>("AddImage", _config.BlacklistIconUrl,
                    _config.BlacklistIconUrl, (ulong) 0);
                
            }
            
            if (!ImageLibrary.Call<bool>("HasImage", _config.SkinPackImageUrl, (ulong) 0))
            {
                ImageLibrary.Call<bool>("AddImage", _config.SkinPackImageUrl,
                    _config.SkinPackImageUrl, (ulong) 0);
            }
            
            LoadData();

            LoadDatabase();

            LoadIconImages();


        }
        
        private void OnItemCraftFinished(ItemCraftTask task, Item item)
        {
            if (task == null || task.owner == null || !task.owner.userID.IsSteamId()) return;

            SetSkin(task.owner, item);
        }
        
        private void OnItemPickup(Item item, BasePlayer player)
        {
            if (item != null && player != null)
            {
                SetupSkinPack(item);
                SetSkin(player, item);
            }
        }
        
        void OnPlayerConnected(BasePlayer player)
        {
            if (!_config.SkinsPacksEnabled || _config.GiveWelcomePacks.Length <= 0) return;
            
            if (!permission.UserHasPermission(player.UserIDString, welcomePackPermission))
            {
                permission.GrantUserPermission(player.UserIDString, welcomePackPermission, this);
                foreach (var packId in _config.GiveWelcomePacks)
                {
                    GiveSkinPack(player, _config.SkinPacks[packId]);
                }
            }
        }
        
        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            SetupSkinPack(item);
            if (container.playerOwner && item != null)
            {
                SetSkin(container.playerOwner, item);
            }
        }
        
        private void OnServerSave() => timer.Once(UnityEngine.Random.Range(0f, 60f), SaveData);
        
        
        
        void Unload()
        {
            foreach (var gui in _skinGui)
            {
                var player = BasePlayer.FindByID(Convert.ToUInt64(gui.Key));
                if (player == null || !player.IsConnected) return;
                gui.Value.Close();
            }
            _skinGui.Clear();
            
            SaveData();
            SaveSkinDatabase();
        }
        
        object OnItemAction(Item item, string action, BasePlayer player)
        {
            if (IsSkinPack(item) && action == "open")
            {
                item.Remove();
                var items = OpenPack(player, GetSkinPack(item));  
                ShowPacksGui(player, items);
                return true;
            }
            return null;
        }

        #endregion

        #region Skins GUI

        void CloseSkinGui(BasePlayer player)
        {
            if (player == null || !_skinGui.ContainsKey(player.UserIDString)) return;

            var x = _skinGui[player.UserIDString].Close();
            Puts("Destroyed " + x + " elements");
            _skinGui.Remove(player.UserIDString);
        }

        void PrepareShowSkinGui(BasePlayer player, WorkshopResult workshop, GuiOptions options = null)
        {
            if (options == null) options = new GuiOptions();

            if (workshop.OwnerId != "")
            {
                if (options.ShowSkinProfile != "")
                {
                    workshop.LoadOwned(_ownedItems, options.ShowSkinProfile);
                }
                else
                {
                    workshop.LoadOwned(_ownedItems);
                }
                ShowSkinGui(player, workshop, options);

                return;
            }

            if (options.ShowCategories || options.ShowSkinPacks)
            {
                ShowSkinGui(player, workshop, options);
                return;
            }

            if (workshop.Categories.Count == 0 && workshop.OwnerId == "") workshop.Categories = new List<string> {_config.DefaultCategory};
            
            // Loading from database instead of from crawling steam workshop URL (much faster)
            if (_config.LoadSkinsFromDatabase)
            {
                var result = _skinDatabase.AsEnumerable();
                result = result.Where(x => workshop.Categories.Contains(x.Value.Category));
                result = result.Where(x => !_config.BlackListedSkins.Contains(Convert.ToUInt64(x.Key)));

                if (!string.IsNullOrEmpty(workshop.Search))
                {
                    result = result.Where(x =>
                        x.Value.Title.ToLower().Contains(workshop.Search.ToLower()) ||
                        x.Value.Description.ToLower().Contains(workshop.Search.ToLower()));
                }
                
                result = result.OrderByDescending(x => Convert.ToUInt64(x.Value.Id));
                
                workshop.TotalResults = result.Count();
                foreach (var r in result.Skip(Math.Max(0,workshop.Page-1) * workshop.PerPage).Take(workshop.PerPage))
                {
                    workshop.AddItem(r.Value);
                }

                ShowSkinGui(player, workshop, options);
                return;
            }

            var cacheKey = Hash(workshop.Url);
            var cache = MemoryCache.Get<WorkshopResult>(cacheKey);
            if (_config.EnableCaching && cache != null)
            {
                workshop = cache;
                ShowSkinGui(player, workshop, options);
                return;
            }
            else
            {
                DownloadWorkshop(workshop, () =>
                {
                    ShowSkinGui(player, workshop, options);
                }, cacheKey);
            }
        }

        void ShowSkinGui(BasePlayer player, WorkshopResult workshop, GuiOptions options)
        {
            CloseSkinGui(player);
            
            var container = new CuiElementContainer();

            var guiHelper = new GuiHelper(player);

            var panel = guiHelper.Panel("Overlay", 0.1, 0.9, 0.1, 0.9, "0.0 0.0 0.0 0.9", true);

            guiHelper.Label(panel,
                options.ShowSkinProfile != ""
                    ? workshop.GetItems()[0].Title
                    : Lang("GuiTitleSkinShop", player.UserIDString),
                0.01, 0.2, 0.94, 0.99
            );

            AddButtons(guiHelper, panel, player, workshop, options);

            if (options.ShowCategories)
            {
                CategoryButtons(player, guiHelper, panel, workshop);
            }else if (options.ShowSkinPacks)
            {
                SkinPacksGrid(guiHelper, panel, workshop, player);
            }
            else if (options.ShowSkinProfile != "")
            {
                SkinProfileGui(guiHelper, panel, workshop, player);
            }
            else
            {
                AddGrid(guiHelper, panel, player, workshop);
            }

            _skinGui[player.UserIDString] = guiHelper;
            guiHelper.Open();
        }

        private void AddButtons(GuiHelper guiHelper, string parent, BasePlayer player, WorkshopResult workshop, GuiOptions options)
        {
            var buttonbar = guiHelper.Panel(parent, 0.2, 0.99, 0.92, 0.97);
            
            guiHelper.Button(buttonbar, 
                Lang("GuiCloseButton", player.UserIDString), 
                "0.69 0.52 0.49 1.0",
                "skinshop.close",
                0.9, 1.0, 0.0, 1.0
            );

            guiHelper.Button(buttonbar, 
                Lang("GuiButtonMySkins", player.UserIDString), 
                workshop.OwnerId == player.UserIDString ? "0.42 0.55 0.22 1.0" : "0.23 0.23 0.23 1.0",
                "skinshop.myskins",
                0.64, 0.74, 0.0, 1.0
            );

            if (_config.SkinsPacksEnabled)
            {
                guiHelper.Button( buttonbar, 
                    Lang("GuiButtonSkinPacks", player.UserIDString), 
                    options.ShowSkinPacks ? "0.42 0.55 0.22 1.0" : "0.23 0.23 0.23 1.0",
                    "skinshop.buypacks",
                    0.53, 0.63, 0.0, 1.0
                );
            }
            
            guiHelper.Button(buttonbar, 
                Lang("GuiButtonSelectCategory", player.UserIDString), 
                workshop.Categories.Count == 0 ? "0.23 0.23 0.23 1.0" : "0.42 0.55 0.22 1.0",
                $"skinshop.selectcategory {workshop.Escape()}",
                0.75, 0.89, 0.0, 1.0
            );

            if (options.ShowSkinProfile == "" && !options.ShowSkinPacks)
            {
                GuiSearchBar(guiHelper, buttonbar, workshop);

                GuiPagination(guiHelper, buttonbar, workshop);
            }

        }

        private void GuiSearchBar(GuiHelper guiHelper, string parent, WorkshopResult workshop)
        {
            
            var inputpanel = guiHelper.Panel(parent, 0.0, 0.24, 0.0, 1.0, "0.0 0.0 0.0 1.0");

            guiHelper.container.Add(new CuiElement
            {
                Parent = inputpanel,
                Components =
                {
                    new CuiInputFieldComponent
                    {
                        Text = "",
                        IsPassword = false,
                        CharsLimit = 50,
                        Command = $"skinshop.search {workshop.Escape()}",
                        Align = TextAnchor.MiddleLeft
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.05 0.0",
                        AnchorMax = "0.95 1.0"
                    }
                }
            });
            
            var searchBtn = guiHelper.Panel( parent, 0.25, 0.29, 0.0, 1.0, "0.0 0.0 0.0 1.0");

            guiHelper.Image(searchBtn, 0.2, 0.8, 0.2, 0.8, GetImage(_config.SearchIconUrl));
        }

        private void GuiPagination(GuiHelper guiHelper, string parent, WorkshopResult workshop)
        {
            var pagination = guiHelper.Panel(parent, 0.3, 0.52, 0.0, 1.0);
            
            guiHelper.Button( pagination,
                "<<",
                "0.0 0.0 0.0 1.0",
                workshop.Page > 1 ? $"skinshop.page {workshop.Page - 1} {workshop.Escape()}" : "",
                0.0, 0.29, 0.0, 1.0
            );
            
            guiHelper.Button(pagination,
                string.Format("{0} of {1}",workshop.Page, workshop.TotalPages),
                "0.0 0.0 0.0 1.0",
                "",
                0.3, 0.7, 0.0, 1.0
            );
            
            guiHelper.Button( pagination,
                ">>",
                "0.0 0.0 0.0 1.0",
                workshop.Page < workshop.TotalPages ? $"skinshop.page {workshop.Page+1} {workshop.Escape()}" : "",
                0.71, 1.0, 0.0, 1.0
            );
        }
        
        private CuiRawImageComponent GetImage(string url, ulong imageId = 0)
        {
            CuiRawImageComponent img;
            if (ImageLibrary.Call<bool>("HasImage", url, imageId))
            {
                img = new CuiRawImageComponent()
                {
                    Png = ImageLibrary?.Call<string>("GetImage", url, imageId)
                };
            }
            else
            {
                ImageLibrary.Call<bool>("AddImage", url, url, imageId, ImageCallback(url));
                img = new CuiRawImageComponent()
                {
                    Url = url
                };
            }

            return img;
        }

        private void SkinPacksGrid(GuiHelper guiHelper, string parent, WorkshopResult workshop, BasePlayer player)
        {
            var grid = guiHelper.Panel( parent, 0.2, 0.8, 0.01, 0.89);

            foreach (var gridItem in GetGridItems(_config.SkinPacks.Count, 3, 2))
            {
                var itemPane = gridItem.Pane(guiHelper.container, grid);

                var packId = gridItem.Id;

                var pack = _config.SkinPacks[packId];
                
                guiHelper.Label( itemPane, pack.PackName, 0.0, 1.0, 0.85, 1.0, 14, "1.0 1.0 1.0 1.0",
                    TextAnchor.MiddleCenter);

                guiHelper.Image( itemPane, 0.0, 1.0, 0.15, 0.85, GetImage(pack.ImageUrl));
                
                guiHelper.Button( itemPane, 
                    Lang("GuiButtonBuyNowShort", player.UserIDString, pack.Price),
                    Color("Green"), 
                    $"skinshop.buypack {packId}",
                    0.0, 1.0, 0.0, 0.15);
            }
            
        }

        private void SkinProfileGui(GuiHelper guiHelper, string parent, WorkshopResult workshop, BasePlayer player)
        {
            if (workshop.GetItems().Count == 0) return;
            var item = workshop.GetItems()[0];

            var grid = guiHelper.Panel( parent, 0.01, 0.99, 0.01, 0.89,  "0.0 0.0 0.0 0.9");

            var imagebox = guiHelper.Panel( grid, 0.05, 0.3, 0.5, 0.95, "0.0 0.0 0.0 1.0");

            guiHelper.Image( imagebox, 0.01, 0.99, 0.01, 0.99, GetImage(item.Image));

            var instantSell = guiHelper.Panel( grid, 0.33, 0.6, 0.5, 0.95, "0.0 0.0 0.0 1.0");

            guiHelper.Label( instantSell, Lang("InstantSell", player.UserIDString), 0.05, 0.95, 0.8, 1.0, 16);

            guiHelper.Label( instantSell,
                Lang("InstantSellDescription", player.UserIDString,
                    item.GetInstantSellPrice(_config.DefaultInstantPricePrice)),
                0.05, 0.95, 0.2, 0.8, 12, "1.0 1.0 1.0 1.0", TextAnchor.UpperLeft);

            guiHelper.Button( instantSell,
                Lang("ButtonSellNow", player.UserIDString),
                Color("Green"),
                $"skinshop.sellskin {item.Id}",
                0.01, 0.99, 0.01, 0.2);
        }


        private List<GuiGridItem> GetGridItems(int totalItems, int columns, int minimumRows=0, double padding=0.01)
        {
            var grid = new List<GuiGridItem>();
            var rows = (int)Math.Max(minimumRows, Math.Ceiling((double)totalItems / columns));
            var totalWidth = 0.99;
            
            var itemWidth = (totalWidth / columns) - padding;
            var itemHeight = (totalWidth / rows) - padding;

            var col = 0;
            var row = 0;
            for (var i = 0; i < totalItems; i++)
            {
                var x = (col * itemWidth) + (padding * (col + 1));
                var y = ((rows - 1 - row) * itemHeight) + (padding * (rows - 1 - row)) + 0.01;
                grid.Add(new GuiGridItem
                {
                    Id = i,
                    x1 = x,
                    x2 = x + itemWidth,
                    y1 = y,
                    y2 = y + itemHeight
                });
                col++;
                if (col >= columns)
                {
                    col = 0;
                    row++;
                }
            }

            return grid;
        }

        private void AddGrid(GuiHelper guiHelper, string parent, BasePlayer player, WorkshopResult workshop)
        {
            var subtitle = workshop.OwnerId == player.UserIDString ? Lang("GuiButtonMySkins", player.UserIDString) :  workshop.Categories[0];
            GuiAddSubtitle(guiHelper, subtitle, parent);
            
            var grid = guiHelper.container.Add(new CuiPanel{
                RectTransform =
                {
                    AnchorMin = "0.01 0.01",
                    AnchorMax = "0.99 0.89"
                },
                Image =
                {
                    Color = "0.0 0.0 0.0 0.9"
                }
            }, parent);

            var items = workshop.GetItems();

            foreach (var gridItem in GetGridItems(items.Count, 6, 3))
            {
                var item = items[gridItem.Id];
                
                // Skip item if it is in the blacklist
                if (_config.BlackListedSkins.Contains(Convert.ToUInt64(item.Id))) continue;
                    
                var itemPane = gridItem.Pane(guiHelper.container, grid);

                guiHelper.Image( itemPane, 0.0, 1.0, 0.15, 0.85, GetImage(item.Image));

                guiHelper.Label( itemPane, item.Title, 0.05, 0.95, 0.85, 1.0, 12);

                if (workshop.OwnerId == "" && permission.UserHasPermission(player.UserIDString, blacklistPermission))
                {
                    var blacklistbtn = guiHelper.Button( itemPane, "", Color("Red"), $"skinshop.blacklist.id {item.Id} {workshop.Escape()}", 0.85,
                        1.0, 0.86, 0.99, 10);
                    
                    guiHelper.Image( blacklistbtn, 0.1, 0.9, 0.05, 0.95, GetImage(_config.BlacklistIconUrl));
                }

                var playerItem = PlayerOwnsItem(player, item);
                if (playerItem != null)
                {
                    if((workshop.OwnerId != "" || !permission.UserHasPermission(player.UserIDString, blacklistPermission)) && PlayerHasItem(player, item.Shortname)){
                        guiHelper.Button( itemPane, Lang("ButtonApply", player.UserIDString), Color("Red"), $"skinshop.apply {item.Escape()}", 0.80,
                            1.0, 0.86, 0.99, 10);
                    }
                    if (playerItem.Equipped)
                    {
                        guiHelper.Button( itemPane,
                            Lang("GuiButtonSkinEquipped", player.UserIDString),
                            Color("Green"),
                            $"skinshop.unequip {workshop.Escape()} {item.Escape()}",
                            0.01, 0.55, 0.0, 0.13, 12);
                    }
                    else
                    {
                        guiHelper.Button( itemPane,
                            Lang("GuiButtonSkinUnequipped", player.UserIDString),
                            Color("Grey"),
                            $"skinshop.equip {workshop.Escape()} {item.Escape()}",
                            0.01, 0.55, 0.0, 0.13, 12);
                    }

                    guiHelper.Button( itemPane, 
                        Lang("ButtonSell", player.UserIDString), 
                        Color("Blue"),
                        $"skinshop.skinprofile {player.UserIDString} {item.Id}",
                        0.56, 0.99, 0.0, 0.13, 12);
                }
                else
                {
                    guiHelper.Button( itemPane,
                        Lang("GuiButtonBuyNow", player.UserIDString, item.GetPrice(_config.DefaultSkinPrice, GetDiscount(player))),
                        "0.22 0.35 0.55 1.0",
                        $"skinshop.buy {workshop.Escape()} {item.Escape()}",
                        0.01, 0.99, 0.0, 0.13, 12);
                }
            }
        }

        private void CategoryButtons(BasePlayer player, GuiHelper guiHelper, string parent, WorkshopResult workshop)
        {
            GuiAddSubtitle(guiHelper, "Select a Category", parent);

            var grid = guiHelper.Panel( parent, 0.01, 0.99, 0.01, 0.89, "0.0 0.0 0.0 0.9");
            
            var categories = _categories.Where(x => !_config.HideCategories.Contains(x.Value));

            foreach (var gridItem in GetGridItems(categories.Count(), 6, 0, 0.005))
            {
                var categoryItem = categories.Skip(gridItem.Id).First();

                var btn = guiHelper.Button( grid,
                    Lang(categoryItem.Value, player.UserIDString),
                    workshop.Categories.Contains(categoryItem.Key) ? "0.42 0.55 0.22 1.0" : "0.0 0.0 0.0 1.0",
                    $"skinshop.category {workshop.Escape()} {Uri.EscapeDataString(categoryItem.Key)}",
                    gridItem.x1, gridItem.x2, gridItem.y1, gridItem.y2, 12);
                
                if (_config.EnabledCategoryIcons && _categoryIconsLoaded)
                {
                    guiHelper.Image( btn, 0.02, 0.17, 0.05, 0.95, GetImage(categoryItem.Value));
                }
            }
        }

        private void GuiAddSubtitle(GuiHelper guiHelper, string text, string parent)
        {
            guiHelper.Label( parent, text, 0.01, 0.2, 0.9, 0.94, 16);
        }
        
        #endregion
        
        #region Skin Functions

        private void ApplySkin(BasePlayer player, WorkShopItem item)
        {
            foreach (var inventoryItem in player.inventory.AllItems())
            {
                if (inventoryItem.info.shortname == item.Shortname)
                {
                    SetSkinId(inventoryItem, Convert.ToUInt64(item.Id));
                }
            }
        }
        
        private void SetSkin(BasePlayer player, Item item)
        {
            if (item.skin != 0UL) return;
            
            var e = EquippedItem(player, item.info.shortname);
            if (e != null)
            {
                var skinID = Convert.ToUInt64(e.Id);
                SetSkinId(item, skinID);
            }
        }

        private void SetSkinId(Item item, ulong skinID)
        {
            item.skin = skinID;
            var held = item.GetHeldEntity();
            if (held != null)
            {
                held.skinID = skinID;
                held.SendNetworkUpdate();
            }

            var world = item.GetWorldEntity();
            if (world != null)
            {
                world.skinID = skinID;
                world.SendNetworkUpdate();
            }
            item.MarkDirty();
        }

        [CanBeNull]
        private string BuyItem(BasePlayer player, WorkShopItem item)
        {
            if (!HasEconomicsPlugin())
                return Lang("PluginNotInstalled", player.UserIDString, _config.CurrencyPlugin);
            
            var balance = GetBalance(player.UserIDString);
            if (balance < item.GetPrice(_config.DefaultSkinPrice, GetDiscount(player))) return Lang("NotEnoughCoinsToBuy", player.UserIDString, item.GetPrice(_config.DefaultSkinPrice, GetDiscount(player)));

            // Take money
            if (!TakeFunds(player.UserIDString, item.GetPrice(_config.DefaultSkinPrice, GetDiscount(player))))
            {
                return Lang("WithdrawCoinsFailed",player.UserIDString);
            }

            GiveItem(player, item);
            return null;

        }

        private string BuyPack(BasePlayer player, SkinPack pack)
        {
            var spaceAvailable = PlayerInventorySpaceAvailable(player);
            if (spaceAvailable <= 0)
            {
                return Lang("NoRoomInInventory",player.UserIDString);
            }
            
            if (!HasEconomicsPlugin())
                return Lang("PluginNotInstalled", player.UserIDString, _config.CurrencyPlugin);
            
            var balance = GetBalance(player.UserIDString);
            if (balance < pack.Price) return string.Format("You need {0} to buy this pack!", pack.Price);

            // Take money
            if (!TakeFunds(player.UserIDString, pack.Price))
            {
                return Lang("WithdrawCoinsFailed",player.UserIDString);
            }

            GiveSkinPack(player, pack);

            return null;
        }

        private void GiveItem(BasePlayer player, WorkShopItem item, bool equip = true)
        {
            if (!_ownedItems.ContainsKey(player.UserIDString))
            {
                _ownedItems.Add(player.UserIDString, new List<WorkShopItem>());
            }
            
            // Disallow duplicates?
            if (PlayerOwnsItem(player, item) != null)
            {
                return;
            }

            if (equip)
            {
                var e = EquippedItem(player, item.Shortname);
                if (e != null) e.Equipped = false;
                item.Equipped = true;
                item.Wrapped = false;
            }

            _ownedItems[player.UserIDString].Add(item);
            NeedsWriting(player.UserIDString);
        }


        private void EquipItem(BasePlayer player, WorkShopItem item)
        {
            var e = EquippedItem(player, item.Shortname);
            if(e != null) e.Equipped = false;

            var owned = PlayerOwnsItem(player, item);
            if (owned != null) owned.Equipped = true;
            NeedsWriting(player.UserIDString);
        }

        private void UnEquipItem(BasePlayer player, WorkShopItem item)
        {
            var owned = PlayerOwnsItem(player, item);
            if (owned != null) owned.Equipped = false;
            NeedsWriting(player.UserIDString);
        }

        private bool HasEconomicsPlugin()
        {
            if (_config.CurrencyPlugin == "Economics")
            {
                return Economics != null && Economics.IsLoaded;
            }else if (_config.CurrencyPlugin == "ServerRewards")
            {
                return ServerRewards != null && ServerRewards.IsLoaded;
            }

            return false;
        }

        private bool AddFunds(string playerId, double amount)
        {
            if (_config.CurrencyPlugin == "ServerRewards")
            {
                return ServerRewards.Call<bool>("AddPoints", playerId, Convert.ToInt32(amount));
            }
            return Economics.Call<bool>("Deposit", playerId, amount);
        }

        private double GetBalance(string playerId)
        {
            if (_config.CurrencyPlugin == "ServerRewards")
            {
                return Convert.ToDouble(ServerRewards.Call<int>("CheckPoints", playerId));
            }
            return Economics.Call<double>("Balance", playerId);
        }

        private bool TakeFunds(string playerId, double amount)
        {
            if (_config.CurrencyPlugin == "ServerRewards")
            {
                return ServerRewards.Call<bool>("TakePoints", playerId, Convert.ToInt32(amount));
            }
            return Economics.Call<bool>("Withdraw", playerId, amount);
        }

        [CanBeNull]
        private WorkShopItem PlayerOwnsItem(BasePlayer player, WorkShopItem item)
        {
            if (!_ownedItems.ContainsKey(player.UserIDString)) return null;

            foreach (var i in _ownedItems[player.UserIDString])
            {
                if (i.Id == item.Id) return i;
            }

            return null;
        }

        private bool PlayerHasItem(BasePlayer player, string item)
        {
            foreach (var i in player.inventory.AllItems())
            {
                if (i.info.shortname == item) return true;
            }
            return false;
        }

        [CanBeNull]
        private WorkShopItem EquippedItem(BasePlayer player, string categoryShort)
        {
            if (!_ownedItems.ContainsKey(player.UserIDString)) return null;
            
            foreach (var i in _ownedItems[player.UserIDString])
            {
                if (i.Shortname == categoryShort && i.Equipped) return i;
            }
            return null;
        }

        #endregion

        #region Skin Pack Functions

        private bool IsSkinPack(Item item)
        {
            if (item == null || item.info.shortname != "wrappedgift") return false;
            
            foreach (var pack in _config.SkinPacks)
            {
                if (item.name == pack.Value.PackName) return true;
            }
            return false;
        }

        private SkinPack GetSkinPack(Item item)
        {
            foreach (var pack in _config.SkinPacks)
            {
                if (item.name == pack.Value.PackName) return pack.Value;
            }

            return null;
        }
        
        private void SetupSkinPack(Item item)
        {
            if (!_config.ConvertGiftsToPacks) return;
            
            if (item != null && item.info.shortname == "wrappedgift" && !IsSkinPack(item))
            {
                var pack = _config.SkinPacks[0];
                item.name = pack.PackName;
                item.skin = pack.SkinId;
            }
        }
        
        private List<WorkShopItem> OpenPack(BasePlayer player, SkinPack pack)
        {
            var items = new List<WorkShopItem>();

            // Filter out blacklisted skins
            var database = _skinDatabase.Where(x => !_config.BlackListedSkins.Contains(Convert.ToUInt64(x.Key)) 
                                                    && (pack.PossibleSkinIds.Length == 0 || pack.PossibleSkinIds.Contains(Convert.ToUInt64(x.Key))) 
                                                    && (pack.PossibleSkinCategories.Length == 0 || pack.PossibleSkinCategories.Contains(x.Value.Shortname))).Select(x => x.Key).ToArray();
            
            Random random = new Random();
            database = database.OrderBy(x => random.Next()).Take(pack.NumberOfSkins).ToArray();
            foreach (var i in database)
            {
                items.Add(_skinDatabase[i]);
                GiveItem(player, _skinDatabase[i], false);
            }
            
            PostToDiscord(Lang("DiscordOpenPackMessage", player.UserIDString, GetServerTime(), player.displayName, pack.PackName));

            return items;
        }

        private void GiveSkinPack(BasePlayer player, SkinPack pack)
        {
            var item = ItemManager.Create(ItemManager.FindItemDefinition("wrappedgift"), 1, pack.SkinId);
            item.name = pack.PackName;
            var beltAvailable = player.inventory.containerBelt.capacity -
                                player.inventory.containerBelt.itemList.Count;
            if (beltAvailable > 0)
            {
                item.MoveToContainer(player.inventory.containerBelt);
            }
            else
            {
                player.inventory.GiveItem(item);
            }
        }

        private string SellSkin(BasePlayer player, string itemId)
        {
            if (!HasEconomicsPlugin())
                return Lang("PluginNotInstalled", player.UserIDString, _config.CurrencyPlugin);
            
            if (!_ownedItems.ContainsKey(player.UserIDString))
            {
                return Lang("InvalidPlayer", player.UserIDString);
            }

            for (int i = _ownedItems[player.UserIDString].Count - 1; i >= 0; i--)
            {
                if (_ownedItems[player.UserIDString][i].Id == itemId)
                {
                    var price = _ownedItems[player.UserIDString][i]
                        .GetInstantSellPrice(_config.DefaultInstantPricePrice);
                    _ownedItems[player.UserIDString].RemoveAt(i);

                    AddFunds(player.UserIDString, price);
                    NeedsWriting(player.UserIDString);
                    return Lang("ItemSold", player.UserIDString, price);
                }
            }

            return Lang("ItemNotFound", player.UserIDString);
        }

        #endregion
        
        #region Open Packs GUI
        
        void ShowPacksGui(BasePlayer player, List<WorkShopItem> items)
        {
            CloseSkinGui(player);

            var guiHelper = new GuiHelper(player);

            var panel = guiHelper.Panel("Overlay", 0.0, 1.0, 0.0, 1.0, "0.17 0.17 0.17 1.0", true);

            var buttonbar = guiHelper.Panel(panel, 0.3, 1.0, 0.9, 1.0);

            guiHelper.Button(buttonbar, Lang("GuiCloseButton", player.UserIDString),
                "0.69 0.52 0.49 1.0",
                "skinshop.packsclose",
                0.8, 1.0, 0.0, 1.0);

            guiHelper.Button(buttonbar, Lang("GuiButtonViewAllMySkins", player.UserIDString),
                Color("Green"),
                "skinshop.myskins",
                0.5, 0.78, 0.0, 1.0
            );

            guiHelper.Label(panel, Lang("GuiTitleOpenSkinPack", player.UserIDString), 0.01, 0.25, 0.9, 0.99, 30);

            var grid = guiHelper.Panel(panel, 0.15, 0.85, 0.05, 0.85, "1.0 1.0 1.0 0.0");

            foreach (var gridItem in GetGridItems(items.Count, 3, 2))
            {
                var item = items[gridItem.Id];

                var bg = guiHelper.Image(grid, gridItem.x1, gridItem.x2, gridItem.y1, gridItem.y2,
                    GetImage(_config.SkinPackImageUrl));
                
                if (item.Wrapped)
                {
                    guiHelper.Button(bg, "", "0.0 0.0 0.0 0.0",
                        $"skinshop.packsopen  {Uri.EscapeDataString(JsonConvert.SerializeObject(items))} {item.Id}",
                        0.0, 1.0, 0.0, 1.0);
                }
                else
                {
                    guiHelper.Image(bg, 0.075, 0.925, 0.15, 0.85, GetImage(item.Image));

                    var label = guiHelper.Panel(bg, 0.075, 0.925, 0.075, 0.15, "0.0 0.0 0.0 1.0");

                    guiHelper.Label(label, item.Title, 0.0, 1.0, 0.0, 1.0, 14, "1.0 1.0 1.0 1.0", TextAnchor.MiddleCenter);

                    var categorylabel = guiHelper.Panel(bg, 0.075, 0.925, 0.85, 0.925, "0.0 0.0 0.0 1.0");

                    guiHelper.Label(categorylabel, item.Category, 0.0, 1.0, 0.0, 1.0, 14, "1.0 1.0 1.0 1.0", TextAnchor.MiddleCenter);
                }
            }


            _skinGui[player.UserIDString] = guiHelper;
            guiHelper.Open();
        }
        

        #endregion
        
        #region Data Management
        
        private void LogMsg(string msg, string level="debug")
        {
            if (level == "error" || _config.LogLevel == "debug" || (_config.LogLevel == "info" && level == "info"))
            {
                Puts(msg);
            }
        }

        private void DownloadDatabase(IPlayer iplayer)
        {
            webrequest.Enqueue(_downloadJsonUrl, "", (code, downloadString) =>
            {
                try
                {
                    var skindb = JObject.Parse(downloadString);
                    if (skindb.Count == 0)
                    {
                        LogMsg(Lang("DownloadEmpty"), "error");
                        return;
                    }
                    
                    Interface.Oxide.DataFileSystem.WriteObject("SkinShop\\database", skindb);
                    LoadDatabase();
                    iplayer.Reply(Lang("SkinDatabaseLoaded", iplayer.Id, _skinDatabase.Count));
                }
                catch (Exception e)
                {
                    LogMsg(Lang("DownloadFailed",null, e.Message), "error");
                }
            }, this);
        }
        
        private void DownloadWorkshop(WorkshopResult workshop, Action callback, string cacheKey="")
        {
            webrequest.Enqueue(workshop.GetUrl(), "", (code, downloadString) =>
            {
                Match totalReg = Regex.Match(downloadString, @"of ([\d,]+) entries");
                if (!totalReg.Success) return;

                var total = Convert.ToInt32(totalReg.Groups[1].Value.Replace(",",""));
                if (total <= 0) return;

                workshop.TotalResults = total;
            
                Regex regex = new Regex("<div class=\\\"workshopItem\\\">.*?</script>", RegexOptions.IgnoreCase | RegexOptions.Singleline);

                var matches = regex.Matches(
                    downloadString);
        
                foreach (Match match in matches)
                {
                    try
                    {
                        Match titleReg = Regex.Match(match.Value, "<div class=\\\"workshopItemTitle[^\\\"]*\\\">(.*?)</div>");
                        if (!titleReg.Success) continue;

                        Match infoReg = Regex.Match(match.Value, "SharedFileBindMouseHover\\(.*?({.*?}).*?\\)");
                        if (!infoReg.Success) continue;

                        var info = JsonConvert.DeserializeObject<JObject>(infoReg.Groups[1].Value);
                
                        Match imgReg = Regex.Match(match.Value,
                            "<img class=\\\"workshopItemPreviewImage[^\\\"]*\\\" src=\\\"([^\\\"]*)\\\"");
                        if (!imgReg.Success) continue;

                        var item = new WorkShopItem()
                        {
                            Title = CleanInput(info.Value<string>("title")),
                            Id = info.Value<string>("id"),
                            Description = CleanInput(info.Value<string>("description")),
                            Image = imgReg.Groups[1].Value.Split('?')[0],
                            Category = workshop.Categories[0]
                        };

                        workshop.AddItem(item);
                        if (!_skinDatabase.ContainsKey(item.Id))
                        {
                            _skinDatabase.Add(item.Id, item);
                        }
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }

                if (cacheKey != "")
                {
                    MemoryCache.Add(cacheKey, workshop, new MemoryCache.CacheItemOptions()
                    {
                        AbsoluteExpiration = DateTimeOffset.UtcNow.AddHours(24)
                    });
                }

                callback();
            }, this);
        }
        
        private void SaveData()
        {
            LogMsg(Lang("SavingDataMessage", null, _needsWriting.Count), "info");
            foreach (var playerId in _needsWriting)
            {
                if (!_ownedItems.ContainsKey(playerId)) continue;
                Interface.Oxide.DataFileSystem.WriteObject("SkinShop\\"+playerId+"_items", _ownedItems[playerId]);
            }
            _needsWriting.Clear();
        }

        private void SaveSkinDatabase()
        {
            
            Interface.Oxide.DataFileSystem.WriteObject("SkinShop\\database", _skinDatabase);
        }

        private void LoadData()
        {
            try
            {
                foreach (string file in Interface.Oxide.DataFileSystem.GetFiles("SkinShop","*_items.json"))
                {
                    Match match = Regex.Match(file,  @".*[/\\]{1}([\d]+)_items");
                    LogMsg(file, "debug");
                    if (match.Success)
                    {
                        var uid = match.Groups[1].Value;
                        LogMsg(Lang("SkinsLoadedForUser", null, uid), "debug");
                        var jsonData = Interface.Oxide.DataFileSystem.ReadObject<List<WorkShopItem>>("SkinShop\\"+uid+"_items");
                        LogMsg(JsonConvert.SerializeObject(jsonData), "debug");
                        _ownedItems[uid] = jsonData;
                    }
                    else
                    {
                        LogMsg(Lang("UserIDMatchNotFound"),"debug");
                    }
                }
            }
            catch (Exception e)
            {
                LogMsg(e.Message, "error");
                LogMsg(Lang("FilesNotFound"), "info");
            }

            
        }

        private void LoadDatabase()
        {
            try
            {
                _skinDatabase =
                    Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, WorkShopItem>>("SkinShop\\database");
                LogMsg(Lang("SkinDatabaseLoaded", null, _skinDatabase.Count), "info");
            }
            catch (Exception e)
            {
                
            }
        }
        
        private Action ImageCallback(string imageName, ulong imageId=0)
        {
            return () =>
            {
                if(!_config.AutomaticallyRemoveMissingImages) return;
                
                if (!ImageLibrary.Call<bool>("HasImage", imageName, imageId))
                {
                    LogMsg(Lang("MissingImage",null, imageName), "error");
                    List<string> deleting = new List<string>();
                    foreach (var delete in _skinDatabase.Where(x => x.Value.Image == imageName))
                    {
                        deleting.Add(delete.Key);
                    }

                    foreach (var d in deleting)
                    {
                        LogMsg(Lang("ItemDeleted",null, _skinDatabase[d].Title), "error");
                        _skinDatabase.Remove(d);
                    }

                    SaveSkinDatabase();
                }
            };
        }

        private Action CategoryIconsDone(int count)
        {
            return () =>
            {
                LogMsg(Lang("IconsLoaded",null, count), "info");
                if(count > 0) _categoryIconsLoaded = true;
            };
        }
        
        private void LoadIconImages()
        {
            if (!_config.EnabledCategoryIcons || ImageLibrary == null || !ImageLibrary.IsLoaded) return;

            var itemIcons = new List<KeyValuePair<string, ulong>>();
            foreach (var cat in _categories)
            {
                itemIcons.Add(new KeyValuePair<string, ulong>(cat.Value,0UL));
            }

            ImageLibrary.Call("LoadImageList", "SkinShop", itemIcons, CategoryIconsDone(itemIcons.Count));
        }

        private void NeedsWriting(string playerId)
        {
            if (!_needsWriting.Contains(playerId))
            {
                _needsWriting.Add(playerId);
            }
        }
        #endregion

        #region Commands

        
        [Command("skinshop"), Permission(useSkinshopPermission)]
        private void ShowSkinShop(IPlayer iplayer, string command, string[] args)
        {
            if (_config.ShowCategorySelectLanding)
            {
                SelectCategorySkinShop(iplayer, command, args);
                return;
            }
            PrepareShowSkinGui(iplayer.Object as BasePlayer, new WorkshopResult());
        }

        
        [Command("skinshop.close"), Permission(useSkinshopPermission)]
        private void CloseSkinShop(IPlayer iplayer, string command, string[] args)
        {
            CloseSkinGui(iplayer.Object as BasePlayer);
        }
        
        [Command("skinshop.page"), Permission(useSkinshopPermission)]
        private void PageChangeSkinShop(IPlayer iplayer, string command, string[] args)
        {
            var workshop = UnEscape(args[1]);
            workshop.Page = Convert.ToInt32(args[0]);
            PrepareShowSkinGui(iplayer.Object as BasePlayer, workshop);
        }
        
        [Command("skinshop.search"), Permission(useSkinshopPermission)]
        private void SearchSkinShop(IPlayer iplayer, string command, string[] args)
        {
            var workshop = UnEscape(args[0]);
            var search = "";
            if (args.Length > 1)
            {
                search = string.Join(" ", args.Skip(1));
            }

            workshop.Search = search;

            PrepareShowSkinGui(iplayer.Object as BasePlayer, workshop);
        }
        
        [Command("skinshop.category"), Permission(useSkinshopPermission)]
        private void CategorySkinShop(IPlayer iplayer, string command, string[] args)
        {
            var workshop = UnEscape(args[0]);
            var category = Uri.UnescapeDataString(args[1]);
            workshop.Categories = new List<string> {category};
            workshop.Page = 1;
            workshop.Search = "";

            PrepareShowSkinGui(iplayer.Object as BasePlayer, workshop);
        }
        
        [Command("skinshop.selectcategory"), Permission(useSkinshopPermission)]
        private void SelectCategorySkinShop(IPlayer iplayer, string command, string[] args)
        {
            WorkshopResult workshop;
            if (args.IsEmpty())
            {
                workshop = new WorkshopResult();
            }
            else
            {
                workshop = UnEscape(args[0]);
                workshop.RemoveOwner();
            }

            PrepareShowSkinGui(iplayer.Object as BasePlayer, workshop, new GuiOptions
            {
                ShowCategories = true
            });
        }
        [Command("skinshop.buy"), Permission(useSkinshopPermission)]
        private void BuySkinShop(IPlayer iplayer, string command, string[] args)
        {
            var workshop = UnEscape(args[0]);
            var item = JsonConvert.DeserializeObject<WorkShopItem>(Uri.UnescapeDataString(args[1]));
            var buy = BuyItem(iplayer.Object as BasePlayer, item);
            if (buy != null)
            {
                ((BasePlayer)iplayer.Object).ChatMessage(buy);
            }
            PrepareShowSkinGui(iplayer.Object as BasePlayer, workshop);
        }
        
        [Command("skinshop.equip"), Permission(useSkinshopPermission)]
        private void EquipItemCommand(IPlayer iplayer, string command, string[] args)
        {
            var workshop = UnEscape(args[0]);
            var item = JsonConvert.DeserializeObject<WorkShopItem>(Uri.UnescapeDataString(args[1]));
            EquipItem(iplayer.Object as BasePlayer, item);
            PrepareShowSkinGui(iplayer.Object as BasePlayer, workshop);
        }
        
        [Command("skinshop.unequip"), Permission(useSkinshopPermission)]
        private void UnEquipItemCommand(IPlayer iplayer, string command, string[] args)
        {
            var workshop = UnEscape(args[0]);
            var item = JsonConvert.DeserializeObject<WorkShopItem>(Uri.UnescapeDataString(args[1]));
            UnEquipItem(iplayer.Object as BasePlayer, item);
            PrepareShowSkinGui(iplayer.Object as BasePlayer, workshop);
        }
        
        [Command("skinshop.myskins"), Permission(useSkinshopPermission)]
        private void MySkinsPage(IPlayer iplayer, string command, string[] args)
        {
            var workshop = new WorkshopResult();
            workshop.OwnerId = ((BasePlayer) iplayer.Object).UserIDString;
            
            PrepareShowSkinGui(iplayer.Object as BasePlayer, workshop);
        }
        
        [Command("skinshop.buypacks"), Permission(useSkinshopPermission)]
        private void BuyPacksPage(IPlayer iplayer, string command, string[] args)
        {
            if (!_config.SkinsPacksEnabled) return;
            
            var workshop = new WorkshopResult();

            PrepareShowSkinGui(iplayer.Object as BasePlayer, workshop, new GuiOptions
            {
                ShowSkinPacks = true
            });
        }

        [Command("skinshop.packsopen"), Permission(useSkinshopPermission)]
        private void OpenSkinPacksShop(IPlayer iplayer, string command, string[] args)
        {
            if (!_config.SkinsPacksEnabled) return;
            
            var items = JsonConvert.DeserializeObject<List<WorkShopItem>>(Uri.UnescapeDataString(args[0]));
            if (args[1] != null)
            {
                foreach (var i in items)
                {
                    if (i.Id == args[1])
                    {
                        i.Wrapped = false;
                    }
                }
            }

            ShowPacksGui(iplayer.Object as BasePlayer, items);
        }
        
        [Command("skinshop.packsclose"), Permission(useSkinshopPermission)]
        private void CloseSkinPacksShop(IPlayer iplayer, string command, string[] args)
        {
            CloseSkinGui(iplayer.Object as BasePlayer);
        }
        
        [Command("skinshop.skinprofile"), Permission(useSkinshopPermission)]
        private void ViewSkinProfileCommand(IPlayer iplayer, string command, string[] args)
        {
            if (args.Length < 2 || args[0] != iplayer.Id)
            {
                iplayer.Reply(Lang("AccessDenied", iplayer.Id));
                return;
            }
            PrepareShowSkinGui(iplayer.Object as BasePlayer, new WorkshopResult
            {
                OwnerId = args[0]
            }, new GuiOptions
            {
                ShowSkinProfile = args[1],
            });
        }

        private Timer ti;

        private void KillTimer()
        {
            ti.Destroy();
        }

        [Command("skinshop.download"), Permission(adminPermission)]
        private void DownloadSkinData(IPlayer iplayer, string command, string[] args)
        {
            DownloadDatabase(iplayer);
        }
        
        [Command("skinshop.builddatabase"), Permission(adminPermission)]
        private void BuildSkinData(IPlayer iplayer, string command, string[] args)
        {
            iplayer.Reply(Lang("CommandDatabaseBuilding", iplayer.Id));

            var categories = _categories.Keys.ToArray();
            var category = "";
            var cID = 0;
            var page = 1;
            if (args.Length > 0)
            {
                if (!Int32.TryParse(args[0], out cID))
                {
                    if (_categories.ContainsValue(args[0]))
                    {
                        category = _categories.FirstOrDefault(x => x.Value == args[0]).Key;
                    }
                }
            }

            if(args.Length > 1) page = Convert.ToInt32(args[1]);
            
            ti = timer.Every(2f, () =>
            {
                if (cID >= categories.Length)
                {
                    iplayer.Reply(Lang("DatabaseBuildCompleted", iplayer.Id));
                    KillTimer();
                    return;
                }
                var workshop = new WorkshopResult();
                workshop.Categories.Add(category != "" ? category : categories[cID]);
                workshop.Page = page;
                DownloadWorkshop(workshop, () =>
                {
                    iplayer.Reply(category != "" ? Lang("DatabaseCategoryPageDone", iplayer.Id, category, page) : Lang("DatabasePageDone", iplayer.Id, categories[cID], cID, page));
                    if (workshop.Page < workshop.TotalPages)
                    {
                        page++;
                    }
                    else
                    {
                        cID++;
                        page = 1;
                        SaveSkinDatabase();
                        if (category != "")
                        {
                            iplayer.Reply(Lang("DatabaseCategoryCompleted",iplayer.Id, category));
                            KillTimer();
                            return;
                        }
                    }
                });
            });
        }

        [Command("skinshop.givepack"), Permission(adminPermission)]
        private void GivePackCommand(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player;
            ulong playerid;
            if (UInt64.TryParse(args[0], out playerid)){
                player = BasePlayer.FindByID(playerid);
            }
            else
            {
                iplayer.Reply("Invalid player");
                return;
            }

            GiveSkinPack(player, _config.SkinPacks[0]);
            iplayer.Reply($"Skin pack given to {player.displayName}");
        }
        
        [Command("skinshop.buypack")]
        private void BuyPackCommand(IPlayer iplayer, string command, string[] args)
        {
            var pack = _config.SkinPacks[Convert.ToInt32(args[0])];
            var buy = BuyPack(iplayer.Object as BasePlayer, pack);
            if (buy != null)
            {
                ((BasePlayer)iplayer.Object).ChatMessage(buy);
                return;
            }
            CloseSkinGui((BasePlayer)iplayer.Object);
        }
        
        [Command("skinshop.sellskin")]
        private void SellSkinCommand(IPlayer iplayer, string command, string[] args)
        {
            if (args.Length == 0) return;
            
            var result = SellSkin(iplayer.Object as BasePlayer, args[0]);
            iplayer.Message(result);
            CloseSkinGui((BasePlayer)iplayer.Object);
            // Open the my skins GUI
            MySkinsPage(iplayer, command, args);

        }
        
        [Command("skinshop.apply"), Permission(useSkinshopPermission)]
        private void ApplySkinCommand(IPlayer iplayer, string command, string[] args)
        {
            var item = UnEscapeItem(args[0]);
            ApplySkin(iplayer.Object as BasePlayer, item);
            iplayer.Message("Skin has been applied");
        }
        
        [Command("skinshop.getskin"), Permission(blacklistPermission)]
        private void GetSkinCommand(IPlayer iplayer, string command, string[] args)
        {
            var item = GetLookingAtItem(iplayer.Object as BasePlayer);
            if (item == null)
            {
                iplayer.Reply(Lang("NotLookingAtItem", iplayer.Id));
            }else if(item.skin == 0UL)
            {
                iplayer.Reply(Lang("ItemNoSkin", iplayer.Id, item.info.displayName.english));
            }
            else
            {
                iplayer.Reply(Lang("SkinIdIs",iplayer.Id, item.info.displayName.english, item.skin));
            }
        }
        
        [Command("skinshop.blacklist.id"), Permission(blacklistPermission)]
        private void BlacklistListId(IPlayer iplayer, string command, string[] args)
        {
            if (args.Length < 1 || !_skinDatabase.ContainsKey(args[0]))
            {
                iplayer.Reply(Lang("InvalidSkinId",iplayer.Id));
                return;
            }

            ulong id;

            if (!ulong.TryParse(args[0], out id))
            {
                iplayer.Reply(Lang("InvalidSkinId",iplayer.Id));
                return;
            }
            
            BlacklistSkin(id);
            iplayer.Message(Lang("SkinBlackListed",iplayer.Id,_skinDatabase[args[0]].Category));

            if (args.Length > 1 && args[1] != "")
            {
                var workshop = UnEscape(args[1]);
                PrepareShowSkinGui(iplayer.Object as BasePlayer, workshop);
            }
            
        }
        
        [Command("skinshop.blacklist.this"), Permission(blacklistPermission)]
        private void BlacklistListThis(IPlayer iplayer, string command, string[] args)
        {
            var item = GetLookingAtItem(iplayer.Object as BasePlayer);
            if (item != null && item.skin != 0UL)
            {
                SetSkinId(item, 0UL);
                BlacklistSkin(item.skin);
                iplayer.Reply(Lang("SkinBlackListed",iplayer.Id,item.info.displayName.english));
                return;
            }
            iplayer.Reply(Lang("MustLookAtCustomSkin",iplayer.Id));
            
        }
        #endregion
        
        #region GuiHelpers
        
        private class GuiGridItem
        {
            public int Id;
            public double x1;
            public double x2;
            public double y1;
            public double y2;
            
            public string Pane(CuiElementContainer container, string parent, string color="0.0 0.0 0.0 1.0")
            {
                return container.Add(new CuiPanel
                {
                    RectTransform =
                    {
                        AnchorMin = AnchorMin(),
                        AnchorMax = AnchorMax()
                    },
                    Image =
                    {
                        Color = color
                    }
                }, parent);
            }

            public string AnchorMin()
            {
                return Convert.ToString(x1) + " " + Convert.ToString(y1);
            }

            public string AnchorMax()
            {
                return Convert.ToString(x2) + " " + Convert.ToString(y2);
            }
        }
        
        private class GuiHelper
        {
            public CuiElementContainer container = new CuiElementContainer();
            public BasePlayer player;

            private List<string> _elements = new List<string>();
            
            public GuiHelper(BasePlayer baseplayer)
            {
                player = baseplayer;
            }

            public string Button(string parent, string text, string buttonColor, string command, double x1, double x2, double y1, double y2, int fontSize=14, string textColor="1.0 1.0 1.0 1.0", TextAnchor align = TextAnchor.MiddleCenter)
            {
                var name = container.Add(new CuiButton
                {
                    Text =
                    {
                        Text = text,
                        Align = align,
                        Color = textColor,
                        FontSize = fontSize
                    },
                    Button =
                    {
                        Color = buttonColor,
                        Command = command
                    
                    },
                    RectTransform =
                    {
                        AnchorMin = x1+" "+y1,
                        AnchorMax = x2+" "+y2
                    }
                }, parent);
                _elements.Add(name);
                return name;
            }

            public string Panel(string parent, double x1, double x2, double y1, double y2, string color="0.0 0.0 0.0 0.0", bool cursor=false)
            {
                var name = container.Add(new CuiPanel
                {
                    RectTransform =
                    {
                        AnchorMin = x1+" "+y1,
                        AnchorMax = x2+" "+y2
                    },
                    Image =
                    {
                        Color = color 
                    },
                    CursorEnabled = cursor
                }, parent);
                _elements.Add(name);
                return name;
            }

            public string Label(string parent, string text, double x1, double x2, double y1, double y2, int fontSize=22, string textColor="1.0 1.0 1.0 1.0", TextAnchor align = TextAnchor.MiddleLeft)
            {
                var name = container.Add(new CuiLabel
                {
                    Text =
                    {
                        Text = text,
                        Align = align,
                        Color = textColor,
                        FontSize = fontSize
                    },
                    RectTransform =
                    {
                        AnchorMin = x1+" "+y1,
                        AnchorMax = x2+" "+y2
                    }
                }, parent);
                _elements.Add(name);
                return name;
            }

            public string Image(string parent, double x1, double x2, double y1, double y2, CuiRawImageComponent image)
            {
                var name = container.Add(new CuiPanel
                {
                    RectTransform =
                    {
                        AnchorMin = x1+" "+y1,
                        AnchorMax = x2+" "+y2
                    },
                    Image = null,
                    RawImage = image
                }, parent);
                _elements.Add(name);
                return name;
            }

            public void Open()
            {
                CuiHelper.AddUi(player, container);
            }

            public int Close()
            {
                _elements.Reverse();
                foreach (var e in _elements)
                {
                    CuiHelper.DestroyUi(player, e);
                }

                return _elements.Count;
            }
        }
        #endregion
        
        #region Helpers
        
        private void BlacklistSkin(ulong skinId)
        {
            if (_config.BlackListedSkins.Contains(skinId))
            {
                return;
            }
            _config.BlackListedSkins = _config.BlackListedSkins.Concat(new ulong[] {skinId}).ToArray();
            SaveConfig();
        }
        private Item GetLookingAtItem(BasePlayer player)
        {
            var ray = new Ray(player.eyes.position, player.eyes.HeadForward());
            var entity = FindObject(ray, 10); // TODO: Make distance configurable

            if (entity != null && entity.GetItem() != null)
            {
                Puts(entity.GetItem().info.shortname);
                return entity.GetItem();
            }

            return null;
        }
        
        private static BaseEntity FindObject(Ray ray, float distance)
        {
            RaycastHit hit;
            return !Physics.Raycast(ray, out hit, distance) ? null : hit.GetEntity();
        }

        private double GetDiscount(BasePlayer player)
        {
            var discount = 0d;
            for (var x = 0; x < _config.VipDiscounts.Length; x++)
            {
                if (permission.UserHasPermission(player.UserIDString, vipPermissions + (x + 1).ToString()))
                {
                    discount = _config.VipDiscounts[x];
                }
            }
            return discount;
        }
        
        private DateTime GetServerTime()
        {
            return DateTime.Now ;
        }

        private string Color(string colorName, string opacity = "1.0")
        {
            if (!_config.Color.ContainsKey(colorName)) return "1.0 1.0 1.0 1.0";
            return _config.Color[colorName] + " " + opacity;
        }

        private int PlayerInventorySpaceAvailable(BasePlayer player)
        {
            var available = player.inventory.containerBelt.capacity - player.inventory.containerBelt.itemList.Count;
            available += player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count;
            return available;
        }
        
        private WorkshopResult UnEscape(string json)
        {
            return JsonConvert.DeserializeObject<WorkshopResult>(Uri.UnescapeDataString(json));
        }

        private WorkShopItem UnEscapeItem(string json)
        {
            return JsonConvert.DeserializeObject<WorkShopItem>(Uri.UnescapeDataString(json));
        }
        
        static string CleanInput(string strIn)
        {
            // Replace invalid characters with empty strings.
            try {
                return Regex.Replace(strIn, @"[^\s\w\d\.@-]", "",
                    RegexOptions.None, TimeSpan.FromSeconds(1.5));
            }
            // If we timeout when replacing invalid characters,
            // we should return Empty.
            catch (RegexMatchTimeoutException) {
                return String.Empty;
            }
        }
        
        static string Hash(string input)
        {
            var hash = new SHA1Managed().ComputeHash(Encoding.UTF8.GetBytes(input));
            return string.Concat(hash.Select(b => b.ToString("x2")));
        }

        #endregion

        #region Discord

        private class DiscordMessage
        {
            public string content;
        }

        private void PostToDiscord(string message)
        {
            if (_config.DiscordChannelId == "" || _config.DiscordApiKey == "") return;
            
            message = JsonConvert.SerializeObject(new DiscordMessage { content = message }, new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore });

            webrequest.Enqueue($"https://discord.com/api/channels/{_config.DiscordChannelId}/messages",
                message,
                (i, s) =>
                { },
                null,
                RequestMethod.POST,
                new Dictionary<string, string> { ["Authorization"] = $"Bot {_config.DiscordApiKey}", ["Content-Type"] = "application/json" });
        }

        #endregion

        #region HumanNPC

        private void OnUseNPC(BasePlayer npc, BasePlayer player)
        {
            if (_config.HumanNpcIds.Contains(npc.userID))
            {
                ShowSkinShop(player.IPlayer, "", new string[0]);
            }
        }
        

        #endregion
    }
}

// --- End of file: SkinShop.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/suicide-vest ---
// --- Original File Path: S/SuicideVest/SuicideVest.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Suicide Vest", "birthdates", "1.1.1")]
    [Description("Allows players to have a suicide vest that blows up")]
    public class SuicideVest : RustPlugin
    {
        #region Variables

        private readonly List<BasePlayer> _armed = new List<BasePlayer>();
        private readonly Dictionary<BasePlayer, long> _cooldowns = new Dictionary<BasePlayer, long>();
        private readonly Dictionary<BasePlayer, Timer> _timers = new Dictionary<BasePlayer, Timer>();
        private Data _data;

        private const string PermissionGive = "suicidevest.give";
        private const string PermissionUse = "suicidevest.use";

        #endregion

        #region Hooks

        private void Init()
        {
            LoadConfig();
            permission.RegisterPermission(PermissionUse, this);
            permission.RegisterPermission(PermissionGive, this);
            cmd.AddChatCommand("givevest", this, ChatCmd);
            _data = Interface.Oxide.DataFileSystem.ReadObject<Data>("Suicide Vest");
            if (!_config.ExplodeWhenShot) Unsubscribe("OnEntityTakeDamage");
        }

        private void OnServerInitialized()
        {
            var prefabs = _config.ExplosionPrefab;
            prefabs.Add(_config.ArmedSoundPrefab);
            prefabs.Add(_config.UnarmedSoundPrefab);
            foreach (var pref in prefabs.Where(IsInvalidPrefab)) PrintError(pref + " is not a valid prefab!");
            SetupItems();
            Cleanup();
        }

        private static bool IsInvalidPrefab(string prefab)
        {
            return !StringPool.toString.Values.Contains(prefab);
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("Suicide Vest", _data);
            if (_data.Vests.Count < 1)
            {
                Unsubscribe("OnPlayerInput");
                Unsubscribe("OnPlayerDie");
                if (_config.ExplodeWhenShot) Unsubscribe("OnEntityTakeDamage");
            }
            else if (_data.Vests.Count == 1)
            {
                Subscribe("OnPlayerInput");
                Subscribe("OnPlayerDie");
                if (_config.ExplodeWhenShot) Subscribe("OnEntityTakeDamage");
            }
        }

        private void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionUse) ||
                !input.WasJustReleased(BUTTON.FIRE_THIRD) || !input.WasDown(BUTTON.SPRINT) || !HasVest(player)) return;

            if (_armed.Contains(player))
            {
                if (!_config.Unarm) return;

                long cooldown;
                if (!_cooldowns.TryGetValue(player, out cooldown))
                {
                    AddCooldown(player);
                }
                else
                {
                    if (cooldown > DateTime.Now.Ticks) return;
                    AddCooldown(player);
                }

                Unarm(player);
            }
            else
            {
                Arm(player);
            }
        }

        private void AddCooldown(BasePlayer player)
        {
            _cooldowns[player] = DateTime.Now.Ticks + TimeSpan.FromSeconds(_config.UnarmCooldown).Ticks;
        }

        private static Vector3 GetBody(BasePlayer player)
        {
            var pos = player.eyes.position;
            pos.y -= 1;
            return pos;
        }

        private void OnPlayerDie(BasePlayer player)
        {
            if (!_armed.Contains(player)) return;

            if (_config.ExplodeOnDeath)
            {
                Explode(player);
                _armed.Remove(player);
            }
            else
            {
                Unarm(player);
            }
        }

        private object CanMoveItem(Item item)
        {
            var player = item.GetOwnerPlayer();
            if (player == null) return null;

            if (!_armed.Contains(player) || !_data.Vests.Contains(item.uid)) return null;
            SendReply(player, lang.GetMessage("CannotMoveWhilstArmed", this, player.UserIDString));
            return false;
        }

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            var player = entity as BasePlayer;

            if (player == null || !_armed.Contains(player)) return;
            var p = info.Initiator as BasePlayer;
            if (p == null) return;
            if (info.boneName != "chest" || info.damageTypes.types[9] < 1f) return;
            Explode(player);
        }

        private static HashSet<Item> GetBoxItems()
        {
            var returnList = new HashSet<Item>();

            var boxes = Resources.FindObjectsOfTypeAll<StorageContainer>();
            foreach (var box in boxes)
            {
                if (box == null || box.inventory?.itemList == null) continue;

                foreach (var item in box.inventory.itemList) returnList.Add(item);
            }

            return returnList;
        }

        private static IEnumerable<Item> GetContainerItems(ItemContainer container)
        {
            var returnList = new HashSet<Item>();

            foreach (var item in container.itemList) returnList.Add(item);

            return returnList;
        }

        private IEnumerable<Item> GetEntityItems()
        {
            var returnList = new HashSet<Item>();
            var entities = BaseNetworkable.serverEntities.ToList();
            foreach (var a in entities.Cast<BaseEntity>()
                .Where(x => x != null && x.GetItem() != null && _data.Vests.Contains(x.GetItem().uid)))
                returnList.Add(a.GetItem());
            return returnList;
        }

        private static IEnumerable<Item> GetPlayerItems()
        {
            var returnList = new HashSet<Item>();

            var players = new HashSet<BasePlayer>(BasePlayer.activePlayerList);
            players.UnionWith(BasePlayer.sleepingPlayerList);

            foreach (var player in players)
            {
                returnList.UnionWith(GetContainerItems(player.inventory.containerMain));
                returnList.UnionWith(GetContainerItems(player.inventory.containerBelt));
                returnList.UnionWith(GetContainerItems(player.inventory.containerWear));
            }

            return returnList;
        }

        private void Arm(BasePlayer player)
        {
            SendReply(player, string.Format(lang.GetMessage("Armed", this, player.UserIDString), _config.Delay));
            _armed.Add(player);

            Effect.server.Run(_config.ArmedSoundPrefab, player.transform.position);
            if (_timers.ContainsKey(player))
            {
                _timers[player].Destroy();
                _timers.Remove(player);
            }

            _timers.Add(player, timer.In(_config.Delay, delegate
            {
                if (!_armed.Contains(player)) return;
                _armed.Remove(player);
                Explode(player);
            }));
        }

        private void Explode(BasePlayer player)
        {
            var vest = GetVest(player);
            if (vest != null)
            {
                vest.RemoveFromContainer();
                vest.RemoveFromWorld();
            }

            var pos = GetBody(player);
            foreach (var pref in _config.ExplosionPrefab) Effect.server.Run(pref, pos);

            if (_config.ExplosionDamage > 0)
            {
                var all = new List<BaseCombatEntity>();

                Vis.Entities(pos, _config.ExplosionRadius, all);

                foreach (var entity in all.ToList())
                {
                    if (entity == null || !(entity.health > 0)) continue;
                    var a = entity.health;
                    entity.Hurt(new HitInfo(player, entity, DamageType.Explosion, _config.ExplosionDamage));
                    var p = entity as BasePlayer;
                    if (p == null || Math.Abs(p.health - a) < 0.1) continue;
                    p.metabolism.bleeding.value += _config.BleedingAfterDamage;
                    Interface.CallHook("OnRunPlayerMetabolism", p.metabolism);
                }
            }

            if (vest != null) _data.Vests.Remove(vest.uid);
            SaveData();
        }

        private void Unarm(BasePlayer player)
        {
            SendReply(player, lang.GetMessage("UnArmed", this, player.UserIDString));
            _armed.Remove(player);
            Effect.server.Run(_config.UnarmedSoundPrefab, player.transform.position);
            Timer playerTimer;
            if (!_timers.TryGetValue(player, out playerTimer)) return;
            playerTimer.Destroy();
            _timers.Remove(player);
        }

        private bool HasVest(BasePlayer player)
        {
            return player.inventory.containerWear.itemList.Find(x => _data.Vests.Contains(x.uid)) != null;
        }

        private Item GetVest(BasePlayer player)
        {
            return player.inventory.containerWear.itemList.Find(x => _data.Vests.Contains(x.uid));
        }

        [ConsoleCommand("givevest")]
        private void ConsoleCmd(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;

            if (arg.Args.Length < 1)
            {
                arg.ReplyWith(lang.GetMessage("InvalidPlayer", this));
                return;
            }

            var player = BasePlayer.Find(arg.GetString(0));
            if (player == null)
            {
                arg.ReplyWith(lang.GetMessage("InvalidPlayer", this));
                return;
            }

            var vestItem = ItemManager.CreateByName(_config.Item, 1, _config.SkinID);
            if (vestItem == null)
            {
                PrintError("Vest item is NULL! Please fix your configuration.");
                return;
            }

            vestItem.name = _config.Name;
            player.GiveItem(vestItem);

            _data.Vests.Add(vestItem.uid);
            SaveData();
        }

        private void SetupItems()
        {
            var list = GetBoxItems();
            list.UnionWith(GetPlayerItems());
            list.UnionWith(GetEntityItems());
            foreach (var item in list.Where(x => _data.Vests.Contains(x.uid)))
            {
                item.name = _config.Name;
                item.skin = _config.SkinID;
                item.MarkDirty();
            }
        }

        private void Unload()
        {
            var list = GetBoxItems();
            list.UnionWith(GetPlayerItems());
            list.UnionWith(GetEntityItems());
            foreach (var item in list.Where(x => _data.Vests.Contains(x.uid)))
            {
                item.name = string.Empty;
                item.skin = 0;
                item.MarkDirty();
            }
        }

        private void OnServerSave()
        {
            Cleanup();
        }

        private void Cleanup()
        {
            var list = GetBoxItems();
            list.UnionWith(GetPlayerItems());
            list.UnionWith(GetEntityItems());
            for (var z = 0; z < _data.Vests.Count; z++)
            {
                var vest = _data.Vests[z];
                if (list.FirstOrDefault(x => x.uid == vest) == null) _data.Vests.Remove(vest);
            }

            SaveData();
        }

        private object OnItemAction(Item item, string action, BasePlayer player)
        {
            if (action != "drop" || !_data.Vests.Contains(item.uid) || !_armed.Contains(player)) return null;
            SendReply(player, lang.GetMessage("CannotMoveWhilstArmed", this, player.UserIDString));
            return false;
        }

        private void ChatCmd(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionGive))
            {
                SendReply(player, lang.GetMessage("NoPermission", this, player.UserIDString));
            }
            else
            {
                BasePlayer target;
                target = args.Length < 1 ? player : BasePlayer.Find(args[0]);

                if (player == null)
                {
                    SendReply(player, lang.GetMessage("InvalidPlayer", this, player.UserIDString));
                    return;
                }

                var vestItem = ItemManager.CreateByName(_config.Item, 1, _config.SkinID);
                if (vestItem == null)
                {
                    PrintError("Vest item is NULL! Please fix your configuration.");
                    return;
                }

                vestItem.name = _config.Name;
                target.GiveItem(vestItem);

                _data.Vests.Add(vestItem.uid);
                SaveData();

                SendReply(player,
                    string.Format(lang.GetMessage("VestGiveSuccess", this, player.UserIDString), target.displayName));
            }
        }

        #endregion

        #region Configuration & Language

        private ConfigFile _config;

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Armed", "You have armed your vest and it will explode in {0} seconds."},
                {"UnArmed", "You have unarmed your vest."},
                {"CannotMoveWhilstArmed", "You cannot move your vest whilst it's armed!"},
                {"NoPermission", "No permission!"},
                {"InvalidPlayer", "Invalid player!"},
                {"VestGiveSuccess", "You have given {0} a suicide vest"}
            }, this);
        }

        private class Data
        {
            public List<uint> Vests { get; } = new List<uint>();
        }

        public class ConfigFile
        {
            [JsonProperty("Vest armed sound (prefab)")]
            public string ArmedSoundPrefab;

            [JsonProperty("Bleeding Damage")] public float BleedingAfterDamage;

            [JsonProperty("Count down after armed (seconds)")]
            public int Delay;

            [JsonProperty("Explode when a user dies with an armed vest?")]
            public bool ExplodeOnDeath;

            [JsonProperty("Explode when a user shoots the vest?")]
            public bool ExplodeWhenShot;

            [JsonProperty("Explosion Damage")] public float ExplosionDamage;

            [JsonProperty("Effect prefabs")] public List<string> ExplosionPrefab;

            [JsonProperty("Explosion Radius")] public float ExplosionRadius;

            [JsonProperty("Vest Item (Shortname)")]
            public string Item;

            [JsonProperty("Vest Name")] public string Name;

            [JsonProperty("Vest Skin ID")] public ulong SkinID;

            [JsonProperty("Ability to unarm")] public bool Unarm;

            [JsonProperty("Unarm Cooldown (seconds)")]
            public long UnarmCooldown;

            [JsonProperty("Vest unarmed sound (prefab)")]
            public string UnarmedSoundPrefab;

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    Item = "metal.plate.torso",
                    SkinID = 0,
                    Name = "Suicide Vest",
                    Delay = 10,
                    Unarm = false,
                    ExplosionPrefab = new List<string>
                    {
                        "assets/bundled/prefabs/fx/gas_explosion_small.prefab",
                        "assets/bundled/prefabs/fx/explosions/explosion_03.prefab"
                    },
                    ArmedSoundPrefab = "assets/prefabs/locks/keypad/effects/lock.code.updated.prefab",
                    UnarmedSoundPrefab = "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab",
                    ExplodeOnDeath = true,
                    UnarmCooldown = 3,
                    ExplosionRadius = 3f,
                    ExplosionDamage = 75f,
                    BleedingAfterDamage = 10f,
                    ExplodeWhenShot = true
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if (_config == null) LoadDefaultConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        #endregion
    }
}
//Generated with birthdates' Plugin Maker

// --- End of file: SuicideVest.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/safe-recycler ---
// --- Original File Path: S/SafeRecycler/SafeRecycler.cs ---

using UnityEngine;
using Oxide.Game.Rust.Cui;
using System.Collections.Generic;


namespace Oxide.Plugins
{
    [Info("Safe Recycler", "Hovmodet", "1.0.1")]
    [Description("Prevents players from getting pushed away from recyclers in safezones.")]
    public class SafeRecycler : RustPlugin
    {
        const string InvisChair = "assets/prefabs/vehicle/seats/standingdriver.prefab";
        List<BasePlayer> RecyclingPlayers = new List<BasePlayer>();
        private const string UsePermission = "saferecycler.use";

        private void Init()
        {
            permission.RegisterPermission(UsePermission, this);
        }

        void OnLootEntity(BasePlayer player, Recycler recycler)
        {
            if (!permission.UserHasPermission(player.userID.ToString(), "saferecycler.use"))
                return;

            if (!player.InSafeZone())
                return;

            RecyclingPlayers.Add(player);
            CuiHelper.AddUi(player, CreateUI_recyclerLock());
            CuiHelper.AddUi(player, AddButton(player));

        }
        void OnLootEntityEnd(BasePlayer player, Recycler recycler)
        {
            if(RecyclingPlayers.Contains(player))  
                RecyclingPlayers.Remove(player);

            UnlockFromRecycler(player);
            CuiHelper.DestroyUi(player, "SafeRecycler_UI");
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LockText"] = "Lock <color=red></color>",
                ["UnlockText"] = "Unlock <color=#93f542></color>"
            }, this);
        }

        private void LockToRecycler(BasePlayer player)
        {
            if (!player.IsOnGround())
                return;

            if (!RecyclingPlayers.Contains(player))
                return;

            if (!player.isMounted)
            {
                var rot = player.GetNetworkRotation().eulerAngles;
                BaseMountable chair = SpawnChair(player.transform.position, Quaternion.Euler(0, rot.y, rot.z));
                player.MountObject(chair);
                chair.mountPose = PlayerModel.MountPoses.Standing;
                chair.MountPlayer(player);
                CuiHelper.DestroyUi(player, "btn_lock");
                CuiHelper.AddUi(player, AddButton(player));
            }
            else
                UnlockFromRecycler(player);
        }

        private void UnlockFromRecycler(BasePlayer player)
        {
            BaseMountable chair = player.GetMounted();
            if (chair == null)
                return;

            DismountSafely(player, chair);

            NextTick( () =>{
                chair.Kill(BaseNetworkable.DestroyMode.None);
            });
            CuiHelper.DestroyUi(player, "btn_lock");
            CuiHelper.AddUi(player, AddButton(player));
        }

        BaseMountable SpawnChair(Vector3 pos, Quaternion rotation)
        {
            var entity = GameManager.server.CreateEntity(InvisChair, pos, rotation);
            entity.Spawn();
            return (BaseMountable)entity;
        }

        [ConsoleCommand("locktorecycler")]
        private void Locktorecycler(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            LockToRecycler(player);
        }

        private void DismountSafely(BasePlayer player, BaseMountable chair)
        {
            chair._mounted.DismountObject();
            chair._mounted.transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);
            chair._mounted.MovePosition(player.transform.position);
            chair._mounted.SendNetworkUpdateImmediate();
            chair._mounted.SendModelState(true);
            chair._mounted = null;
            player.ForceUpdateTriggers();
            if ((bool)(UnityEngine.Object)player.GetParentEntity())
            {
                BaseEntity parentEntity = player.GetParentEntity();
                player.ClientRPCPlayer<Vector3, uint>(null, player, "ForcePositionToParentOffset", parentEntity.transform.InverseTransformPoint(player.transform.position), parentEntity.net.ID);
            }
            else
                player.ClientRPCPlayer<Vector3>(null, player, "ForcePositionTo", player.transform.position);
        }

        private CuiElementContainer AddButton(BasePlayer player)
        {
            bool locked = player.isMounted;
            string txt = lang.GetMessage("LockText", this, player.UserIDString);
            if (locked)
                txt = lang.GetMessage("UnlockText", this, player.UserIDString);
            CuiElementContainer elements = new CuiElementContainer();
            elements.Add(new CuiButton
            {
                Button =
                {
                    Color = "0.39 0.3 0.39 0",
                    Command = "locktorecycler"
                },
                RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 1",
                },
                Text =
                {
                    Text = txt,
                    Align = TextAnchor.MiddleLeft,
                    Color = "1 1 1 1",
                    FontSize = 12,
                }
            }, "SafeRecycler_UI", "btn_lock");
            return elements;
        }

        private static CuiElementContainer CreateUI_recyclerLock()
        {
            CuiElementContainer elements = new CuiElementContainer();

            elements.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0.9 0.519", AnchorMax = "0.9463 0.546" }
            }, "Hud.Menu", "SafeRecycler_UI");
            return elements;
        }

    }

}

// --- End of file: SafeRecycler.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/simple-gambling ---
// --- Original File Path: S/SimpleGambling/SimpleGambling.cs ---

using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

/*
 * This update 1.4.0
 * Updated to Covalence plugin
 * Added admin permission
 * Commands are both chat and console commands.
 *
 * TODO
 * Add Server Rewards Support, Add UI option, Add HumanNPC Support.
 */

namespace Oxide.Plugins
{
    [Info("Simple Gambling", "Khan", "1.4.0")]
    [Description("Allows admins to create item gambling")]
    class SimpleGambling : CovalencePlugin
    {
        private const string Use = "simplegambling.allowed";
        private const string Admin = "simplegambling.admin";
        ConfigData configData;
        StoredData storedData;

        #region Classes

        class StoredData
        {
            public List<Gamble> gambles;
            public List<Preserved> preserveds;
            public List<Reward> rewards;

            public StoredData()
            {
                gambles = new List<Gamble>();
                preserveds = new List<Preserved>();
                rewards = new List<Reward>();
            }
        }

        class ConfigData
        {
            public bool preservePot;
            public bool showWinners;
        }

        public class Reward
        {
            public ulong id;
            public string item;
            public int quantity;

            public Reward(ulong id, string item, int quantity)
            {
                this.id = id;
                this.item = item;
                this.quantity = quantity;
            }
        }

        public class Gamble
        {
            public string name, item;
            public int numbers, itemAmount;
            public List<Bets> bets;
            public int preservedPot;

            public Gamble(string name, string item, int itemAmount, int numbers, int preservedPot)
            {
                this.name = name;
                this.item = item;
                this.itemAmount = itemAmount;
                this.numbers = numbers;
                this.preservedPot = preservedPot;
                bets = new List<Bets>();
            }
        }

        public class Bets
        {
            public ulong player;
            public int number;

            public Bets(ulong player, int number)
            {
                this.player = player;
                this.number = number;
            }
        }

        public class Preserved
        {
            public int amount;
            public string itemName;

            public Preserved(int amount, string itemName)
            {
                this.amount = amount;
                this.itemName = itemName;
            }
        }

        #endregion

        #region Config+Data+Lang

        private void LoadAll()
        {
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>("SimpleGamblingData");
            configData = Config.ReadObject<ConfigData>();
        }

        private void SaveAll()
        {
            Config.WriteObject(configData, true);
            Interface.Oxide.DataFileSystem.WriteObject("SimpleGamblingData", storedData);
        }

        protected override void LoadDefaultConfig()//called the first time 
        {
            ConfigData defaultConfig = new ConfigData();
            Config.WriteObject(defaultConfig, true);
        }

        private void Init()
        {
            permission.RegisterPermission(Use, this);
            permission.RegisterPermission( Admin, this);
            LoadAll();
        }

        private string Lang(string key, string id, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private new void LoadDefaultMessages()
        {
            //English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PlayerHelp"] = "type \"/gamble current\" to see current gambles or \"gamble reward\" to redeem rewards",
                ["Winners"] = "The winners are: ",
                ["AdminHelp"] = "type \"/gamble set\" or \"/gamble finish\" or \"/gamble config\" for help",
                ["ConfigHelp"] = "use \"/gamble Config Winners\" and TRUE or FALSE to show winner's names on chat when a gamble finishes\n\nuse \"/gamble Config PreservePot\" and TRUE or FALSE to preserve all betted items and add them to the next gamble",
                ["WinnersValues"] = "INVALID VALUE\nshould winner's names be printed on chat?\nvalues TRUE or FALSE",
                ["PreserveValues"] = "INVALID VALUE\nshould the pot be preserved for the next bet if there is no winner?\nvalues TRUE or FALSE",
                ["ConfigChanged"] = "{0} set to {1}",
                ["ItemNotFound"] = "{0} is not a valid item shortname",
                ["GambleNotFound"] = "gamble not found",
                ["DontHavePermission"] = "<color=#00ffffff>[Simple Gambling]</color> You do not have permission to use this command",
                ["NewGamble"] = "A gambling has just started, type \"/gamble play {0} \" and a number from 1 to {1}, to bet {2} {3}",
                ["CurrentGambles"] = "{0} gambling haves {1} items on the pool, type \"/gamble play {2} \" and a number from 1 to {3} to bet {4} {5}",
                ["NoGambles"] = "There are no current gambles",
                ["ValidNumbers"] = "Valid numbers from 1 to {0}",
                ["InvalidItemAmount"] = "Item amount can not be greater than the item stack limit or less than 1",
                ["AlreadyBet"] = "You have already bet",
                ["GamblingFinished"] = "{0} gambling finished! number {1} won, the loot will be shared between {2} players",
                ["GamblingFinishedNoWinner"] = "{0} gambling finished but no one won! the number was {1}",
                ["ExistingGamble"] = "There is already a gamble with that name",
                ["GambleCreated"] = "{0} gamble created",
                ["BetPlaced"] = "your bet in {0} has been placed",
                ["NotEnoughItems"] = "Yo do not have enough items to bet",
                ["InvalidNumbers"] = "numbers should be greater than 1",
                ["SetHelp"] = "\"/gamble Set gambleName itemName itemAmount numbers\"\ngambleName can be anything but just use 1 word\nitemName must be the shortname of the item\nitemAmount is the amount of items you need to have to play\nnumbers is the amount of numbers you can bet on\n\nFor example: \"/gamble set Rockets ammo.rocket.basic 3 20\"\nplayers will be able to bet 3 rocket on numbers from 1 to 20",
                ["FinishHelp"] = "use \"/gamble Finish gambleName\" to finish a gambling\nFor example \"/gamble finish Rockets\"",
                ["RewardReceived"] = "Rewards Received!",
                ["RewardInventorySpace"] = "You do not have enough space in your inventory",
                ["NoRewards"] = "There are no available rewards"
            }, this);
        }

        #endregion

        #region Helper Methods
        
        private void PrintToChat(string format, params object[] args)
        {
            if (BasePlayer.active