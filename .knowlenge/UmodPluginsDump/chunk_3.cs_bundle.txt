");
            } 
            /*
            if (!configData.CannibalS.Eat.FoodItems.ContainsKey("water.barrel"))
            {
                configData.CannibalS.Eat.FoodItems.Add("water.barrel" , true);
                Puts($"water.barrel added to food items");
            }
            if (!configData.CannibalS.Eat.FoodItems.ContainsKey("vehicle.2mod.fuel.tank"))
            {
                configData.CannibalS.Eat.FoodItems.Add("vehicle.2mod.fuel.tank" , true);
                Puts($"vehicle.2mod.fuel.tank added to food items");
            }
            if (!configData.CannibalS.Eat.FoodItems.ContainsKey("botabag"))
            {
                configData.CannibalS.Eat.FoodItems.Add("botabag" , false);
                Puts($"botabag added to food items");
            }
            */
            SaveConf();
        }

        #endregion

        #region API

        public T GetCannibalData<T>(IPlayer player , string dataType)
        {
            if (player == null)
            {
                Puts("Error: Player object is null.");
                return default(T);
            }

            if (dataFile == null)
            {
                LoadData();
            }

            string playerId = player.Id;

            if (dataFile.Players.ContainsKey(playerId))
            {
                PlayerData playerData = dataFile.Players[playerId];

                switch (dataType.ToLower())
                {
                    case "totaltimeascannibal":
                        return (T)Convert.ChangeType(playerData.TotalTimeAsCannibal , typeof(T));
                    case "humanmeatconsumed":
                        return (T)Convert.ChangeType(playerData.HumanMeatConsumed , typeof(T));
                    case "humanskilled":
                        return (T)Convert.ChangeType(playerData.HumansKilled , typeof(T));
                    case "cannibalskilled":
                        return (T)Convert.ChangeType(playerData.CannibalsKilled , typeof(T));
                    case "animalskilled":
                        return (T)Convert.ChangeType(playerData.AnimalsKilled , typeof(T));
                    case "npckilled":
                        return (T)Convert.ChangeType(playerData.NpcKilled , typeof(T));
                    case "woodcollected":
                        return (T)Convert.ChangeType(playerData.WoodCollected , typeof(T));
                    case "stonecollected":
                        return (T)Convert.ChangeType(playerData.StoneCollected , typeof(T));
                    case "sulfurcollected":
                        return (T)Convert.ChangeType(playerData.SulfurCollected , typeof(T));
                    case "metalcollected":
                        return (T)Convert.ChangeType(playerData.MetalCollected , typeof(T));
                    case "hqmcollected":
                        return (T)Convert.ChangeType(playerData.HQMCollected , typeof(T));
                    default:
                        Puts($"Invalid data type: {dataType}");
                        break;
                }
            }
            else
            {
                Puts($"{player.Name}'s data not found.");
            }
            return default(T);
        }

        public T GetCannibalLifeTimeData<T>(IPlayer player , string dataType)
        {
            if (cannibalLifeTimeDataFile == null) LoadCannibalLifeTimeData();

            string playerId = player.Id;

            if (cannibalLifeTimeDataFile.CannibalLifeTime.ContainsKey(playerId))
            {
                CannibalLifeTimeData lifetimeData = cannibalLifeTimeDataFile.CannibalLifeTime[playerId];

                switch (dataType.ToLower())
                {
                    case "canniballifetime":
                        return (T)Convert.ChangeType(lifetimeData.CannibalLifeTime , typeof(T));
                    case "humanmeatconsumed":
                        return (T)Convert.ChangeType(lifetimeData.HumanMeatConsumed , typeof(T));
                    case "humanskilled":
                        return (T)Convert.ChangeType(lifetimeData.HumansKilled , typeof(T));
                    case "cannibalskilled":
                        return (T)Convert.ChangeType(lifetimeData.CannibalsKilled , typeof(T));
                    case "animalskilled":
                        return (T)Convert.ChangeType(lifetimeData.AnimalsKilled , typeof(T));
                    case "npckilled":
                        return (T)Convert.ChangeType(lifetimeData.NpcKilled , typeof(T));
                    case "woodcollected":
                        return (T)Convert.ChangeType(lifetimeData.WoodCollected , typeof(T));
                    case "stonecollected":
                        return (T)Convert.ChangeType(lifetimeData.StoneCollected , typeof(T));
                    case "sulfurcollected":
                        return (T)Convert.ChangeType(lifetimeData.SulfurCollected , typeof(T));
                    case "metalcollected":
                        return (T)Convert.ChangeType(lifetimeData.MetalCollected , typeof(T));
                    case "hqmcollected":
                        return (T)Convert.ChangeType(lifetimeData.HQMCollected , typeof(T));
                    default:
                        Puts($"Invalid data type: {dataType}");
                        break;
                }
            }
            else
            {
                Puts($"{player.Name}'s lifetime data not found.");
            }
            return default(T);
        }

        public bool IsCannibal(BasePlayer player)
        {
            if (player == null)return false;
            IPlayer iplayer = covalence.Players.FindPlayerById(player.UserIDString);
            if (iplayer == null) return false;
            return IsCannibal(iplayer);
        }

        public bool IsCannibal(IPlayer player)
        {
            if (dataFile == null) LoadData();
            string playerId = player.Id;
            bool isCannibal = dataFile.Players.ContainsKey(playerId);
            return isCannibal;
        }

        public double GetTotalCannibalTime(IPlayer player)
        {
            if (player == null)
            {
                return 0.0;
            }

            double currentTime = GetCannibalTime(player);
            double storedTime = GetCannibalLifeTime(player);
            return currentTime + storedTime;
        }

        public double GetCannibalLifeTime(IPlayer player)
        {
            if (cannibalLifeTimeDataFile == null)
            {
                LoadCannibalLifeTimeData();
            }

            if (cannibalLifeTimeDataFile != null && cannibalLifeTimeDataFile.CannibalLifeTime.TryGetValue(player.Id , out CannibalLifeTimeData cannibalLifeTimeData))
            {
                return cannibalLifeTimeData.CannibalLifeTime;
            }
            return 0.0;
        }

        public double GetCannibalTime(BasePlayer player)
        {
            IPlayer iplayer = covalence.Players.FindPlayerById(player.UserIDString);
            return GetCannibalTime(iplayer);
        }

        public double GetCannibalTime(IPlayer player)
        {
            string playerId = player.Id;

            if (dataFile.Players.ContainsKey(playerId))
            {
                return dataFile.Players[playerId].TotalTimeAsCannibal;
            }
            return 0.0;
        }

        public int CountCannibals()
        {
            if (dataFile == null) LoadData();
            return dataFile.Players.Count;
        }

        public int CountOnlineCannibals()
        {
            if (dataFile == null) LoadData();
            int onlineCannibalCount = 0;
            foreach (IPlayer player in players.Connected)
            {
                if (IsCannibal(player))
                {
                    onlineCannibalCount++;
                }
            }
            return onlineCannibalCount;
        }

        public void AddPlayerAsCannibal(BasePlayer player)
        {
            IPlayer iplayer = covalence.Players.FindPlayerById(player.UserIDString);
            AddPlayerAsCannibal(iplayer);
        }

        public void AddPlayerAsCannibal(IPlayer player)
        {
            AddPlayerData(player);
        }

        public void RemovePlayerFromCannibals(IPlayer player)
        {
            RemovePlayer(player);
        }

        public void RemovePlayerFromCannibals(BasePlayer player)
        {
            IPlayer iplayer = covalence.Players.FindPlayerById(player.UserIDString);
            RemovePlayer(iplayer);
        }
        #endregion

        #region CUI HUD

        void DestroyCannibalHuds(BasePlayer player)
        {
            CuiHelper.DestroyUi(player , "CannibalUI");
        }

        [Command("CannibalHudClose")]
        private void CannibalHudClose(IPlayer player , string command , string[] args)
        {
            if (player == null) return;
            BasePlayer basePlayer = player.Object as BasePlayer;
            DestroyCannibalHuds(basePlayer);
            textRefreshTimer.Destroy();
            CuiHelper.DestroyUi(basePlayer , "CannibalUITimerPanel_" + basePlayer.userID);
        }

        void Cannibalhud(BasePlayer player)
        {
            DestroyCannibalHuds(player);
            // Define colors
            string CannibalMeat = "1 1 1 0.8";
            if (IsCannibal(player)) CannibalMeat = "1 0 0 0.8";//red
            var elements = new CuiElementContainer();

            // Main panel for the CannibalUI
            var mainPanel = elements.Add(new CuiPanel
            {
                Image = { Color = $"0 0 0 0" } ,
                RectTransform = { AnchorMin = configData.Settings.Anchormin , AnchorMax = configData.Settings.Anchormax } ,
                CursorEnabled = false
            } , "Under" , "CannibalUI");

            // Counter panel inside CannibalUI
            var counterPanel = elements.Add(new CuiPanel
            {
                Image = { Color = "1 1 1 0" } ,
                RectTransform = { AnchorMin = "0 0" , AnchorMax = "1 1" } ,
                CursorEnabled = false
            } , mainPanel , "CounterPanel");
            // Add the icons
            AddIconElement(elements , "CounterPanel" , cannibalicon , "0 0" , "35 35" , CannibalMeat);
            AddIconElement(elements , "CounterPanel" , "assets/icons/stopwatch.png" , "35 4" , "60 31" , "1 1 1 0.8");

            CuiHelper.AddUi(player , elements);
            ShowCannibalTimer(player);
        }

        void AddTextElement(CuiElementContainer elements , string parent , string text , string offset)
        {
            elements.Add(new CuiElement
            {
                Parent = parent ,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = text,
                        FontSize = 12,
                        Align = TextAnchor.MiddleLeft
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 0",
                        OffsetMin = offset,
                        OffsetMax = $"{int.Parse(offset.Split(' ')[0]) + 85} {int.Parse(offset.Split(' ')[1]) + 15}"
                    }
                }
            });
        }

        void AddIconElement(CuiElementContainer elements , string parent , string sprite , string offsetMin , string offsetMax , string color)
        {
            if (sprite.Contains("assets"))
            {
                elements.Add(new CuiElement
                {
                    Parent = parent ,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Sprite = sprite,
                            Material = "assets/icons/iconmaterial.mat",
                            Color = color,
                            FadeIn = 0.0f
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = offsetMin,
                            OffsetMax = offsetMax
                        }
                    }
                });
            }
            else
            {
                elements.Add(new CuiElement
                {
                    Parent = parent ,
                    Components =
                {
                    new CuiRawImageComponent
                    {
                        Url = sprite,
                        Material = "assets/icons/iconmaterial.mat",
                        Color = color,
                        FadeIn = 0.0f
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 0",
                        OffsetMin = offsetMin,
                        OffsetMax = offsetMax
                    }
                }
                });
            }
        }

        void AddImageElement(CuiElementContainer elements , string parent , string png , string offsetMin , string offsetMax , string color)
        {
            elements.Add(new CuiElement
            {
                Parent = parent ,
                Components =
                {
                    new CuiRawImageComponent
                    {
                        Png = png,
                        Material = "assets/icons/iconmaterial.mat",
                        Color = color,
                        FadeIn = 0.0f
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 0",
                        OffsetMin = offsetMin,
                        OffsetMax = offsetMax
                    }
                }
            });
        }

        const float TimerInterval = 1f;//1 ?
        Timer textRefreshTimer;
        bool isTimerActive = false;

        void ShowCannibalTimer(BasePlayer player)
        {
            if (isTimerActive)
            {
                UpdateCannibalTimerText(player);
                if (!IsCannibal(player))
                {
                    StopCannibalTimer(player);
                }
            }
            else
            {
                textRefreshTimer = timer.Repeat(TimerInterval , 0 , () =>
                {
                    UpdateCannibalTimerText(player);
                    if (GetRemainingTime(player.userID) == "No Buff" || !IsCannibal(player))
                    {
                        StopCannibalTimer(player);
                    }
                });
                isTimerActive = true;
            }
        }

        void StopCannibalTimer(BasePlayer player)
        {
            if (textRefreshTimer != null && !textRefreshTimer.Destroyed)
            {
                textRefreshTimer.Destroy();
            }
            DestroyCannibalTimerPanel(player);
            textRefreshTimer = null;
            isTimerActive = false;
        }

        void UpdateCannibalTimerText(BasePlayer player)
        {
            string color = "1 1 1 1";

            int remainingTime = totalBoostDurations.TryGetValue(player.userID , out var time) ? time : 0;
            if (remainingTime <= 0)
            { 
                return;
            }

            if (remainingTime <= 30 && remainingTime >= 10)
            {
                color = HexToCuiColor("#00FF00");// Green
            }

            if (remainingTime <= 10 && remainingTime >= 1)
            {
                color = HexToCuiColor("#FF0000");// Red
            }

            string remainingTimeString = GetRemainingTime(player.userID);
            CuiHelper.DestroyUi(player , "CannibalUITimerPanel_" + player.userID);
            CuiHelper.AddUi(player , new List<CuiElement>
            {
                new CuiElement
                {
                    Parent = "CounterPanel",
                    Name = "CannibalUITimerPanel_" + player.userID,
                    Components =
                    {
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0" ,
                            AnchorMax = "1 1",
                            OffsetMin = "65 0",
                            OffsetMax = "240 0"
                        },
                        new CuiTextComponent
                        {
                            Text = remainingTimeString,
                            FontSize = 16,
                            Color = color,
                            Align = TextAnchor.MiddleLeft
                        }
                    }
                }
            });
        }

        void DestroyCannibalTimerPanel(BasePlayer player)
        {
            var panelName = "CannibalUITimerPanel_" + player.userID;
            CuiHelper.DestroyUi(player , panelName);
        }

        string GetRemainingTime(ulong userID)
        {
            if (textRefreshTimer == null || textRefreshTimer.Destroyed)
            {
                return "No Buff";
            }
            int remainingTime = totalBoostDurations.TryGetValue(userID , out var time) ? time : 0;
            return remainingTime > 0 ? $"{FormatTime(remainingTime)}" : "No Buff";
        }

        #endregion

        #region CUI Info Panel
        int currentPage = 1; // Set the default page

        private void CannibalinfoPanel(IPlayer iPlayer)
        {
            if (iPlayer.Object is BasePlayer basePlayer)
            {
                var container = new CuiElementContainer();
                var TitleColor = HexToCuiColor("#0077b5");

                CuiHelper.DestroyUi(basePlayer , "MainPanel");
                // Create the main panel
                var mainPanel = container.Add(new CuiPanel
                {
                    Image = { Color = "1 1 1 0.3" } ,
                    RectTransform = { AnchorMin = "0.1 0.1" , AnchorMax = "0.9 0.9" } ,
                    CursorEnabled = true
                } , "Overlay" , "MainPanel");
                if (configData.Settings.UseBloody)
                {
                    container.Add(new CuiElement
                    {
                        Parent = "MainPanel" ,
                        Components =
                    {
                        new CuiRawImageComponent
                        {
                            Sprite = "assets/content/ui/overlay_bleeding.png",
                            Material = "assets/icons/iconmaterial.mat",
                            Color = "1 0 0 0.65",
                            FadeIn = 0.0f
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1"
                        }
                    }
                    });

                }

                container.Add(new CuiPanel { Image = { Color = "1 0 0 0.8"} , RectTransform = { AnchorMin = $"0.005 0.873" , AnchorMax = $"0.995 0.876" } } , mainPanel);

                switch (currentPage)
                {
                    case 1:
                        CreatePage1(ref container , mainPanel , iPlayer);
                        break;
                    case 2:
                        CreatePage2(ref container , mainPanel , iPlayer);
                        break;
                    case 3:
                        CreatePage3(ref container , mainPanel , iPlayer);
                        break;
                    case 4:
                        CreatePage4(ref container , mainPanel , iPlayer);
                        break;
                }

                //Create the Title
                AddTextWithOutline(container , Translate(iPlayer , "InfoTitle") , 42 , "0 0.80" , "1 0.99" , TextAnchor.UpperCenter , mainPanel);

                // Create the close button
                AddTextWithOutline(container , $"<color=red>{Translate(iPlayer , "InfoClose")}</color>" , 16 , "0.025 0.85" , "0.07 0.90" , TextAnchor.MiddleCenter , mainPanel);
                container.Add(new CuiButton
                {
                    Button = { Command = "ui.close MainPanel" , Color = "1 0 0 0" , FadeIn = 0.0f } ,
                    RectTransform = { AnchorMin = "0.025 0.85" , AnchorMax = "0.07 0.90" } ,
                    Text = { Text = "" , FontSize = 16 , Align = TextAnchor.MiddleCenter }
                } , mainPanel);
                AddTextWithOutline(container , $"<color=white>{Translate(iPlayer , "InfoMain")}</color>" , 16 , "0.08 0.85" , "0.15 0.90" , TextAnchor.MiddleCenter , mainPanel);
                container.Add(new CuiButton
                {
                    Button = { Command = "CPage1" , Color = "1 0 0 0" , FadeIn = 0.0f } ,
                    RectTransform = { AnchorMin = "0.08 0.85" , AnchorMax = "0.15 0.90" } ,
                    Text = { Text = "" , FontSize = 16 , Align = TextAnchor.MiddleCenter }
                } , mainPanel);
                AddTextWithOutline(container , $"<color=white>{Translate(iPlayer , "InfoDamage")}</color>" , 16 , "0.16 0.85" , "0.24 0.90" , TextAnchor.MiddleCenter , mainPanel);
                container.Add(new CuiButton
                {
                    Button = { Command = "CPage2" , Color = "1 0 0 0" , FadeIn = 0.0f } ,
                    RectTransform = { AnchorMin = "0.16 0.85" , AnchorMax = "0.24 0.90" } ,
                    Text = { Text = "" , FontSize = 16 , Align = TextAnchor.MiddleCenter }
                } , mainPanel);
                AddTextWithOutline(container , $"<color=white>{Translate(iPlayer , "InfoStat")}</color>" , 16 , "0.25 0.85" , "0.33 0.90" , TextAnchor.MiddleCenter , mainPanel);
                container.Add(new CuiButton
                {
                    Button = { Command = "CPage3" , Color = "1 0 0 0" , FadeIn = 0.0f } ,
                    RectTransform = { AnchorMin = "0.25 0.85" , AnchorMax = "0.33 0.90" } ,
                    Text = { Text = "" , FontSize = 16 , Align = TextAnchor.MiddleCenter }
                } , mainPanel);

                AddTextWithOutline(container , $"<color=white>{Translate(iPlayer , "InfoRankings")}</color>" , 16 , "0.34 0.85" , "0.42 0.90" , TextAnchor.MiddleCenter , mainPanel);
                container.Add(new CuiButton
                {
                    Button = { Command = "CPage4" , Color = "1 0 0 0.2" , FadeIn = 0.0f } ,
                    RectTransform = { AnchorMin = "0.34 0.85" , AnchorMax = "0.42 0.90" } ,
                    Text = { Text = "" , FontSize = 16 , Align = TextAnchor.MiddleCenter }
                } , mainPanel);

                AddTextWithOutline(container , $"<color=white>{this.Title} v{this.Version}</color>" , 12 , "0.01 0.01" , "0.99 0.05" , TextAnchor.LowerRight , mainPanel);

                CuiHelper.AddUi(basePlayer , container);
            }
        }

        void CreatePage1(ref CuiElementContainer container , string mainPanel, IPlayer player)
        {
            // Page Title
            AddTextWithOutline(container , $"<color=orange>{Translate(player , "InfoTitleMain")}</color>" , 24 , "0 0.81" , "1 0.86" , TextAnchor.MiddleCenter , mainPanel);
            // Page intro
            AddTextWithOutline(container , $"{Translate(player , "InfoWelcome")} <color=orange>{player.Name}</color>." , 16 , "0 0.77" , "1 0.81" , TextAnchor.MiddleCenter , mainPanel);
            // Left panel
            var panel = container.Add(new CuiPanel
            {
                Image = { Color = "0.1 0.1 0.1 0.45" } ,
                RectTransform = { AnchorMin = $"0.05 0.05" , AnchorMax = $"0.45 0.76" } ,
                CursorEnabled = true
            } , mainPanel , "Main1");
            container.Add(new CuiElement
            {
                Parent = "Main1" ,
                Components =
                    {
                        new CuiRawImageComponent
                        {
                            Sprite = cannibalicon,
                            Material = "assets/icons/iconmaterial.mat",
                            Color = "1 1 1 0.2",
                            FadeIn = 0.0f
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-200 -200",
                            OffsetMax = "200 200"
                        }
                    }
            });
            container.Add(new CuiPanel { Image = { Color = "0 0 0 0.8" } , RectTransform = { AnchorMin = $"0 0.945" , AnchorMax = $"1 1" } } , panel);
            AddTextWithOutline(container , $"<color=white>{Translate(player , "InfoMainLeftPanelTitle")}</color>" , 16 , "0 0.945" , "1 1" , TextAnchor.MiddleCenter , "Main1");
            var height = 0.93;
            var heightlow = 0.89;
            AddTextWithOutline(container , Translate(player , "InfoMainLeftPanel") , 14 , "0.025 0.025" , $"0.975 {heightlow - 0.01}" , TextAnchor.UpperLeft , "Main1");

            // Right panel
            var panel2 = container.Add(new CuiPanel
            {
                Image = { Color = "0.1 0.1 0.1 0.45" } ,
                RectTransform = { AnchorMin = $"0.55 0.05" , AnchorMax = $"0.95 0.76" } ,
                CursorEnabled = true
            } , mainPanel , "Main2a");
            container.Add(new CuiElement
            {
                Parent = "Main2a" ,
                Components =
                    {
                        new CuiRawImageComponent
                        {
                            Sprite = cannibalicon,
                            Material = "assets/icons/iconmaterial.mat",
                            Color = "1 1 1 0.2",
                            FadeIn = 0.0f
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-200 -200",
                            OffsetMax = "200 200"
                        }
                    }
            });
            container.Add(new CuiPanel { Image = { Color = "0 0 0 0.8" } , RectTransform = { AnchorMin = $"0 0.945" , AnchorMax = $"1 1" } } , panel2);
            AddTextWithOutline(container , $"<color=white>{Translate(player , "InfoCmdInfoTitle")}</color>" , 16 , "0 0.945" , "1 1" , TextAnchor.MiddleCenter , "Main2a");
            height = 0.93;
            heightlow = 0.89;
            AddChatCommandsText(container , Translate(player , "/cannibal info") , Translate(player , "InfoCmdInfo") , ref height , ref heightlow);
            AddChatCommandsText(container , Translate(player , "/cannibal start") , $"<color=green>{Translate(player , "InfoCmdStart")}</color>" , ref height , ref heightlow);
            AddChatCommandsText(container , Translate(player , "/cannibal end") , $"<color=green>{Translate(player , "InfoCmdEnd")}</color>" , ref height , ref heightlow);
            AddChatCommandsText(container , Translate(player , "/cannibal time") , Translate(player , "InfoCmdTime") , ref height , ref heightlow);
            AddChatCommandsText(container , Translate(player , "/cannibal total") , $"<color=orange>{Translate(player , "InfoCmdTotal")}</color>" , ref height , ref heightlow);
            AddChatCommandsText(container , Translate(player , "/cannibal online") , $"<color=orange>{Translate(player , "InfoCmdOnline")}</color>" , ref height , ref heightlow);
            AddTextWithOutline(container , Translate(player , $"{Translate(player , "All")} <color=green>{Translate(player , "Permission")}</color> <color=orange>{Translate(player , "Admin")}</color>") , 14 , $"0.025 {heightlow}" , $"0.975 {height}" , TextAnchor.UpperLeft , "Main2a");
            height -= 0.05;
            heightlow -= 0.05;

            //InfoGatheringDescription
            container.Add(new CuiPanel { Image = { Color = "0 0 0 0.8" } , RectTransform = { AnchorMin = $"0 {heightlow - 0.01}" , AnchorMax = $"1 {height}" } } , panel2);
            AddTextWithOutline(container , $"<color=white>{Translate(player , "InfoGatheringTitle")}</color>" , 16 , $"0 {heightlow - 0.01}" , $"1 {height}" , TextAnchor.MiddleCenter , "Main2a");
            height -= 0.08;
            heightlow -= 0.08;
            AddChatCommandsText(container , Translate(player , "Wood") , $"{configData.CannibalS.Gather.GWood * 100 - 100}% <color=white>{Translate(player , $"InfoGatheringDescription")}</color>" , ref height , ref heightlow);
            AddChatCommandsText(container , Translate(player , "Stones") , $"{configData.CannibalS.Gather.GStone * 100 - 100}% <color=white>{Translate(player , $"InfoGatheringDescription")}</color>" , ref height , ref heightlow);
            AddChatCommandsText(container , Translate(player , "Sulfur") , $"{configData.CannibalS.Gather.GSulfur * 100 - 100}% <color=white>{Translate(player , $"InfoGatheringDescription")}</color>" , ref height , ref heightlow);
            AddChatCommandsText(container , Translate(player , "Metal") , $"{configData.CannibalS.Gather.GMetal * 100 - 100}% <color=white>{Translate(player , $"InfoGatheringDescription")}</color>" , ref height , ref heightlow);
            AddChatCommandsText(container , Translate(player , "HQM") , $"{configData.CannibalS.Gather.GHQM * 100 - 100}% <color=white>{Translate(player , $"InfoGatheringDescription")}</color>" , ref height , ref heightlow);
            AddChatCommandsText(container , Translate(player , "InfoStatMeats") , $"<color=white>{Translate(player , "N/a")}</color>" , ref height , ref heightlow);
        }

        void CreatePage2(ref CuiElementContainer container , string mainPanel ,IPlayer player)
        {
            AddTextWithOutline(container , $"<color=orange>{Translate(player , "InfoWeaponTitle")}</color>" , 24 , "0 0.81" , "1 0.86" , TextAnchor.MiddleCenter , mainPanel);
            CreateWeaponPanel(container , "InfoWeaponTitleMelee" , configData.CannibalS.Dmg.MeleeWeapons , 0 , mainPanel , player);
            CreateWeaponPanel(container , "InfoWeaponTitleRanged" , configData.CannibalS.Dmg.RangedWeapons , 1 , mainPanel, player);
        }

        void CreatePage3(ref CuiElementContainer container , string mainPanel , IPlayer player)
        {
            // Time Checks
            double GetTime = GetCannibalData<double>(player , "totalTimeAsCannibal");
            var formattedTime = FormatTimeFilter(GetTime);
            string CannibalTime = $"{formattedTime}";
            double GetTotalTime = GetCannibalLifeTimeData<double>(player , "cannibalLifeTime");
            double BothTimes = GetTotalTime + GetTime;
            var formattedTotalTime = FormatTimeFilter(BothTimes);
            if (GetTime == 0) CannibalTime = Translate(player , "N/a");
            if (GetTotalTime == 0) formattedTotalTime = Translate(player , "N/a");
            // Human kill Checks
            int HumanKills = GetCannibalData<int>(player , "humanskilled");
            int HumanKillsLife = GetCannibalLifeTimeData<int>(player , "humanskilled");
            int TotalHumanKills = HumanKills + HumanKillsLife;
            // Npc kill Checks
            int NpcKills = GetCannibalData<int>(player , "npckilled");
            int NpcKillsLife = GetCannibalLifeTimeData<int>(player , "npckilled");
            int TotalNpcKills = NpcKills + NpcKillsLife;
            // Cannibal kill Checks
            int CannibalKills = GetCannibalData<int>(player , "cannibalskilled");
            int CannibalKillsLife = GetCannibalLifeTimeData<int>(player , "cannibalsKilled");
            int TotalCannibalKills = CannibalKills + CannibalKillsLife;
            // Animal kill Checks
            int AnimalKills = GetCannibalData<int>(player , "animalskilled");
            int AnimallKillsLife = GetCannibalLifeTimeData<int>(player , "animalskilled");
            int TotalAnimalKills = AnimalKills + AnimallKillsLife;
            // Consumed meat Checks
            int meatConsumed = GetCannibalData<int>(player , "humanmeatconsumed");
            int meatConsumedlife = GetCannibalLifeTimeData<int>(player , "humanmeatconsumed");
            int TotalMeatConsumed = meatConsumed + meatConsumedlife;
            // Wood Collected checks
            int woodcollected = GetCannibalData<int>(player , "woodcollected");
            int woodcollectedlife = GetCannibalLifeTimeData<int>(player , "woodcollected");
            int TotalWoodCollected = woodcollected + woodcollectedlife;
            // Stone Collected checks
            int stonecollected = GetCannibalData<int>(player , "stonecollected");
            int stonecollectedlife = GetCannibalLifeTimeData<int>(player , "stonecollected");
            int TotalStoneCollected = stonecollected + stonecollectedlife;
            // Sulfur Collected checks
            int sulfurcollected = GetCannibalData<int>(player , "sulfurcollected");
            int sulfurcollectedlife = GetCannibalLifeTimeData<int>(player , "sulfurcollected");
            int TotalSulfurCollected = sulfurcollected + sulfurcollectedlife;
            // Metal Collected checks
            int metalcollected = GetCannibalData<int>(player , "metalcollected");
            int metalcollectedlife = GetCannibalLifeTimeData<int>(player , "metalcollected");
            int TotalMetalCollected = metalcollected + metalcollectedlife;
            // HQM Collected checks
            int hqmcollected = GetCannibalData<int>(player , "hqmcollected");
            int hqmcollectedlife = GetCannibalLifeTimeData<int>(player , "hqmcollected");
            int TotalHQMCollected = hqmcollected + hqmcollectedlife;
            string CountWColor = "white";
            string CountStColor = "white";
            string CountSuColor = "white";
            string CountMColor = "white";
            if (woodcollected < 0) CountWColor = "red";
            if (stonecollected < 0) CountStColor = "red";
            if (sulfurcollected < 0) CountSuColor = "red";
            if (metalcollected < 0) CountMColor = "red";
            // Page Title
            AddTextWithOutline(container , $"<color=orange>{Translate(player , "InfoTitleStat")}</color>" , 24 , "0 0.81" , "1 0.86" , TextAnchor.MiddleCenter , mainPanel);

            // Stats panel
            var panel = container.Add(new CuiPanel
            {
                Image = { Color = "0.1 0.1 0.1 0.45" } ,
                RectTransform = { AnchorMin = $"0.05 0.05" , AnchorMax = $"0.45 0.76" } ,
                CursorEnabled = true
            } , mainPanel , "Stats");
            container.Add(new CuiElement
            {
                Parent = "Stats" ,
                Components =
                    {
                        new CuiRawImageComponent
                        {
                            Sprite = "assets/icons/stopwatch.png",
                            Material = "assets/icons/iconmaterial.mat",
                            Color = "1 1 1 0.2",
                            FadeIn = 0.0f
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-200 -200",
                            OffsetMax = "200 200"
                        }
                    }
            });
            // Stats Content
            container.Add(new CuiPanel { Image = { Color = "0 0 0 0.8" } , RectTransform = { AnchorMin = $"0 0.945" , AnchorMax = $"1 1" } } , "Stats");
            AddTextWithOutline(container , $"<color=white>{Translate(player , "InfoStatDescription")}</color>" , 16 , "0.025 0.945" , "0.40 0.995" , TextAnchor.MiddleLeft , "Stats");
            AddTextWithOutline(container , $"<color=white>{Translate(player , "InfoStatCurrent")}</color>" , 16 , "0.41 0.945" , "0.69 0.995" , TextAnchor.MiddleCenter , "Stats");
            AddTextWithOutline(container , $"<color=white>{Translate(player , "InfoStatTotal")}</color>" , 16 , "0.71 0.945" , "0.995 0.995" , TextAnchor.MiddleCenter , "Stats");

            var height = 0.93;
            var heightlow = 0.89;

            AddStatPanelWithText(container , Translate(player , "InfoStatTime") , CannibalTime , formattedTotalTime , ref height , ref heightlow);
            AddStatPanelWithText(container , Translate(player , "InfoStatMeats") , $"{meatConsumed}" , $"{TotalMeatConsumed}" , ref height , ref heightlow);
            AddStatPanelWithText(container , Translate(player , "InfoStatKillHuman") , $"{HumanKills}" , $"{TotalHumanKills}" , ref height , ref heightlow);
            AddStatPanelWithText(container , Translate(player , "InfoStatKillCannibal") , $"{CannibalKills}" , $"{TotalCannibalKills}" , ref height , ref heightlow);
            AddStatPanelWithText(container , Translate(player , "InfoStatKillAnimal") , $"{AnimalKills}" , $"{TotalAnimalKills}" , ref height , ref heightlow);
            AddStatPanelWithText(container , Translate(player , "InfoStatKillNpc") , $"{NpcKills}" , $"{TotalNpcKills}" , ref height , ref heightlow);
            AddStatPanelWithText(container , Translate(player , "InfoStatWood") , $"<color={CountWColor}>{woodcollected}</color>" , $"{TotalWoodCollected}" , ref height , ref heightlow);
            AddStatPanelWithText(container , Translate(player , "InfoStatStone") , $"<color={CountStColor}>{stonecollected}</color>" , $"{TotalStoneCollected}" , ref height , ref heightlow);
            AddStatPanelWithText(container , Translate(player , "InfoStatSulfur") , $"<color={CountSuColor}>{sulfurcollected}</color>" , $"{TotalSulfurCollected}" , ref height , ref heightlow);
            AddStatPanelWithText(container , Translate(player , "InfoStatMetal") , $"<color={CountMColor}>{metalcollected}</color>" , $"{TotalMetalCollected}" , ref height , ref heightlow);
            AddStatPanelWithText(container , Translate(player , "InfoStatHQM") , $"{hqmcollected}" , $"{TotalHQMCollected}" , ref height , ref heightlow);
            AddStatPanelWithText(container , Translate(player , "PlaceHolder") , Translate(player , "N/a") , Translate(player , "N/a") , ref height , ref heightlow);

            AddTextWithOutline(container , Translate(player , "InfoStatSubtext") , 14 , "0.025 0.025" , $"0.975 {heightlow - 0.01}" , TextAnchor.LowerLeft , "Stats");
        }

        void CreatePage4(ref CuiElementContainer container , string mainPanel , IPlayer player)
        {
            if (player == null)
            {
                // Handle the case where player is null (log an error, return, etc.)
                Puts("Player is null in CreatePage4 method.");
                return;
            }

            AddTextWithOutline(container , $"<color=orange>{Translate(player , "InfoRankingsTitle")}</color>" , 24 , "0 0.81" , "1 0.86" , TextAnchor.MiddleCenter , mainPanel);
            var panel = container.Add(new CuiPanel
            {
                Image = { Color = "0.1 0.1 0.1 0.45" } ,
                RectTransform = { AnchorMin = $"0.005 0.05" , AnchorMax = $"0.20 0.76" } ,
                CursorEnabled = true
            } , mainPanel , "RankMeat");
            var panel2 = container.Add(new CuiPanel
            {
                Image = { Color = "0.1 0.1 0.1 0.45" } ,
                RectTransform = { AnchorMin = $"0.205 0.05" , AnchorMax = $"0.40 0.76" } ,
                CursorEnabled = true
            } , mainPanel , "RankHKill");
            var panel3 = container.Add(new CuiPanel
            {
                Image = { Color = "0.1 0.1 0.1 0.45" } ,
                RectTransform = { AnchorMin = $"0.405 0.05" , AnchorMax = $"0.60 0.76" } ,
                CursorEnabled = true
            } , mainPanel , "RankCKill");
            var panel4 = container.Add(new CuiPanel
            {
                Image = { Color = "0.1 0.1 0.1 0.45" } ,
                RectTransform = { AnchorMin = $"0.605 0.05" , AnchorMax = $"0.80 0.76" } ,
                CursorEnabled = true
            } , mainPanel , "RankNPCKill");
            var panel5 = container.Add(new CuiPanel
            {
                Image = { Color = "0.1 0.1 0.1 0.45" } ,
                RectTransform = { AnchorMin = $"0.805 0.05" , AnchorMax = $"0.995 0.76" } ,
                CursorEnabled = true
            } , mainPanel , "RankAnimalKill");

            container.Add(new CuiPanel { Image = { Color = "0 0 0 0.8" } , RectTransform = { AnchorMin = $"0 0.945" , AnchorMax = $"1 1" } } , panel);
            AddTextWithOutline(container , $"<color=white>{Translate(player , "Top Eaters")}</color>" , 16 , "0 0.945" , "1 1" , TextAnchor.MiddleCenter , "RankMeat");

            container.Add(new CuiPanel { Image = { Color = "0 0 0 0.8" } , RectTransform = { AnchorMin = $"0 0.945" , AnchorMax = $"1 1" } } , panel2);
            AddTextWithOutline(container , $"<color=white>{Translate(player , "Top Slayers")}</color>" , 16 , "0 0.945" , "1 1" , TextAnchor.MiddleCenter , "RankHKill");

            container.Add(new CuiPanel { Image = { Color = "0 0 0 0.8" } , RectTransform = { AnchorMin = $"0 0.945" , AnchorMax = $"1 1" } } , panel3);
            AddTextWithOutline(container , $"<color=white>{Translate(player , "Top Traitors")}</color>" , 16 , "0 0.945" , "1 1" , TextAnchor.MiddleCenter , "RankCKill");

            container.Add(new CuiPanel { Image = { Color = "0 0 0 0.8" } , RectTransform = { AnchorMin = $"0 0.945" , AnchorMax = $"1 1" } } , panel4);
            AddTextWithOutline(container , $"<color=white>{Translate(player , "Top PVE")}</color>" , 16 , "0 0.945" , "1 1" , TextAnchor.MiddleCenter , "RankNPCKill");

            container.Add(new CuiPanel { Image = { Color = "0 0 0 0.8" } , RectTransform = { AnchorMin = $"0 0.945" , AnchorMax = $"1 1" } } , panel5);
            AddTextWithOutline(container , $"<color=white>{Translate(player , "Top Butchers")}</color>" , 16 , "0 0.945" , "1 1" , TextAnchor.MiddleCenter , "RankAnimalKill");

            AddRanking(container , panel , "humanmeatconsumed" , "assets/icons/meat.png");
            AddRanking(container , panel2 , "humanskilled", "assets/icons/weapon.png");
            AddRanking(container , panel3 , "cannibalskilled", "assets/icons/demolish.png");
            AddRanking(container , panel4 , "npckilled" , "assets/content/ui/hypnotized.png");
            AddRanking(container , panel5 , "animalskilled" , "assets/icons/food_raw.png");

        }
        private void AddRanking(CuiElementContainer container , string ranking , string Type ,string image)
        {
            container.Add(new CuiElement
            {
                Parent = ranking ,
                Components =
                    {
                        new CuiRawImageComponent
                        {
                            Sprite = image,
                            Material = "assets/icons/iconmaterial.mat",
                            Color = "1 1 1 0.2",
                            FadeIn = 0.0f
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-100 -100",
                            OffsetMax = "100 100"
                        }
                    }
            });
            // Create a dictionary to store players and their values
            Dictionary<string , int> playerValues = new Dictionary<string , int>();

            // Populate the dictionary with player values
            foreach (var playerEntry in dataFile.Players)
            {
                var playerId = playerEntry.Key;
                var playerData = playerEntry.Value;

                // Determine the value based on the specified type
                int valueAmount = 0;
                switch (Type)
                {
                    case "humanmeatconsumed":
                        valueAmount = playerData.HumanMeatConsumed;
                        break;
                    case "humanskilled":
                        valueAmount = playerData.HumansKilled;
                        break;
                    case "cannibalskilled":
                        valueAmount = playerData.CannibalsKilled;
                        break;
                    case "npckilled":
                        valueAmount = playerData.NpcKilled;
                        break;
                    case "animalskilled":
                        valueAmount = playerData.AnimalsKilled;
                        break;
                        // Add more cases for other types as needed
                }

                // Add player and value to the dictionary
                playerValues.Add(playerId , valueAmount);
            }

            // Order the dictionary by values in descending order
            var topPlayers = playerValues.OrderByDescending(pair => pair.Value);

            int rank = 1;
            var height = 0.93;
            var heightlow = 0.89;
            string titleColor = "white";

            foreach (var topPlayer in topPlayers.Take(10))
            {
                var playerId = topPlayer.Key;
                if (dataFile.Players.TryGetValue(playerId , out var playerData))
                {
                    if (rank == 1) titleColor = "orange";
                    if (rank == 2) titleColor = "magenta";
                    if (rank == 3) titleColor = "lightblue";
                    if (rank >= 4) titleColor = "white";
                    var playerName = playerData.DisplayName ?? "Unknown";

                    // Display player rank, name, and value for the specified type
                    AddTextWithOutline(container , $"{rank} <color={titleColor}>{playerName}</color> - ({topPlayer.Value})" , 14 , $"0 {heightlow}" , $"1 {height}" , TextAnchor.MiddleCenter , ranking);
                }
                else
                {
                    Puts($"Player data not found for {playerId} in CreatePage4 method.");
                }

                rank++;
                height -= 0.05;
                heightlow -= 0.05;
            }

            // Add blank entries for the remaining lines (up to 5)
            for (int i = rank; i <= 5; i++)
            {
                AddTextWithOutline(container , $"<color=grey>{i}. Open position. </color>" , 14 , $"0 {heightlow}" , $"1 {height}" , TextAnchor.MiddleCenter , ranking);
                height -= 0.05;
                heightlow -= 0.05;
            }
        }

        private void AddChatCommandsText(CuiElementContainer container , string labelText , string valueText , ref double height , ref double heightLow)
        {
            container.Add(new CuiPanel { Image = { Color = "0.1 0.1 0.1 0.7" } , RectTransform = { AnchorMin = $"0.01 {heightLow}" , AnchorMax = $"0.29 {height}" } , CursorEnabled = true } , "Main2a");
            AddTextWithOutline(container , $"{labelText}" , 14 , $"0.025 {heightLow}" , $"0.305 {height}" , TextAnchor.MiddleLeft , "Main2a");

            container.Add(new CuiPanel { Image = { Color = "0.1 0.1 0.1 0.7" } , RectTransform = { AnchorMin = $"0.30 {heightLow}" , AnchorMax = $"0.990 {height}" } , CursorEnabled = true } , "Main2a");
            AddTextWithOutline(container , $"<color=white>{valueText}</color>" , 12 , $"0.31 {heightLow}" , $"0.995 {height}" , TextAnchor.MiddleLeft , "Main2a");

            height -= 0.05;
            heightLow -= 0.05;
        }

        private void AddStatPanelWithText(CuiElementContainer container , string labelText , string valueText , string valueText2 , ref double height , ref double heightLow)
        {
            container.Add(new CuiPanel { Image = { Color = "0.1 0.1 0.1 0.7" } , RectTransform = { AnchorMin = $"0.01 {heightLow}" , AnchorMax = $"0.39 {height}" } , CursorEnabled = true } , "Stats");
            AddTextWithOutline(container , $"{labelText}" , 14 , $"0.025 {heightLow}" , $"0.405 {height}" , TextAnchor.MiddleLeft , "Stats");

            container.Add(new CuiPanel { Image = { Color = "0.1 0.1 0.1 0.7" } , RectTransform = { AnchorMin = $"0.40 {heightLow}" , AnchorMax = $"0.690 {height}" } , CursorEnabled = true } , "Stats");
            AddTextWithOutline(container , $"<color=white>{valueText}</color>" , 14 , $"0.41 {heightLow}" , $"0.695 {height}" , TextAnchor.MiddleCenter , "Stats");

            container.Add(new CuiPanel { Image = { Color = "0.1 0.1 0.1 0.7" } , RectTransform = { AnchorMin = $"0.70 {heightLow}" , AnchorMax = $"0.990 {height}" } , CursorEnabled = true } , "Stats");
            AddTextWithOutline(container , $"<color=white>{valueText2}</color>" , 14 , $"0.71 {heightLow}" , $"0.990 {height}" , TextAnchor.MiddleCenter , "Stats");

            height -= 0.05;
            heightLow -= 0.05;
        }

        float spacing = 0.01f; // Adjust the spacing value

        private void CreateWeaponPanel(CuiElementContainer container , string title , Dictionary<string , float> weapons , int column , string parentPanel ,IPlayer player)
        {

            // Colors
            string ScaleColor = "white";

            // Calculate position based on the column
            float positionX = column * 0.5f + 0.05f;

            // Create the panel
            var panel = container.Add(new CuiPanel
            {
                Image = { Color = "0.1 0.1 0.1 0.45" } ,
                RectTransform = { AnchorMin = $"{positionX} 0.05" , AnchorMax = $"{positionX + 0.4f} 0.76" } ,
                CursorEnabled = true
            } , parentPanel , $"{title}Panel");
            container.Add(new CuiElement
            {
                Parent = $"{title}Panel" ,
                Components =
                    {
                        new CuiRawImageComponent
                        {
                            Sprite = "assets/icons/weapon.png",
                            Material = "assets/icons/iconmaterial.mat",
                            Color = "1 1 1 0.2",
                            FadeIn = 0.0f
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-200 -200",
                            OffsetMax = "200 200"
                        }
                    }
            });
            container.Add(new CuiPanel { Image = { Color = "0 0 0 0.8" } , RectTransform = { AnchorMin = $"0 0.945" , AnchorMax = $"1 1" } } , panel);
            // Add title text using your current text conversion method
            AddTextWithOutline(container , Translate(player , $"{title}") , 16 , "0 0.80" , "1 0.99" , TextAnchor.UpperCenter , panel);

            // Add weapon entries
            float offsetY = 0.93f; // Starting height for the first line
            float lineHeight = 0.038f; // Adjust this value for proper spacing
            int entryCount = 0;
            int maxEntriesPerColumn = 19; // Set the maximum entries per column
            float offsetX = 0.05f; // Starting offset for the first column

            foreach (var weapon in weapons)
            {
                if (weapon.Value > 1) ScaleColor = "green";
                if (weapon.Value < 1) ScaleColor = "red";
                if (weapon.Value == 1) ScaleColor = "white";

                // Create a panel with the same anchors as the text
                var textPanel = container.Add(new CuiPanel
                {
                    Image = { Color = "0.1 0.1 0.1 0.7" } ,
                    RectTransform = { AnchorMin = $"{offsetX} {offsetY - lineHeight * (entryCount + 1)}" , AnchorMax = $"{offsetX + 0.4f} {offsetY - lineHeight * entryCount}" } ,
                    CursorEnabled = true
                } , panel);
                int result = (int)Math.Floor(weapon.Value * 100 - 100);
                string roundedpercentage = $"{result}%";
                if (result == 0) roundedpercentage = "";
                // Add weapon entry text with outline
                AddTextWithOutline(container , $"  {weapon.Key}  <color={ScaleColor}>{roundedpercentage}</color>" , 14 , $"{offsetX} {offsetY - lineHeight * (entryCount + 1)}" , $"{offsetX + 0.4f} {offsetY - lineHeight * entryCount}" , TextAnchor.MiddleLeft , panel);

                offsetY -= spacing; // Adjust the spacing value
                entryCount++;

                // Check if the maximum entries per column is reached
                if (entryCount >= maxEntriesPerColumn)
                {
                    // Reset the counter and move to the next column
                    entryCount = 0;
                    positionX += 0.5f; // Adjust this value for the spacing between columns
                    offsetX += 0.5f; // Adjust this value for the spacing between columns
                    offsetY = 0.93f; // Reset starting height for the first line
                }
            }
        }

        private void AddTextWithOutline(CuiElementContainer container , string text , int fontSize , string anchorMin , string anchorMax , TextAnchor align , string parentPanel)
        {
            container.Add(new CuiElement
            {
                Parent = parentPanel ,
                Components =
                {
                    new CuiTextComponent { Text = text, FontSize = fontSize, Align = align, Color = "1 1 1 1", FadeIn = 0.0f },
                    new CuiOutlineComponent { Color = "0.1 0.1 0.1 1", Distance = "0.5 0.5" },
                    new CuiOutlineComponent { Color = "0 0 0 1", Distance = "1.5 1.5" },
                    new CuiRectTransformComponent { AnchorMin = anchorMin, AnchorMax = anchorMax }
                }
            });
        }

        [Command("CPage1")]
        private void CPage1(IPlayer player , string command , string[] args)
        {
            currentPage = 1;
            CannibalinfoPanel(player);
        }
        [Command("CPage2")]
        private void CPage2(IPlayer player , string command , string[] args)
        {
            currentPage = 2;
            CannibalinfoPanel(player);
        }
        [Command("CPage3")]
        private void CPage3(IPlayer player , string command , string[] args)
        {
            currentPage = 3;
            CannibalinfoPanel(player);
        }
        [Command("CPage4")]
        private void CPage4(IPlayer player , string command , string[] args)
        {
            currentPage = 4;
            CannibalinfoPanel(player);
        }
        [Command("ui.close")]
        private void CloseUICommand(IPlayer iPlayer , string command , string[] args)
        {
            // Check the title of the panel to close
            string panelTitle = args.Length > 0 ? args[0] : string.Empty;

            if (iPlayer.Object is BasePlayer basePlayer)
            {
                // Destroy the specified panel
                CuiHelper.DestroyUi(basePlayer , panelTitle);
                currentPage = 1;
            }
        }

        #endregion

        #region Helpers

        private static bool IsZombieHorde(BasePlayer player) => player.GetType().Name.Equals("ZombieNPC");

        private float GetMultiplierForItem(string itemShortname)
        {
            switch (itemShortname)
            {
                case "wood":
                    return configData.CannibalS.Gather.GWood;
                case "stones":
                    return configData.CannibalS.Gather.GStone;
                case "metal.ore":
                    return configData.CannibalS.Gather.GMetal;
                case "sulfur.ore":
                    return configData.CannibalS.Gather.GSulfur;
                case "hq.metal.ore":
                    return configData.CannibalS.Gather.GHQM;
                case "metal.refined":
                    return configData.CannibalS.Gather.GHQM;
                default:
                    return 1f; // Default multiplier
            }
        }

        private void SendFX(BasePlayer player , string FXstring)
        {
            Effect.server.Run(FXstring , player.ServerPosition + new Vector3(0 , 1 , 0));
        }

        private string Translate(IPlayer player , string key)
        {
            string Translation = lang.GetMessage(key , this , player.Id);
            return Translation;
        }

        bool IsMeleeWeapon(string itemShortName , BaseEntity weaponEntity)
        {
            if (itemShortName == null || weaponEntity == null) return false;
            bool isMelee = weaponEntity is BaseMelee;
            bool isListedMelee = configData.CannibalS.Dmg.MeleeWeapons.ContainsKey(itemShortName);
            return isMelee && isListedMelee;
        }

        bool IsRangedWeapon(string itemShortName , BaseEntity weaponEntity)
        {
            if (itemShortName == null || weaponEntity == null) return false;
            bool isRanged = weaponEntity is BaseProjectile;
            bool isListedRanged = configData.CannibalS.Dmg.RangedWeapons.ContainsKey(itemShortName);
            return isRanged && isListedRanged;
        }

        public string HexToCuiColor(string hex)/// needs some work on the alpha part
        {
            hex = hex.TrimStart('#');
            int r = int.Parse(hex.Substring(0 , 2) , System.Globalization.NumberStyles.HexNumber);
            int g = int.Parse(hex.Substring(2 , 2) , System.Globalization.NumberStyles.HexNumber);
            int b = int.Parse(hex.Substring(4 , 2) , System.Globalization.NumberStyles.HexNumber);

            float rf = r / 255f;
            float gf = g / 255f;
            float bf = b / 255f;

            return $"{rf} {gf} {bf} 1";
        }

        bool HasPermission(IPlayer player , string perm)
        {
            if (player is BasePlayer rustPlayer)
            {
                return permission.UserHasPermission(rustPlayer.UserIDString , perm);
            }
            else
            {
                return permission.UserHasPermission(player.Id , perm);
            }
        }

        bool HasPerm(IPlayer player , string perm) => HasPermission(player , perm);

        void SendMessage(object playerObject , string messageKey)
        {
            string prefix = configData.Prefix;
            string text;

            if (playerObject is BasePlayer)
            {
                BasePlayer basePlayer = playerObject as BasePlayer;
                text = $"{prefix} {lang.GetMessage(messageKey , this , basePlayer.UserIDString)}";
                basePlayer.SendConsoleCommand("chat.add" , 2 , SteamIDIcon , text);
            }
            else if (playerObject is IPlayer)
            {
                IPlayer iPlayer = playerObject as IPlayer;
                text = $"{prefix} {lang.GetMessage(messageKey , this , iPlayer.Id)}";
                (iPlayer.Object as BasePlayer).SendConsoleCommand("chat.add" , 2 , SteamIDIcon , text);
            }
        }

        // Function to format time into days, hours, minutes, and seconds
        private TimeSpan FormatTime(double seconds)
        {
            return TimeSpan.FromSeconds(seconds);
        }

        private string FormatTimeFilter(double seconds)
        {
            TimeSpan timeSpan = TimeSpan.FromSeconds(seconds);
            string formattedTime = $"{(timeSpan.TotalDays >= 1 ? (int)timeSpan.TotalDays + "d" : "")}" +
                                   $"{(timeSpan.Hours > 0 ? (int)timeSpan.Hours + "h" : "")}" +
                                   $"{(timeSpan.Minutes > 0 ? timeSpan.Minutes + "m" : "")}" +
                                   $"{(timeSpan.Seconds > 0 ? timeSpan.Seconds + "s" : "")}";
            return formattedTime;
        }

        #endregion
    }
}

// --- End of file: Cannibal.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/container-control ---
// --- Original File Path: C/ContainerControl/ContainerControl.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("ContainerControl", "Hamster", "1.0.1")]
    [Description("Allows you to restrict types of items which can be put in a certain kind of containers")]
    class ContainerControl : RustPlugin
    {

        #region Config
        private PluginConfig config;
        private struct PluginConfig
        {
            [JsonProperty("Containers")]
            public Dictionary<string, ContainerEntry> Containers { get; set; }
        }
        
        private struct ContainerEntry
        {
            [JsonProperty("Allow")]
            public bool Allow { get; set; }
            [JsonProperty("Items")]
            public List<string> ListItem { get; set; }
        }
        
        protected override void LoadDefaultConfig()
        {
            PrintWarning("reate a new configuration file");
            config = new PluginConfig()
            {
                Containers = new Dictionary<string, ContainerEntry>
                {
                    ["cupboard.tool.deployed"] = new ContainerEntry
                    {
                        Allow = false,
                        ListItem = new List<string>
                        {
                            "cloth",
                            "scrap",
                            "sulfur",
                            "sulfur.ore",
                            "charcoal",
                            "hq.metal.ore",
                            "fat.animal",
                            "leather",
                            "crude.oil",
                            "gunpowder",
                            "metal.ore",
                            "lowgradefuel"
                        }
                    },
                    ["campfire"] = new ContainerEntry
                    {
                        Allow = true,
                        ListItem = new List<string>
                        {
                            "wood",
                            "charcoal",
                            "horsemeat.raw",
                            "bearmeat",
                            "deermeat.raw",
                            "fish.raw",
                            "meat.boar",
                            "wolfmeat.raw",
                            "chicken.raw",
                            "humanmeat.raw",
                            "can.tuna.empty",
                            "can.beans.empty"
                        }
                    }
                }
            };
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Oxide hook

        private ItemContainer.CanAcceptResult? CanAcceptItem(ItemContainer container, Item item, int targetPos)
        {
            if (container == null || item == null) return null;
            BaseEntity baseEntity = container.entityOwner;
            if (baseEntity == null) return null;
            if (baseEntity.OwnerID <= 76560000000000000L) return null;
            ContainerEntry values;
            if (!config.Containers.TryGetValue(baseEntity.ShortPrefabName, out values)) return null;
            if (values.Allow)
            {
                return values.ListItem.Contains(item.info.shortname) ? ItemContainer.CanAcceptResult.CanAccept : ItemContainer.CanAcceptResult.CannotAccept;
            }
            else
            {
                if (values.ListItem.Contains(item.info.shortname)) return ItemContainer.CanAcceptResult.CannotAccept;
                return null;
            }
        }

        #endregion

    }
}


// --- End of file: ContainerControl.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/component-blocker ---
// --- Original File Path: C/ComponentBlocker/ComponentBlocker.cs ---

using System;
using System.Text;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Component Blocker", "Calytic", "0.1.9")]
    class ComponentBlocker : RustPlugin
    {
        [PluginReference] Plugin RaidableBases;

        List<string> blockList = new List<string>();
        List<string> blockCache = new List<string>();

        bool enabled = false;
        bool craftRefund = true;
        private bool sendMessages = true;

        private Dictionary<string, string> messages = new Dictionary<string, string>();

        private List<string> texts = new List<string>() {
            "You are not allowed to use this command",
            "You may not research this (restricted), blueprints refunded!",
            "You may not research this (restricted)",
            "You may not craft this (restricted)",
            "You may not deploy this (restricted)",
            "You may not pick that up (restricted)"
        };

        void OnServerInitialized()
        {
            blockList = GetConfig<List<string>>("blockList", new List<string>());
            sendMessages = GetConfig<bool>("sendMessages", true);
            craftRefund = GetConfig<bool>("craftRefund", true);
            Config["blockList"] = blockList;

            Dictionary<string, object> customMessages = GetConfig<Dictionary<string, object>>("messages", null);
            if (customMessages != null)
            {
                foreach (KeyValuePair<string, object> kvp in customMessages)
                {
                    messages[kvp.Key] = kvp.Value.ToString();
                }
            }

            LoadData();

            timer.Once(1f, delegate()
            {
                enabled = true;
            });
        }

        void LoadData()
        {
            if (this.Config["VERSION"] == null)
            {
                // FOR COMPATIBILITY WITH INITIAL VERSIONS WITHOUT VERSIONED CONFIG
                ReloadConfig();
            }
            else if (this.GetConfig<string>("VERSION", this.Version.ToString()) != this.Version.ToString())
            {
                // ADDS NEW, IF ANY, CONFIGURATION OPTIONS
                ReloadConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            Dictionary<string, object> messages = new Dictionary<string, object>();

            foreach (string text in texts)
            {
                if (messages.ContainsKey(text))
                {
                    PrintWarning("Duplicate translation string: " + text);
                }
                else
                {
                    messages.Add(text, text);
                }
            }

            Config["messages"] = messages;
            Config["sendMessages"] = true;
            Config["craftRefund"] = true;
            Config["blockList"] = new List<string>();
            Config["VERSION"] = this.Version.ToString();
        }

        protected void ReloadConfig()
        {
            Dictionary<string, object> messages = new Dictionary<string, object>();

            foreach (string text in texts)
            {
                if (!messages.ContainsKey(text))
                {
                    messages.Add(text, text);
                }
            }

            Config["messages"] = messages;
            Config["VERSION"] = this.Version.ToString();

            // NEW CONFIGURATION OPTIONS HERE
            Config["craftRefund"] = true;
            // END NEW CONFIGURATION OPTIONS

            PrintWarning("Upgrading Configuration File");
            SaveConfig();
        }

        private void SendHelpText(BasePlayer player)
        {
            if (player.net.connection.authLevel < 1)
            {
                return;
            }

            var sb = new StringBuilder()
               .Append("ComponentBlocker by <color=#ce422b>http://rustservers.io</color>\n")
               .Append("  ").Append("<color=\"#ffd479\">/blocker \"name\"</color> - Adds or removes item/entity to/from blocklist").Append("\n");
            player.ChatMessage(sb.ToString());
        }

        [ChatCommand("listinv")]
        private void cmdListInv(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel < 1)
            {
                return;
            }

            List<string> prefabs = new List<string>();

            foreach (Item item in player.inventory.containerMain.itemList)
            {
                if (item.info.itemMods.Length > 0)
                {
                    foreach (ItemMod itemMod in item.info.itemMods)
                    {
                        prefabs.Add(itemMod.name);
                    }
                }
            }

            player.ConsoleMessage("Inventory item prefabs:");
            player.ConsoleMessage(string.Join("\n", prefabs.ToArray()));
            SendReply(player, "Press F1 and open console");
        }

        [ChatCommand("clearblocklist")]
        private void cmdClearBlockList(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel < 1)
            {
                return;
            }

            blockList.Clear();
            blockCache.Clear();
            SaveConfig();
            SendReply(player, "Blocklist cleared");
        }

        [ChatCommand("blocklist")]
        private void cmdBlockList(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel < 1)
            {
                return;
            }

            string[] list = blockList.ToArray();
            player.ConsoleMessage("CURRENT BLOCKLIST:");
            player.ConsoleMessage(string.Join(", ", list));
            SendReply(player, "Press F1 and open console");
        }

        [ChatCommand("blocker")]
        private void cmdBlock(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel < 1)
            {
                return;
            }

            if (args.Length == 1)
            {
                string name = args[0];
                if (blockList.Contains(name))
                {
                    blockList.Remove(name);
                    blockCache.Remove(name);
                    SaveConfig();
                    player.ChatMessage(name + " removed from block list");
                }
                else
                {
                    blockList.Add(name);
                    SaveConfig();
                    player.ChatMessage(name + " added to block list");
                }
            }
            else
            {
                player.ChatMessage("Invalid Syntax.  /blocker \"name\"");
            }
        }

        [ConsoleCommand("blocker")]
        void ccBlock(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1)
            {
                return;
            }

            if (arg.Args.Length == 1)
            {
                string name = arg.Args[0];
                if (blockList.Contains(name))
                {
                    blockList.Remove(name);
                    SaveConfig();
                    SendReply(arg, name + " removed from block list");
                }
                else
                {
                    blockList.Add(name);
                    SaveConfig();
                    SendReply(arg, name + " added to block list");
                }
            }
            else
            {
                SendReply(arg, "Invalid Syntax.  blocker \"name\"");
            }
        }

        void AddBlock(string name)
        {
            if (!blockList.Contains(name))
            {
                blockList.Add(name);
            }
        }

        void RemoveBlock(string name)
        {
            if (blockList.Contains(name))
            {
                blockList.Remove(name);
            }
        }

        bool IsBlocking(string name)
        {
            return blockList.Contains(name);
        }

        T GetConfig<T>(string key, T defaultValue)
        {
            try
            {
                var val = Config[key];
                if (val == null)
                    return defaultValue;
                if (val is List<object>)
                {
                    var t = typeof(T).GetGenericArguments()[0];
                    if (t == typeof(String))
                    {
                        var cval = new List<string>();
                        foreach (var v in val as List<object>)
                            cval.Add((string)v);
                        val = cval;
                    }
                    else if (t == typeof(int))
                    {
                        var cval = new List<int>();
                        foreach (var v in val as List<object>)
                            cval.Add(Convert.ToInt32(v));
                        val = cval;
                    }
                }
                else if (val is Dictionary<string, object>)
                {
                    var t = typeof(T).GetGenericArguments()[1];
                    if (t == typeof(int))
                    {
                        var cval = new Dictionary<string, int>();
                        foreach (var v in val as Dictionary<string, object>)
                            cval.Add(Convert.ToString(v.Key), Convert.ToInt32(v.Value));
                        val = cval;
                    }
                    else if (t == typeof(List<object>) || t == typeof(List<string>))
                    {
                        var cval = new Dictionary<string, List<string>>();
                        foreach(var v in val as Dictionary<string, object>) {
                            if (v.Value is List<object>)
                            {
                                var clist = new List<string>();
                                foreach (object str in (List<object>)v.Value)
                                {
                                    clist.Add(str.ToString());
                                }
                                cval.Add(v.Key.ToString(), clist);
                            }
                        }
                        val = cval;
                    }
                }
                return (T)Convert.ChangeType(val, typeof(T));
            }
            catch (Exception)
            {
                return defaultValue;
            }
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (!enabled) return;
            //this.CheckBlueprints(player);
        }

        object OnItemCraft(ItemCraftTask task, BasePlayer player, Item fromTempBlueprint)
        {
            if (!enabled) return null;
            ItemDefinition def = task.blueprint.targetItem;

            if (isBlocked(def.displayName.english, def.shortname))
            {
                task.cancelled = true;
                if (craftRefund && 
                    ((player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count) +
                    (player.inventory.containerBelt.capacity - player.inventory.containerBelt.itemList.Count)) > 0)
                {
                    RefundIngredients(task.blueprint, player, task.amount);
                }
                if (sendMessages)
                    SendReply(player, messages["You may not craft this (restricted)"]);

                return false;
            }

            return null;
        }

        private void RefundIngredients(ItemBlueprint bp, BasePlayer player, int amount = 1)
        {
            using (List<ItemAmount>.Enumerator enumerator = bp.ingredients.GetEnumerator())
            {
                while (enumerator.MoveNext())
                {
                    ItemAmount current = enumerator.Current;

                    Item i = ItemManager.CreateByItemID(current.itemid, Convert.ToInt32(current.amount) * amount);
                    if (!i.MoveToContainer(player.inventory.containerMain))
                    {
                        i.Drop(player.eyes.position, player.eyes.BodyForward() * 2f);
                    }
                }
            }
        }

        void OnEntitySpawned(BaseNetworkable networkable)
        {
            if (!enabled) return;
            if (!EventTerritory(networkable.transform.position) && !CheckNetworkable(networkable))
            {
                var container = networkable as LootContainer;
                if (container == null)
                    return;
                if (container.inventory == null || container.inventory.itemList == null)
                {
                    return;
                }

                foreach (Item item in container.inventory.itemList)
                {
                    CheckItem(item);
                }
            }
        }

        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if (!enabled) return;
            CheckItem(item);
        }

        void OnItemDeployed(Deployer deployer, BaseEntity entity)
        {
            if (!enabled) return;
            if (CheckNetworkable(entity))
            {
                if(sendMessages)
                    SendReply(deployer.GetOwnerPlayer(), messages["You may not deploy this (restricted)"]);
            }
        }

        object OnCollectiblePickup(CollectibleEntity collectible, BasePlayer player)
        {
            if (!enabled) return null;
            bool anyFailed = false;
            foreach (ItemAmount itemAmount in collectible.itemList)
            {
                if(CheckItem(itemAmount.itemDef))
                {
                    anyFailed = true;
                    break;
                }
            }

            if(anyFailed)
            {
                if(sendMessages)
                {
                    SendReply(player, messages["You may not pick that up (restricted)"]);
                }
                
                return true; // cancel by returning non-null
            }
            
            return null;
        }

        //void OnBlueprintReveal(Item item, Item revealed, BasePlayer player)
        //{

        //    if (!enabled) return;
        //    ItemMod[] mods = item.info.itemMods;
        //    //if (CheckItem(revealed))
        //    //{
        //        // REFUND BLUEPRINT FRAGMENT/PAGE/BOOK/LIBRARY
        //        timer.Once(0.1f, delegate()
        //        {
        //            if (item.info.itemid == 1351589500)
        //            {
        //                player.inventory.GiveItem(ItemManager.Create(item.info.itemid, 20));
        //            }
        //            else
        //            {
        //                player.inventory.GiveItem(ItemManager.Create(item.info.itemid, 1));
        //            }
        //        });

        //        if(sendMessages)
        //            SendReply(player, messages["You may not research this (restricted), blueprints refunded!"]);
        //    //}
        //}

        void OnGrowableGather(GrowableEntity growable, Item item, BasePlayer player)
        {
            if (!enabled) return;
            if (CheckItem(item))
            {
                if(sendMessages)
                    SendReply(player, messages["You may not pick that up (restricted)"]);
            }
        }

        void OnQuarryGather(MiningQuarry quarry, Item item)
        {
            if (!enabled) return;
            CheckItem(item);
        }

        //private void CheckBlueprints(BasePlayer player)
        //{
        //    if (player.net == null)
        //    {
        //        return;
        //    }

        //    if (player.net.connection == null)
        //    {
        //        return;
        //    }

        //    if (SingletonComponent<ServerMgr>.Instance == null)
        //    {
        //        return;
        //    }

        //    if (SingletonComponent<ServerMgr>.Instance.persistance == null)
        //    {
        //        return;
        //    }

        //    bool removed = false;
        //    ProtoBuf.PersistantPlayer persistentPlayer = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerInfo(player.userID);

        //    if (persistentPlayer is ProtoBuf.PersistantPlayer)
        //    {
        //        foreach (string blocked in this.blockList)
        //        {
        //            ItemDefinition item = ItemManager.FindItemDefinition(blocked);
        //            if (item is ItemDefinition && persistentPlayer.blueprints is ProtoBuf.BlueprintList && persistentPlayer.blueprints.complete is List<int> && persistentPlayer.blueprints.complete.Contains(item.itemid))
        //            {
        //                persistentPlayer.blueprints.complete.Remove(item.itemid);
        //                removed = true;
        //            }
        //        }

        //        if (removed)
        //        {
        //            PlayerBlueprints.InitializePersistance(persistentPlayer);
        //            SingletonComponent<ServerMgr>.Instance.persistance.SetPlayerInfo(player.userID, persistentPlayer);
        //            player.SendFullSnapshot();
        //        }
        //    }
        //}

        private bool CheckItem(Item item)
        {
            if(item == null)
            {
                return false;
            }
            
            if(CheckItem(item.info))
            {
                item.Remove(0f);
                item.RemoveFromContainer();
                return true;
            }

            return false;
        }
        
        private bool CheckItem(ItemDefinition info)
        {
            if(info == null)
            {
                return false;
            }
            
            List<string> properties = new List<string>();

            if (info != null)
            {
                if (info.shortname != null)
                {
                    properties.Add(info.shortname);
                }

                if (info.displayName is Translate.Phrase && info.displayName.english != null)
                {
                    properties.Add(info.displayName.english);
                }

                properties.Add(info.itemid.ToString());

                if (info.itemMods?.Length > 0)
                {
                    foreach (ItemMod itemMod in info.itemMods)
                    {
                        if (!properties.Contains(itemMod.name))
                        {
                            properties.Add(itemMod.name);
                            break;
                        }
                    }
                }
            }

            if (properties.Count > 0 && isBlocked(properties.ToArray()))
            {
                return true;
            }

            return false;
        }

        private bool CheckNetworkable(BaseNetworkable networkable)
        {
            if (isBlocked(networkable.name, networkable.PrefabName, networkable.ShortPrefabName))
            {
                networkable.Invoke(networkable.KillMessage, 0.1f);
                return true;
            }

            return false;
        }

        object OnStructureUpgrade(BuildingBlock block, BasePlayer player, BuildingGrade.Enum grade)
        {
            if (grade == BuildingGrade.Enum.Wood && isBlocked("structure.wood"))
            {
                if (sendMessages)
                    SendReply(player, messages["You may not deploy this (restricted)"]);

                return true;
            }
            else if (grade == BuildingGrade.Enum.Stone && isBlocked("structure.stone"))
            {
                if (sendMessages)
                    SendReply(player, messages["You may not deploy this (restricted)"]);

                return true;
            }
            else if (grade == BuildingGrade.Enum.Metal && isBlocked("structure.metal"))
            {
                if (sendMessages)
                    SendReply(player, messages["You may not deploy this (restricted)"]);

                return true;
            }
            else if (grade == BuildingGrade.Enum.TopTier && isBlocked("structure.armored"))
            {
                if (sendMessages)
                    SendReply(player, messages["You may not deploy this (restricted)"]);

                return true;
            }

            return null;
        }

        private bool isBlocked(params string[] names)
        {
            foreach (string name in names)
            {
                if (blockCache.Contains(name))
                {
                    return true;
                }
            }

            foreach (string blocked in blockList)
            {
                foreach (string name in names)
                {
                    if (name.Contains(blocked))
                    {
                        blockCache.Add(name);
                        return true;
                    }
                }
            }

            return false;
        }

        private bool EventTerritory(Vector3 pos) => RaidableBases != null && Convert.ToBoolean(RaidableBases?.Call("EventTerritory", pos));
    }
}

// --- End of file: ComponentBlocker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/custom-vending-setup ---
// --- Original File Path: C/CustomVendingSetup/CustomVendingSetup.cs ---

// #define DEBUG_READONLY

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;
using ProtoBuf;
using UnityEngine;
using VLB;
using static ProtoBuf.VendingMachine;
using static VendingMachine;

using CustomGetDataCallback = System.Func<Newtonsoft.Json.Linq.JObject>;
using CustomSaveDataCallback = System.Action<Newtonsoft.Json.Linq.JObject>;
using CustomGetSkinCallback = System.Func<ulong>;
using CustomSetSkinCallback = System.Action<ulong>;
using Pool = Facepunch.Pool;
using Time = UnityEngine.Time;

namespace Oxide.Plugins
{
    [Info("Custom Vending Setup", "WhiteThunder", "2.14.3")]
    [Description("Allows editing orders at NPC vending machines.")]
    internal class CustomVendingSetup : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private readonly Plugin BagOfHolding, Economics, ItemRetriever, MonumentFinder, ServerRewards;

        private SavedPrefabRelativeData _prefabRelativeData;
        private SavedMapData _mapData;
        private SavedSalesData _salesData;
        private Configuration _config;

        private const string PermissionUse = "customvendingsetup.use";

        private const string StoragePrefab = "assets/prefabs/deployable/large wood storage/box.wooden.large.prefab";

        private const int ItemsPerRow = 6;
        private const int InventorySize = 24;

        // Going over 7 causes offers to get cut off regardless of resolution.
        private const int MaxVendingOffers = 7;

        private const int GeneralSettingsNoteSlot = 29;
        private const int ContainerCapacity = 30;
        private const int MaxItemRows = ContainerCapacity / ItemsPerRow;
        private const int BlueprintItemId = -996920608;
        private const float MinCurrencyCondition = 0.5f;

        private const ulong NpcVendingMachineSkinId = 861142659;

        private static readonly Regex KeyValueRegex = new(@"^([^:]+):(.+(?:\n[^:\n]+$)*)", RegexOptions.Compiled | RegexOptions.Multiline);

        private readonly object True = true;
        private readonly object False = false;

        private ItemRetrieverAdapter _itemRetrieverAdapter;
        private PluginDataProviderRegistry _dataProviderRegistry = new();
        private ComponentTracker<NPCVendingMachine, VendingMachineComponent> _componentTracker = new();
        private ComponentFactory<NPCVendingMachine, VendingMachineComponent> _componentFactory;
        private MonumentFinderAdapter _monumentFinderAdapter;
        private VendingMachineManager _vendingMachineManager;
        private BagOfHoldingLimitManager _bagOfHoldingLimitManager;
        private DynamicHookSubscriber<VendingController> _inaccessibleVendingMachines;
        private DynamicHookSubscriber<BasePlayer> _playersNeedingFakeInventory;
        private PaymentProviderResolver _paymentProviderResolver;

        private ItemDefinition _noteItemDefinition;
        private bool _isServerInitialized;
        private bool _performingInstantRestock;
        private VendingItem _itemBeingSold;
        private Dictionary<string, object> _itemRetrieverQuery = new();
        private List<Item> _reusableItemList = new();
        private object[] _objectArray1 = new object[1];
        private object[] _objectArray2 = new object[2];

        public CustomVendingSetup()
        {
            _monumentFinderAdapter = new MonumentFinderAdapter(this);
            _itemRetrieverAdapter = new ItemRetrieverAdapter(this);
            _componentFactory = new ComponentFactory<NPCVendingMachine, VendingMachineComponent>(this, _componentTracker);
            _vendingMachineManager = new VendingMachineManager(this, _componentFactory, _dataProviderRegistry);
            _bagOfHoldingLimitManager = new BagOfHoldingLimitManager(this);
            _paymentProviderResolver = new PaymentProviderResolver(this);
            _inaccessibleVendingMachines = new DynamicHookSubscriber<VendingController>(this, nameof(CanAccessVendingMachine));
            _playersNeedingFakeInventory = new DynamicHookSubscriber<BasePlayer>(this, nameof(OnEntitySaved), nameof(OnInventoryNetworkUpdate));
        }

        #endregion

        #region Hooks

        private void Init()
        {
            _config.Init();
            _prefabRelativeData = SavedPrefabRelativeData.Load();
            _salesData = SavedSalesData.Load();

            permission.RegisterPermission(PermissionUse, this);

            Unsubscribe(nameof(OnEntitySpawned));

            _inaccessibleVendingMachines.UnsubscribeAll();
            _playersNeedingFakeInventory.UnsubscribeAll();
        }

        private void OnServerInitialized()
        {
            _isServerInitialized = true;
            _mapData = SavedMapData.Load();

            if (MonumentFinder == null)
            {
                LogWarning("MonumentFinder is not loaded, so you won't be able to save vending machine customizations relative to monuments.");
            }

            // Delay to allow Monument Finder to register monuments via its `OnServerInitialized()` hook.
            NextTick(() =>
            {
                _vendingMachineManager.SetupAll();

                foreach (var player in BasePlayer.activePlayerList)
                {
                    var container = player.inventory.loot.containers.FirstOrDefault();
                    if (container == null)
                        continue;

                    var vendingMachine = container.entityOwner as NPCVendingMachine;
                    if (vendingMachine != null)
                    {
                        OnVendingShopOpened(vendingMachine, player);
                    }
                }
            });

            if (ItemRetriever != null)
            {
                _itemRetrieverAdapter.HandleItemRetrieverLoaded();
            }

            _bagOfHoldingLimitManager.OnServerInitialized();

            Subscribe(nameof(OnEntitySpawned));

            _noteItemDefinition = ItemManager.FindItemDefinition("note");
        }

        private void Unload()
        {
            if (NPCVendingMachine.DynamicPricingEnabled)
            {
                _vendingMachineManager.SaveAllSalesData();
            }

            _vendingMachineManager.ResetAll();
            ObjectCache.Clear<int>();
            ObjectCache.Clear<float>();
            ObjectCache.Clear<ulong>();
        }

        private void OnNewSave()
        {
            if (NPCVendingMachine.DynamicPricingEnabled)
            {
                _salesData.Reset();
            }
        }

        private void OnServerSave()
        {
            if (NPCVendingMachine.DynamicPricingEnabled)
            {
                _vendingMachineManager.SaveAllSalesData();
            }
        }

        private void OnPluginLoaded(Plugin plugin)
        {
            switch (plugin.Name)
            {
                case nameof(MonumentFinder):
                {
                    // Check whether initialized to detect only late (re)loads.
                    // Note: We are not dynamically subscribing to OnPluginLoaded since that interferes with the PluginReference attribute.
                    if (_isServerInitialized)
                    {
                        // Delay to ensure MonumentFinder's `OnServerInitialized` method is called.
                        NextTick(_vendingMachineManager.SetupAll);
                    }

                    return;
                }

                case nameof(BagOfHolding):
                    _bagOfHoldingLimitManager.HandleBagOfHoldingLoadedChanged();
                    return;

                case nameof(ItemRetriever):
                    _itemRetrieverAdapter.HandleItemRetrieverLoaded();
                    return;
            }
        }

        private void OnPluginUnloaded(Plugin plugin)
        {
            switch (plugin.Name)
            {
                case nameof(ItemRetriever):
                    _itemRetrieverAdapter.HandleItemRetrieverUnloaded();
                    return;
            }
        }

        private void OnEntitySpawned(NPCVendingMachine vendingMachine)
        {
            // Delay to give other plugins a chance to save a reference so they can block setup.
            NextTick(() =>
            {
                if (vendingMachine == null || vendingMachine.IsDestroyed)
                    return;

                _vendingMachineManager.HandleVendingMachineSpawned(vendingMachine);
            });
        }

        private void OnEntityKill(NPCVendingMachine vendingMachine)
        {
            _vendingMachineManager.HandleVendingMachineKilled(vendingMachine);
        }

        private void OnVendingShopOpened(NPCVendingMachine vendingMachine, BasePlayer player)
        {
            var controller = _vendingMachineManager.GetController(vendingMachine);
            if (controller == null)
                return;

            var component = _componentTracker.GetComponent(vendingMachine);
            if (component == null)
                return;

            if (permission.UserHasPermission(player.UserIDString, PermissionUse))
            {
                component.ShowAdminUI(player);
            }

            var profile = controller.Profile;
            if (profile?.Offers == null)
                return;

            if (_config.ShopUISettings.EnableSkinOverlays)
            {
                component.ShowShopUI(player);
            }

            if ((_config.Economics.EnabledAndValid && profile.HasPaymentProviderCurrency(_config.Economics))
                || (_config.ServerRewards.EnabledAndValid && profile.HasPaymentProviderCurrency(_config.ServerRewards)))
            {
                // Make sure OnEntitySaved/OnInventoryNetworkUpdate are subscribed to modify network updates.
                _playersNeedingFakeInventory.Add(player);

                // Mark inventory dirty to send a network update, which will be modified by hooks.
                player.inventory.containerMain.MarkDirty();
            }
        }

        private object OnVendingTransaction(NPCVendingMachine vendingMachine, BasePlayer player, int sellOrderIndex, int numberOfTransactions, ItemContainer targetContainer)
        {
            var vendingProfile = _vendingMachineManager.GetController(vendingMachine)?.Profile;
            if (vendingProfile?.Offers == null)
            {
                // Don't override the transaction logic because the vending machine is not customized by this plugin.
                return null;
            }

            var component = _componentTracker.GetComponent(vendingMachine);
            if (component == null)
                return null;

            var offer = vendingProfile.GetOfferForSellOrderIndex(sellOrderIndex);
            if (offer == null)
            {
                // Something is wrong. No valid offer exists at the specified index.
                return null;
            }

            numberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, HasCondition(offer.SellItem.ItemDefinition) ? 1 : 1000000);

            var sellAmount = offer.SellItem.Amount * numberOfTransactions;
            var sellOrder = vendingMachine.sellOrders.sellOrders[sellOrderIndex];
            if (offer.SellItem.ItemDefinition == NPCVendingMachine.ScrapItem && sellOrder.receivedQuantityMultiplier != 1f)
            {
                // Modify the amount of scrap received according to dynamic pricing.
                sellAmount = GetTotalPriceForOrder(sellAmount, sellOrder.receivedQuantityMultiplier);
            }

            var sellItemQuery = ItemQuery.FromSellItem(offer.SellItem);
            if (ItemUtils.SumContainerItems(vendingMachine.inventory, ref sellItemQuery) < sellAmount)
            {
                // The vending machine has insufficient stock.
                return False;
            }

            var currencyAmount = GetTotalPriceForOrder(offer.CurrencyItem.Amount, sellOrder.priceMultiplier) * numberOfTransactions;
            var currencyProvider = _paymentProviderResolver.Resolve(offer.CurrencyItem);
            if (currencyProvider.GetBalance(player) < currencyAmount)
            {
                // The player has insufficient currency.
                return False;
            }

            _reusableItemList.Clear();
            currencyProvider.TakeBalance(player, currencyAmount, _reusableItemList);

            var onMarketplaceItemPurchase = (targetContainer?.entityOwner as MarketTerminal)?._onItemPurchasedCached;

            // Note: The list will be empty if Economics or Server Rewards currency were used.
            foreach (var currencyItem in _reusableItemList)
            {
                MaybeGiveWeaponAmmo(currencyItem, player);

                // Show a notice on the marketplace UI that the item was taken.
                onMarketplaceItemPurchase?.Invoke(player, currencyItem);

                // Instead of calling `vendingMachine.TakeCurrencyItem(itemToTake)`, just remove the item.
                // This fixes an "issue" where the item would go into the vending machine storage if there was a matching stack.
                // Note: The "OnTakeCurrencyItem" hook is not called because Item Retriever always takes the items.
                currencyItem.RemoveFromContainer();
                currencyItem.Remove();
            }

            _reusableItemList.Clear();

            if (offer.RefillDelay <= 0)
            {
                // Don't change the stock amount. Instead, we will just leave the items in the vending machine.
                // The "CanVendingStockRefill" hook will use this flag to skip all logic.
                _performingInstantRestock = true;
            }
            else
            {
                // The "CanVendingStockRefill" hook may use this to add stock.
                _itemBeingSold = offer.SellItem;
            }

            _paymentProviderResolver.Resolve(offer.SellItem).AddBalance(player, sellAmount, new TransactionContext
            {
                VendingMachine = vendingMachine,
                SellItem = offer.SellItem,
                TargetContainer = targetContainer,
                OnMarketplaceItemPurchase = onMarketplaceItemPurchase,
            });

            vendingMachine.RecordSale(sellOrderIndex, sellAmount, offer.CurrencyItem.Amount * numberOfTransactions);

            // These can now be unset since the "CanVendingStockRefill" hook can no longer be called after this point.
            _performingInstantRestock = false;
            _itemBeingSold = null;

            if (offer.RefillDelay > 0)
            {
                // Remove stock only after the items have been given to the player,
                // so that max stack size can be determined by an item in stock.
                ItemUtils.TakeContainerItems(vendingMachine.inventory, ref sellItemQuery, sellAmount);
            }

            vendingMachine.UpdateEmptyFlag();

            // Reopen the UI if it was closed due to a transaction delay.
            if (!component.HasUI(player) && IsLootingVendingMachine(player, vendingMachine))
            {
                OnVendingShopOpened(vendingMachine, player);
            }

            if (offer.CustomSettings?.Count > 0)
            {
                ExposedHooks.OnCustomVendingSetupTransactionWithCustomSettings(vendingMachine, offer.CustomSettings);
            }

            return True;
        }

        private void OnBuyVendingItem(NPCVendingMachine vendingMachine, BasePlayer player, int sellOrderID, int amount)
        {
            if (!IsCustomized(vendingMachine))
                return;

            var component = _componentTracker.GetComponent(vendingMachine);
            if (component == null)
                return;

            ScheduleRemoveUI(vendingMachine, player, component);
        }

        private object OnNpcGiveSoldItem(NPCVendingMachine vendingMachine, Item item, BasePlayer player)
        {
            if (!IsCustomized(vendingMachine))
                return null;

            ExposedHooks.OnCustomVendingSetupGiveSoldItem(vendingMachine, item, player);

            // Simply give the item, without splitting it, since stack size logic has already been taken into account.
            player.GiveItem(item);
            return False;
        }

        // This hook is exposed by plugin: Vending In Stock (VendingInStock).
        private object CanVendingStockRefill(NPCVendingMachine vendingMachine, Item soldItem, BasePlayer player)
        {
            if (!IsCustomized(vendingMachine))
            {
                // Allow VendingInStock to restock the item.
                return null;
            }

            if (_performingInstantRestock)
            {
                // Don't restock the item, since it was never removed from the vending machine in the first place.
                return False;
            }

            // Override VendingInStock behavior to prevent creating new items in the container.
            // This also ensures additional item attributes are preserved.
            var itemQuery = ItemQuery.FromSellItem(_itemBeingSold);
            var existingItem = ItemUtils.FindFirstContainerItem(vendingMachine.inventory, ref itemQuery);
            if (existingItem != null)
            {
                existingItem.amount += soldItem.amount;
                existingItem.MarkDirty();
                return False;
            }

            if (_itemBeingSold == null)
            {
                // Something is wrong. The "CanPurchaseItem" hook was not called via this plugin.
                return null;
            }

            var newItem = _itemBeingSold.Create(soldItem.amount);
            vendingMachine.transactionActive = true;
            if (!newItem.MoveToContainer(vendingMachine.inventory, allowStack: false))
            {
                newItem.Remove();
            }

            vendingMachine.transactionActive = false;

            return False;
        }

        private object CanAccessVendingMachine(DeliveryDroneConfig deliveryDroneConfig, NPCVendingMachine vendingMachine)
        {
            if (!vendingMachine.IsBroadcasting())
                return null;

            var controller = _vendingMachineManager.GetController(vendingMachine);
            if (controller == null)
                return null;

            if (_inaccessibleVendingMachines.Contains(controller))
                return False;

            return null;
        }

        private void OnEntitySaved(BasePlayer player, BaseNetworkable.SaveInfo saveInfo)
        {
            AddCurrencyToContainerSnapshot(player, saveInfo.msg.basePlayer.inventory.invMain);
        }

        private void OnInventoryNetworkUpdate(PlayerInventory inventory, ItemContainer container, ProtoBuf.UpdateItemContainer updatedItemContainer, PlayerInventory.Type inventoryType)
        {
            if (inventoryType != PlayerInventory.Type.Main)
                return;

            AddCurrencyToContainerSnapshot(inventory.baseEntity, updatedItemContainer.container[0]);
        }

        #endregion

        #region API



        [HookMethod(nameof(API_IsCustomized))]
        public object API_IsCustomized(NPCVendingMachine vendingMachine)
        {
            return IsCustomized(vendingMachine) ? True : False;
        }

        [HookMethod(nameof(API_RefreshDataProvider))]
        public void API_RefreshDataProvider(NPCVendingMachine vendingMachine)
        {
            _vendingMachineManager.RefreshDataProvider(vendingMachine);
        }

        // Undocumented. Intended for MonumentAddons migration to become a Data Provider.
        [HookMethod(nameof(API_MigrateVendingProfile))]
        public JObject API_MigrateVendingProfile(NPCVendingMachine vendingMachine)
        {
            if (PrefabRelativePosition.FromVendingMachine(_monumentFinderAdapter, vendingMachine) is not {} location)
            {
                // This can happen if a vending machine was moved outside a monument's bounds.
                return null;
            }

            var vendingProfile = _prefabRelativeData.FindProfile(location);
            if (vendingProfile == null)
            {
                return null;
            }

            JObject jObject;

            try
            {
                jObject = JObject.FromObject(vendingProfile);
            }
            catch (Exception e)
            {
                LogError($"Unable to migrate vending profile\n{e}");
                return null;
            }

            _prefabRelativeData.VendingProfiles.Remove(vendingProfile);
            _prefabRelativeData.Save();

            return jObject;
        }

        #endregion

        #region Dependencies

        private class MonumentAdapter
        {
            public string PrefabName => (string)_monumentInfo["PrefabName"];
            public string ShortName => (string)_monumentInfo["ShortName"];
            public string Alias => (string)_monumentInfo["Alias"];
            public Vector3 Position => (Vector3)_monumentInfo["Position"];

            private Dictionary<string, object> _monumentInfo;

            public MonumentAdapter(Dictionary<string, object> monumentInfo)
            {
                _monumentInfo = monumentInfo;
            }

            public Vector3 InverseTransformPoint(Vector3 worldPosition)
            {
                return ((Func<Vector3, Vector3>)_monumentInfo["InverseTransformPoint"]).Invoke(worldPosition);
            }

            public bool IsInBounds(Vector3 position)
            {
                return ((Func<Vector3, bool>)_monumentInfo["IsInBounds"]).Invoke(position);
            }
        }

        private class MonumentFinderAdapter
        {
            private CustomVendingSetup _plugin;
            private Plugin _monumentFinder => _plugin.MonumentFinder;

            public MonumentFinderAdapter(CustomVendingSetup plugin)
            {
                _plugin = plugin;
            }

            public MonumentAdapter GetMonumentAdapter(Vector3 position)
            {
                if (_monumentFinder?.Call("API_GetClosest", position) is not Dictionary<string, object> dictResult)
                    return null;

                var monument = new MonumentAdapter(dictResult);
                return monument.IsInBounds(position) ? monument : null;
            }

            public MonumentAdapter GetMonumentAdapter(BaseEntity entity)
            {
                return GetMonumentAdapter(entity.transform.position);
            }
        }

        private class BagOfHoldingLimitManager
        {
            private class CustomLimitProfile
            {
                [JsonProperty("Max total bags")]
                public int MaxTotalBags = -1;
            }

            private CustomVendingSetup _plugin;
            private object _limitProfile;

            public BagOfHoldingLimitManager(CustomVendingSetup plugin)
            {
                _plugin = plugin;
            }

            public void OnServerInitialized()
            {
                HandleBagOfHoldingLoadedChanged();
            }

            public void HandleBagOfHoldingLoadedChanged()
            {
                if (_plugin.BagOfHolding == null)
                    return;

                _limitProfile = _plugin.BagOfHolding.Call("API_CreateLimitProfile", JsonConvert.SerializeObject(new CustomLimitProfile()));

                if (_limitProfile == null)
                {
                    LogError("Failed to create limit profile.");
                }
            }

            public void SetLimitProfile(ItemContainer container)
            {
                if (_limitProfile == null || _plugin.BagOfHolding == null)
                    return;

                var result = _plugin.BagOfHolding.Call("API_SetLimitProfile", container, _limitProfile);
                if (result is not true)
                {
                    LogError("Failed to set limit profile for vending container");
                }
            }

            public void RemoveLimitProfile(ItemContainer container)
            {
                if (_limitProfile == null || _plugin.BagOfHolding == null)
                    return;

                _plugin.BagOfHolding.Call("API_RemoveLimitProfile", container);
            }
        }

        private class ItemRetrieverApi
        {
            public Func<BasePlayer, Dictionary<string, object>, int> SumPlayerItems { get; }
            public Func<BasePlayer, Dictionary<string, object>, int, List<Item>, int> TakePlayerItems { get; }

            public ItemRetrieverApi(Dictionary<string, object> apiDict)
            {
                SumPlayerItems = apiDict[nameof(SumPlayerItems)] as Func<BasePlayer, Dictionary<string, object>, int>;
                TakePlayerItems = apiDict[nameof(TakePlayerItems)] as Func<BasePlayer, Dictionary<string, object>, int, List<Item>, int>;
            }
        }

        private class ItemRetrieverAdapter
        {
            public ItemRetrieverApi Api { get; private set; }

            private CustomVendingSetup _plugin;

            private Plugin ItemRetriever => _plugin.ItemRetriever;

            public ItemRetrieverAdapter(CustomVendingSetup plugin)
            {
                _plugin = plugin;
            }

            public void HandleItemRetrieverLoaded()
            {
                Api = new ItemRetrieverApi(ItemRetriever.Call("API_GetApi") as Dictionary<string, object>);
            }

            public void HandleItemRetrieverUnloaded()
            {
                Api = null;
            }
        }

        #endregion

        #region Exposed Hooks

        private static class ExposedHooks
        {
            public static object OnCustomVendingSetup(NPCVendingMachine vendingMachine)
            {
                return Interface.CallHook("OnCustomVendingSetup", vendingMachine);
            }

            public static object CanPurchaseItem(BasePlayer player, Item item, Action<BasePlayer, Item> onItemPurchased, NPCVendingMachine vendingMachine, ItemContainer targetContainer)
            {
                return Interface.CallHook("CanPurchaseItem", player, item, onItemPurchased, vendingMachine, targetContainer);
            }

            public static Dictionary<string, object> OnCustomVendingSetupDataProvider(NPCVendingMachine vendingMachine)
            {
                return Interface.CallHook("OnCustomVendingSetupDataProvider", vendingMachine) as Dictionary<string, object>;
            }

            public static void OnCustomVendingSetupOfferSettingsParse(CaseInsensitiveDictionary<string> localizedSettings, CaseInsensitiveDictionary<object> customSettings)
            {
                Interface.CallHook("OnCustomVendingSetupOfferSettingsParse", localizedSettings, customSettings);
            }

            public static void OnCustomVendingSetupOfferSettingsDisplay(CaseInsensitiveDictionary<object> customSettings, CaseInsensitiveDictionary<string> localizedSettings)
            {
                Interface.CallHook("OnCustomVendingSetupOfferSettingsDisplay", customSettings, localizedSettings);
            }

            public static void OnCustomVendingSetupTransactionWithCustomSettings(NPCVendingMachine vendingMachine, CaseInsensitiveDictionary<object> customSettings)
            {
                Interface.CallHook("OnCustomVendingSetupTransactionWithCustomSettings", vendingMachine, customSettings);
            }

            public static void OnCustomVendingSetupGiveSoldItem(NPCVendingMachine vendingMachine, Item item, BasePlayer player)
            {
                Interface.CallHook("OnCustomVendingSetupGiveSoldItem", vendingMachine, item, player);
            }
        }

        #endregion

        #region Commands

        private static class UICommands
        {
            public const string Edit = "edit";
            public const string Reset = "reset";
            public const string Save = "save";
            public const string Cancel = "cancel";
            public const string ToggleBroadcast = "togglebroadcast";
            public const string ToggleDroneAccessible = "toggledroneaccessible";
        }

        [Command("customvendingsetup.ui")]
        private void CommandUI(IPlayer player, string cmd, string[] args)
        {
            if (args.Length < 2)
                return;

            if (!PassesUICommandChecks(player, args, out var vendingMachine, out var vendingController))
                return;

            var basePlayer = player.Object as BasePlayer;
            var subCommand = args[1];

            switch (subCommand)
            {
                case UICommands.Edit:
                    if (vendingController.EditController != null)
                    {
                        basePlayer.EndLooting();
                        ChatMessage(basePlayer, Lang.ErrorCurrentlyBeingEdited, vendingController.EditController.EditorPlayer.displayName);
                        return;
                    }

                    vendingController.StartEditing(basePlayer, vendingMachine);
                    break;

                case UICommands.Reset:
                    vendingController.HandleReset();

                    // Allow Map data provider to be replaced with a Monument data provider.
                    if (vendingController.DataProvider is MapDataProvider)
                    {
                        _vendingMachineManager.RefreshDataProvider(vendingMachine);
                    }

                    vendingMachine.FullUpdate();
                    basePlayer.EndLooting();
                    basePlayer.inventory.loot.SendImmediate();
                    OpenVendingMachineDelayed(basePlayer, vendingMachine);
                    break;

                case UICommands.ToggleBroadcast:
                    vendingController.EditController?.ToggleBroadcast();
                    break;

                case UICommands.ToggleDroneAccessible:
                    vendingController.EditController?.ToggleDroneAccessible();
                    break;

                case UICommands.Save:
                    vendingController.HandleSave(vendingMachine);
                    vendingMachine.FullUpdate();
                    OpenVendingMachine(basePlayer, vendingMachine);
                    break;

                case UICommands.Cancel:
                    OpenVendingMachine(basePlayer, vendingMachine);
                    break;
            }
        }

        #endregion

        #region Helper Methods

        public static void LogInfo(string message) => Interface.Oxide.LogInfo($"[Custom Vending Setup] {message}");
        public static void LogError(string message) => Interface.Oxide.LogError($"[Custom Vending Setup] {message}");
        public static void LogWarning(string message) => Interface.Oxide.LogWarning($"[Custom Vending Setup] {message}");

        private static bool IsLootingVendingMachine(BasePlayer player, NPCVendingMachine vendingMachine)
        {
            return player.inventory.loot.containers.FirstOrDefault()?.entityOwner == vendingMachine;
        }

        private static bool AreVectorsClose(Vector3 a, Vector3 b, float xZTolerance = 0.01f, float yTolerance = 10)
        {
            // Allow a generous amount of vertical distance given that plugins may snap entities to terrain.
            return Math.Abs(a.y - b.y) < yTolerance
                && Math.Abs(a.x - b.x) < xZTolerance
                && Math.Abs(a.z - b.z) < xZTolerance;
        }

        private static bool HasCondition(ItemDefinition itemDefinition)
        {
            return itemDefinition.condition is { enabled: true, max: > 0 };
        }

        private static void OpenVendingMachine(BasePlayer player, NPCVendingMachine vendingMachine)
        {
            if (vendingMachine.OccupiedCheck(player) && Interface.CallHook("OnVendingShopOpen", vendingMachine, player) == null)
            {
                vendingMachine.SendSellOrders(player);
                vendingMachine.PlayerOpenLoot(player, vendingMachine.customerPanel);
                Interface.CallHook(nameof(OnVendingShopOpened), vendingMachine, player);
            }
        }

        private static bool CanVendingMachineBeSkinned(NPCVendingMachine vendingMachine)
        {
            return vendingMachine is not InvisibleVendingMachine
                && vendingMachine.GetParentEntity() is not TravellingVendor;
        }

        private static bool CanVendingMachineBroadcast(NPCVendingMachine vendingMachine)
        {
            return vendingMachine.GetParentEntity() is not TravellingVendor;
        }

        private static VendingOffer[] GetOffersFromVendingMachine(NPCVendingMachine vendingMachine)
        {
            var vanillaOffers = vendingMachine.sellOrders.sellOrders;
            var offers = new VendingOffer[vanillaOffers.Count];

            for (var i = 0; i < offers.Length; i++)
            {
                var manifestEntry = vendingMachine.vendingOrders.orders.ElementAtOrDefault(i);
                offers[i] = VendingOffer.FromVanillaSellOrder(vanillaOffers[i], manifestEntry);
            }

            return offers;
        }

        private static VendingOffer[] GetOffersFromContainer(CustomVendingSetup plugin, BasePlayer player, ItemContainer container)
        {
            var offers = new List<VendingOffer>();

            for (var columnIndex = 0; columnIndex < 2; columnIndex++)
            {
                for (var rowIndex = 0; rowIndex < MaxItemRows; rowIndex++)
                {
                    var sellItemSlot = rowIndex * ItemsPerRow + columnIndex * 3;

                    var sellItem = container.GetSlot(sellItemSlot);
                    var currencyItem = container.GetSlot(sellItemSlot + 1);
                    var settingsItem = container.GetSlot(sellItemSlot + 2);
                    if (sellItem == null || currencyItem == null)
                        continue;

                    offers.Add(VendingOffer.FromItems(plugin, player, sellItem, currencyItem, settingsItem));
                }
            }

            return offers.ToArray();
        }

        private static StorageContainer CreateContainerEntity(string prefabPath)
        {
            var entity = GameManager.server.CreateEntity(prefabPath);
            if (entity == null)
                return null;

            var container = entity as StorageContainer;
            if (container == null)
            {
                UnityEngine.Object.Destroy(entity);
                return null;
            }

            UnityEngine.Object.DestroyImmediate(container.GetComponent<DestroyOnGroundMissing>());
            UnityEngine.Object.DestroyImmediate(container.GetComponent<GroundWatch>());

            container.limitNetworking = true;
            container.EnableSaving(false);
            container.Spawn();

            return container;
        }

        private static int OrderIndexToSlot(int orderIndex)
        {
            if (orderIndex < MaxItemRows)
                return orderIndex * ItemsPerRow;

            return (orderIndex % MaxItemRows) * ItemsPerRow + 3;
        }

        private static string CreateNoteContents(Dictionary<string, string> settingsMap)
        {
            var lines = new List<string>();
            foreach (var entry in settingsMap)
            {
                lines.Add($"{entry.Key}: {entry.Value}");
            }

            return string.Join("\n", lines);
        }

        private static StorageContainer CreateOrdersContainer(CustomVendingSetup plugin, NPCVendingMachine vendingMachine, BasePlayer player, VendingOffer[] vendingOffers)
        {
            var containerEntity = CreateContainerEntity(StoragePrefab);

            var container = containerEntity.inventory;
            container.allowedContents = ItemContainer.ContentsType.Generic;
            container.capacity = ContainerCapacity;

            plugin._bagOfHoldingLimitManager.SetLimitProfile(container);

            for (var orderIndex = 0; orderIndex < vendingOffers.Length && orderIndex < 9; orderIndex++)
            {
                var offer = vendingOffers[orderIndex];
                var sellItem = offer.SellItem.Create();
                if (sellItem == null)
                    continue;

                var currencyItem = offer.CurrencyItem.Create();
                if (currencyItem == null)
                {
                    sellItem.Remove();
                    continue;
                }

                var destinationSlot = OrderIndexToSlot(orderIndex);

                if (!sellItem.MoveToContainer(container, destinationSlot))
                    sellItem.Remove();

                if (!currencyItem.MoveToContainer(container, destinationSlot + 1))
                    currencyItem.Remove();
            }

            // Add 7 note items, so the user doesn't have to make them.
            for (var orderIndex = 0; orderIndex < 7; orderIndex++)
            {
                var offer = vendingOffers.Length > orderIndex
                    ? vendingOffers[orderIndex]
                    : null;

                var settingsItem = ItemManager.Create(plugin._noteItemDefinition);
                if (settingsItem == null)
                    continue;

                var refillMaxLabel = plugin.GetMessage(player, Lang.SettingsRefillMax);
                var refillDelayLabel = plugin.GetMessage(player, Lang.SettingsRefillDelay);
                var refillAmountLabel = plugin.GetMessage(player, Lang.SettingsRefillAmount);

                var settingsMap = new CaseInsensitiveDictionary<string>
                {
                    [refillMaxLabel] = (offer?.RefillMax ?? VendingOffer.DefaultRefillMax).ToString(),
                    [refillDelayLabel] = (offer?.RefillDelay ?? VendingOffer.DefaultRefillDelay).ToString(),
                    [refillAmountLabel] = (offer?.RefillAmount ?? VendingOffer.DefaultRefillAmount).ToString(),
                };

                // Allow other plugins to parse the custom settings and display localized options.
                ExposedHooks.OnCustomVendingSetupOfferSettingsDisplay(
                    offer?.CustomSettings ?? new CaseInsensitiveDictionary<object>(), settingsMap);

                settingsItem.text = CreateNoteContents(settingsMap);

                var destinationSlot = OrderIndexToSlot(orderIndex);

                if (!settingsItem.MoveToContainer(container, destinationSlot + 2))
                {
                    settingsItem.Remove();
                }
            }

            var generalSettingsItem = ItemManager.Create(plugin._noteItemDefinition);
            if (generalSettingsItem != null)
            {
                var settingsMap = new CaseInsensitiveDictionary<string>();

                if (NPCVendingMachine.DynamicPricingEnabled)
                {
                    var dynamicPricingLabel = plugin.GetMessage(player, Lang.SettingsBypassDynamicPricing);
                    settingsMap[dynamicPricingLabel] = vendingMachine.BypassDynamicPricing.ToString();
                }

                if (CanVendingMachineBeSkinned(vendingMachine))
                {
                    var skinIdLabel = plugin.GetMessage(player, Lang.SettingsSkinId);
                    settingsMap[skinIdLabel] = vendingMachine.skinID.ToString();
                }

                var shopNameLabel = plugin.GetMessage(player, Lang.SettingsShopName);
                settingsMap[shopNameLabel] = vendingMachine.shopName;

                generalSettingsItem.text = CreateNoteContents(settingsMap);
                if (!generalSettingsItem.MoveToContainer(container, GeneralSettingsNoteSlot))
                {
                    generalSettingsItem.Remove();
                }
            }

            return containerEntity;
        }

        private static void MaybeGiveWeaponAmmo(Item item, BasePlayer player)
        {
            var heldEntity = item.GetHeldEntity();
            if (heldEntity == null)
                return;

            if (heldEntity.creationFrame == Time.frameCount)
            {
                // The item was probably split off another item, so don't refund its ammo.
                return;
            }

            var baseProjectile = heldEntity as BaseProjectile;
            if ((object)baseProjectile != null)
            {
                var ammoType = baseProjectile.primaryMagazine?.ammoType;
                if (ammoType != null && baseProjectile.primaryMagazine.contents > 0)
                {
                    var ammoItem = ItemManager.Create(ammoType, baseProjectile.primaryMagazine.contents);
                    if (ammoItem != null)
                    {
                        player.GiveItem(ammoItem);
                    }
                }

                return;
            }

            var flameThrower = heldEntity as FlameThrower;
            if ((object)flameThrower != null)
            {
                if (flameThrower.fuelType != null && flameThrower.ammo > 0)
                {
                    var ammoItem = ItemManager.Create(flameThrower.fuelType, flameThrower.ammo);
                    if (ammoItem != null)
                    {
                        player.GiveItem(ammoItem);
                    }
                }
            }
        }

        private static void GiveSoldItem(Item item, BasePlayer player, ref TransactionContext transaction)
        {
            var vendingMachine = transaction.VendingMachine;
            var targetContainer = transaction.TargetContainer;

            // Unset the placeholder flag to allow Enchanted Items to transform the artifact.
            item.SetFlag(Item.Flag.Placeholder, false);

            if (targetContainer == null)
            {
                vendingMachine.GiveSoldItem(item, player);
            }
            else if (!item.MoveToContainer(targetContainer))
            {
                item.Drop(targetContainer.dropPosition, targetContainer.dropVelocity);
            }

            transaction.OnMarketplaceItemPurchase?.Invoke(player, item);
        }

        private static int GetHighestUsedSlot(ProtoBuf.ItemContainer containerData)
        {
            var highestUsedSlot = -1;

            foreach (var item in containerData.contents)
            {
                if (item.slot > highestUsedSlot)
                {
                    highestUsedSlot = item.slot;
                }
            }

            return highestUsedSlot;
        }

        private static void AddItemForNetwork(ProtoBuf.ItemContainer containerData, int slot, int itemId, int amount, ItemId uid)
        {
            var itemData = Pool.Get<ProtoBuf.Item>();
            itemData.slot = slot;
            itemData.itemid = itemId;
            itemData.amount = amount;
            itemData.UID = uid;
            containerData.contents.Add(itemData);
        }

        private static CaseInsensitiveDictionary<string> ParseSettings(string text)
        {
            var dict = new CaseInsensitiveDictionary<string>();
            if (string.IsNullOrEmpty(text))
                return dict;

            foreach (Match match in KeyValueRegex.Matches(text))
            {
                dict[match.Groups[1].Value.Trim()] = match.Groups[2].Value.Trim();
            }

            return dict;
        }

        private object CallPlugin<T1>(Plugin plugin, string methodName, T1 arg1)
        {
            _objectArray1[0] = ObjectCache.Get(arg1);
            return plugin.Call(methodName, _objectArray1);
        }

        private object CallPlugin<T1, T2>(Plugin plugin, string methodName, T1 arg1, T2 arg2)
        {
            _objectArray2[0] = ObjectCache.Get(arg1);
            _objectArray2[1] = ObjectCache.Get(arg2);
            return plugin.Call(methodName, _objectArray2);
        }

        private void ScheduleRemoveUI(NPCVendingMachine vendingMachine, BasePlayer player, VendingMachineComponent component)
        {
            component.Invoke(() =>
            {
                if (vendingMachine == null || vendingMachine.IsDestroyed)
                    return;

                if (IsLootingVendingMachine(player, vendingMachine) &&
                    !vendingMachine.IsInvoking(vendingMachine.CompletePendingOrder))
                    return;

                // Remove the UI because the player stopped viewing the vending machine or the transaction is pending.
                component.RemoveUI(player);
            }, 0);
        }

        private void AddCurrencyToContainerSnapshot(BasePlayer player, ProtoBuf.ItemContainer containerData)
        {
            if (containerData == null
                || containerData.slots < InventorySize
                || !_playersNeedingFakeInventory.Contains(player))
                return;

            var lootingContainer = player.inventory.loot.containers.FirstOrDefault();
            var vendingMachine = lootingContainer?.entityOwner as NPCVendingMachine;
            if ((object)vendingMachine == null)
                return;

            var profile = _componentTracker.GetComponent(vendingMachine)?.Profile;
            if (profile == null)
                return;

            var nextInvisibleSlot = Math.Max(containerData.slots, GetHighestUsedSlot(containerData) + 1);

            if (_config.Economics.EnabledAndValid && profile.HasPaymentProviderCurrency(_config.Economics))
            {
                AddItemForNetwork(
                    containerData,
                    slot: nextInvisibleSlot,
                    itemId: _config.Economics.ItemDefinition.itemid,
                    amount: _paymentProviderResolver.EconomicsPaymentProvider.GetBalance(player),
                    uid: new ItemId(ulong.MaxValue - (ulong)nextInvisibleSlot)
                );
                nextInvisibleSlot++;
            }

            if (_config.ServerRewards.EnabledAndValid && profile.HasPaymentProviderCurrency(_config.ServerRewards))
            {
                AddItemForNetwork(
                    containerData,
                    slot: nextInvisibleSlot,
                    itemId: _config.ServerRewards.ItemDefinition.itemid,
                    amount: _paymentProviderResolver.ServerRewardsPaymentProvider.GetBalance(player),
                    uid: new ItemId(ulong.MaxValue - (ulong)nextInvisibleSlot)
                );
                nextInvisibleSlot++;
            }

            containerData.slots = nextInvisibleSlot;
        }

        private Dictionary<string, object> SetupItemRetrieverQuery(ref ItemQuery itemQuery)
        {
            _itemRetrieverQuery.Clear();
            _itemRetrieverQuery["MinCondition"] = ObjectCache.Get(MinCurrencyCondition);
            _itemRetrieverQuery["RequireEmpty"] = True;

            if (itemQuery.BlueprintId != 0)
            {
                _itemRetrieverQuery["BlueprintId"] = ObjectCache.Get(itemQuery.BlueprintId);
            }

            if (itemQuery.DataInt != 0)
            {
                _itemRetrieverQuery["DataInt"] = ObjectCache.Get(itemQuery.DataInt);
            }

            if (itemQuery.ItemId != 0)
            {
                _itemRetrieverQuery["ItemId"] = ObjectCache.Get(itemQuery.ItemId);
            }

            if (itemQuery.SkinId.HasValue)
            {
                _itemRetrieverQuery["SkinId"] = ObjectCache.Get(itemQuery.SkinId.Value);
            }

            return _itemRetrieverQuery;
        }

        private int SumPlayerItems(BasePlayer player, ref ItemQuery itemQuery)
        {
            return _itemRetrieverAdapter?.Api?.SumPlayerItems.Invoke(player, SetupItemRetrieverQuery(ref itemQuery))
                   ?? ItemUtils.SumPlayerItems(player, ref itemQuery);
        }

        private int TakePlayerItems(BasePlayer player, ref ItemQuery itemQuery, int amount, List<Item> collect = null)
        {
            return _itemRetrieverAdapter?.Api?.TakePlayerItems.Invoke(player, SetupItemRetrieverQuery(ref itemQuery), amount, collect)
                   ?? ItemUtils.TakePlayerItems(player, ref itemQuery, amount, collect);
        }

        private bool PassesUICommandChecks(IPlayer player, string[] args, out NPCVendingMachine vendingMachine, out VendingController controller)
        {
            vendingMachine = null;
            controller = null;

            if (player.IsServer || !player.HasPermission(PermissionUse))
                return false;

            if (args.Length == 0 || !ulong.TryParse(args[0], out var vendingMachineId))
                return false;

            vendingMachine = BaseNetworkable.serverEntities.Find(new NetworkableId(vendingMachineId)) as NPCVendingMachine;
            if (vendingMachine == null)
                return false;

            controller = _vendingMachineManager.GetController(vendingMachine);
            if (controller == null)
                return false;

            return true;
        }

        private void OpenVendingMachineDelayed(BasePlayer player, NPCVendingMachine vendingMachine, float delay = 0.1f)
        {
            timer.Once(delay, () =>
            {
                if (player == null || vendingMachine == null || vendingMachine.IsDestroyed)
                    return;

                OpenVendingMachine(player, vendingMachine);
            });
        }

        private bool IsCustomized(NPCVendingMachine vendingMachine) =>
            _vendingMachineManager.GetController(vendingMachine)?.Profile?.Offers != null;

        #endregion

        #region UI

        private static class UIConstants
        {
            public const string EditButtonColor = "0.451 0.553 0.271 1";
            public const string EditButtonTextColor = "0.659 0.918 0.2 1";

            public const string ResetButtonColor = "0.9 0.5 0.2 1";
            public const string ResetButtonTextColor = "1 0.9 0.7 1";

            public const string SaveButtonColor = EditButtonColor;
            public const string SaveButtonTextColor = EditButtonTextColor;

            public const string CancelButtonColor = "0.4 0.4 0.4 1";
            public const string CancelButtonTextColor = "0.71 0.71 0.71 1";

            public const float PanelWidth = 380.5f;
            public const float HeaderHeight = 23;
            public const float ItemSpacing = 4;
            public const float ItemBoxSize = 58;

            public const int ButtonHorizontalSpacing = 6;

            public const int ButtonHeight = 32;
            public const int ButtonWidth = 80;

            public const string TexturedBackgroundSprite = "assets/content/ui/ui.background.tiletex.psd";
            public const string BroadcastIcon = "assets/icons/broadcast.png";
            public const string DroneIcon = "assets/icons/drone.png";
            public const string IconMaterial = "assets/icons/iconmaterial.mat";
            public const string GreyOutMaterial = "assets/icons/greyout.mat";

            public const string AnchorMin = "0.5 0";
            public const string AnchorMax = "0.5 0";
        }

        private class EditFormState
        {
            public static EditFormState FromVendingMachine(VendingController vendingController, NPCVendingMachine vendingMachine)
            {
                return new EditFormState
                {
                    Broadcast = vendingController.Profile?.Broadcast ?? vendingMachine.IsBroadcasting(),
                    DroneAccessible = vendingController.Profile?.DroneAccessible ?? true,
                };
            }

            public bool Broadcast;
            public bool DroneAccessible;
        }

        private static class ContainerUIRenderer
        {
            public const string UIName = "CustomVendingSetup.ContainerUI";

            public const string TipUIName = "CustomVendingSetup.ContainerUI.Tip";
            public const string BroadcastUIName = "CustomVendingSetup.ContainerUI.Broadcast";
            public const string DroneUIName = "CustomVendingSetup.ContainerUI.Drone";

            public static string RenderContainerUI(CustomVendingSetup plugin, BasePlayer player, NPCVendingMachine vendingMachine, VendingController controller, EditFormState uiState)
            {
                var offsetX = 192;
                var offsetY = 142.5f;

                var cuiElements = new CuiElementContainer
                {
                    {
                        new CuiPanel
                        {
                            RectTransform =
                            {
                                AnchorMin = UIConstants.AnchorMin,
                                AnchorMax = UIConstants.AnchorMax,
                                OffsetMin = $"{offsetX} {offsetY + MaxItemRows * (UIConstants.ItemBoxSize + UIConstants.ItemSpacing)}",
                                OffsetMax = $"{offsetX} {offsetY + MaxItemRows * (UIConstants.ItemBoxSize + UIConstants.ItemSpacing)}",
                            },
                        },
                        "Hud.Menu",
                        UIName
                    },
                };

                var saveButtonText = plugin.GetMessage(player, Lang.ButtonSave);
                var cancelButtonText = plugin.GetMessage(player, Lang.ButtonCancel);

                var vendingMachineId = vendingMachine.net.ID.Value;

                AddButton(
                    cuiElements,
                    vendingMachineId,
                    saveButtonText,
                    UICommands.Save,
                    UIConstants.PanelWidth - UIConstants.ButtonWidth - UIConstants.ButtonHorizontalSpacing,
                    UIConstants.SaveButtonColor,
                    UIConstants.SaveButtonTextColor
                );
                AddButton(
                    cuiElements,
                    vendingMachineId,
                    cancelButtonText,
                    UICommands.Cancel,
                    UIConstants.PanelWidth,
                    UIConstants.CancelButtonColor,
                    UIConstants.CancelButtonTextColor
                );

                if (CanVendingMachineBroadcast(vendingMachine))
                {
                    AddBroadcastButton(cuiElements, vendingMachine, uiState);
                    AddDroneButton(cuiElements, vendingMachine, uiState);
                }

                AddDataProviderInfo(cuiElements, controller.DataProvider switch
                {
                    MapDataProvider => plugin.GetMessage(player, Lang.InfoDataProviderMap, SavedMapData.GetMapName()),
                    PrefabRelativeDataProvider prefabRelativeDataProvider => plugin.GetMessage(player, prefabRelativeDataProvider.Location.GetDataProviderLabel(), prefabRelativeDataProvider.Location.GetShortName()),
                    PluginDataProvider pluginDataProvider => pluginDataProvider.Plugin != null
                        ? plugin.GetMessage(player, Lang.InfoDataProviderPlugin, pluginDataProvider.Plugin.Name)
                        : plugin.GetMessage(player, Lang.InfoDataProviderPluginUnknownName),
                    _ => "",
                });

                var headerOffset = -6;

                cuiElements.Add(new CuiElement
                {
                    Parent = UIName,
                    Name = TipUIName,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = UIConstants.CancelButtonColor,
                            Sprite = UIConstants.TexturedBackgroundSprite,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = UIConstants.AnchorMin,
                            AnchorMax = UIConstants.AnchorMax,
                            OffsetMin = $"0 {headerOffset - UIConstants.HeaderHeight}",
                            OffsetMax = $"{UIConstants.PanelWidth} {headerOffset}",
                        },
                    },
                });

                var forSaleText = plugin.GetMessage(player, Lang.InfoForSale);
                var costText = plugin.GetMessage(player, Lang.InfoCost);
                var settingsText = plugin.GetMessage(player, Lang.InfoSettings);

                AddHeaderLabel(cuiElements, 0, forSaleText);
                AddHeaderLabel(cuiElements, 1, costText);
                AddHeaderLabel(cuiElements, 2, settingsText);
                AddHeaderLabel(cuiElements, 3, forSaleText);
                AddHeaderLabel(cuiElements, 4, costText);
                AddHeaderLabel(cuiElements, 5, settingsText);

                return CuiHelper.ToJson(cuiElements);
            }

            private static void AddDataProviderInfo(CuiElementContainer cuiElements, string text)
            {
                var xMax = UIConstants.PanelWidth;
                var xMin = 0;

                var textHeight = 14;
                var padding = 2;

                cuiElements.Add(
                    new CuiLabel
                    {
                        Text =
                        {
                            Text = text,
                            Color = "1 1 1 1",
                            Align = TextAnchor.LowerRight,
                            FontSize = 10,
                            Font = "RobotoCondensed-Regular.ttf",
                        },
                        RectTransform =
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{xMin} {UIConstants.ButtonHeight + padding}",
                            OffsetMax = $"{xMax} {UIConstants.ButtonHeight + padding + textHeight}",
                        },
                    },
                    UIName
                );
            }

            private static void AddHeaderLabel(CuiElementContainer cuiElements, int index, string text)
            {
                var xMin = 6 + index * (UIConstants.ItemBoxSize + UIConstants.ItemSpacing);
                var xMax = xMin + UIConstants.ItemBoxSize;

                cuiElements.Add(
                    new CuiLabel
                    {
                        Text =
                        {
                            Text = text,
                            Color = UIConstants.CancelButtonTextColor,
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 13,
                        },
                        RectTransform =
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{xMin} 0",
                            OffsetMax = $"{xMax} {UIConstants.HeaderHeight}",
                        },
                    },
                    TipUIName
                );
            }

            private static void AddBroadcastButton(CuiElementContainer cuiElements, NPCVendingMachine vendingMachine, EditFormState uiState)
            {
                var iconSize = UIConstants.ButtonHeight;

                var xMax = UIConstants.PanelWidth - 2 * (UIConstants.ButtonWidth + UIConstants.ButtonHorizontalSpacing);
                var xMin = xMax - iconSize;

                cuiElements.Add(new CuiElement
                {
                    Parent = UIName,
                    Name = BroadcastUIName,
                    DestroyUi = BroadcastUIName,
                    Components =
                    {
                        new CuiButtonComponent
                        {
                            Color = "0 0 0 0",
                            Command = $"customvendingsetup.ui {vendingMachine.net.ID} {UICommands.ToggleBroadcast}",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{xMin} 0",
                            OffsetMax = $"{xMax} {UIConstants.ButtonHeight}",
                        },
                    },
                });

                cuiElements.Add(new CuiElement
                {
                    Parent = BroadcastUIName,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = uiState.Broadcast ? UIConstants.SaveButtonTextColor : UIConstants.CancelButtonTextColor,
                            Sprite = UIConstants.BroadcastIcon,
                            Material = UIConstants.IconMaterial,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = "0 0",
                            OffsetMax = $"{iconSize} {iconSize}",
                        },
                    },
                });
            }

            private static void AddDroneButton(CuiElementContainer cuiElements, NPCVendingMachine vendingMachine, EditFormState uiState)
            {
                var iconSize = UIConstants.ButtonHeight;

                var xMax = - UIConstants.ButtonHorizontalSpacing;
                var xMin = xMax - iconSize;

                var droneAccessible = uiState.Broadcast && uiState.DroneAccessible;

                cuiElements.Add(new CuiElement
                {
                    Parent = BroadcastUIName,
                    Name = DroneUIName,
                    Components =
                    {
                        new CuiButtonComponent
                        {
                            Color = "0 0 0 0",
                            Command = $"customvendingsetup.ui {vendingMachine.net.ID} {UICommands.ToggleDroneAccessible}",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{xMin} 0",
                            OffsetMax = $"{xMax} {UIConstants.ButtonHeight}",
                        },
                    },
                });

                cuiElements.Add(new CuiElement
                {
                    Parent = DroneUIName,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = droneAccessible ? UIConstants.SaveButtonTextColor : UIConstants.CancelButtonTextColor,
                            Sprite = UIConstants.DroneIcon,
                            Material = UIConstants.GreyOutMaterial,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = "0 0",
                            OffsetMax = $"{iconSize} {iconSize}",
                        },
                    },
                });
            }

            public static string RenderBroadcastUI(NPCVendingMachine vendingMachine, EditFormState uiState)
            {
                var cuiElements = new CuiElementContainer();
                AddBroadcastButton(cuiElements, vendingMachine, uiState);
                AddDroneButton(cuiElements, vendingMachine, uiState);
                return CuiHelper.ToJson(cuiElements);
            }

            private static void AddButton(CuiElementContainer cuiElements, ulong vendingMachineId, string text, string subCommand, float xMax, string color, string textColor)
            {
                var xMin = xMax - UIConstants.ButtonWidth;

                cuiElements.Add(
                    new CuiButton
                    {
                        Text =
                        {
                            Text = text,
                            Color = textColor,
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 18,
                        },
                        Button =
                        {
                            Color = color,
                            FadeIn = 0.1f,
                            Command = $"customvendingsetup.ui {vendingMachineId} {subCommand}",
                        },
                        RectTransform =
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{xMin} 0",
                            OffsetMax = $"{xMax} {UIConstants.ButtonHeight}",
                        },
                    },
                    UIName
                );
            }
        }

        private static class AdminUIRenderer
        {
            public const string UIName = "CustomVendingSetup.AdminUI";

            public static string RenderAdminUI(CustomVendingSetup plugin, BasePlayer player, NPCVendingMachine vendingMachine, VendingProfile profile)
            {
                var numSellOrders = vendingMachine.sellOrders?.sellOrders.Count ?? 0;
                var offsetY = 137.5f + 74 * numSellOrders;
                var offsetX = 192;

                var cuiElements = new CuiElementContainer
                {
                    new CuiElement
                    {
                        Parent = "Overlay",
                        Name = UIName,
                        DestroyUi = UIName,
                        Components =
                        {
                            new CuiRectTransformComponent
                            {
                                AnchorMin = UIConstants.AnchorMin,
                                AnchorMax = UIConstants.AnchorMax,
                                OffsetMin = $"{offsetX} {offsetY}",
                                OffsetMax = $"{offsetX} {offsetY}",
                            },
                        },
                    },
                };

                var buttonIndex = 0;
                var vendingMachineId = vendingMachine.net.ID.Value;

                if (profile != null)
                {
                    var resetButtonText = plugin.GetMessage(player, Lang.ButtonReset);
                    AddVendingButton(cuiElements, vendingMachineId, resetButtonText, UICommands.Reset, buttonIndex, UIConstants.ResetButtonColor, UIConstants.ResetButtonTextColor);
                    buttonIndex++;
                }

                var editButtonText = plugin.GetMessage(player, Lang.ButtonEdit);
                AddVendingButton(cuiElements, vendingMachineId, editButtonText, UICommands.Edit, buttonIndex, UIConstants.SaveButtonColor, UIConstants.SaveButtonTextColor);

                return CuiHelper.ToJson(cuiElements);
            }

            private static float GetButtonOffset(int reverseButtonIndex)
            {
                return UIConstants.PanelWidth - reverseButtonIndex * (UIConstants.ButtonWidth + UIConstants.ButtonHorizontalSpacing);
            }

            private static void AddVendingButton(CuiElementContainer cuiElements, ulong vendingMachineId, string text, string subCommand, int reverseButtonIndex, string color, string textColor)
            {
                var xMax = GetButtonOffset(reverseButtonIndex);
                var xMin = xMax - UIConstants.ButtonWidth;

                cuiElements.Add(
                    new CuiButton
                    {
                        Text =
                        {
                            Text = text,
                            Color = textColor,
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 18,
                        },
                        Button =
                        {
                            Color = color,
                            FadeIn = 0.1f,
                            Command = $"customvendingsetup.ui {vendingMachineId} {subCommand}",
                        },
                        RectTransform =
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{xMin} 0",
                            OffsetMax = $"{xMax} {UIConstants.ButtonHeight}",
                        },
                    },
                    UIName
                );
            }
        }

        private static class ShopUIRenderer
        {
            public const string UIName = "CustomVendingSetup.ShopUI";

            private const float OffsetXItem = 210;
            private const float OffsetXCurrency = 352;
            private const float OverlaySize = 60;

            private const float IconSize = 50;
            private const float PaddingLeft = 5.5f;
            private const float PaddingBottom = 8;

            public static string RenderShopUI(VendingProfile vendingProfile)
            {
                var cuiElements = new CuiElementContainer
                {
                    new CuiElement
                    {
                        Parent = "Hud.Menu",
                        Name = UIName,
                        DestroyUi = UIName,
                        Components =
                        {
                            new CuiRectTransformComponent
                            {
                                AnchorMin = UIConstants.AnchorMin,
                                AnchorMax = UIConstants.AnchorMax,
                            },
                        },
                    },
                };

                var skinsByItemShortName = new Dictionary<string, HashSet<ulong>>();
                var numValidOffers = 0;

                foreach (var offer in vendingProfile.Offers)
                {
                    if (!offer.IsValid)
                        continue;

                    numValidOffers++;

                    if (!skinsByItemShortName.TryGetValue(offer.SellItem.ShortName, out var skins))
                    {
                        skins = new HashSet<ulong>();
                        skinsByItemShortName[offer.SellItem.ShortName] = skins;
                    }

                    skins.Add(offer.SellItem.SkinId);
                }

                var offerIndex = 0;

                foreach (var offer in vendingProfile.Offers)
                {
                    if (!offer.IsValid)
                        continue;

                    if (skinsByItemShortName[offer.SellItem.ShortName].Count > 1)
                    {
                        AddItemOverlay(cuiElements, numValidOffers - offerIndex, offer, isCurrency: false);
                    }

                    if (offer.CurrencyItem.SkinId != 0)
                    {
                        AddItemOverlay(cuiElements, numValidOffers - offerIndex, offer, isCurrency: true);
                    }

                    offerIndex++;
                }

                if (cuiElements.Count == 1)
                    return string.Empty;

                return CuiHelper.ToJson(cuiElements);
            }

            private static void AddItemOverlay(CuiElementContainer cuiElements, int indexFromBottom, VendingOffer offer, bool isCurrency = false)
            {
                var offsetX = isCurrency ? OffsetXCurrency : OffsetXItem;
                var offsetY = 41.5f + 74 * indexFromBottom;

                var vendingItem = isCurrency ? offer.CurrencyItem : offer.SellItem;

                // Background
                cuiElements.Add(new CuiElement
                {
                    Parent = UIName,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = "0.35 0.35 0.35 1",
                            Sprite = UIConstants.TexturedBackgroundSprite,
                            FadeIn = 0.1f,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = UIConstants.AnchorMin,
                            AnchorMax = UIConstants.AnchorMax,
                            OffsetMin = $"{offsetX} {offsetY}",
                            OffsetMax = $"{offsetX + OverlaySize} {offsetY + OverlaySize}",
                        },
                    },
                });

                // Skin icon
                cuiElements.Add(new CuiElement
                {
                    Name = $"{UIName}.Offer.{indexFromBottom}.Currency",
                    Parent = UIName,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Sprite = "assets/content/textures/generic/fulltransparent.tga",
                            ItemId = vendingItem.ItemId,
                            SkinId = vendingItem.SkinId,
                            FadeIn = 0.1f,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{offsetX + PaddingLeft} {offsetY + PaddingBottom}",
                            OffsetMax = $"{offsetX + PaddingLeft + IconSize} {offsetY + PaddingBottom + IconSize}",
                        },
                    },
                });

                if (vendingItem.Amount > 1)
                {
                    // Amount
                    cuiElements.Add(new CuiElement
                    {
                        Parent = UIName,
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"x{vendingItem.Amount}",
                                Align = TextAnchor.LowerRight,
                                FontSize = 12,
                                Color = "0.65 0.65 0.65 1",
                                FadeIn = 0.1f,
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = UIConstants.AnchorMin,
                                AnchorMax = UIConstants.AnchorMax,
                                OffsetMin = $"{offsetX + 4} {offsetY + 1f}",
                                OffsetMax = $"{offsetX - 3f + OverlaySize} {offsetY + OverlaySize}",
                            },
                        },
                    });
                }
            }
        }

        #endregion

        #region Utilities

        private static class StringUtils
        {
            public static bool EqualsCaseInsensitive(string a, string b)
            {
                return string.Compare(a, b, StringComparison.OrdinalIgnoreCase) == 0;
            }
        }

        private static class ObjectCache
        {
            private static class StaticObjectCache<T>
            {
                private static readonly Dictionary<T, object> _cacheByValue = new();

                public static object Get(T value)
                {
                    if (!_cacheByValue.TryGetValue(value, out var cachedObject))
                    {
                        cachedObject = value;
                        _cacheByValue[value] = cachedObject;
                    }

                    return cachedObject;
                }

                public static void Clear()
                {
                    _cacheByValue.Clear();
                }
            }

            public static object Get<T>(T value)
            {
                return StaticObjectCache<T>.Get(value);
            }

            public static void Clear<T>()
            {
                StaticObjectCache<T>.Clear();
            }
        }

        private interface IRelativePosition
        {
            string GetPrefabName();
            string GetPrefabAlias();
            Vector3 GetPosition();
        }

        private static bool LocationsMatch<T1, T2>(T1 a, T2 b)
            where T1 : IRelativePosition
            where T2 : IRelativePosition
        {
            var prefabsMatch = a.GetPrefabAlias() != null && a.GetPrefabAlias() == b.GetPrefabAlias()
                || StringUtils.EqualsCaseInsensitive(a.GetPrefabName(), b.GetPrefabName());

            if (!prefabsMatch)
                return false;

            return AreVectorsClose(a.GetPosition(), b.GetPosition());
        }

        private struct PrefabRelativePosition : IRelativePosition
        {
            public static PrefabRelativePosition? FromVendingMachine(MonumentFinderAdapter monumentFinderAdapter, NPCVendingMachine vendingMachine)
            {
                var parentEntity = vendingMachine.GetParentEntity();
                if (parentEntity != null)
                {
                    return new PrefabRelativePosition
                    {
                        _vendingMachine = vendingMachine,
                        _parentEntity = parentEntity,
                        _position = vendingMachine.transform.localPosition,
                    };
                }

                var monument = monumentFinderAdapter.GetMonumentAdapter(vendingMachine);
                if (monument == null)
                    return null;

                return new PrefabRelativePosition
                {
                    _vendingMachine = vendingMachine,
                    _monumentAdapter = monument,
                    _position = monument.InverseTransformPoint(vendingMachine.transform.position),
                };
            }

            private NPCVendingMachine _vendingMachine;
            private BaseEntity _parentEntity;
            private MonumentAdapter _monumentAdapter;
            private Vector3 _position;

            public string GetShortName()
            {
                return _monumentAdapter != null
                    ? _monumentAdapter.ShortName
                    : _parentEntity.ShortPrefabName;
            }

            public Vector3 GetCurrentPosition()
            {
                return _monumentAdapter?.InverseTransformPoint(_vendingMachine.transform.position)
                       ?? _vendingMachine.transform.localPosition;
            }

            public string GetDataProviderLabel()
            {
                return _monumentAdapter != null
                    ? Lang.InfoDataProviderMonument
                    : Lang.InfoDataProviderEntity;
            }

            // IPrefabRelativePosition members.
            public string GetPrefabName() => _monumentAdapter != null
                ? _monumentAdapter.PrefabName
                : _parentEntity.PrefabName;

            public string GetPrefabAlias() => _monumentAdapter?.Alias;
            public Vector3 GetPosition() => _position;
        }

        #endregion

        #region Payment Providers

        private struct TransactionContext
        {
            public NPCVendingMachine VendingMachine;
            public VendingItem SellItem;
            public ItemContainer TargetContainer;
            public Action<BasePlayer, Item> OnMarketplaceItemPurchase;
        }

        private interface IPaymentProvider
        {
            int GetBalance(BasePlayer player);
            bool AddBalance(BasePlayer player, int amount, TransactionContext transaction);
            bool TakeBalance(BasePlayer player, int amount, List<Item> collect);
        }

        private class ItemsPaymentProvider : IPaymentProvider
        {
            public VendingItem VendingItem;

            private CustomVendingSetup _plugin;

            public ItemsPaymentProvider(CustomVendingSetup plugin)
            {
                _plugin = plugin;
            }

            public int GetBalance(BasePlayer player)
            {
                var itemQuery = ItemQuery.FromCurrencyItem(VendingItem);
                return _plugin.SumPlayerItems(player, ref itemQuery);
            }

            public bool AddBalance(BasePlayer player, int amount, TransactionContext transaction)
            {
                var vendingMachine = transaction.VendingMachine;
                var sellItem = transaction.SellItem;

                var sellItemQuery = ItemQuery.FromSellItem(sellItem);
                var firstSellableItem = ItemUtils.FindFirstContainerItem(vendingMachine.inventory, ref sellItemQuery);
                var maxStackSize = _plugin._config.GetItemMaxStackSize(firstSellableItem);

                // Create new items and give them to the player.
                // This approach was chosen instead of transferring the items because in many cases new items would have to
                // be created anyway, since the vending machine maintains a single large stack of each item.
                while (amount > 0)
                {
                    var amountToGive = Math.Min(amount, maxStackSize);
                    var itemToGive = sellItem.Create(amountToGive);

                    amount -= amountToGive;

                    // The "CanPurchaseItem" hook may cause "CanVendingStockRefill" hook to be called.
                    var hookResult = ExposedHooks.CanPurchaseItem(player, itemToGive, transaction.OnMarketplaceItemPurchase, vendingMachine, transaction.TargetContainer);
                    if (hookResult is bool)
                    {
                        LogWarning($"A plugin returned {hookResult} in the CanPurchaseItem hook, which has been ignored.");
                    }

                    GiveSoldItem(itemToGive, player, ref transaction);
                }

                return true;
            }

            public bool TakeBalance(BasePlayer player, int amount, List<Item> collect)
            {
                if (amount <= 0)
                    return true;

                var itemQuery = ItemQuery.FromCurrencyItem(VendingItem);
                _plugin.TakePlayerItems(player, ref itemQuery, amount, collect);
                return true;
            }
        }

        private class EconomicsPaymentProvider : IPaymentProvider
        {
            private CustomVendingSetup _plugin;
            private Plugin _ownerPlugin => _plugin.Economics;

            public EconomicsPaymentProvider(CustomVendingSetup plugin)
            {
                _plugin = plugin;
            }

            public bool IsAvailable => _ownerPlugin != null;

            public int GetBalance(BasePlayer player)
            {
                return Convert.ToInt32(_plugin.CallPlugin(_ownerPlugin, "Balance", (ulong)player.userID));
            }

            public bool AddBalance(BasePlayer player, int amount, TransactionContext transaction)
            {
                var result = _plugin.CallPlugin(_ownerPlugin, "Deposit", (ulong)player.userID, Convert.ToDouble(amount));
                return result is true;
            }

            public bool TakeBalance(BasePlayer player, int amount, List<Item> collect)
            {
                var result = _plugin.CallPlugin(_ownerPlugin, "Withdraw", (ulong)player.userID, Convert.ToDouble(amount));
                return result is true;
            }
        }

        private class ServerRewardsPaymentProvider : IPaymentProvider
        {
            private CustomVendingSetup _plugin;
            private Plugin _ownerPlugin => _plugin.ServerRewards;

            public ServerRewardsPaymentProvider(CustomVendingSetup plugin)
            {
                _plugin = plugin;
            }

            public bool IsAvailable => _ownerPlugin != null;

            public int GetBalance(BasePlayer player)
            {
                return Convert.ToInt32(_plugin.CallPlugin(_ownerPlugin, "CheckPoints", (ulong)player.userID));
            }

            public bool AddBalance(BasePlayer player, int amount, TransactionContext transaction)
            {
                var result = _plugin.CallPlugin(_ownerPlugin, "AddPoints", (ulong)player.userID, amount);
                return result is true;
            }

            public bool TakeBalance(BasePlayer player, int amount, List<Item> collect)
            {
                var result = _plugin.CallPlugin(_ownerPlugin, "TakePoints", (ulong)player.userID, amount);
                return result is true;
            }
        }

        private class PaymentProviderResolver
        {
            public readonly EconomicsPaymentProvider EconomicsPaymentProvider;
            public readonly ServerRewardsPaymentProvider ServerRewardsPaymentProvider;

            private readonly CustomVendingSetup _plugin;
            private readonly ItemsPaymentProvider _itemsPaymentProvider;
            private Configuration _config => _plugin._config;

            public PaymentProviderResolver(CustomVendingSetup plugin)
            {
                _plugin = plugin;
                _itemsPaymentProvider = new ItemsPaymentProvider(plugin);
                EconomicsPaymentProvider = new EconomicsPaymentProvider(plugin);
                ServerRewardsPaymentProvider = new ServerRewardsPaymentProvider(plugin);
            }

            public IPaymentProvider Resolve(VendingItem vendingItem)
            {
                if (_config.Economics.MatchesItem(vendingItem) && EconomicsPaymentProvider.IsAvailable)
                    return EconomicsPaymentProvider;

                if (_config.ServerRewards.MatchesItem(vendingItem) && ServerRewardsPaymentProvider.IsAvailable)
                    return ServerRewardsPaymentProvider;

                _itemsPaymentProvider.VendingItem = vendingItem;
                return _itemsPaymentProvider;
            }
        }

        #endregion

        #region Item Query

        private struct ItemQuery
        {
            public static ItemQuery FromSellItem(VendingItem vendingItem)
            {
                return new ItemQuery
                {
                    BlueprintId = vendingItem.IsBlueprint ? vendingItem.ItemId : 0,
                    DataInt = vendingItem.DataInt,
                    DisplayName = vendingItem.DisplayName,
                    ItemId = vendingItem.IsBlueprint ? BlueprintItemId : vendingItem.ItemId,
                    SkinId = vendingItem.SkinId,
                };
            }

            public static ItemQuery FromCurrencyItem(VendingItem vendingItem)
            {
                var itemQuery = new ItemQuery
                {
                    BlueprintId = vendingItem.IsBlueprint ? vendingItem.ItemId : 0,
                    MinCondition = MinCurrencyCondition,
                    ItemId = vendingItem.IsBlueprint ? BlueprintItemId : vendingItem.ItemId,
                };

                if (vendingItem.SkinId != 0)
                {
                    itemQuery.SkinId = vendingItem.SkinId;
                }

                return itemQuery;
            }

            public int BlueprintId;
            public int DataInt;
            public string DisplayName;
            public Item.Flag Flags;
            public int ItemId;
            public float MinCondition;
            public bool RequireEmpty;
            public ulong? SkinId;

            public int GetUsableAmount(Item item)
            {
                if (ItemId != 0 && ItemId != item.info.itemid)
                    return 0;

                if (SkinId.HasValue && SkinId != item.skin)
                    return 0;

                if (BlueprintId != 0 && BlueprintId != item.blueprintTarget)
                    return 0;

                if (DataInt != 0 && DataInt != (item.instanceData?.dataInt ?? 0))
                    return 0;

                if (Flags != 0 && !item.flags.HasFlag(Flags))
                    return 0;

                if (MinCondition > 0 && item.hasCondition && (item.conditionNormalized < MinCondition || item.maxConditionNormalized < MinCondition))
                    return 0;

                if (!string.IsNullOrEmpty(DisplayName) && !StringUtils.EqualsCaseInsensitive(DisplayName, item.name))
                    return 0;

                return RequireEmpty && item.contents?.itemList?.Count > 0
                    ? Math.Max(0, item.amount - 1)
                    : item.amount;
            }
        }

        #endregion

        #region Item Utils

        private static class ItemUtils
        {
            public static Item FindFirstContainerItem(ItemContainer container, ref ItemQuery itemQuery)
            {
                foreach (var item in container.itemList)
                {
                    if (itemQuery.GetUsableAmount(item) > 0)
                        return item;
                }

                return null;
            }

            public static int SumContainerItems(ItemContainer container, ref ItemQuery itemQuery)
            {
                var sum = 0;

                foreach (var item in container.itemList)
                {
                    sum += itemQuery.GetUsableAmount(item);
                }

                return sum;
            }

            public static int SumPlayerItems(BasePlayer player, ref ItemQuery itemQuery)
            {
                return SumContainerItems(player.inventory.containerMain, ref itemQuery)
                    + SumContainerItems(player.inventory.containerBelt, ref itemQuery);
            }

            public static int TakeContainerItems(ItemContainer container, ref ItemQuery itemQuery, int totalAmountToTake, List<Item> collect = null)
            {
                var totalAmountTaken = 0;

                for (var i = container.itemList.Count - 1; i >= 0; i--)
                {
                    var amountToTake = totalAmountToTake - totalAmountTaken;
                    if (amountToTake <= 0)
                        break;

                    var item = container.itemList[i];
                    var usableAmount = itemQuery.GetUsableAmount(item);
                    if (usableAmount > 0)
                    {
                        amountToTake = Math.Min(item.amount, amountToTake);

                        if (item.amount > amountToTake)
                        {
                            if (collect != null)
                            {
                                var splitItem = item.SplitItem(amountToTake);
                                var playerOwner = splitItem.GetOwnerPlayer();
                                if (playerOwner != null)
                                {
                                    splitItem.CollectedForCrafting(playerOwner);
                                }
                                collect.Add(splitItem);
                            }
                            else
                            {
                                item.amount -= amountToTake;
                                item.MarkDirty();
                            }
                        }
                        else
                        {
                            item.RemoveFromContainer();

                            if (collect != null)
                            {
                                collect.Add(item);
                            }
                            else
                            {
                                item.Remove();
                            }
                        }

                        totalAmountTaken += amountToTake;
                    }

                    if (totalAmountTaken >= totalAmountToTake)
                        return totalAmountTaken;
                }

                return totalAmountTaken;
            }

            public static int TakePlayerItems(BasePlayer player, ref ItemQuery itemQuery, int amountToTake, List<Item> collect = null)
            {
                var amountTaken = TakeContainerItems(player.inventory.containerMain, ref itemQuery, amountToTake, collect);
                if (amountTaken >= amountToTake)
                    return amountTaken;

                amountTaken += TakeContainerItems(player.inventory.containerBelt, ref itemQuery, amountToTake - amountTaken, collect);
                if (amountTaken >= amountToTake)
                    return amountTaken;

                amountTaken += TakeContainerItems(player.inventory.containerWear, ref itemQuery, amountToTake - amountTaken, collect);
                if (amountTaken >= amountToTake)
                    return amountTaken;

                return amountTaken;
            }
        }

        #endregion

        #region Dynamic Hook Subscriptions

        private class DynamicHookSubscriber<T>
        {
            private CustomVendingSetup _plugin;
            private HashSet<T> _list = new();
            private string[] _hookNames;

            public DynamicHookSubscriber(CustomVendingSetup plugin, params string[] hookNames)
            {
                _plugin = plugin;
                _hookNames = hookNames;
            }

            public bool Contains(T item)
            {
                return _list.Contains(item);
            }

            public void Add(T item)
            {
                if (_list.Add(item) && _list.Count == 1)
                {
                    SubscribeAll();
                }
            }

            public void Remove(T item)
            {
                if (_list.Remove(item) && _list.Count == 0)
                {
                    UnsubscribeAll();
                }
            }

            public void SubscribeAll()
            {
                foreach (var hookName in _hookNames)
                {
                    _plugin.Subscribe(hookName);
                }
            }

            public void UnsubscribeAll()
            {
                foreach (var hookName in _hookNames)
                {
                    _plugin.Unsubscribe(hookName);
                }
            }
        }

        #endregion

        #region Data Utils

        private interface IDataLoader
        {
            bool Exists(string filename);
            T Load<T>(string filename) where T : new();
            void Save<T>(string filename, T data);
        }

        private class ProtoLoader : IDataLoader
        {
            public bool Exists(string filename)
            {
                return ProtoStorage.Exists(filename);
            }

            public T Load<T>(string filename) where T : new()
            {
                if (Exists(filename))
                    return ProtoStorage.Load<T>(filename) ?? new T();

                return new T();
            }

            public void Save<T>(string filename, T data)
            {
                ProtoStorage.Save(data, filename);
            }
        }

        private class JsonLoader : IDataLoader
        {
            public bool Exists(string filename)
            {
                return Interface.Oxide.DataFileSystem.ExistsDatafile(filename);
            }

            public T Load<T>(string filename) where T : new()
            {
                if (Exists(filename))
                    return Interface.Oxide.DataFileSystem.ReadObject<T>(filename) ?? new T();

                return new T();
            }

            public void Save<T>(string filename, T data)
            {
                Interface.Oxide.DataFileSystem.WriteObject(filename, data);
            }
        }

        private interface IDataLoader<T> where T : new()
        {
            bool Exists();
            T Load();
            void Save(T data);
        }

        private class ProtoLoader<T> : IDataLoader<T> where T : new()
        {
            private readonly ProtoLoader _protoLoader = new();
            private readonly string _filename = null;

            public ProtoLoader(string filename)
            {
                _filename = filename;
            }

            public bool Exists()
            {
                return _protoLoader.Exists(_filename);
            }

            public T Load()
            {
                return _protoLoader.Load<T>(_filename);
            }

            public void Save(T data)
            {
                _protoLoader.Save(_filename, data);
            }
        }

        private class JsonLoader<T> : IDataLoader<T> where T : new()
        {
            private readonly JsonLoader _jsonLoader = new();
            private readonly string _filename = null;

            public JsonLoader(string filename)
            {
                _filename = filename;
            }

            public bool Exists()
            {
                return _jsonLoader.Exists(_filename);
            }

            public T Load()
            {
                return _jsonLoader.Load<T>(_filename);
            }

            public void Save(T data)
            {
                _jsonLoader.Save(_filename, data);
            }
        }

        #endregion

        #region Data Provider

        private interface IDataProvider
        {
            VendingProfile GetData();
            void SaveData(VendingProfile vendingProfile, NPCVendingMachine vendingMachine = null);
        }

        private abstract class DataFileDataProvider : IDataProvider
        {
            private BaseVendingProfileDataFile _dataFile;
            private VendingProfile _vendingProfile;

            protected abstract void BeforeSave(VendingProfile vendingProfile, NPCVendingMachine vendingMachine);

            protected DataFileDataProvider(BaseVendingProfileDataFile dataFile, VendingProfile vendingProfile)
            {
                _dataFile = dataFile;
                _vendingProfile = vendingProfile;
            }

            public VendingProfile GetData()
            {
                return _vendingProfile;
            }

            public void SaveData(VendingProfile vendingProfile, NPCVendingMachine vendingMachine = null)
            {
                if (vendingProfile == null)
                {
                    if (_vendingProfile == null)
                        return;

                    if (!_dataFile.VendingProfiles.Remove(_vendingProfile))
                        return;
                }
                else if (!_dataFile.VendingProfiles.Contains(vendingProfile))
                {
                    _dataFile.VendingProfiles.Add(vendingProfile);
                }

                _vendingProfile = vendingProfile;
                BeforeSave(vendingProfile, vendingMachine);
                _dataFile.Save();
            }
        }

        private class PrefabRelativeDataProvider : DataFileDataProvider
        {
            public PrefabRelativePosition Location;

            public PrefabRelativeDataProvider(SavedPrefabRelativeData prefabRelativeData, PrefabRelativePosition location, VendingProfile vendingProfile)
                : base(prefabRelativeData, vendingProfile)
            {
                Location = location;
            }

            protected override void BeforeSave(VendingProfile vendingProfile, NPCVendingMachine vendingMachine)
            {
                if (vendingProfile == null)
                    return;

                vendingProfile.Monument = Location.GetPrefabName();
                vendingProfile.MonumentAlias = Location.GetPrefabAlias();
                vendingProfile.Position = Location.GetCurrentPosition();
            }
        }

        private class MapDataProvider : DataFileDataProvider
        {
            public MapDataProvider(SavedMapData mapData, VendingProfile vendingProfile)
                : base(mapData, vendingProfile) {}

            protected override void BeforeSave(VendingProfile vendingProfile, NPCVendingMachine vendingMachine)
            {
                if (vendingProfile == null)
                    return;

                // Update the location, in case the vending machine has moved.
                vendingProfile.Position = vendingMachine.transform.position;
            }
        }

        private class PluginDataProvider : IDataProvider
        {
            public static PluginDataProvider FromDictionary(Dictionary<string, object> spec)
            {
                var dataProvider = new PluginDataProvider
                {
                    Spec = spec,
                };

                if (spec.TryGetValue("Plugin", out var plugin))
                {
                    dataProvider.Plugin = plugin as Plugin;
                }

                if (spec.TryGetValue("GetData", out var getDataCallback))
                {
                    dataProvider.GetDataCallback = getDataCallback as CustomGetDataCallback;
                }

                if (spec.TryGetValue("SaveData", out var saveDataCallback))
                {
                    dataProvider.SaveDataCallback = saveDataCallback as CustomSaveDataCallback;
                }

                if (spec.TryGetValue("GetSkin", out var getSkinCallback))
                {
                    dataProvider.GetSkinCallback = getSkinCallback as CustomGetSkinCallback;
                }

                if (spec.TryGetValue("SetSkin", out var setSkinCallback))
                {
                    dataProvider.SetSkinCallback = setSkinCallback as CustomSetSkinCallback;
                }

                if (dataProvider.GetDataCallback == null)
                {
                    LogError("Data provider missing GetData");
                    return null;
                }

                if (dataProvider.SaveDataCallback == null)
                {
                    LogError("Data provider missing SaveData");
                    return null;
                }

                return dataProvider;
            }

            public Dictionary<string, object> Spec { get; private set; }
            public Plugin Plugin;
            public CustomGetDataCallback GetDataCallback;
            public CustomSaveDataCallback SaveDataCallback;
            public CustomGetSkinCallback GetSkinCallback;
            public CustomSetSkinCallback SetSkinCallback;

            private VendingProfile _vendingProfile;

            public VendingProfile GetData()
            {
                _vendingProfile ??= GetDataCallback()?.ToObject<VendingProfile>();
                if (_vendingProfile?.Offers == null)
                    return null;

                // DataProvider skin takes precedence if not 0.
                if (GetSkinCallback?.Invoke() is { } skinId && skinId != 0)
                {
                    _vendingProfile.SkinId = skinId;
                }

                return _vendingProfile;
            }

            public void SaveData(VendingProfile vendingProfile, NPCVendingMachine vendingMachine = null)
            {
                var jObject = vendingProfile != null ? JObject.FromObject(vendingProfile) : null;

                if (vendingProfile != null && SetSkinCallback != null)
                {
                    // Inform the Data Provider about the updated skin.
                    SetSkinCallback.Invoke(vendingProfile.SkinId == NpcVendingMachineSkinId ? 0 : vendingProfile.SkinId);

                    // Remove the skin from the full payload, so the Data Provider has only one source of truth.
                    jObject.Remove(VendingProfile.SkinIdField);
                }

                _vendingProfile = vendingProfile;
                SaveDataCallback(jObject);
            }
        }

        private class PluginDataProviderRegistry
        {
            private Dictionary<Dictionary<string, object>, PluginDataProvider> _dataProviderCache = new();

            public PluginDataProvider Register(Dictionary<string, object> dataProviderSpec)
            {
                if (_dataProviderCache.TryGetValue(dataProviderSpec, out var dataProvider))
                    return dataProvider;

                dataProvider = PluginDataProvider.FromDictionary(dataProviderSpec);
                if (dataProvider == null)
                    return null;

                _dataProviderCache[dataProviderSpec] = dataProvider;
                return dataProvider;
            }

            public void Unregister(PluginDataProvider dataProvider)
            {
                _dataProviderCache.Remove(dataProvider.Spec);
            }
        }

        #endregion

        #region Vending Machine Manager

        private class VendingMachineManager
        {
            private CustomVendingSetup _plugin;
            private ComponentFactory<NPCVendingMachine, VendingMachineComponent> _componentFactory;
            private PluginDataProviderRegistry _dataProviderRegistry;

            private HashSet<VendingController> _uniqueControllers = new();

            // Controllers are also cached by vending machine, in case MonumentFinder is unloaded or becomes unstable.
            private Dictionary<NetworkableId, VendingController> _controllersByVendingMachine = new();

            private Dictionary<PluginDataProvider, VendingController> _controllersByPluginDataProvider = new();

            private MonumentFinderAdapter _monumentFinderAdapter => _plugin._monumentFinderAdapter;
            private SavedPrefabRelativeData PrefabRelativeData => _plugin._prefabRelativeData;
            private SavedMapData _mapData => _plugin._mapData;
            private SavedSalesData _salesData => _plugin._salesData;

            public VendingMachineManager(CustomVendingSetup plugin, ComponentFactory<NPCVendingMachine, VendingMachineComponent> componentFactory, PluginDataProviderRegistry dataProviderRegistry)
            {
                _plugin = plugin;
                _componentFactory = componentFactory;
                _dataProviderRegistry = dataProviderRegistry;
            }

            public void HandleVendingMachineSpawned(NPCVendingMachine vendingMachine)
            {
                var controller = GetController(vendingMachine);
                if (controller != null)
                {
                    // A controller may already exist if this was called when handling a reload of MonumentFinder.
                    HandleExistingController(vendingMachine, controller);
                    return;
                }

                var hookResult = ExposedHooks.OnCustomVendingSetup(vendingMachine);
                if (hookResult is false)
                    return;

                controller = GetOrCreateController(vendingMachine);
                if (controller == null)
                    return;

                controller.AddVendingMachine(vendingMachine);
                _controllersByVendingMachine[vendingMachine.net.ID] = controller;
            }

            public void HandleVendingMachineKilled(NPCVendingMachine vendingMachine)
            {
                var controller = GetController(vendingMachine);
                if (controller == null)
                    return;

                RemoveFromController(controller, vendingMachine);
            }

            public void RefreshDataProvider(NPCVendingMachine vendingMachine)
            {
                HandleVendingMachineKilled(vendingMachine);
                HandleVendingMachineSpawned(vendingMachine);
            }

            public VendingController GetController(NPCVendingMachine vendingMachine)
            {
                return _controllersByVendingMachine.TryGetValue(vendingMachine.net.ID, out var controller)
                    ? controller
                    : null;
            }

            public void SetupAll()
            {
                foreach (var entity in BaseNetworkable.serverEntities)
                {
                    var vendingMachine = entity as NPCVendingMachine;
                    if (vendingMachine == null)
                        continue;

                    HandleVendingMachineSpawned(vendingMachine);
                }
            }

            public void ResetAll()
            {
                foreach (var controller in _controllersByVendingMachine.Values)
                {
                    controller.Destroy();
                }
            }

            public void SaveAllSalesData()
            {
                _salesData.VendingMachines.Clear();

                foreach (var controller in _uniqueControllers)
                {
                    // Only save vending machines which are customized.
                    if (controller.Profile?.Offers == null)
                        continue;

                    foreach (var vendingMachine in controller.VendingMachineList)
                    {
                        // Only save vending machines which have dynamic pricing enabled.
                        if (vendingMachine.BypassDynamicPricing)
                            continue;

                        _salesData.VendingMachines.Add(VendingMachineState.FromVendingMachine(vendingMachine));
                    }
                }

                _salesData.Save();
            }

            private VendingController FindPrefabRelativeController(PrefabRelativePosition location)
            {
                foreach (var controller in _uniqueControllers)
                {
                    if (controller.DataProvider is not PrefabRelativeDataProvider relativeDataProvider)
                        continue;

                    if (LocationsMatch(relativeDataProvider.Location, location))
                        return controller;
                }

                return null;
            }

            private VendingController GetControllerByPluginDataProvider(PluginDataProvider dataProvider)
            {
                return _controllersByPluginDataProvider.TryGetValue(dataProvider, out var controller)
                    ? controller
                    : null;
            }

            private VendingController CreateController(IDataProvider dataProvider)
            {
                var controller = new VendingController(_plugin, _componentFactory, dataProvider);
                _uniqueControllers.Add(controller);
                return controller;
            }

            private void AddToController(VendingController controller, NPCVendingMachine vendingMachine)
            {
                controller.AddVendingMachine(vendingMachine);
                _controllersByVendingMachine[vendingMachine.net.ID] = controller;
            }

            private void RemoveFromController(VendingController controller, NPCVendingMachine vendingMachine)
            {
                controller.RemoveVendingMachine(vendingMachine);
                _controllersByVendingMachine.Remove(vendingMachine.net.ID);

                if (controller.HasVendingMachines)
                    return;

                _uniqueControllers.Remove(controller);

                if (controller.DataProvider is PluginDataProvider dataProvider)
                {
                    _controllersByPluginDataProvider.Remove(dataProvider);
                    _dataProviderRegistry.Unregister(dataProvider);
                }
            }

            private VendingController CreatePrefabRelativeController(PrefabRelativePosition location)
            {
                return CreateController(new PrefabRelativeDataProvider(PrefabRelativeData, location, PrefabRelativeData.FindProfile(location)));
            }

            private void HandleExistingController(NPCVendingMachine vendingMachine, VendingController controller)
            {
                // Only replace a controller if it's a map data provider without existing data.
                if (controller.DataProvider is not MapDataProvider || controller.DataProvider.GetData() != null)
                    return;

                // Keep using the existing map controller and data provider if not prefab-relative eligible.
                if (PrefabRelativePosition.FromVendingMachine(_monumentFinderAdapter, vendingMachine) is not { } location)
                    return;

                // Replace the map controller with a prefab-relative controller.
                RemoveFromController(controller, vendingMachine);
                AddToController(FindPrefabRelativeController(location) ?? CreatePrefabRelativeController(location), vendingMachine);
            }

            private MapDataProvider CreateMapDataProvider(VendingProfile vendingProfile = null)
            {
                return new MapDataProvider(_mapData, vendingProfile);
            }

            private VendingController GetOrCreateController(NPCVendingMachine vendingMachine)
            {
                // Check if another plugin wants to take ownership of the vending machine.
                var dataProviderSpec = ExposedHooks.OnCustomVendingSetupDataProvider(vendingMachine);
                if (dataProviderSpec != null)
                {
                    var pluginDataProvider = _dataProviderRegistry.Register(dataProviderSpec);
                    if (pluginDataProvider == null)
                    {
                        // Data provider is invalid.
                        return null;
                    }

                    var pluginController = GetControllerByPluginDataProvider(pluginDataProvider);
                    if (pluginController != null)
                        return pluginController;

                    pluginController = CreateController(pluginDataProvider);
                    _controllersByPluginDataProvider[pluginDataProvider] = pluginController;
                    return pluginController;
                }

                // Use a map data provider if map data exists for this vending machine.
                var vendingProfile = _mapData.FindProfile(vendingMachine.transform.position);
                if (vendingProfile != null)
                    return CreateController(CreateMapDataProvider(vendingProfile));

                // Use a prefab-relative data provider if parented or within a monument.
                if (PrefabRelativePosition.FromVendingMachine(_monumentFinderAdapter, vendingMachine) is { } location)
                    return FindPrefabRelativeController(location) ?? CreatePrefabRelativeController(location);

                // Use a map data provider if not prefab-relative eligible.
                return CreateController(CreateMapDataProvider());
            }
        }

        #endregion

        #region Edit Controller

        private class EditContainerComponent : FacepunchBehaviour
        {
            public static void AddToContainer(CustomVendingSetup plugin, StorageContainer container, EditController editController)
            {
                var component = container.GetOrAddComponent<EditContainerComponent>();
                component._plugin = plugin;
                component._editController = editController;
            }

            private CustomVendingSetup _plugin;
            private EditController _editController;

            private void PlayerStoppedLooting(BasePlayer player)
            {
                _plugin.TrackStart();
                _editController.HandlePlayerLootEnd(player);
                _plugin.TrackEnd();
            }
        }

        private class EditController
        {
            private static void OpenEditPanel(BasePlayer player, StorageContainer containerEntity)
            {
                var playerLoot = player.inventory.loot;
                playerLoot.Clear();
                playerLoot.PositionChecks = false;
                playerLoot.entitySource = containerEntity;
                playerLoot.itemSource = null;
                playerLoot.MarkDirty();
                playerLoot.AddContainer(containerEntity.inventory);
                playerLoot.SendImmediate();
                player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", containerEntity.panelName);
            }

            public BasePlayer EditorPlayer { get; }

            private CustomVendingSetup _plugin;
            private VendingController _vendingController;
            private NPCVendingMachine _vendingMachine;
            private StorageContainer _container;
            private EditFormState _formState;

            public EditController(CustomVendingSetup plugin, VendingController vendingController, NPCVendingMachine vendingMachine, BasePlayer editorPlayer)
            {
                _plugin = plugin;
                _vendingController = vendingController;
                _vendingMachine = vendingMachine;
                EditorPlayer = editorPlayer;

                var offers = vendingController.Profile?.Offers ?? GetOffersFromVendingMachine(vendingMachine);

                _container = CreateOrdersContainer(plugin, vendingMachine, editorPlayer, offers);
                _formState = EditFormState.FromVendingMachine(vendingController, vendingMachine);
                EditContainerComponent.AddToContainer(plugin, _container, this);
                _container.SendAsSnapshot(editorPlayer.Connection);
                OpenEditPanel(editorPlayer, _container);

                CuiHelper.AddUi(editorPlayer, ContainerUIRenderer.RenderContainerUI(plugin, editorPlayer, vendingMachine, _vendingController, _formState));
            }

            public void ToggleBroadcast()
            {
                _formState.Broadcast = !_formState.Broadcast;

                CuiHelper.AddUi(EditorPlayer, ContainerUIRenderer.RenderBroadcastUI(_vendingMachine, _formState));
            }

            public void ToggleDroneAccessible()
            {
                if (!_formState.Broadcast)
                {
                    _formState.DroneAccessible = true;
                    _formState.Broadcast = true;
                }
                else
                {
                    _formState.DroneAccessible = !_formState.DroneAccessible;
                }

                CuiHelper.AddUi(EditorPlayer, ContainerUIRenderer.RenderBroadcastUI(_vendingMachine, _formState));
            }

            public void ApplyStateTo(VendingProfile profile)
            {
                profile.Offers = GetOffersFromContainer(_plugin, EditorPlayer, _container.inventory);
                profile.Broadcast = _formState.Broadcast;
                profile.DroneAccessible = _formState.DroneAccessible;

                var generalSettingsText = _container.inventory.GetSlot(GeneralSettingsNoteSlot)?.text.Trim();

                if (!string.IsNullOrEmpty(generalSettingsText))
                {
                    var settingsDict = ParseSettings(generalSettingsText);

                    if (NPCVendingMachine.DynamicPricingEnabled)
                    {
                        var dynamicPricingEnabledKey = _plugin.GetMessage(EditorPlayer, Lang.SettingsBypassDynamicPricing);
                        if (settingsDict.TryGetValue(dynamicPricingEnabledKey, out var bypassDynamicPricingString)
                            && bool.TryParse(bypassDynamicPricingString, out var bypassDynamicPricing))
                        {
                            profile.BypassDynamicPricing = bypassDynamicPricing;
                        }
                    }

                    if (CanVendingMachineBeSkinned(_vendingMachine))
                    {
                        var skinIdKey = _plugin.GetMessage(EditorPlayer, Lang.SettingsSkinId);
                        if (settingsDict.TryGetValue(skinIdKey, out var skinIdString)
                            && ulong.TryParse(skinIdString, out var skinId))
                        {
                            profile.SkinId = skinId;
                        }
                        else
                        {
                            // Allow the user to revert to vanilla skin by simply removing the option.
                            profile.SkinId = NpcVendingMachineSkinId;
                        }
                    }

                    var shopNameKey = _plugin.GetMessage(EditorPlayer, Lang.SettingsShopName);
                    if (settingsDict.TryGetValue(shopNameKey, out var shopName))
                    {
                        profile.ShopName = shopName;
                    }
                }
            }

            public void HandlePlayerLootEnd(BasePlayer player)
            {
                Kill();
            }

            public void Kill()
            {
                DestroyUI();
                KillContainer();
                _vendingController.OnEditControllerKilled();
            }

            private void DestroyUI()
            {
                CuiHelper.DestroyUi(EditorPlayer, ContainerUIRenderer.UIName);
            }

            private void KillContainer()
            {
                if (_container == null || _container.IsDestroyed)
                    return;

                if (EditorPlayer != null && !EditorPlayer.IsDestroyed && EditorPlayer.IsConnected)
                {
                    _container.OnNetworkSubscribersLeave(new List<Network.Connection> { EditorPlayer.Connection });
                }

                _plugin._bagOfHoldingLimitManager.RemoveLimitProfile(_container.inventory);
                _container.Kill();
                _container = null;
            }
        }

        #endregion

        #region Vending Machine Controller

        private class VendingController
        {
            public IDataProvider DataProvider { get; }

            // While the Profile is null, the vending machines will be vanilla.
            public VendingProfile Profile => DataProvider.GetData();

            // While the EditController is non-null, a player is editing the vending machine.
            public EditController EditController { get; protected set; }

            public bool HasVendingMachines => VendingMachineList.Count > 0;

            protected CustomVendingSetup _plugin;

            // List of vending machines with a position matching this controller.
            public HashSet<NPCVendingMachine> VendingMachineList = new();

            private ComponentFactory<NPCVendingMachine, VendingMachineComponent> _componentFactory;

            private string _cachedShopUI;

            public VendingController(CustomVendingSetup plugin, ComponentFactory<NPCVendingMachine, VendingMachineComponent> componentFactory, IDataProvider dataProvider)
            {
                _plugin = plugin;
                _componentFactory = componentFactory;
                DataProvider = dataProvider;
                UpdateDroneAccessibility();
            }

            public void StartEditing(BasePlayer player, NPCVendingMachine vendingMachine)
            {
                if (EditController != null)
                    return;

                EditController = new EditController(_plugin, this, vendingMachine, player);
            }

            public void HandleReset()
            {
                DataProvider.SaveData(null);
                SetupVendingMachines();
                EditController?.Kill();
                _plugin._inaccessibleVendingMachines.Remove(this);

                _cachedShopUI = null;
            }

            public void Destroy()
            {
                ResetVendingMachines();
                EditController?.Kill();
            }

            public void HandleSave(NPCVendingMachine vendingMachine)
            {
                var profile = Profile ?? VendingProfile.FromVendingMachine(vendingMachine);

                EditController.ApplyStateTo(profile);
                EditController.Kill();

                DataProvider.SaveData(profile, vendingMachine);
                SetupVendingMachines();

                _cachedShopUI = null;

                UpdateDroneAccessibility();
            }

            public void AddVendingMachine(NPCVendingMachine vendingMachine)
            {
                if (!VendingMachineList.Add(vendingMachine))
                    return;

                var component = _componentFactory.GetOrAddTo(vendingMachine);
                component.SetController(this);
                component.SetProfile(Profile);
            }

            public void RemoveVendingMachine(NPCVendingMachine vendingMachine)
            {
                if (!VendingMachineList.Remove(vendingMachine))
                    return;

                if (VendingMachineList.Count == 0)
                {
                    EditController?.Kill();
                    _plugin._inaccessibleVendingMachines.Remove(this);
                }
            }

            public void OnEditControllerKilled()
            {
                EditController = null;
            }

            public string GetShopUI()
            {
                return _cachedShopUI ??= ShopUIRenderer.RenderShopUI(Profile);
            }

            protected void UpdateDroneAccessibility()
            {
                if (Profile == null)
                    return;

                if (Profile.Broadcast && !Profile.DroneAccessible)
                {
                    _plugin._inaccessibleVendingMachines.Add(this);
                }
                else
                {
                    _plugin._inaccessibleVendingMachines.Remove(this);
                }
            }

            private void SetupVendingMachines()
            {
                foreach (var vendingMachine in VendingMachineList)
                {
                    _componentFactory.GetOrAddTo(vendingMachine).SetProfile(Profile);
                }
            }

            private void ResetVendingMachines()
            {
                foreach (var vendingMachine in VendingMachineList)
                {
                    VendingMachineComponent.RemoveFromVendingMachine(vendingMachine);
                }
            }
        }

        #endregion

        #region Component Tracker & Factory

        private class ComponentTracker<THost, TGuest>
            where THost : UnityEngine.Component
            where TGuest : UnityEngine.Component
        {
            private readonly Dictionary<THost, TGuest> _hostToGuest = new();

            public void RegisterComponent(THost host, TGuest guest)
            {
                _hostToGuest[host] = guest;
            }

            public TGuest GetComponent(THost host)
            {
                return _hostToGuest.TryGetValue(host, out var guest)
                    ? guest
                    : null;
            }

            public void UnregisterComponent(THost source)
            {
                _hostToGuest.Remove(source);
            }
        }

        private class TrackedComponent<THost, TGuest> : FacepunchBehaviour
            where THost : UnityEngine.Component
            where TGuest : TrackedComponent<THost, TGuest>
        {
            public CustomVendingSetup Plugin;
            public ComponentTracker<THost, TGuest> ComponentTracker;
            public THost Host;

            public virtual void OnCreated() {}

            protected virtual void OnDestroy()
            {
                ComponentTracker?.UnregisterComponent(Host);
            }
        }

        private class ComponentFactory<THost, TGuest>
            where THost : UnityEngine.Component
            where TGuest : TrackedComponent<THost, TGuest>
        {
            private CustomVendingSetup _plugin;
            private ComponentTracker<THost, TGuest> _componentTracker;

            public ComponentFactory(CustomVendingSetup plugin, ComponentTracker<THost, TGuest> componentTracker)
            {
                _plugin = plugin;
                _componentTracker = componentTracker;
            }

            public TGuest GetOrAddTo(THost host)
            {
                var guest = _componentTracker.GetComponent(host);
                if (guest == null)
                {
                    guest = host.gameObject.AddComponent<TGuest>();
                    guest.Plugin = _plugin;
                    guest.ComponentTracker = _componentTracker;
                    guest.Host = host;
                    guest.OnCreated();
                    _componentTracker.RegisterComponent(host, guest);
                }

                return guest;
            }
        }

        #endregion

        #region Vending Machine Component

        private class VendingMachineComponent : TrackedComponent<NPCVendingMachine, VendingMachineComponent>
        {
            public static void RemoveFromVendingMachine(NPCVendingMachine vendingMachine) =>
                DestroyImmediate(vendingMachine.GetComponent<VendingMachineComponent>());

            public VendingProfile Profile { get; private set; }

            private readonly List<BasePlayer> _adminUIViewers = new();
            private readonly List<BasePlayer> _shopUIViewers = new();
            private VendingController _vendingController;
            private NPCVendingMachine _vendingMachine;
            private float[] _refillTimes;

            private string _originalShopName;
            private ulong _originalSkinId;
            private bool _originalBypassDynamicPricing;
            private bool? _originalBroadcast;

            private IDataProvider _dataProvider => _vendingController.DataProvider;

            public override void OnCreated()
            {
                _vendingMachine = Host;
            }

            public bool HasUI(BasePlayer player)
            {
                return _adminUIViewers.Contains(player) || _shopUIViewers.Contains(player);
            }

            public void ShowAdminUI(BasePlayer player)
            {
                _adminUIViewers.Add(player);
                CuiHelper.AddUi(player, AdminUIRenderer.RenderAdminUI(Plugin, player, _vendingMachine, Profile));
            }

            public void ShowShopUI(BasePlayer player)
            {
                var json = _vendingController.GetShopUI();
                if (json == string.Empty)
                    return;

                _shopUIViewers.Add(player);
                CuiHelper.AddUi(player, json);
            }

            public void RemoveUI(BasePlayer player)
            {
                if (_adminUIViewers.Remove(player))
                {
                    DestroyAdminUI(player);
                }

                if (_shopUIViewers.Remove(player))
                {
                    DestroyShopUI(player);
                }

                // Make sure OnEntitySaved/OnInventoryNetworkUpdate are unsubscribed (when all players are removed).
                Plugin._playersNeedingFakeInventory.Remove(player);

                // Mark inventory dirty to send a network update, which will no longer be modified by hooks.
                player.inventory.containerMain.MarkDirty();
            }

            protected override void OnDestroy()
            {
                base.OnDestroy();

                DestroyUIs();

                if (Profile?.Offers != null && (_vendingMachine != null && !_vendingMachine.IsDestroyed))
                {
                    ResetToVanilla();
                }
            }

            private void PlayerStoppedLooting(BasePlayer player)
            {
                Plugin.TrackStart();
                RemoveUI(player);
                Plugin.TrackEnd();
            }

            public void SetController(VendingController vendingController)
            {
                _vendingController = vendingController;
            }

            public void SetProfile(VendingProfile profile)
            {
                if (Profile == null && profile != null)
                {
                    DisableVanillaBehavior();
                }
                else if (Profile != null && profile == null)
                {
                    ResetToVanilla();
                }

                Profile = profile;

                if (profile?.Offers == null)
                    return;

                _refillTimes = new float[Profile.Offers.Length];

                for (var i = _vendingMachine.inventory.itemList.Count - 1; i >= 0; i--)
                {
                    var item = _vendingMachine.inventory.itemList[i];
                    item.RemoveFromContainer();
                    item.Remove();
                }

                _vendingMachine.ClearSellOrders();

                // Save original values.
                _originalBypassDynamicPricing = _vendingMachine.BypassDynamicPricing;
                _originalSkinId = _vendingMachine.skinID;
                _originalShopName ??= _vendingMachine.shopName;
                _originalBroadcast ??= _vendingMachine.IsBroadcasting();

                // Apply profiles values.
                _vendingMachine.BypassDynamicPricing = profile.BypassDynamicPricing;
                _vendingMachine.skinID = profile.SkinId;

                if (!string.IsNullOrEmpty(profile.ShopName))
                {
                    _vendingMachine.shopName = profile.ShopName;
                }

                if (_vendingMachine.IsBroadcasting() != profile.Broadcast)
                {
                    _vendingMachine.SetFlag(VendingMachineFlags.Broadcasting, profile.Broadcast);
                    _vendingMachine.UpdateMapMarker();
                }

                for (var i = 0; i < profile.Offers.Length && i < MaxVendingOffers; i++)
                {
                    var offer = profile.Offers[i];
                    if (!offer.IsValid)
                        continue;

                    var vendingOffer = new SellOrder
                    {
                        ShouldPool = false,
                        itemToSellID = offer.SellItem.ItemId,
                        itemToSellAmount = offer.SellItem.Amount,
                        itemToSellIsBP = offer.SellItem.IsBlueprint,
                        currencyID = offer.CurrencyItem.ItemId,
                        currencyAmountPerItem = offer.CurrencyItem.Amount,
                        currencyIsBP = offer.CurrencyItem.IsBlueprint,
                    };

                    Interface.CallHook("OnAddVendingOffer", _vendingMachine, vendingOffer);
                    _vendingMachine.sellOrders.sellOrders.Add(vendingOffer);
                }

                CustomRefill(maxRefill: true);

                Plugin._salesData.FindState(_vendingMachine)?.ApplyToVendingMachine(_vendingMachine);
            }

            private void ScheduleRefill(int offerIndex, VendingOffer offer, int min = 0)
            {
                _refillTimes[offerIndex] = Time.realtimeSinceStartup + Math.Max(offer.RefillDelay, min);
            }

            private void ScheduleDelayedRefill(int offerIndex, VendingOffer offer)
            {
                ScheduleRefill(offerIndex, offer, 300);
            }

            private void StopRefilling(int offerIndex)
            {
                _refillTimes[offerIndex] = float.MaxValue;
            }

            private void CustomRefill(bool maxRefill = false)
            {
                if (_vendingMachine.IsDestroyed)
                {
                    return;
                }

                for (var offerIndex = 0; offerIndex < Profile.Offers.Length; offerIndex++)
                {
                    if (_refillTimes[offerIndex] > Time.realtimeSinceStartup)
                    {
                        continue;
                    }

                    var offer = Profile.Offers[offerIndex];
                    if (!offer.IsValid || offer.SellItem.Amount <= 0 || offer.CurrencyItem.Amount <= 0)
                    {
                        StopRefilling(offerIndex);
                        continue;
                    }

                    var itemQuery = ItemQuery.FromSellItem(offer.SellItem);
                    var numPurchasesInStock = ItemUtils.SumContainerItems(_vendingMachine.inventory, ref itemQuery) / offer.SellItem.Amount;
                    var refillNumberOfPurchases = offer.RefillMax - numPurchasesInStock;

                    if (!maxRefill)
                    {
                        refillNumberOfPurchases = Mathf.Min(refillNumberOfPurchases, offer.RefillAmount);
                    }

                    if (refillNumberOfPurchases <= 0)
                    {
                        ScheduleRefill(offerIndex, offer);
                        continue;
                    }

                    int refillAmount;

                    try
                    {
                        refillAmount = checked(refillNumberOfPurchases * offer.SellItem.Amount);
                    }
                    catch (OverflowException ex)
                    {
                        LogError($"Cannot multiply {refillNumberOfPurchases} by {offer.SellItem.Amount} because the result is too large. You have misconfigured the plugin. It is not necessary to stock that much of any item. Please reduce Max Stock or Refill Amount for item {offer.SellItem.ShortName}.\n" + ex);

                        // Prevent further refills to avoid spamming the console since this case cannot be fixed without editing the vending machine.
                        StopRefilling(offerIndex);
                        continue;
                    }

                    // Always increase the quantity of an existing item if present, rather than creating a new item.
                    // This is done to prevent ridiculous configurations from potentially filling up the vending machine with specific items.
                    var existingItem = ItemUtils.FindFirstContainerItem(_vendingMachine.inventory, ref itemQuery);
                    if (existingItem != null)
                    {
                        try
                        {
                            existingItem.amount = checked(existingItem.amount + refillAmount);
                            existingItem.MarkDirty();
                            ScheduleRefill(offerIndex, offer);
                        }
                        catch (OverflowException ex)
                        {
                            LogError($"Cannot add {refillAmount} to {existingItem.amount} because the result is too large. You have misconfigured the plugin. It is not necessary to stock that much of any item. Please reduce Max Stock or Refill Amount for item {offer.SellItem.ShortName}.\n" + ex);

                            // Reduce refill rate to avoid spamming the console.
                            ScheduleDelayedRefill(offerIndex, offer);
                        }
                        continue;
                    }

                    var item = offer.SellItem.Create(refillAmount);
                    if (item == null)
                    {
                        LogError($"Unable to create item '{offer.SellItem.ShortName}'. Does that item exist? Was it removed from the game?");

                        // Prevent further refills to avoid spamming the console since this case cannot be fixed without editing the vending machine.
                        StopRefilling(offerIndex);
                        continue;
                    }

                    _vendingMachine.transactionActive = true;

                    if (item.MoveToContainer(_vendingMachine.inventory, allowStack: false))
                    {
                        ScheduleRefill(offerIndex, offer);
                    }
                    else
                    {
                        LogError($"Unable to add {item.amount} '{item.info.shortname}' because the vending machine container rejected it.");

                        item.Remove();

                        // Reduce refill rate to avoid spamming the console.
                        ScheduleDelayedRefill(offerIndex, offer);
                    }

                    _vendingMachine.transactionActive = false;
                }
            }

            private void TimedRefill() => CustomRefill();

            private void DestroyAdminUI(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, AdminUIRenderer.UIName);
            }

            private void DestroyShopUI(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, ShopUIRenderer.UIName);
            }

            private void DestroyUIs()
            {
                foreach (var player in _adminUIViewers)
                {
                    DestroyAdminUI(player);
                }

                foreach (var player in _shopUIViewers)
                {
                    DestroyShopUI(player);
                }
            }

            private void DisableVanillaBehavior()
            {
                _vendingMachine.CancelInvoke(_vendingMachine.InstallFromVendingOrders);
                _vendingMachine.CancelInvoke(_vendingMachine.Refill);

                InvokeRandomized(TimedRefill, 1, 1, 0.1f);

                if (_vendingMachine is InvisibleVendingMachine invisibleVendingMachine)
                {
                    _vendingMachine.CancelInvoke(invisibleVendingMachine.CheckSellOrderRefresh);
                }
            }

            private ulong GetOriginalSkin()
            {
                if ((_dataProvider as PluginDataProvider)?.GetSkinCallback?.Invoke() is { } skinId)
                    return skinId == 0 ? NpcVendingMachineSkinId : skinId;

                return _originalSkinId;
            }

            private void ResetToVanilla()
            {
                CancelInvoke(TimedRefill);

                _vendingMachine.BypassDynamicPricing = _originalBypassDynamicPricing;
                _vendingMachine.skinID = GetOriginalSkin();

                if (_originalShopName != null)
                {
                    _vendingMachine.shopName = _originalShopName;
                }

                if (_originalBroadcast != null && _originalBroadcast != _vendingMachine.IsBroadcasting())
                {
                    _vendingMachine.SetFlag(VendingMachineFlags.Broadcasting, _originalBroadcast.Value);
                    _vendingMachine.UpdateMapMarker();
                }

                _vendingMachine.InstallFromVendingOrders();
                _vendingMachine.InvokeRandomized(_vendingMachine.Refill, 1f, 1f, 0.1f);

                if (_vendingMachine is InvisibleVendingMachine { canRefreshOrders: true } invisibleVendingMachine)
                {
                    invisibleVendingMachine.nextOrderRefresh = ConVar.Server.waterWellNpcSalesRefreshFrequency * 60f * 60f;
                    invisibleVendingMachine.InvokeRepeating(invisibleVendingMachine.CheckSellOrderRefresh, 30f, 30f);
                }
            }
        }

        #endregion

        #region Saved Data

        private class CaseInsensitiveDictionary<TValue> : Dictionary<string, TValue>
        {
            public CaseInsensitiveDictionary() : base(StringComparer.OrdinalIgnoreCase) {}

            public CaseInsensitiveDictionary(Dictionary<string, TValue> dict) : base(dict, StringComparer.OrdinalIgnoreCase) {}
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class VendingItem
        {
            public static VendingItem FromItem(Item item)
            {
                var ammoAmount = GetAmmoAmountAndType(item, out var ammoType);

                return new VendingItem
                {
                    ShortName = item.IsBlueprint() ? item.blueprintTargetDef.shortname : item.info.shortname,
                    Amount = item.amount,
                    DisplayName = item.name,
                    SkinId = item.skin,
                    IsBlueprint = item.blueprintTarget != 0,
                    DataInt = item.instanceData?.dataInt ?? 0,
                    AmmoAmount = ammoAmount,
                    AmmoType = ammoType?.shortname,
                    Position = item.position,
                    Capacity = item.contents?.capacity ?? 0,
                    Contents = item.contents?.itemList?.Count > 0 ? SerializeContents(item.contents.itemList) : null,
                };
            }

            private static List<VendingItem> SerializeContents(List<Item> itemList)
            {
                var vendingItemList = new List<VendingItem>(itemList.Count);

                foreach (var item in itemList)
                {
                    vendingItemList.Add(FromItem(item));
                }

                return vendingItemList;
            }

            private static int GetAmmoAmountAndType(Item item, out ItemDefinition ammoType)
            {
                ammoType = null;

                var heldEntity = item.GetHeldEntity();
                if (heldEntity == null)
                    return -1;

                var baseProjectile = heldEntity as BaseProjectile;
                if ((object)baseProjectile != null)
                {
                    ammoType = baseProjectile.primaryMagazine?.ammoType;
                    return baseProjectile.primaryMagazine?.contents ?? 0;
                }

                var flameThrower = heldEntity as FlameThrower;
                if ((object)flameThrower != null)
                {
                    return flameThrower.ammo;
                }

                return -1;
            }

            [JsonProperty("ShortName")]
            public string ShortName;

            [JsonProperty("DisplayName", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string DisplayName;

            [JsonProperty("Amount")]
            public int Amount = 1;

            [JsonProperty("Skin", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public ulong SkinId;

            [JsonProperty("IsBlueprint", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool IsBlueprint;

            [JsonProperty("DataInt", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int DataInt;

            [JsonProperty("Position", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int Position;

            [JsonProperty("Ammo", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(-1)]
            public int AmmoAmount = -1;

            [JsonProperty("AmmoType", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string AmmoType;

            [JsonProperty("Capacity", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int Capacity;

            [JsonProperty("Contents", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public List<VendingItem> Contents;

            private ItemDefinition _itemDefinition;
            public ItemDefinition ItemDefinition
            {
                get
                {
                    if ((object)_itemDefinition == null && ShortName != null)
                    {
                        _itemDefinition = ItemManager.FindItemDefinition(ShortName);
                    }

                    return _itemDefinition;
                }
            }

            private ItemDefinition _ammoTypeDefinition;
            public ItemDefinition AmmoTypeDefinition
            {
                get
                {
                    if ((object)_ammoTypeDefinition == null && AmmoType != null)
                    {
                        _ammoTypeDefinition = ItemManager.FindItemDefinition(AmmoType);
                    }

                    return _ammoTypeDefinition;
                }
            }

            public bool IsValid => (object)ItemDefinition != null;
            public int ItemId => ItemDefinition.itemid;

            public Item Create(int amount)
            {
                Item item;
                if (IsBlueprint)
                {
                    item = ItemManager.CreateByItemID(BlueprintItemId, amount, SkinId);
                    item.blueprintTarget = ItemDefinition.itemid;
                }
                else
                {
                    item = ItemManager.Create(ItemDefinition, amount, SkinId);
                }

                if (item == null)
                    return null;

                item.name = DisplayName;
                item.position = Position;

                if (DataInt != 0)
                {
                    if (item.instanceData == null)
                    {
                        item.instanceData = new ProtoBuf.Item.InstanceData();
                        item.instanceData.ShouldPool = false;
                    }

                    item.instanceData.dataInt = DataInt;
                }

                if (Contents is { Count: > 0 })
                {
                    if (item.contents == null)
                    {
                        item.contents = new ItemContainer();
                        item.contents.ServerInitialize(null, Math.Max(Capacity, Contents.Count));
                        item.contents.GiveUID();
                        item.contents.parent = item;
                    }
                    else
                    {
                        item.contents.capacity = Math.Max(item.contents.capacity, Capacity);
                    }

                    foreach (var childItemSpec in Contents)
                    {
                        var childItem = childItemSpec.Create(childItemSpec.Amount);
                        if (!childItem.MoveToContainer(item.contents, childItemSpec.Position))
                        {
                            childItem.Remove();
                        }
                    }
                }

                var heldEntity = item.GetHeldEntity();
                if (heldEntity != null)
                {
                    var baseProjectile = heldEntity as BaseProjectile;
                    if ((object)baseProjectile != null)
                    {
                        var magazine = baseProjectile.primaryMagazine;
                        if (magazine != null)
                        {
                            if (AmmoAmount >= 0)
                            {
                                magazine.contents = AmmoAmount;
                            }

                            if (AmmoType != null)
                            {
                                magazine.ammoType = AmmoTypeDefinition;
                            }
                        }
                    }

                    var flameThrower = heldEntity as FlameThrower;
                    if ((object)flameThrower != null)
                    {
                        flameThrower.ammo = AmmoAmount;
                    }
                }

                // Set the placeholder flag so that Enchanted Items doesn't transform the artifact into an enchanted item yet.
                item.SetFlag(Item.Flag.Placeholder, true);

                return item;
            }

            public Item Create() => Create(Amount);

            public VendingItem Copy()
            {
                return new VendingItem
                {
                    ShortName = ShortName,
                    DisplayName = DisplayName,
                    Amount = Amount,
                    SkinId = SkinId,
                    IsBlueprint = IsBlueprint,
                    DataInt = DataInt,
                    Position = Position,
                    AmmoAmount = AmmoAmount,
                    AmmoType = AmmoType,
                    Capacity = Capacity,
                    Contents = Contents,
                };
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class VendingOffer
        {
            public const int DefaultRefillMax = 10;
            public const int DefaultRefillDelay = 10;
            public const int DefaultRefillAmount = 1;

            public static VendingOffer FromVanillaSellOrder(SellOrder sellOrder, NPCVendingOrder.Entry manifestEntry)
            {
                return new VendingOffer
                {
                    SellItem = new VendingItem
                    {
                        ShortName = ItemManager.FindItemDefinition(sellOrder.itemToSellID)?.shortname,
                        Amount = sellOrder.itemToSellAmount,
                        IsBlueprint = sellOrder.itemToSellIsBP,
                    },
                    CurrencyItem = new VendingItem
                    {
                        ShortName = ItemManager.FindItemDefinition(sellOrder.currencyID)?.shortname,
                        Amount = sellOrder.currencyAmountPerItem,
                        IsBlueprint = sellOrder.currencyIsBP,
                    },
                    RefillDelay = manifestEntry != null ? (int)manifestEntry.refillDelay : DefaultRefillDelay,
                };
            }

            public static VendingOffer FromItems(CustomVendingSetup plugin, BasePlayer player, Item sellItem, Item currencyItem, Item settingsItem)
            {
                var offer = new VendingOffer
                {
                    SellItem = VendingItem.FromItem(sellItem),
                    CurrencyItem = VendingItem.FromItem(currencyItem),
                };

                offer.SellItem.Position = 0;
                offer.CurrencyItem.Position = 0;

                if (settingsItem != null)
                {
                    var refillMaxLabel = plugin.GetMessage(player, Lang.SettingsRefillMax);
                    var refillDelayLabel = plugin.GetMessage(player, Lang.SettingsRefillDelay);
                    var refillAmountLabel = plugin.GetMessage(player, Lang.SettingsRefillAmount);

                    var localizedSettings = ParseSettings(settingsItem.text);

                    if (TryParseIntKey(localizedSettings, refillMaxLabel, out var refillMax))
                    {
                        offer.RefillMax = refillMax;
                    }

                    if (TryParseIntKey(localizedSettings, refillDelayLabel, out var refillDelay))
                    {
                        offer.RefillDelay = refillDelay;
                    }

                    if (TryParseIntKey(localizedSettings, refillAmountLabel, out var refillAmount))
                    {
                        offer.RefillAmount = refillAmount;
                    }

                    // Allow other plugins to parse the settings and populate custom settings.
                    // Other plugins determine data file keys, as well as localized option names.
                    var customSettings = new CaseInsensitiveDictionary<object>();
                    ExposedHooks.OnCustomVendingSetupOfferSettingsParse(localizedSettings, customSettings);
                    if (customSettings.Count > 0)
                    {
                        offer.CustomSettings = customSettings;
                    }
                }

                return offer;
            }

            private static bool TryParseIntKey(Dictionary<string, string> dict, string key, out int result)
            {
                result = 0;
                return dict.TryGetValue(key, out var stringValue)
                    && int.TryParse(stringValue, out result);
            }

            [JsonProperty("SellItem")]
            public VendingItem SellItem;

            [JsonProperty("CurrencyItem")]
            public VendingItem CurrencyItem;

            [JsonProperty("RefillMax", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(DefaultRefillMax)]
            public int RefillMax = DefaultRefillMax;

            [JsonProperty("RefillDelay", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(DefaultRefillDelay)]
            public int RefillDelay = DefaultRefillDelay;

            [JsonProperty("RefillAmount", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(DefaultRefillAmount)]
            public int RefillAmount = DefaultRefillAmount;

            [JsonProperty("CustomSettings", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public CaseInsensitiveDictionary<object> CustomSettings;

            public bool IsValid => SellItem.IsValid && CurrencyItem.IsValid;

            public VendingOffer Copy()
            {
                return new VendingOffer
                {
                    SellItem = SellItem.Copy(),
                    CurrencyItem = CurrencyItem.Copy(),
                    RefillMax = RefillMax,
                    RefillDelay = RefillDelay,
                    RefillAmount = RefillAmount,
                    CustomSettings = CustomSettings != null
                        ? new CaseInsensitiveDictionary<object>(CustomSettings)
                        : null,
                };
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class VendingProfile : IRelativePosition
        {
            public const string SkinIdField = "SkinId";

            public static VendingProfile FromVendingMachine(NPCVendingMachine vendingMachine)
            {
                return new VendingProfile
                {
                    SkinId = vendingMachine.skinID,
                    ShopName = vendingMachine.shopName,
                    Broadcast = vendingMachine.IsBroadcasting(),
                };
            }

            [JsonProperty("ShopName", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string ShopName;

            [JsonProperty(SkinIdField, DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(NpcVendingMachineSkinId)]
            public ulong SkinId = NpcVendingMachineSkinId;

            [JsonProperty("BypassDynamicPricing", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool BypassDynamicPricing;

            [JsonProperty("Broadcast", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(true)]
            public bool Broadcast = true;

            [JsonProperty("DroneAccessible", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(true)]
            public bool DroneAccessible = true;

            [JsonProperty("Monument", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string Monument;

            [JsonProperty("MonumentAlias", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string MonumentAlias;

            [JsonProperty("Position", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public Vector3 Position;

            [JsonProperty("Offers")]
            public VendingOffer[] Offers;

            public VendingOffer GetOfferForSellOrderIndex(int index)
            {
                var sellOrderIndex = 0;

                foreach (var offer in Offers)
                {
                    if (!offer.IsValid)
                        continue;

                    if (sellOrderIndex == index)
                        return offer;

                    sellOrderIndex++;
                }

                return null;
            }

            public bool HasPaymentProviderCurrency(PaymentProviderConfig paymentProviderConfig)
            {
                foreach (var offer in Offers)
                {
                    if (paymentProviderConfig.MatchesItem(offer.CurrencyItem))
                        return true;
                }

                return false;
            }

            // IPrefabRelativePosition members.
            public string GetPrefabName() => Monument;
            public string GetPrefabAlias() => MonumentAlias;
            public Vector3 GetPosition() => Position;

            [OnDeserialized]
            private void OnDeserialized(StreamingContext context)
            {
                UpdateOldSaddleOffers();
            }

            private void UpdateOldSaddleOffers()
            {
                if (Offers == null)
                    return;

                VendingOffer singleSaddleOffer = null;
                var singleSaddleIndex = -1;

                for (var i = 0; i < Offers.Length; i++)
                {
                    var offer = Offers[i];
                    if (offer.SellItem.ShortName == "horse.saddle")
                    {
                        // Copy serialized fields, and change the short name. This will reset the cached ItemDefinition.
                        offer.SellItem = offer.SellItem.Copy();
                        offer.SellItem.ShortName = "horse.saddle.single";
                        singleSaddleOffer = offer;
                        singleSaddleIndex = i;
                        break;
                    }
                }

                if (singleSaddleOffer != null && singleSaddleIndex >= 0 && Offers.Length < MaxVendingOffers)
                {
                    var doubleSaddleOffer = singleSaddleOffer.Copy();
                    doubleSaddleOffer.SellItem.ShortName = "horse.saddle.double";
                    doubleSaddleOffer.CurrencyItem.Amount = Mathf.FloorToInt(doubleSaddleOffer.CurrencyItem.Amount * 1.2f);

                    var newOfferList = new List<VendingOffer>(Offers);
                    newOfferList.Insert(singleSaddleIndex + 1, doubleSaddleOffer);
                    Offers = newOfferList.ToArray();
                }
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private abstract class BaseVendingProfileDataFile
        {
            [JsonProperty("VendingProfiles")]
            public List<VendingProfile> VendingProfiles { get; } = new();

            public abstract void Save();
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class SavedPrefabRelativeData : BaseVendingProfileDataFile
        {
            private static IDataLoader<SavedPrefabRelativeData> _dataLoader = new JsonLoader<SavedPrefabRelativeData>(nameof(CustomVendingSetup));

            public static SavedPrefabRelativeData Load()
            {
                return _dataLoader.Load();
            }

            public override void Save()
            {
                _dataLoader.Save(this);
            }

            public VendingProfile FindProfile<T>(T location) where T : IRelativePosition
            {
                foreach (var profile in VendingProfiles)
                {
                    if (LocationsMatch(profile, location))
                        return profile;
                }

                return null;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class SavedMapData : BaseVendingProfileDataFile
        {
            private static IDataLoader _dataLoader = new JsonLoader();

            // Return example: proceduralmap.1500.548423.212
            private static string GetPerWipeSaveName()
            {
                return World.SaveFileName[..World.SaveFileName.LastIndexOf(".")];
            }

            // Return example: proceduralmap.1500.548423
            private static string GetCrossWipeSaveName()
            {
                var saveName = GetPerWipeSaveName();
                return saveName[..saveName.LastIndexOf(".")];
            }

            private static bool IsProcedural() => World.SaveFileName.StartsWith("proceduralmap");

            private static string GetPerWipeFilePath() => $"{nameof(CustomVendingSetup)}/{GetPerWipeSaveName()}";
            private static string GetCrossWipeFilePath() => $"{nameof(CustomVendingSetup)}/{GetCrossWipeSaveName()}";
            private static string GetFilepath() => IsProcedural() ? GetPerWipeFilePath() : GetCrossWipeFilePath();
            public static string GetMapName() => IsProcedural() ? GetPerWipeSaveName() : GetCrossWipeSaveName();

            public static SavedMapData Load()
            {
                return _dataLoader.Load<SavedMapData>(GetFilepath());
            }

            public override void Save()
            {
                _dataLoader.Save(GetFilepath(), this);
            }

            public VendingProfile FindProfile(Vector3 position)
            {
                foreach (var vendingProfile in VendingProfiles)
                {
                    if (AreVectorsClose(vendingProfile.Position, position))
                        return vendingProfile;
                }

                return null;
            }
        }

        [ProtoContract]
        [JsonObject(MemberSerialization.OptIn)]
        private class CustomSalesData
        {
            public static CustomSalesData FromVendingMachineSalesData(NPCVendingMachine.SalesData salesData)
            {
                return new CustomSalesData
                {
                    CurrentMultiplier = salesData.CurrentMultiplier,
                    SoldThisInterval = salesData.SoldThisInterval,
                    TotalIntervals = salesData.TotalIntervals,
                    TotalSales = salesData.TotalSales,
                };
            }

            [ProtoMember(1)]
            [JsonProperty("CurrentMultiplier")]
            public float CurrentMultiplier;

            [ProtoMember(2)]
            [JsonProperty("SoldThisInterval")]
            public ulong SoldThisInterval;

            [ProtoMember(3)]
            [JsonProperty("TotalIntervals")]
            public ulong TotalIntervals;

            [ProtoMember(4)]
            [JsonProperty("TotalSales")]
            public ulong TotalSales;

            public NPCVendingMachine.SalesData ToVendingMachineSalesData()
            {
                var vendingMachineSalesData = new NPCVendingMachine.SalesData();
                CopyToVendingMachineSalesData(vendingMachineSalesData);
                return vendingMachineSalesData;
            }

            public void CopyToVendingMachineSalesData(NPCVendingMachine.SalesData salesData)
            {
                salesData.CurrentMultiplier = CurrentMultiplier;
                salesData.SoldThisInterval = SoldThisInterval;
                salesData.TotalIntervals = TotalIntervals;
                salesData.TotalSales = TotalSales;
            }
        }

        [ProtoContract]
        public struct SerializableVector3
        {
            [ProtoMember(1)]
            [JsonProperty("x")]
            public readonly float x;

            [ProtoMember(2)]
            [JsonProperty("y")]
            public readonly float y;

            [ProtoMember(3)]
            [JsonProperty("z")]
            public readonly float z;

            public SerializableVector3() {}

            public SerializableVector3(float x, float y, float z)
            {
                this.x = x;
                this.y = y;
                this.z = z;
            }

            public static implicit operator Vector3(SerializableVector3 vector)
            {
                return new Vector3(vector.x, vector.y, vector.z);
            }

            public static implicit operator SerializableVector3(Vector3 vector)
            {
                return new SerializableVector3(vector.x, vector.y, vector.z);
            }
        }

        [ProtoContract]
        [JsonObject(MemberSerialization.OptIn)]
        private class VendingMachineState
        {
            private static readonly FieldInfo AllSalesDataField = typeof(NPCVendingMachine)
                .GetField("allSalesData", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

            public static VendingMachineState FromVendingMachine(NPCVendingMachine vendingMachine)
            {
                var salesData = (NPCVendingMachine.SalesData[])AllSalesDataField?.GetValue(vendingMachine)
                                ?? Array.Empty<NPCVendingMachine.SalesData>();

                return new VendingMachineState
                {
                    EntityId = vendingMachine.net.ID.Value,
                    SalesData = salesData.Select(CustomSalesData.FromVendingMachineSalesData).ToArray(),
                    Position = vendingMachine.transform.position,
                };
            }

            [ProtoMember(1)]
            [JsonProperty("EntityId")]
            public ulong EntityId;

            [ProtoMember(2)]
            [JsonProperty("SalesData")]
            public CustomSalesData[] SalesData = Array.Empty<CustomSalesData>();

            [ProtoMember(3)]
            [JsonProperty("Position")]
            public SerializableVector3 Position;

            public void ApplyToVendingMachine(NPCVendingMachine vendingMachine)
            {
                var salesData = SalesData?.Select(data => data.ToVendingMachineSalesData())
                        .Take(vendingMachine.sellOrders.sellOrders.Count)
                        .ToArray() ?? Array.Empty<NPCVendingMachine.SalesData>();

                AllSalesDataField?.SetValue(vendingMachine, salesData);
            }
        }

        [ProtoContract]
        [JsonObject(MemberSerialization.OptIn)]
        private class SavedSalesData
        {
            private static string FileName = $"{nameof(CustomVendingSetup)}_SalesData";
            private static IDataLoader<SavedSalesData> DataLoader = new ProtoLoader<SavedSalesData>(FileName);

            public static SavedSalesData Load()
            {
                return DataLoader.Load();
            }

            [ProtoMember(1)]
            [JsonProperty("VendingMachines")]
            public List<VendingMachineState> VendingMachines = new();

            public void Save()
            {
                DataLoader.Save(this);
            }

            public void Reset()
            {
                if (VendingMachines.Count == 0)
                    return;

                VendingMachines.Clear();
                Save();
            }

            public VendingMachineState FindState(NPCVendingMachine vendingMachine)
            {
                var position = vendingMachine.transform.position;

                foreach (var vendingMachineState in VendingMachines)
                {
                    if (vendingMachineState.EntityId == vendingMachine.net.ID.Value
                        || AreVectorsClose(vendingMachineState.Position, position))
                        return vendingMachineState;
                }

                return null;
            }
        }

        #endregion

        #region Configuration

        [JsonObject(MemberSerialization.OptIn)]
        private class ShopUISettings
        {
            [JsonProperty("Enable skin overlays")]
            public bool EnableSkinOverlays = true;
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class PaymentProviderConfig
        {
            [JsonProperty("Enabled")]
            public bool Enabled;

            [JsonProperty("Item short name")]
            public string ItemShortName;

            [JsonProperty("Item skin ID")]
            public ulong ItemSkinId;

            public ItemDefinition ItemDefinition { get; private set; }

            public bool EnabledAndValid => Enabled && (object)ItemDefinition != null;

            public void Init()
            {
                if (string.IsNullOrWhiteSpace(ItemShortName))
                    return;

                ItemDefinition = ItemManager.FindItemDefinition(ItemShortName);
                if (ItemDefinition == null)
                {
                    LogError($"Invalid item short name in config: {ItemShortName}");
                }
            }

            public bool MatchesItem(VendingItem vendingItem)
            {
                return Enabled && vendingItem.ItemDefinition == ItemDefinition && vendingItem.SkinId == ItemSkinId;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class Configuration : SerializableConfiguration
        {
            [JsonProperty("Shop UI settings")]
            public ShopUISettings ShopUISettings = new();

            [JsonProperty("Economics integration")]
            public PaymentProviderConfig Economics = new();

            [JsonProperty("Server Rewards integration")]
            public PaymentProviderConfig ServerRewards = new();

            [JsonProperty("Override item max stack sizes (shortname: amount)")]
            public Dictionary<string, int> ItemStackSizeOverrides = new();

            public void Init()
            {
                Economics.Init();
                ServerRewards.Init();

                foreach (var entry in ItemStackSizeOverrides)
                {
                    if (ItemManager.FindItemDefinition(entry.Key) == null)
                    {
                        LogError($"Invalid item short name in config: {entry.Key}");
                    }
                }
            }

            public int GetItemMaxStackSize(Item item)
            {
                var maxStackSize = item.MaxStackable();

                if (ItemStackSizeOverrides.TryGetValue(item.info.shortname, out var overrideMaxStackSize))
                {
                    maxStackSize = Math.Max(maxStackSize, overrideMaxStackSize);
                }

                return Math.Max(1, maxStackSize);
            }
        }

        private Configuration GetDefaultConfig() => new();

        #region Configuration Helpers

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                if (currentRaw.TryGetValue(key, out var currentRawValue))
                {
                    var currentDictValue = currentRawValue as Dictionary<string, object>;
                    if (currentWithDefaults[key] is Dictionary<string, object> defaultDictValue)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion

        #region Localization

        private string GetMessage(string playerId, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, playerId);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        private string GetMessage(IPlayer player, string messageName, params object[] args) =>
            GetMessage(player.Id, messageName, args);

        private string GetMessage(BasePlayer player, string messageName, params object[] args) =>
            GetMessage(player.UserIDString, messageName, args);

        private void ChatMessage(BasePlayer player, string messageName, params object[] args) =>
            player.ChatMessage(string.Format(GetMessage(player, messageName), args));

        private static class Lang
        {
            public const string ButtonEdit = "Button.Edit";
            public const string ButtonReset = "Button.Reset";
            public const string InfoForSale = "Info.ForSale";
            public const string ButtonSave = "Button.Save";
            public const string ButtonCancel = "Button.Cancel";
            public const string InfoCost = "Info.Cost";
            public const string InfoSettings = "Info.Settings";
            public const string SettingsRefillMax = "Settings.RefillMax";
            public const string SettingsRefillDelay = "Settings.RefillDelay";
            public const string SettingsRefillAmount = "Settings.RefillAmount";
            public const string SettingsSkinId = "Settings.SkinId";
            public const string SettingsBypassDynamicPricing = "Settings.BypassDynamicPricing";
            public const string SettingsShopName = "Settings.ShopName";
            public const string ErrorCurrentlyBeingEdited = "Error.CurrentlyBeingEdited";
            public const string InfoDataProviderMap = "Info.DataProvider.Map";
            public const string InfoDataProviderEntity = "Info.DataProvider.Entity";
            public const string InfoDataProviderMonument = "Info.DataProvider.Monument";
            public const string InfoDataProviderPlugin = "Info.DataProvider.Plugin";
            public const string InfoDataProviderPluginUnknownName = "Info.DataProvider.Plugin.UnknownName";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.ButtonSave] = "SAVE",
                [Lang.ButtonCancel] = "CANCEL",
                [Lang.ButtonEdit] = "EDIT",
                [Lang.ButtonReset] = "RESET",
                [Lang.InfoForSale] = "FOR SALE",
                [Lang.InfoCost] = "COST",
                [Lang.InfoSettings] = "SETTINGS",
                [Lang.SettingsRefillMax] = "Max Stock",
                [Lang.SettingsRefillDelay] = "Seconds Between Refills",
                [Lang.SettingsRefillAmount] = "Refill Amount",
                [Lang.SettingsSkinId] = "Skin ID",
                [Lang.SettingsBypassDynamicPricing] = "Bypass Dynamic Pricing",
                [Lang.SettingsShopName] = "Shop Name",
                [Lang.ErrorCurrentlyBeingEdited] = "That vending machine is currently being edited by {0}.",
                [Lang.InfoDataProviderMap] = "Data Provider: <color=#f90>Map ({0})</color>",
                [Lang.InfoDataProviderEntity] = "Data Provider: <color=#6f6>Entity ({0})</color>",
                [Lang.InfoDataProviderMonument] = "Data Provider: <color=#6f6>Monument ({0})</color>",
                [Lang.InfoDataProviderPlugin] = "Data Provider: <color=#f9f>Plugin ({0})</color>",
                [Lang.InfoDataProviderPluginUnknownName] = "Data Provider: <color=#f9f>Plugin</color>",
            }, this, "en");
        }

        #endregion
    }
}


// --- End of file: CustomVendingSetup.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/chat-prefix ---
// --- Original File Path: C/ChatPrefix/ChatPrefix.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Math;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;

// ToDo: better betterchat support

namespace Oxide.Plugins
{
    [Info("Chat Prefix", "Gonzi", "1.2.1")]
    [Description("Chat Prefix per Permission")]
    public class ChatPrefix : RustPlugin
    {
        #region Fields

        [PluginReference] Plugin ColouredChat;
        [PluginReference] Plugin Quests;
        [PluginReference] Plugin BetterChat;

        private Dictionary<ulong, PlayerPrefix> playerPrefixData = new Dictionary<ulong, PlayerPrefix>();

        private class PlayerPrefix
        {
            public string Prefix { get; set; }
            public string Color { get; set; }
            public bool active { get; set; }
        }

        private class PrefixConfig
        {
            public bool Disabled { get; set; }
            public int Priority { get; set; }
            public string Prefix { get; set; }
            public string Color { get; set; }
            public string Permission { get; set; }
            public string GroupName { get; set; }
        }

        private static ConfigData config;

        private class ConfigData
        {
            public bool debug = false;

            [JsonProperty("Use Groupname instead of Permission")]
            public bool useGroup = false;

            public Dictionary<string, PrefixConfig> Prefixes { get; set; }
        }

        #endregion Fields

        #region Configuration

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                Puts("{0} Exception caught.", e);
                PrintError("The configuration file is corrupted! Using Default Config!");
                LoadDefaultConfig();
            }
            RegPerm("reload");
        }

        protected override void LoadDefaultConfig() => config = DefaultConfig();
        protected override void SaveConfig() => Config.WriteObject(config);
        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
            }

            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
            }
            return value;
        }

        ConfigData DefaultConfig()
        {
            var DefaultConfig = new ConfigData
            {
                Prefixes = new Dictionary<string, PrefixConfig>
                {
                    {
                        "admin", new PrefixConfig
                        {
                            Disabled = false,
                            Priority = 1,
                            Prefix = "[ADMIN]",
                            Color = "#FF0000",
                            Permission = "admin",
                            GroupName = "admin"
                        }
                    },
                    {
                        "mod", new PrefixConfig
                        {
                            Disabled = false,
                            Priority = 2,
                            Prefix = "[MOD]",
                            Color = "#0000FF",
                            Permission = "mod",
                            GroupName = "mod"
                        }
                    },
                    {
                        "vip", new PrefixConfig
                        {
                            Disabled = false,
                            Priority = 3,
                            Prefix = "[VIP]",
                            Color = "#ffb400",
                            Permission = "vip",
                            GroupName = "vip"
                        }
                    }
                }
            };
            return DefaultConfig;
        }

        #endregion Configuration

        #region Hooks

        // ColouredChat integration
        private string ColChat_GetColName(IPlayer player) => Interface.Oxide.CallHook("API_GetColouredName", player) as string;

        private string ColChat_GetColMessage(IPlayer player, string message) => Interface.Oxide.CallHook("API_GetColouredMessage", player, message) as string;
        // end ColouredChat

        private void OnPlayerConnected(BasePlayer player) => ReloadPrefix(player);

        private void OnUserPermissionGranted(string id, string permName)
        {
            if (config.debug) Puts($"Player '{id}' granted permission: {permName}");
            playerPrefixData.Clear();
            foreach (BasePlayer bplayer in BasePlayer.activePlayerList)
            {
                ReloadPrefix(bplayer);
            }
            return;
        }

        private void OnUserPermissionRevoked(string id, string permName)
        {
            if (config.debug) Puts($"Player '{id}' revoked permission: {permName}");
            playerPrefixData.Clear();
            foreach (BasePlayer bplayer in BasePlayer.activePlayerList)
            {
                ReloadPrefix(bplayer);
            }
        }

        private void OnGroupPermissionGranted(string name, string perm)
        {
            if (config.debug) Puts($"Group '{name}' granted permission: {perm}");
            playerPrefixData.Clear();
            foreach (BasePlayer bplayer in BasePlayer.activePlayerList)
            {
                ReloadPrefix(bplayer);
            }
        }

        private void OnGroupPermissionRevoked(string name, string perm)
        {
            if (config.debug) Puts($"Group '{name}' revoked permission: {perm}");
            playerPrefixData.Clear();
            foreach (BasePlayer bplayer in BasePlayer.activePlayerList)
            {
                ReloadPrefix(bplayer);
            }
        }

        private void OnUserGroupAdded(string id, string groupName)
        {
            if (config.debug) Puts($"Player '{id}' added to group: {groupName}");
            var p = BasePlayer.activePlayerList.Where(pl => pl.UserIDString == id && pl.IsValid() == true).FirstOrDefault();
            if (!p) return;
            ReloadPrefix(p);
        }

        private void OnUserGroupRemoved(string id, string groupName)
        {
            if (config.debug) Puts($"Player '{id}' removed from group: {groupName}");
            var p = BasePlayer.activePlayerList.Where(pl => pl.UserIDString == id && pl.IsValid() == true).FirstOrDefault();
            if (!p) return;
            ReloadPrefix(p);
        }

        private object OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            if (config.debug) Puts("OnPlayerChat");

            // Plugin Quests - prevents to send input to globalchat while quest creation is active
            if (QuestsActv() && Quests.Call<bool>("API_GetNotChatOutput", player))
            {
                Puts("Quests Plugin API requests return of msg! - no chat output!");
                return true;
            }

            PlayerPrefix pP;
            playerPrefixData.TryGetValue(player.userID, out pP);
            if (pP == null) return null;

            if (ColouredChatActv())
            {
                var name = Interface.Oxide.CallHook("API_GetColouredName", player.IPlayer) as string;
                var cmsg = ColChat_GetColMessage(player.IPlayer, message);

                Puts(Interface.Oxide.CallHook("API_GetColouredMessage", player.IPlayer, message) as string);

                if (pP.active) SendChatMessage(player, "<color=" + pP.Color + ">", pP.Prefix, name + "</color>" + ":", cmsg, channel);
                else SendChatMessage(player, null, null, name + ":", cmsg, channel);
                return true;
            }
            else
            {
                if (pP.active) SendChatMessage(player, "<color=" + pP.Color + ">", pP.Prefix, player.displayName + "</color>" + ":", message, channel);
                else return null;
            }
            return true;
        }

        // cancel message to prevent duplicate messages - // ToDo: Add better support (Username etc.)
        private object OnBetterChat(Dictionary<string, object> dict)
        {
            var player = (dict["Player"] as IPlayer).Object as BasePlayer;
            if (player == null) return null;
            dict["CancelOption"] = 2;
            return dict;
        }

        // always return to prevent double messages
        private object OnColouredChat(Dictionary<string, object> dict)
        {
            return false;
        }

        #endregion Hooks

        #region Util

        private object SendChatMessage(BasePlayer player, string pColor, string prefix, string displayname, string message, Chat.ChatChannel channel)
        {
            // if (Chat.serverlog && player.IsValid())
            // {
            //     object[] logMsgArr = new object[] { ConsoleColor.DarkYellow, null, null, null };
            //     logMsgArr[1] = string.Concat(new object[] { "[", channel, "] ", player.displayName.EscapeRichText(), ": " });
            //     logMsgArr[2] = ConsoleColor.DarkGreen;
            //     logMsgArr[3] = new System.Text.RegularExpressions.Regex("<[^>]*>").Replace(string.Join(" ", message), "");
            //     ServerConsole.PrintColoured(logMsgArr);
            // }

            RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
            {
                Channel = channel,
                Message = new System.Text.RegularExpressions.Regex("<[^>]*>").Replace(string.Join(" ", message), ""),
                UserId = player.IPlayer.Id,
                Username = player.displayName,
                Color = pColor,
                Time = Epoch.Current
            });

            switch ((int)channel)
            {
                // global chat
                case 0:
                    if (config.debug) Puts("default / global chat");

                    var gMsg = ArrayPool.Get(3);
                    gMsg[0] = (int)channel;
                    gMsg[1] = player.UserIDString;

                    foreach (BasePlayer p in BasePlayer.activePlayerList.Where(p => p.IsValid() == true))
                    {
                        gMsg[2] = $"{pColor}{Lang(prefix, p.UserIDString)} {displayname} {message}";
                        p.SendConsoleCommand("chat.add", gMsg);
                        if (config.debug) Puts("sended GLOBAL message (" + message + ") to " + p.displayName);
                    }
                    ArrayPool.Free(gMsg);
                    break;

                // team channel
                case 1:
                    if (config.debug) Puts("team chat");

                    var tMsg = ArrayPool.Get(3);
                    tMsg[0] = (int)channel;
                    tMsg[1] = player.UserIDString;

                    foreach (BasePlayer p in BasePlayer.activePlayerList.Where(p => p.Team != null && player.Team != null && p.Team.teamID == player.Team.teamID && p.IsValid() == true))
                    {
                        tMsg[2] = $"{pColor}{Lang(prefix, p.UserIDString)} {displayname} {message}";
                        p.SendConsoleCommand("chat.add", tMsg);
                        if (config.debug) Puts("sended GLOBAL message (" + message + ") to " + p.displayName);
                    }
                    ArrayPool.Free(tMsg);
                    break;

                default:
                    break;
            }
            return true;
        }

        private void RegPerm(string name)
        {
            if (permission.PermissionExists("chatprefix." + name, this)) return;
            permission.RegisterPermission("chatprefix." + name, this);
            if (config.debug) Puts("Registered permission: chatprefix." + name);
            return;
        }

        private object ReloadPrefix(BasePlayer player)
        {
            if (config.debug) Puts("ReloadPrefix for " + player.displayName);
            if (!player.IsValid()) return false;

            playerPrefixData.Remove(player.userID);

            bool foundPrefixForPly = false;
            foreach (var p in config.Prefixes.OrderBy(x => x.Value.Priority))
            {
                if (foundPrefixForPly) return true;
                if (permission.UserHasPermission(player.UserIDString, p.Value.Permission) && !config.useGroup && !p.Value.Disabled || permission.UserHasGroup(player.UserIDString, p.Value.GroupName) && config.useGroup && !p.Value.Disabled)
                {
                    foundPrefixForPly = true;
                    if (config.debug) Puts("Found Prefix for " + player.displayName + " Prefix: " + p.Value.Prefix + " Prefixcolor" + p.Value.Color + " Permission:" + p.Value.Permission + " GroupName:" + p.Value.GroupName);
                    playerPrefixData.Add(player.userID, new PlayerPrefix { Prefix = p.Value.Prefix, Color = p.Value.Color, active = true });
                }
            }

            if (!foundPrefixForPly) playerPrefixData.Add(player.userID, new PlayerPrefix { Prefix = null, Color = null, active = false });
            return true;
        }

        private bool QuestsActv() => (Quests != null && Quests.IsLoaded);
        private bool ColouredChatActv() => (ColouredChat != null && ColouredChat.IsLoaded);
        private bool BetterChatActv() => (BetterChat != null && BetterChat.IsLoaded);
        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            var messages = new Dictionary<string, string>();
            foreach (var pCfg in config.Prefixes.OrderBy(x => x.Value.Priority))
            {
                messages.Add(pCfg.Value.Prefix, pCfg.Value.Prefix);
                RegPerm(pCfg.Value.Permission);
            }

            messages.Add("xPrefixesReloaded", "Prefix for {0} players was reloaded!");

            lang.RegisterMessages(messages, this, "en");

            playerPrefixData.Clear();
            foreach (BasePlayer bplayer in BasePlayer.activePlayerList)
            {
                ReloadPrefix(bplayer);
            }
        }

        private string Lang(string key, string id = null, params object[] args)
        {
            if (key == null) return null;
            return string.Format(lang.GetMessage(key, this, id), args);
        }

        #endregion

        #region API

        private string API_GetPrefixedMessageForPlayer(BasePlayer player, string messageText)
        {
            PlayerPrefix pP;
            playerPrefixData.TryGetValue(player.userID, out pP);
            if (pP == null || !pP.active) return null;

            if (ColouredChat)
            {
                if (pP.active) return "<color=" + pP.Color + ">" + pP.Prefix + " " + ColChat_GetColName(player.IPlayer) + "</color>:" + ColChat_GetColMessage(player.IPlayer, messageText);
                else return null;
            }
            else
            {
                if (pP.active) return "<color=" + pP.Color + ">" + pP.Prefix + " " + player.displayName + "</color>:" + messageText;
                else return null;
            }
        }

        private bool API_ReloadPrefixForPlayer(BasePlayer player)
        {
            if (player != null)
            {
                ReloadPrefix(player);
                return true;
            }
            else return false;
        }

        private bool API_ReloadPrefixForAllPlayers()
        {
            playerPrefixData.Clear();
            foreach (BasePlayer bplayer in BasePlayer.activePlayerList)
            {
                ReloadPrefix(bplayer);
            }
            return true;
        }

        #endregion
    }
}

// --- End of file: ChatPrefix.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/cargo-ship-cctv ---
// --- Original File Path: C/CargoShipCCTV/CargoShipCCTV.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    /*  Copyright 2021, GrumpyGordon
     * 
     *  This software is licensed & protected under the MIT Copyright License (1988)
     * 
     *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the
     *  Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
     *  and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
     * 
     *  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
     * 
     *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     *  ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
     *  THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     * 
     */

    [Info("Cargo Ship CCTV", "GrumpyGordon", "1.2.3")]
    [Description("Adds CCTV to the cargo ship including an onboard monitoring station.")]
    public class CargoShipCCTV : RustPlugin
    {
        #region Fields

        private Configuration _config;
        const string _camPrefab = "assets/prefabs/deployable/cctvcamera/cctv.static.prefab";
        const string _computerStation = "assets/prefabs/deployable/computerstation/computerstation.deployed.prefab";

        #endregion

        #region Config

        private class Configuration
        {
            [JsonProperty("Announce Cargo Ship Code")]
            public bool AnnounceCargoShipCode;

            [JsonProperty("Make Camera Names Unique")]
            public bool MakeCameraNamesUnique;

            public List<CCTV_Config> Cameras;
            public List<Station_Config> Stations;
        }

        private Configuration GetDefaultConfiguration()
        {
            var config = new Configuration
            {
                Cameras = new List<CCTV_Config>(),
                Stations = new List<Station_Config>(),
                AnnounceCargoShipCode = true,
                MakeCameraNamesUnique = true
            };

            config.Cameras.Add(new CCTV_Config(n: "CARGODECKA", p: new Vector3(0, 22, -37.5f), pitch: 50));
            config.Cameras.Add(new CCTV_Config(n: "CARGODECKB", p: new Vector3(0, 15, -51), r: new Vector3(0, 180, 0), pitch: 50));
            config.Cameras.Add(new CCTV_Config(n: "CARGODECKC", p: new Vector3(0, 22f, 68.55f), r: new Vector3(0, 180, 0), pitch: 28));
            config.Cameras.Add(new CCTV_Config(n: "CARGOHOLDA", p: new Vector3(0, 5.5f, -33f), pitch: 40));
            config.Cameras.Add(new CCTV_Config(n: "CARGOHOLDB", p: new Vector3(0, 5.5f, 50.9f), r: new Vector3(0, 180, 0), pitch: 40));
            config.Cameras.Add(new CCTV_Config(n: "CARGOLADDERA", p: new Vector3(12.1f, 6.3f, 28.6f), r: new Vector3(0, 90, 0), pitch: 24, yaw: 90));
            config.Cameras.Add(new CCTV_Config(n: "CARGOLADDERB", p: new Vector3(-12.1f, 6.3f, 28.6f), r: new Vector3(0, -90, 0), pitch: 24, yaw: -90));

            config.Stations.Add(new Station_Config(new Vector3(-9.2f, 24.5f, -39.7f), new Vector3(0, 180, 0)));

            return config;
        }

        #region ConfigSubclasses
        private class CCTV_Config
        {
            [JsonProperty("Camera Name")]
            public string Name = "Camera";

            [JsonProperty("Camera Position")]
            public Vector3 Position = Vector3.zero;

            [JsonProperty("Camera Rotation")]
            public Vector3 Rotation = Vector3.zero;

            [JsonProperty("Camera Pitch")]
            public float Pitch = 0;

            [JsonProperty("Camera Yaw")]
            public float Yaw = 0;

            public CCTV_Config(string n, Vector3 p, Vector3? r = null, float pitch = 0, float yaw = 0)
            {
                if (r == null)
                    r = Vector3.zero;

                Name = n;
                Position = p;
                Rotation = (Vector3)r;
                Pitch = pitch;
                Yaw = yaw;
            }
            public CCTV_Config Get(string suffix)
            {
                Name += suffix;
                return this;
            }
        }
        private class Station_Config
        {
            [JsonProperty("Station Position")]
            public Vector3 Position = Vector3.zero;

            [JsonProperty("Station Rotation")]
            public Vector3 Rotation = Vector3.zero;

            public Station_Config(Vector3 p, Vector3? r = null)
            {
                if (r == null)
                    r = Vector3.zero;

                Position = p;
                Rotation = (Vector3)r;
            }
        }
        
        #endregion

        #endregion

        #region Oxide

        private void Init() => _config = Config.ReadObject<Configuration>();

        protected override void LoadDefaultConfig()
        {
            PrintWarning("A new config file is being generated using default values.");
            _config = GetDefaultConfiguration();
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        private void OnEntitySpawned(CargoShip cargo) => Setup(cargo);

        private object CanPickupEntity(BasePlayer player, ComputerStation entity)
        {
            if (entity.OwnerID == 0)
                return false;
            return null;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["AnnounceCargoShipCode"] = "A new Cargo Ship has entered the proximity of the island. Camera codes are \nCARGODECKA{0} \nCARGODECKB{0} \nCARGODECKC{0} \nCARGOHOLDA{0} \nCARGOHOLDB{0} \nCARGOLADDERA{0} \nCARGOLADDERB{0}",
                ["AnnounceCargoShip"] = "A new Cargo Ship has entered the proximity of the island.",
            }, this);
        }

        #endregion

        #region Helpers
        public void Setup(CargoShip cargo)
        {
            List<CCTV_RC> cams = new List<CCTV_RC>();
            int suffix = 0;
            if (_config.MakeCameraNamesUnique)
                suffix = UnityEngine.Random.Range(1000, 9999);

            foreach (var item in _config.Cameras)
            {
                var cam = MakeCamera(cargo, item, suffix);
                if (cam != null)
                    cams.Add(cam);
            }
            foreach (var item in _config.Stations)
                MakeComputerStation(cargo, item, cams);

            AnnounceCargoShip(suffix);

            Interface.Oxide.CallHook("OnCargoShipCCTVSpawned", cargo, cams);
        }

        private void AnnounceCargoShip(int code = 0)
        {
            if (!_config.AnnounceCargoShipCode) return;
            foreach (var ply in BasePlayer.activePlayerList)
            {
                if (!ply.IsConnected) continue;
                if(code != 0)
                    ply.IPlayer.Message(string.Format(lang.GetMessage("AnnounceCargoShipCode", this, ply.IPlayer.Id), code.ToString()));
                else
                    ply.IPlayer.Message(lang.GetMessage("AnnounceCargoShip", this, ply.IPlayer.Id));
            }
        }
        public void RemoveCollidersFromEntity(BaseEntity colliderEntity)
        {
            foreach (var meshCollider in colliderEntity.GetComponentsInChildren<MeshCollider>())
                UnityEngine.Object.DestroyImmediate(meshCollider);

            UnityEngine.Object.DestroyImmediate(colliderEntity.GetComponent<GroundWatch>());
        }

        private void MakeComputerStation(BaseEntity obj, Station_Config config, List<CCTV_RC> cams)
        {
            ComputerStation cs = GameManager.server.CreateEntity(_computerStation, obj.transform.position) as ComputerStation;
            if (cs == null) 
                return;

            cs.SetParent(obj);

            cs.transform.localPosition = config.Position;

            cs.transform.localRotation = Quaternion.Euler(config.Rotation.x, config.Rotation.y, config.Rotation.z);

            RemoveCollidersFromEntity(cs);

            foreach (var item in cams)
                if (!cs.controlBookmarks.Contains(item.rcIdentifier))
                    cs.controlBookmarks.Add(item.rcIdentifier);
        }
        CCTV_RC MakeCamera(BaseEntity obj, CCTV_Config config, int code = 0)
        {
            CCTV_RC cam = GameManager.server.CreateEntity(_camPrefab, obj.transform.position) as CCTV_RC;
            if (cam == null) { return null; }

            cam.SetParent(obj);

            cam.transform.localPosition = config.Position;

            cam.transform.localRotation = Quaternion.Euler(config.Rotation.x, config.Rotation.y, config.Rotation.z);

            cam.isStatic = false;
            cam.yawAmount = config.Yaw;
            cam.pitchAmount = config.Pitch;
            if(code != 0)
                cam.UpdateIdentifier(config.Name + code.ToString());
            else
                cam.UpdateIdentifier(config.Name);

            RemoveCollidersFromEntity(cam);
            cam.OwnerID = obj.OwnerID;
            cam.Spawn();
            cam.isStatic = true;
            cam.UpdateHasPower(999999, 1);
            cam.SendNetworkUpdateImmediate(true);
            return cam;
        }

        #endregion
    }
}

// --- End of file: CargoShipCCTV.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/capture-the-flag ---
// --- Original File Path: C/CaptureTheFlag/CaptureTheFlag.cs ---

// Requires: EventManager
using Newtonsoft.Json;
using Oxide.Plugins.EventManagerEx;
using System;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("CaptureTheFlag", "k1lly0u", "0.4.2"), Description("Capture the flag event mode for EventManager")]
    class CaptureTheFlag : RustPlugin, IEventPlugin
    {
        #region Oxide Hooks
        private void OnServerInitialized()
        {      
            EventManager.RegisterEvent(Title, this);

            GetMessage = Message;
        }

        protected override void LoadDefaultMessages() => lang.RegisterMessages(Messages, this);

        private object CanUpdateSign(BasePlayer player, Signage sign) => sign.GetComponentInParent<FlagController>() != null ? (object)true : null;

        private void Unload()
        {
            if (!EventManager.IsUnloading)
                EventManager.UnregisterEvent(Title);

            Configuration = null;
        }
        #endregion

        #region Event Checks
        public bool InitializeEvent(EventManager.EventConfig config) => EventManager.InitializeEvent<CaptureTheFlagEvent>(this, config);

        public bool CanUseClassSelector => true;

        public bool RequireTimeLimit => true;

        public bool RequireScoreLimit => false;

        public bool UseScoreLimit => true;

        public bool UseTimeLimit => true;

        public bool IsTeamEvent => true;

        public void FormatScoreEntry(EventManager.ScoreEntry scoreEntry, ulong langUserId, out string score1, out string score2)
        {
            score1 = string.Format(Message("Score.FlagCaptures", langUserId), scoreEntry.value1);
            score2 = string.Format(Message("Score.Kills", langUserId), scoreEntry.value2);
        }

        public List<EventManager.EventParameter> AdditionalParameters { get; } = new List<EventManager.EventParameter>
        {            
            new EventManager.EventParameter
            {
                DataType = "int",
                Field = "flagRespawnTimer",
                Input = EventManager.EventParameter.InputType.InputField,               
                IsRequired = true,
                Name = "Flag Reset Time",
                DefaultValue = 30
            },
            new EventManager.EventParameter
            {
                DataType = "bool",
                Field = "closeOnStart",
                Input = EventManager.EventParameter.InputType.Toggle,
                IsRequired = false,
                Name = "Close Event On Start",
                DefaultValue = false
            }
        };

        public string ParameterIsValid(string fieldName, object value) => null;
        #endregion

        #region Event Classes
        public class CaptureTheFlagEvent : EventManager.BaseEventGame
        {
            public EventManager.Team winningTeam;

            internal int flagRespawnTime;

            private int teamAScore;
            private int teamBScore;            

            internal FlagController TeamAFlag { get; private set; }

            internal FlagController TeamBFlag { get; private set; }

            internal override void InitializeEvent(IEventPlugin plugin, EventManager.EventConfig config)
            {
                flagRespawnTime = config.GetParameter<int>("flagRespawnTimer");

                base.InitializeEvent(plugin, config);

                TeamAFlag = FlagController.Create(this, EventManager.Team.A, _spawnSelectorA.ReserveSpawnPoint(0));
                TeamBFlag = FlagController.Create(this, EventManager.Team.B, _spawnSelectorB.ReserveSpawnPoint(0));
            }

            internal override void PrestartEvent()
            {
                if (Config.GetParameter<bool>("closeEventOnStart"))
                    CloseEvent();
                
                base.PrestartEvent();
            }

            protected override void StartEvent()
            {
                BalanceTeams();
                base.StartEvent();
            }

            internal override void EndEvent()
            {
                TeamAFlag.DropFlag(false);
                TeamBFlag.DropFlag(false);
                
                base.EndEvent();
            }

            protected override void OnDestroy()
            {
                Destroy(TeamAFlag);
                Destroy(TeamBFlag);

                base.OnDestroy();
            }

            protected override EventManager.BaseEventPlayer AddPlayerComponent(BasePlayer player) => player.gameObject.AddComponent<CaptureTheFlagPlayer>();

            protected override EventManager.Team GetPlayerTeam(BasePlayer player)
            {
                if (GetTeamCount(EventManager.Team.A) > GetTeamCount(EventManager.Team.B))
                    return EventManager.Team.B;
                return EventManager.Team.A;
            }

            internal override int GetTeamScore(EventManager.Team team) => team == EventManager.Team.B ? teamBScore : teamAScore;

            internal override void OnPlayerTakeDamage(EventManager.BaseEventPlayer eventPlayer, HitInfo hitInfo)
            {
                EventManager.BaseEventPlayer attacker = EventManager.GetUser(hitInfo.InitiatorPlayer);
                if (attacker == null || eventPlayer.Team != attacker.Team)
                {
                    base.OnPlayerTakeDamage(eventPlayer, hitInfo);
                    return;
                }

                if (GodmodeEnabled || eventPlayer.IsDead || eventPlayer.IsInvincible)
                {
                    EventManager.ClearDamage(hitInfo);
                    return;
                }

                if (Configuration.FriendlyFireModifier != 1f)
                    hitInfo.damageTypes.ScaleAll(Configuration.FriendlyFireModifier);

                eventPlayer.OnTakeDamage(attacker.Player.userID);
            }

            internal override void OnEventPlayerDeath(EventManager.BaseEventPlayer victim, EventManager.BaseEventPlayer attacker = null, HitInfo info = null)
            {
                if (victim == null)
                    return;

                if ((victim as CaptureTheFlagPlayer).IsCarryingFlag)
                {
                    FlagController flagController = victim.Team == EventManager.Team.B ? TeamAFlag : TeamBFlag;
                    if (flagController.FlagHolder == victim)
                    {
                        flagController.DropFlag(true);
                        BroadcastToPlayers(GetMessage, "Notification.FlagDropped", victim.Player.displayName, flagController.Team, GetTeamColor(victim.Team), GetTeamColor(flagController.Team));
                    }
                }

                victim.OnPlayerDeath(attacker, Configuration.RespawnTime);

                if (attacker != null && victim != attacker && victim.Team != attacker.Team)                                  
                    attacker.OnKilledPlayer(info);

                UpdateScoreboard();
                base.OnEventPlayerDeath(victim, attacker);
            }

            protected override void GetWinningPlayers(ref List<EventManager.BaseEventPlayer> winners)
            {
                if (winningTeam != EventManager.Team.None)
                {
                    if (eventPlayers.Count > 0)
                    {
                        for (int i = 0; i < eventPlayers.Count; i++)
                        {
                            EventManager.BaseEventPlayer eventPlayer = eventPlayers[i];
                            if (eventPlayer == null)
                                continue;

                            if (eventPlayer.Team == winningTeam)
                                winners.Add(eventPlayer);
                        }
                    }
                }
            }

            internal void OnFlagCaptured(CaptureTheFlagPlayer eventPlayer, EventManager.Team team)
            {
                int flagCaptures;

                if (eventPlayer.Team == EventManager.Team.B)
                    flagCaptures = teamBScore += 1;
                else flagCaptures = teamAScore += 1;

                eventPlayer.FlagCaptures += 1;

                BroadcastToPlayers(GetMessage, "Notification.FlagCaptured", eventPlayer.Player.displayName, team, GetTeamColor(eventPlayer.Team), GetTeamColor(team));                

                UpdateScoreboard();

                if (flagCaptures >= Config.ScoreLimit)
                {
                    winningTeam = eventPlayer.Team;
                    InvokeHandler.Invoke(this, EndEvent, 0.1f);
                }
            }

            internal string GetTeamColor(EventManager.Team team) => team == EventManager.Team.B ? TeamBColor : TeamAColor;

            #region Scoreboards
            protected override void BuildScoreboard()
            {
                scoreContainer = EMInterface.CreateScoreboardBase(this);

                int index = -1;
                EMInterface.CreatePanelEntry(scoreContainer, string.Format(GetMessage("Score.Team", 0UL), teamAScore, TeamAColor, TeamBColor, teamBScore), index += 1);

                if (Config.ScoreLimit > 0)
                    EMInterface.CreatePanelEntry(scoreContainer, string.Format(GetMessage("Score.Limit", 0UL), Config.ScoreLimit), index += 1);

                EMInterface.CreateScoreEntry(scoreContainer, string.Empty, "C", "K", index += 1);

                for (int i = 0; i < Mathf.Min(scoreData.Count, 15); i++)
                {
                    EventManager.ScoreEntry score = scoreData[i];
                    EMInterface.CreateScoreEntry(scoreContainer, $"<color={(score.team == EventManager.Team.A ? TeamAColor : TeamBColor)}>{score.displayName}</color>", ((int)score.value1).ToString(), ((int)score.value2).ToString(), i + index + 1);
                }
            }

            protected override float GetFirstScoreValue(EventManager.BaseEventPlayer eventPlayer) => (eventPlayer as CaptureTheFlagPlayer).FlagCaptures;

            protected override float GetSecondScoreValue(EventManager.BaseEventPlayer eventPlayer) => eventPlayer.Kills;

            protected override void SortScores(ref List<EventManager.ScoreEntry> list)
            {
                list.Sort(delegate (EventManager.ScoreEntry a, EventManager.ScoreEntry b)
                {
                    int primaryScore = a.value1.CompareTo(b.value1);

                    if (primaryScore == 0)
                        return a.value2.CompareTo(b.value2);

                    return primaryScore;
                });
            }
            #endregion
        }

        internal class CaptureTheFlagPlayer : EventManager.BaseEventPlayer
        {
            public int FlagCaptures { get; set; }

            public bool IsCarryingFlag { get; set; }
        }

        internal class FlagController : MonoBehaviour
        {
            private Signage primary;
            private Signage secondary;

            private Transform tr;

            private Vector3 basePosition;
            private BoxCollider boxCollider;

            private uint signImageCRC = 0;

            private CaptureTheFlagEvent captureTheFlagEvent;

            internal EventManager.Team Team { get; set; }

            internal CaptureTheFlagPlayer FlagHolder { get; private set; }

            internal bool IsAtBase { get; private set; } = true;

            private const string SIGN_PREFAB = "assets/prefabs/deployable/signs/sign.post.single.prefab";

            private const float ROTATE_SPEED = 48f;

            internal static FlagController Create(CaptureTheFlagEvent captureTheFlagEvent, EventManager.Team team, Vector3 position)
            {                
                Signage signage = Spawn(position);
                FlagController flagController = signage.gameObject.AddComponent<FlagController>();

                flagController.captureTheFlagEvent = captureTheFlagEvent;
                flagController.Team = team;
                flagController.basePosition = position;

                return flagController;
            }

            private static Signage Spawn(Vector3 position)
            {
                Signage signage = GameManager.server.CreateEntity(SIGN_PREFAB, position) as Signage;
                signage.enableSaving = false;
                signage.Spawn();

                Destroy(signage.GetComponent<MeshCollider>());
                Destroy(signage.GetComponent<DestroyOnGroundMissing>());
                Destroy(signage.GetComponent<GroundWatch>());

                return signage;
            }

            private void Awake()
            {
                primary = GetComponent<Signage>();
                tr = primary.transform;
            }

            private void Start()
            {
                secondary = Spawn(tr.position);
                
                secondary.SetParent(primary);
                secondary.transform.localPosition = Vector3.zero;
                secondary.transform.localRotation = Quaternion.Euler(0f, 180f, 0f);

                SetSignImages(primary);
                SetSignImages(secondary);

                primary.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                secondary.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                primary.gameObject.layer = (int)Rust.Layer.Reserved1;

                boxCollider = primary.gameObject.AddComponent<BoxCollider>();
                boxCollider.size = new Vector3(1.2f, 2f, 1f);
                boxCollider.center = new Vector3(0f, 1.1f, 0f);
                boxCollider.isTrigger = true;
            }

            private void Update()
            {
                tr.RotateAround(tr.position, tr.up, Time.deltaTime * ROTATE_SPEED);
                primary.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            }

            private void OnDestroy()
            {
                Destroy(boxCollider);

                if (secondary != null && !secondary.IsDestroyed)
                {
                    secondary.SetParent(null);
                    secondary.Kill(BaseNetworkable.DestroyMode.None);
                }

                if (primary != null && !primary.IsDestroyed)
                {
                    primary.SetParent(null);
                    primary.Kill();
                }
            }

            private void SetSignImages(Signage signage)
            {
                string hex = Team == EventManager.Team.B ? captureTheFlagEvent.TeamBColor : captureTheFlagEvent.TeamAColor;

                if (signImageCRC == 0)
                {
                    hex = hex.TrimStart('#');

                    int red = int.Parse(hex.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                    int green = int.Parse(hex.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                    int blue = int.Parse(hex.Substring(4, 2), NumberStyles.AllowHexSpecifier);

                    Color color = new Color((float)red / 255f, (float)green / 255f, (float)blue / 255f);

                    Color[] array = new Color[256 * 256];
                    for (int i = 0; i < array.Length; i++)
                        array[i] = color;

                    Texture2D texture2D = new Texture2D(256, 256);
                    texture2D.SetPixels(array);
                    byte[] bytes = texture2D.EncodeToPNG();

                    Destroy(texture2D);

                    signImageCRC = FileStorage.server.Store(bytes, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID);
                }

                Array.Resize<uint>(ref signage.textureIDs, 1);

                signage.textureIDs[0] = signImageCRC;
                signage.SetFlag(BaseEntity.Flags.Locked, true);
            }
            
            private void OnTriggerEnter(Collider col)
            {
                if (captureTheFlagEvent.Status != EventManager.EventStatus.Started)
                    return;

                CaptureTheFlagPlayer eventPlayer = col.GetComponent<CaptureTheFlagPlayer>();
                if (eventPlayer == null || eventPlayer.IsDead)
                    return;

                if (IsAtBase)
                {
                    if (eventPlayer.Team != Team)                    
                        PickupFlag(eventPlayer);                    
                    else
                    {
                        if (eventPlayer.IsCarryingFlag)
                        {
                            FlagController enemyFlag = Team == EventManager.Team.A ? captureTheFlagEvent.TeamBFlag : captureTheFlagEvent.TeamAFlag;
                            enemyFlag.CaptureFlag(eventPlayer);
                        }
                    }
                }
                else
                {
                    if (FlagHolder == null)
                    {
                        if (eventPlayer.Team != Team)                        
                            PickupFlag(eventPlayer);                        
                        else
                        {
                            ResetFlag();
                            captureTheFlagEvent.BroadcastToPlayers(GetMessage, "Notification.FlagReset", eventPlayer.Team, captureTheFlagEvent.GetTeamColor(eventPlayer.Team));
                        }
                    }
                }
            }

            private void PickupFlag(CaptureTheFlagPlayer eventPlayer)
            {
                FlagHolder = eventPlayer;
                eventPlayer.IsCarryingFlag = true;

                IsAtBase = false;
                InvokeHandler.CancelInvoke(this, DroppedTimeExpired);

                primary.SetParent(eventPlayer.Player);
                tr.localPosition = new Vector3(0f, 0.25f, -0.75f);

                captureTheFlagEvent.BroadcastToPlayers(GetMessage, "Notification.FlagPickedUp", eventPlayer.Player.displayName, Team, captureTheFlagEvent.GetTeamColor(eventPlayer.Team), captureTheFlagEvent.GetTeamColor(Team));
            }

            internal void DropFlag(bool resetToBase)
            {                
                primary.SetParent(null, true);

                if (FlagHolder != null)
                {
                    FlagHolder.IsCarryingFlag = false;
                    FlagHolder = null;
                }

                primary.UpdateNetworkGroup();
                primary.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                if (resetToBase)
                    InvokeHandler.Invoke(this, DroppedTimeExpired, captureTheFlagEvent.flagRespawnTime);
            }

            private void CaptureFlag(CaptureTheFlagPlayer eventPlayer)
            {
                ResetFlag();
                captureTheFlagEvent.OnFlagCaptured(eventPlayer, Team);                
            }

            private void DroppedTimeExpired()
            {
                captureTheFlagEvent.BroadcastToPlayers(GetMessage, "Notification.FlagReset", Team, captureTheFlagEvent.GetTeamColor(Team));
                ResetFlag();
            }

            private void ResetFlag()
            {
                if (FlagHolder != null)
                {
                    FlagHolder.IsCarryingFlag = false;
                    FlagHolder = null;
                }

                InvokeHandler.CancelInvoke(this, DroppedTimeExpired);

                primary.SetParent(null);

                tr.position = basePosition;

                primary.UpdateNetworkGroup();
                primary.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                IsAtBase = true;
            }
        }
        #endregion

        #region Config        
        private static ConfigData Configuration;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Respawn time (seconds)")]
            public int RespawnTime { get; set; }

            [JsonProperty(PropertyName = "Friendly fire damage modifier (0.0 is no damage, 1.0 is normal damage)")]
            public float FriendlyFireModifier { get; set; }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Configuration = Config.ReadObject<ConfigData>();

            if (Configuration.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(Configuration, true);
        }

        protected override void LoadDefaultConfig() => Configuration = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                RespawnTime = 5,
                FriendlyFireModifier = 1.0f,
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(Configuration, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (Configuration.Version < new Core.VersionNumber(0, 4, 1))
                Configuration.FriendlyFireModifier = baseConfig.FriendlyFireModifier;

            Configuration.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        #region Localization
        public string Message(string key, ulong playerId = 0U) => lang.GetMessage(key, this, playerId != 0U ? playerId.ToString() : null);

        private static Func<string, ulong, string> GetMessage;

        private readonly Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["Score.FlagCaptures"] = "Flag Captures: {0}",
            ["Score.Kills"] = "Kills: {0}",
            ["Score.Name"] = "Kills",
            ["Score.Limit"] = "Score Limit : {0}",
            ["Score.Team"] = "{0} : <color={1}>Team A</color> | <color={2}>Team B</color> : {3}",
            ["Notification.FlagPickedUp"] = "<color={2}>{0}</color> has picked up <color={3}>Team {1}</color>'s flag",
            ["Notification.FlagReset"] = "<color={1}>Team {0}</color>'s flag has been returned to base",
            ["Notification.FlagCaptured"] = "<color={2}>{0}</color> has captured <color={3}>Team {1}</color>'s flag",
            ["Notification.FlagDropped"] = "<color={2}>{0}</color> has dropped <color={3}>Team {1}</color>'s flag"

        };
        #endregion
    }
}


// --- End of file: CaptureTheFlag.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/car-commander-lite ---
// --- Original File Path: C/CarCommanderLite/CarCommanderLite.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using Rust;
using UnityEngine;
using System.Linq;
using System.Globalization;

namespace Oxide.Plugins
{
    [Info("CarCommanderLite", "k1lly0u", "0.1.3")]
    [Description("Car spawner with added features")]
    class CarCommanderLite : RustPlugin
    {
        #region Fields
        [PluginReference] Plugin Spawns;

        private List<uint> storedCars = new List<uint>();
        private DynamicConfigFile data;

        static CarCommanderLite ins;
        
        private List<CarController> saveableCars = new List<CarController>();

        private bool initialized;
        private bool wipeData = false;       
       
        const string carPrefab = "assets/content/vehicles/sedan_a/sedantest.entity.prefab";
        const string heliExplosion = "assets/prefabs/npc/patrol helicopter/effects/heli_explosion.prefab";

        const string uiHealth = "CCUI_Health";
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            permission.RegisterPermission("carcommanderlite.admin", this);
            permission.RegisterPermission("carcommanderlite.use", this);
            permission.RegisterPermission("carcommanderlite.canspawn", this);

            lang.RegisterMessages(Messages, this);
            data = Interface.Oxide.DataFileSystem.GetFile("carcommander_data");
        }

        private void OnServerInitialized()
        {
            ins = this;
            LoadVariables();
            LoadData();

            initialized = true;

            if (wipeData)
            {
                PrintWarning("Map wipe detected! Wiping previous car data");
                saveableCars.Clear();
                SaveData();
            }

            timer.In(3, RestoreVehicles);
        }

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null) return;
            if (entity.GetComponent<CarController>())            
                entity.GetComponent<CarController>().ManageDamage(info);                       
        }
        
        private void OnEntityKill(BaseNetworkable networkable)
        {
            CarController controller = networkable.GetComponent<CarController>();
            if (controller != null && saveableCars.Contains(controller))
            {
                saveableCars.Remove(controller);
            }
        }

        private void OnNewSave(string filename) => wipeData = true;

        private void OnServerSave()
        {
            for (int i = saveableCars.Count - 1; i >= 0; i--)
            {
                CarController controller = saveableCars[i];
                if (controller == null || controller.entity == null || !controller.entity.IsValid() || controller.entity.IsDestroyed)
                {
                    saveableCars.RemoveAt(i);
                    continue;
                }                
            }
            SaveData();
        }

        private void Unload()
        {
            var objects = UnityEngine.Object.FindObjectsOfType<CarController>();
            if (objects != null)
            {
                foreach (var obj in objects)
                    UnityEngine.Object.Destroy(obj);
            }
        }

        private object CanMountEntity(BasePlayer player, BaseMountable mountable)
        {
            CarController controller = mountable.GetComponent<CarController>();
            if (controller != null)
            {
                if (player.isMounted)
                    return false;
                
                if (controller.isDieing)
                    return false;

                if (!HasPermission(player, "carcommanderlite.use"))
                {
                    SendReply(player, msg("nopermission", player.UserIDString));
                    return false;
                }                
            }            
            return null;
        }

        private void OnEntityMounted(BaseMountable mountable, BasePlayer player)
        {
            CarController controller = mountable.VehicleParent()?.GetComponent<CarController>();
            if (controller != null && controller.player == null)            
                controller.OnDriverEnter(player);                       
        }

        private void OnEntityDismounted(BaseMountable mountable, BasePlayer player)
        {
            CarController controller = mountable.VehicleParent()?.GetComponent<CarController>();
            if (controller != null && controller.player == player)            
                controller.OnDriverExit();
        }
        #endregion

        #region Functions        
        private bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm) || permission.UserHasPermission(player.UserIDString, "carcommanderlite.admin");

        private void RestoreVehicles()
        {
            if (storedCars.Count > 0)
            {
                BaseEntity[] objects = BaseEntity.saveList.Where(x => x is BasicCar).ToArray();
                if (objects != null)
                {
                    foreach (var obj in objects)
                    {
                        if (!obj.IsValid() || obj.IsDestroyed)
                            continue;

                        if (storedCars.Contains(obj.net.ID))
                        {                            
                            saveableCars.Add(obj.gameObject.AddComponent<CarController>());
                        }
                    }
                }
            }
            CheckForSpawns();
        }

        private BaseEntity SpawnAtLocation(Vector3 position, Quaternion rotation = default(Quaternion), bool enableSaving = false)
        {
            BasicCar entity = (BasicCar)GameManager.server.CreateEntity(carPrefab, position + Vector3.up, rotation);
            entity.enableSaving = enableSaving;
            entity.Spawn();

            CarController controller = entity.gameObject.AddComponent<CarController>();

            if (enableSaving)
            {
                saveableCars.Add(controller);
                SaveData();
            }

            return entity;
        }

        private void CheckForSpawns()
        {
            if (configData.Spawnable.Enabled)
            {
                if (saveableCars.Count < configData.Spawnable.Max)
                {
                    object position = null;
                    if (!Spawns)
                    {
                        PrintError("Spawns Database can not be found! Unable to autospawn cars");
                        return;
                    }

                    object success = Spawns.Call("GetSpawnsCount", configData.Spawnable.Spawnfile);
                    if (success is string)
                    {
                        PrintError("An invalid spawnfile has been set in the config. Unable to autospawn cars : " + (string)success);
                        return;
                    }

                    success = Spawns.Call("GetRandomSpawn", configData.Spawnable.Spawnfile);
                    if (success is string)
                    {
                        PrintError((string)success);
                        return;
                    }
                    else position = (Vector3)success;

                    if (position != null)
                    {
                        List<BasicCar> entities = Facepunch.Pool.GetList<BasicCar>();
                        Vis.Entities((Vector3)position, 5f, entities);
                        if (entities.Count > 0)
                            timer.In(60, CheckForSpawns);
                        else
                        {
                            SpawnAtLocation((Vector3)position, new Quaternion(), true);
                            timer.In(configData.Spawnable.Time, CheckForSpawns);
                        }
                        Facepunch.Pool.FreeList(ref entities);
                    }
                }
            }
        }
        #endregion

        #region Component
        public class CarController : MonoBehaviour
        {
            public BasicCar entity;
            public BasePlayer player;
            public bool isDieing;

            private bool allowHeldItems;
            private string[] disallowedItems;

            private void Awake()
            {
                entity = GetComponent<BasicCar>();

                allowHeldItems = !ins.configData.ActiveItems.Disable;
                disallowedItems = ins.configData.ActiveItems.BlackList;
            }

            private void Update()
            {
                UpdateHeldItems();
                CheckWaterLevel();
            }

            public void OnDriverEnter(BasePlayer player)
            {
                this.player = player;
                ins.CreateHealthUI(player, this);
            }

            public void OnDriverExit()
            {
                ins.DestroyUI(player);
                this.player = null;                
            }

            public void ManageDamage(HitInfo info)
            {
                if (isDieing)
                {
                    NullifyDamage(info);
                    return;
                }

                if (info.damageTypes.GetMajorityDamageType() == DamageType.Bullet)
                    info.damageTypes.ScaleAll(200);

                if (info.damageTypes.Total() >= entity.health)
                {
                    isDieing = true;
                    NullifyDamage(info);
                    OnDeath();
                    return;
                }

                if (player != null)
                    ins.NextTick(() => ins.CreateHealthUI(player, this));
            }

            private void NullifyDamage(HitInfo info)
            {
                info.damageTypes = new DamageTypeList();
                info.HitEntity = null;
                info.HitMaterial = 0;
                info.PointStart = Vector3.zero;
            }

            public void UpdateHeldItems()
            {
                if (player == null)
                    return;

                var item = player.GetActiveItem();
                if (item == null || item.GetHeldEntity() == null)
                    return;

                if (disallowedItems.Contains(item.info.shortname) || !allowHeldItems)
                {
                    player.ChatMessage(ins.msg("itemnotallowed", player.UserIDString));

                    var slot = item.position;
                    item.SetParent(null);
                    item.MarkDirty();

                    ins.timer.Once(0.15f, () =>
                    {
                        if (player == null || item == null) return;
                        item.SetParent(player.inventory.containerBelt);
                        item.position = slot;
                        item.MarkDirty();
                    });
                }
            }

            public void CheckWaterLevel()
            {
                if (WaterLevel.Factor(entity.WorldSpaceBounds().ToBounds()) > 0.7f)                
                    StopToDie();                
            }

            public void StopToDie()
            {
                if (entity != null)
                {
                    entity.SetFlag(BaseEntity.Flags.Reserved1, false, false);

                    foreach (var wheel in entity.wheels)
                    {
                        wheel.wheelCollider.motorTorque = 0;
                        wheel.wheelCollider.brakeTorque = float.MaxValue;
                    }

                    entity.GetComponent<Rigidbody>().velocity = Vector3.zero;

                    if (player != null)
                        entity.DismountPlayer(player);
                }
                OnDeath();
            }

            private void OnDeath()
            {
                isDieing = true;

                if (player != null)                
                    player.EnsureDismounted();                

                InvokeHandler.Invoke(this, () =>
                {
                    Effect.server.Run(heliExplosion, transform.position);
                    ins.NextTick(() =>
                    {
                        if (entity != null && !entity.IsDestroyed)
                            entity.DieInstantly();
                        Destroy(this);
                    });
                }, 5f);
            }
        }
        #endregion

        #region UI
        #region UI Elements
        public static class UI
        {
            static public CuiElementContainer ElementContainer(string panelName, string color, UI4 dimensions, bool useCursor = false, string parent = "Overlay")
            {
                var NewElement = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax()},
                            CursorEnabled = useCursor
                        },
                        new CuiElement().Parent = parent,
                        panelName
                    }
                };
                return NewElement;
            }
            static public void Panel(ref CuiElementContainer container, string panel, string color, UI4 dimensions, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                    CursorEnabled = cursor
                },
                panel);
            }
            static public void Label(ref CuiElementContainer container, string panel, string text, int size, UI4 dimensions, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Align = align, Text = text, Font = "droidsansmono.ttf" },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                },
                panel);

            }
            public static string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.Substring(1);
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }
        }
        public class UI4
        {
            public float xMin, yMin, xMax, yMax;
            public UI4(float xMin, float yMin, float xMax, float yMax)
            {
                this.xMin = xMin;
                this.yMin = yMin;
                this.xMax = xMax;
                this.yMax = yMax;
            }
            public string GetMin() => $"{xMin} {yMin}";
            public string GetMax() => $"{xMax} {yMax}";
        }
        #endregion

        #region UI Creation        
        private void CreateHealthUI(BasePlayer player, CarController controller)
        {
            var opt = configData.UI.Health;
            if (!opt.Enabled)
                return;

            var container = UI.ElementContainer(uiHealth, UI.Color(opt.Color1, opt.Color1A), new UI4(opt.Xmin, opt.YMin, opt.XMax, opt.YMax));
            UI.Label(ref container, uiHealth, msg("health", player.UserIDString), 12, new UI4(0.03f, 0, 1, 1), TextAnchor.MiddleLeft);
            var percentHealth = System.Convert.ToDouble((float)controller.entity.health / (float)controller.entity.MaxHealth());
            float yMaxHealth = 0.25f + (0.73f * (float)percentHealth);
            UI.Panel(ref container, uiHealth, UI.Color(opt.Color2, opt.Color2A), new UI4(0.25f, 0.1f, yMaxHealth, 0.9f));
            DestroyUI(player);
            CuiHelper.AddUi(player, container);
        }
       
        private void DestroyUI(BasePlayer player) => CuiHelper.DestroyUi(player, uiHealth);        
        #endregion
        #endregion
        
        #region Commands
        [ChatCommand("spawncar")]
        void cmdSpawnCar(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, "carcommanderlite.canspawn")) return;

            Vector3 position = player.transform.position + (player.transform.forward * 3);

            RaycastHit hit;
            if (Physics.SphereCast(player.eyes.position, 0.1f, Quaternion.Euler(player.serverInput.current.aimAngles) * Vector3.forward, out hit, 20f))
                position = hit.point;

            SpawnAtLocation(position, new Quaternion(), (args.Length == 1 && args[0].ToLower() == "save"));
        }

        [ChatCommand("clearcars")]
        void cmdClearCars(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, "carcommanderlite.admin")) return;

            for (int i = saveableCars.Count - 1; i >= 0; i--)
            {
                var car = saveableCars[i];
                if (car != null && car.entity != null && !car.entity.IsDestroyed)
                    car.StopToDie();
            }
        }

        [ConsoleCommand("clearcars")]
        void ccmdClearCars(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null || arg.Args == null)
                return;

            for (int i = saveableCars.Count - 1; i >= 0; i--)
            {
                var car = saveableCars[i];
                if (car != null && car.entity != null && !car.entity.IsDestroyed)
                    car.StopToDie();
            }
        }

        [ConsoleCommand("spawncar")]
        void ccmdSpawnCar(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null || arg.Args == null)
                return;

            if (arg.Args.Length == 1 || arg.Args.Length == 2)
            {
                BasePlayer player = covalence.Players.Connected.FirstOrDefault(x => x.Id == arg.GetString(0))?.Object as BasePlayer;
                if (player != null)
                {
                    Vector3 position = player.transform.position + (player.transform.forward * 3) + Vector3.up;

                    RaycastHit hit;
                    if (Physics.SphereCast(player.eyes.position, 0.5f, Quaternion.Euler(player.serverInput.current.aimAngles) * Vector3.forward, out hit, 20f))
                        position = hit.point;

                    SpawnAtLocation(position, new Quaternion(), (arg.Args.Length == 2 && arg.Args[1].ToLower() == "save"));
                }
                return;
            }
            if (arg.Args.Length > 2)
            {
                float x;
                float y;
                float z;

                if (float.TryParse(arg.GetString(0), out x))
                {
                    if (float.TryParse(arg.GetString(1), out y))
                    {
                        if (float.TryParse(arg.GetString(2), out z))
                        {
                            SpawnAtLocation(new Vector3(x, y, z), new Quaternion(), (arg.Args.Length == 4 && arg.Args[3].ToLower() == "save"));
                            return;
                        }
                    }
                }
                PrintError($"Invalid arguments supplied to spawn a car at position : (x = {arg.GetString(0)}, y = {arg.GetString(1)}, z = {arg.GetString(2)})");
            }
        }
        #endregion
       
        #region Config        
        private ConfigData configData;
        class ConfigData
        {            
            [JsonProperty(PropertyName = "Spawnable Options")]
            public SpawnableOptions Spawnable { get; set; }            
            [JsonProperty(PropertyName = "Active Item Options")]
            public ActiveItemOptions ActiveItems { get; set; }
            [JsonProperty(PropertyName = "UI Options")]
            public UIOptions UI { get; set; }
                     
            public class SpawnableOptions
            {
                [JsonProperty(PropertyName = "Enable automatic vehicle spawning")]
                public bool Enabled { get; set; }               
                [JsonProperty(PropertyName = "Spawnfile name")]
                public string Spawnfile { get; set; }
                [JsonProperty(PropertyName = "Maximum spawned vehicles at any time")]
                public int Max { get; set; }
                [JsonProperty(PropertyName = "Time between autospawns (seconds)")]
                public int Time { get; set; }
            }           
            public class ActiveItemOptions
            {
                [JsonProperty(PropertyName = "Disable all held items")]
                public bool Disable { get; set; }
                [JsonProperty(PropertyName = "List of disallowed held items (item shortnames)")]
                public string[] BlackList { get; set; }               
            }
            public class UIOptions
            {
                [JsonProperty(PropertyName = "Health settings")]
                public UICounter Health { get; set; }                

                public class UICounter
                {
                    [JsonProperty(PropertyName = "Display to player")]
                    public bool Enabled { get; set; }
                    [JsonProperty(PropertyName = "Position - X minimum")]
                    public float Xmin { get; set; }
                    [JsonProperty(PropertyName = "Position - X maximum")]
                    public float XMax { get; set; }
                    [JsonProperty(PropertyName = "Position - Y minimum")]
                    public float YMin { get; set; }
                    [JsonProperty(PropertyName = "Position - Y maximum")]
                    public float YMax { get; set; }
                    [JsonProperty(PropertyName = "Background color (hex)")]
                    public string Color1 { get; set; }
                    [JsonProperty(PropertyName = "Background alpha")]
                    public float Color1A { get; set; }
                    [JsonProperty(PropertyName = "Status color (hex)")]
                    public string Color2 { get; set; }
                    [JsonProperty(PropertyName = "Status alpha")]
                    public float Color2A { get; set; }
                }
            }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                ActiveItems = new ConfigData.ActiveItemOptions
                {
                    Disable = true,
                    BlackList = new string[]
                    {
                        "explosive.timed", "rocket.launcher", "surveycharge", "explosive.satchel"
                    }
                },                
                Spawnable = new ConfigData.SpawnableOptions
                {
                    Enabled = true,
                    Max = 5,
                    Time = 1800,
                    Spawnfile = ""
                },               
                UI = new ConfigData.UIOptions
                {                   
                    Health = new ConfigData.UIOptions.UICounter
                    {
                        Color1 = "#F2F2F2",
                        Color1A = 0.05f,
                        Color2 = "#ce422b",
                        Color2A = 0.6f,
                        Enabled = true,
                        Xmin = 0.69f,
                        XMax = 0.83f,
                        YMin = 0.1f,
                        YMax = 0.135f
                    }
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Data Management
        void SaveData() => data.WriteObject(saveableCars.Where(x => x != null).Select(x => x.entity.net.ID).ToList());
        void LoadData()
        {
            try
            {
                storedCars = data.ReadObject<List<uint>>();
            }
            catch
            {
                storedCars = new List<uint>();
            }
        }
        #endregion

        #region Localization
        string msg(string key, string playerId = null) => lang.GetMessage(key, this, playerId);

        Dictionary<string, string> Messages = new Dictionary<string, string>
        {            
            ["nopermission"] = "<color=#D3D3D3>You do not have permission to drive this car</color>",
            ["health"] = "HLTH: ",
            ["itemnotallowed"] = "<color=#D3D3D3>You can not use that item whilst you are in a car</color>"
        };
        #endregion
    }
}


// --- End of file: CarCommanderLite.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/customizable-extended-magazines ---
// --- Original File Path: C/CustomizableMagazines/CustomizableMagazines.cs ---

using System.Collections.Generic;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using UnityEngine;
using System.Linq;
using Oxide.Core;
using System;

namespace Oxide.Plugins
{
    [Info("Customizable Magazines", "Razor", "1.1.5")]
    [Description("Change the Magazines Around.")]
    public class CustomizableMagazines : RustPlugin
    {
        #region Init/Unloading
        bool debug = false;
        static CustomizableMagazines Instance;
        private ItemModMagazine _itemModMagazine;
        private string MagazineUse = "customizablemagazines.admin";

        private void Init()
        {
            permission.RegisterPermission(MagazineUse, this);

            if (configData.mags.Count <= 0)
            {
                configData.mags.Add(2892143123, new customMagazines("Extended Magazine 15%", 1.5f, 1.0f, new List<string>() { "crate_basic", "crate_normal", "crate_normal_2" }));
                configData.mags.Add(2892142979, new customMagazines("Extended Magazine 30%", 1.75f, 1.0f, new List<string>() { "crate_basic", "crate_normal", "crate_normal_2" }));
                configData.mags.Add(2892142846, new customMagazines("Extended Magazine 50%", 2.0f, 1.0f, new List<string>() { "crate_basic", "crate_normal", "crate_normal_2" }));
                configData.mags.Add(2892142705, new customMagazines("Extended Magazine 100%", 3.0f, 1.0f, new List<string>() { "crate_basic", "crate_normal", "crate_normal_2" }));
                SaveConfig();
            }
        }

        private void OnServerInitialized()
        {
            var magazineItemDef = ItemManager.FindItemDefinition("weapon.mod.extendedmags");
            _itemModMagazine = magazineItemDef.gameObject.AddComponent<ItemModMagazine>();
            AddToItemDefinition(magazineItemDef, _itemModMagazine);
        }

        private void Unload()
        {
            var magazineItemDef = ItemManager.FindItemDefinition("weapon.mod.extendedmags");
            if (_itemModMagazine != null)
            {
                RemoveFromItemDefinition(magazineItemDef, _itemModMagazine);
            }

            UnityEngine.Object.DestroyImmediate(_itemModMagazine);
            Instance = null;
        }
        #endregion

        #region ItemModMagazine
        private static void AddToItemDefinition(ItemDefinition itemDefinition, ItemMod itemMod)
        {
            if (itemDefinition.itemMods.Contains(itemMod))
                return;

            var length = itemDefinition.itemMods.Length;
            Array.Resize(ref itemDefinition.itemMods, length + 1);
            itemDefinition.itemMods[length] = itemMod;
        }

        private static void RemoveFromItemDefinition(ItemDefinition itemDefinition, ItemMod itemMod)
        {
            if (!itemDefinition.itemMods.Contains(itemMod))
                return;

            itemDefinition.itemMods = itemDefinition.itemMods.Where(mod => mod != itemMod).ToArray();
        }

        private class ItemModMagazine : ItemMod
        {
            public override void OnParentChanged(Item item)
            {
                if (Instance != null && item != null && item.parent != null && item.skin != 0UL && Instance.configData.mags.ContainsKey(item.skin))
                {
                    ProjectileWeaponMod held = item.GetHeldEntity() as ProjectileWeaponMod;
                    if (held == null)
                        return;

                    SetupMagazine(held, item, item.skin);
                }
            }
        }
        #endregion

        #region hooks
        void OnLootSpawn(LootContainer container)
        {
            if (container == null || container.inventory == null || !configData.settings.randomMagazine || container.ShortPrefabName == "stocking_large_deployed" ||
                container.ShortPrefabName == "stocking_small_deployed") return;
            foreach (var ItemsConfig in configData.mags)
            {
                bool ItemAdded = false;
                foreach (var LootContainers in ItemsConfig.Value.LootContainers)
                {
                    if (LootContainers == null || ItemsConfig.Value.SpawnChance <= 0)
                        continue;

                    if (LootContainers.Contains(container.ShortPrefabName))
                    {
                        if (UnityEngine.Random.Range(0, 100) < ItemsConfig.Value.SpawnChance)
                        {
                            if (container.inventory.itemList.Count == container.inventory.capacity)
                            {
                                container.inventory.capacity++;
                            }
                            string name = ItemsConfig.Value.displayName;
                            var MagazineItem = ItemManager.CreateByItemID(2005491391, 1, ItemsConfig.Key);
                            MagazineItem.MoveToContainer(container.inventory);
                            if (debug) PrintWarning($"{name} Spawned in container {LootContainers} At: {container.transform.position}");
                            ItemAdded = true;
                            break;
                        }
                    }
                }
                if (ItemAdded)
                    break;
            }
        }

        private static void SetupMagazine(ProjectileWeaponMod mag, Item item, ulong configName)
        {
            if (mag != null && Instance.configData.mags.ContainsKey(configName))
            {
                customMagazines magconfig = Instance.configData.mags[configName];

                mag.magazineCapacity.scalar = magconfig.totalAmmo;
                mag.skinID = configName;
                item.skin = configName;
                mag.name = magconfig.displayName;
                item.name = magconfig.displayName;
                item.MarkDirty();
                mag.SendNetworkUpdateImmediate();
            }
        }
        #endregion

        #region Class Definitions
        public class customMagazines
        {
            [JsonProperty(PropertyName = "Magazine Display Name")]
            public string displayName;
            [JsonProperty(PropertyName = "Ammo Multiplier 1.0 = default Gun")]
            public float totalAmmo;
            [JsonProperty(PropertyName = "Can Spawn In LootContainer types")]
            public List<string> LootContainers;
            [JsonProperty(PropertyName = "LootContainer Spawn Chance 1-100")]
            public float SpawnChance;

            public customMagazines(string displayName, float totalAmmo, float reloadTime, List<string> lootContainers)
            {
                this.displayName = displayName;
                this.totalAmmo = totalAmmo;
                this.LootContainers = lootContainers;
                this.SpawnChance = 20f;
            }
        }

        #endregion

        #region Configuration
        [JsonObject(MemberSerialization.OptIn)]
        class ConfigData
        {
            [JsonProperty(PropertyName = "Settings")]
            public Settings settings { get; set; } = new Settings();

            [JsonProperty(PropertyName = "Magazine settings")]
            public Dictionary<ulong, customMagazines> mags { get; set; } = new Dictionary<ulong, customMagazines>();

            public class Settings
            {
                [JsonProperty("Enable Loot Container Spawns")]
                public bool randomMagazine { get; set; }
            }

            [JsonProperty(PropertyName = "Version")]
            public VersionNumber Version { get; set; } = Instance.Version;

            public VersionNumber LastBreakingChange { get; private set; } = new VersionNumber(1, 1, 2);
        }
        #endregion

        #region Configuration Handling
        private ConfigData configData;

        protected override void LoadConfig()
        {
            Instance = this;

            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                    LoadDefaultConfig();
                UpdateConfigVersion();
            }
            catch
            {
                PrintError("Your configuration file is invalid");
                UpdateConfig();
                return;
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => configData = new ConfigData();

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfig()
        {
            PrintWarning("Invalid config file detected! Backing up current and creating new config...");
            var outdatedConfig = Config.ReadObject<object>();
            Config.WriteObject(outdatedConfig, filename: $"{Name}.Backup");
            LoadDefaultConfig();
            PrintWarning("Config update completed!");
        }

        void UpdateConfigVersion() => configData.Version = Version;
        #endregion

        #region Commands    
        [ConsoleCommand("magazine")]
        private void CmdConsoleMagazine(ConsoleSystem.Arg args)
        {
            if (args == null || args.Args.Length < 2) return;

            string userID = args.Args[0];
            string portal = args.Args[1];

            BasePlayer player = null;
            var ids = default(ulong);
            var skinId = default(ulong);
            int total = 1;

            if (ulong.TryParse(userID, out ids))
            {
                player = BasePlayer.FindByID(ids);
            }

            if (!ulong.TryParse(portal, out skinId))
            {
                SendReply(args, "Incorrect SkinID format");
                return;
            }

            if (args.Args.Length >= 3)
            {
                if (!int.TryParse(args.Args[2], out total))
                {
                    SendReply(args, "Amount not set correctly");
                    return;
                }
            }

            if (player != null)
            {
                string[] theItemConfig = args.Args.ToArray();
                GetTheMagazine(null, "", theItemConfig);
            }
            else
            {
                SendReply(args, "Player not found");
            }
        }

        [ChatCommand("magazine")]
        private void GetTheMagazine(BasePlayer player, string command, string[] args)
        {
            if (player == null)
            {
                var ids = default(ulong);
                if (ulong.TryParse(args[0], out ids))
                {
                    player = BasePlayer.FindByID(ids);
                    if (player == null)
                        return;
                    args = args.Skip(1).ToArray();
                }
                else
                    return;
            }

            else if (player.net?.connection != null && !permission.UserHasPermission(player.UserIDString, MagazineUse))
            {
                SendReply(player, string.Format(lang.GetMessage("NoPerm", this, player.UserIDString)));
                return;
            }

            if (args == null || args.Length <= 0)
            {
                messagePlayer(player);
                return;
            }

            if (args[0].ToLower() == "list")
            {
                messagePlayer(player);
                return;
            }

            var theItemConfig = default(ulong);
            if (!ulong.TryParse(args[0], out theItemConfig))
            {
                messagePlayer(player);
                return;
            }

            int total = 1;

            if (args.Length > 1)
            {
                if (!int.TryParse(args[1], out total))
                    total = 1;
            }

            if (!configData.mags.ContainsKey(theItemConfig))
            {
                messagePlayer(player);
            }

            else if (configData.mags.ContainsKey(theItemConfig))
            {
                GetMagazineItem(player, theItemConfig, total, true);
                return;
            }
            SendReply(player, lang.GetMessage("NoValidItem", this, player.UserIDString), theItemConfig);
        }

        private void messagePlayer(BasePlayer player)
        {
            string configitems = "<color=#ce422b>Magazine Item List Usage /magazine <SkinID></color>\n\n";
            foreach (var key in configData.mags)
            {
                configitems += $"<color=#FFFF00>Item Skin</color>: {key.Key} <color=#FFFF00>Item Name:</color> {key.Value.displayName}\n";
            }
            SendReply(player, configitems);
        }

        private void GetMagazineItem(BasePlayer player, ulong skinID, int total, bool message)
        {
            customMagazines magconfig = Instance.configData.mags[skinID];
            var MagazineItem = ItemManager.CreateByItemID(2005491391, total, skinID);
            if (MagazineItem == null) return;
            MagazineItem.name = magconfig.displayName;
            ProjectileWeaponMod held = MagazineItem.GetHeldEntity() as ProjectileWeaponMod;

            if (MagazineItem.MoveToContainer(player.inventory.containerBelt, -1, true))
            {
                if (message) SendReply(player, lang.GetMessage("gaveProtector", this), magconfig.displayName);
                return;
            }
            else if (MagazineItem.MoveToContainer(player.inventory.containerMain, -1, true))
            {
                if (message) SendReply(player, lang.GetMessage("gaveProtector", this), magconfig.displayName);
                return;
            }
            Vector3 velocity = new Vector3(-107.3504f, 12.1489f, -107.7641f);
            velocity = Vector3.zero;
            MagazineItem.Drop(player.transform.position + new Vector3(0.5f, 1f, 0), velocity);
            if (message) SendReply(player, lang.GetMessage("droped", this), magconfig.displayName);
        }

        #endregion

        #region Messages
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPerm"] = "<color=#ce422b>You lack the permishions to use this command!</color>",
                ["gaveProtector"] = "<color=#ce422b>You have just got a {0}!</color>",
                ["droped"] = "<color=#ce422b>You'r inventory was full so i dropped your {0} on the ground!</color>",
                ["blocked"] = "<color=#ce422b>You are building blocked!</color>",
                ["NoValidItem"] = "That is not a valid config item {0}!",
                ["NoPlayer"] = "Player not found!",
                ["ammountNot"] = "Amount not set correctly",
                ["SkinIDformat"] = "Incorrect skinID format"
            }, this);
        }
        #endregion
    }
}
    


// --- End of file: CustomizableMagazines.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/craft-multiplier ---
// --- Original File Path: C/CraftMultiplier/CraftMultiplier.cs ---

using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Craft Multiplier", "Arainrr", "1.4.1")]
    [Description("Multiplier in craft, can craft more items at once")]
    internal class CraftMultiplier : RustPlugin
    {
        #region Fields

        private const string PERMISSION_USE = "craftmultiplier.use";
        private bool initialized;
        private readonly Dictionary<ulong, int> enabledMultiplier = new Dictionary<ulong, int>();
        private readonly Dictionary<ulong, Timer> autoDisableTimer = new Dictionary<ulong, Timer>();

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            permission.RegisterPermission(PERMISSION_USE, this);
            cmd.AddChatCommand(configData.command, this, nameof(CmdCraftMultiplier));
        }

        private void Unload()
        {
            foreach (var value in autoDisableTimer.Values)
            {
                value?.Destroy();
            }
        }

        private void OnServerInitialized()
        {
            var hookSubscriptionsFieldInfo = typeof(PluginManager).GetField("hookSubscriptions", BindingFlags.Instance | BindingFlags.NonPublic);
            var hookSubscriptions = hookSubscriptionsFieldInfo?.GetValue(Interface.Oxide.RootPluginManager) as IDictionary<string, IList<Plugin>>;
            if (hookSubscriptions != null)
            {
                foreach (var entry in hookSubscriptions)
                {
                    if (entry.Key == nameof(OnItemCraft))
                    {
                        entry.Value.Remove(this);
                        entry.Value.Insert(0, this);
                    }
                }
                initialized = true;
            }
            else
            {
                PrintError("An error occurred. Please notify the plugin developer");
            }
        }

        private object OnItemCraft(ItemCraftTask itemCraftTask, BasePlayer player, Item item)
        {
            if (player == null) return null;
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE)) return null;
            int multiplier;
            if (enabledMultiplier.TryGetValue(player.userID, out multiplier) && multiplier > 1)
            {
                var itemCrafter = player.inventory.crafting;
                if (itemCrafter == null) return null;
                var blueprint = itemCraftTask.blueprint;
                if (blueprint == null || blueprint.targetItem == null) return null;
                var existing = configData.itemList.Contains(blueprint.targetItem.shortname);
                if (configData.useBlacklist ? existing : !existing)
                {
                    Print(player, Lang("IsBlocked", player.UserIDString));
                    return null;
                }

                var amount = itemCraftTask.amount * multiplier;
                if (CanAffordCraftMultiplier(itemCrafter, blueprint, amount - itemCraftTask.amount))
                {
                    CollectIngredients(itemCrafter, blueprint, itemCraftTask, amount - itemCraftTask.amount, player);
                    itemCraftTask.amount = amount;
                }
                else
                {
                    Print(player, Lang("CantAfford", player.UserIDString));
                    return null;
                }

                itemCrafter.queue.AddLast(itemCraftTask);
                if (itemCraftTask.owner != null)
                    itemCraftTask.owner.Command("note.craft_add", itemCraftTask.taskUID,
                        itemCraftTask.blueprint.targetItem.itemid, itemCraftTask.amount, itemCraftTask.skinID);
                return false;
            }

            return null;
        }

        #endregion Oxide Hooks

        #region Methods

        private static void CollectIngredients(ItemCrafter itemCrafter, ItemBlueprint bp, ItemCraftTask task,
            int amount, BasePlayer player)
        {
            var collect = new List<Item>();
            foreach (var ingredient in bp.ingredients)
            {
                CollectIngredient(itemCrafter, ingredient.itemid, (int)ingredient.amount * amount, collect);
            }

            foreach (var item in collect)
            {
                item.CollectedForCrafting(player);
            }

            task.takenItems.AddRange(collect);
        }

        private static void CollectIngredient(ItemCrafter itemCrafter, int item, int amount, List<Item> collect)
        {
            foreach (var container in itemCrafter.containers)
            {
                amount -= container.Take(collect, item, amount);
                if (amount <= 0) break;
            }
        }

        private static bool CanAffordCraftMultiplier(ItemCrafter itemCrafter, ItemBlueprint bp, int amount)
        {
            foreach (var ingredient in bp.ingredients)
            {
                if (!DoesHaveUsableItem(itemCrafter, ingredient.itemid, (int)ingredient.amount * amount))
                {
                    return false;
                }
            }
            return true;
        }

        private static bool DoesHaveUsableItem(ItemCrafter itemCrafter, int item, int iAmount)
        {
            var num = itemCrafter.containers.Sum(container => container.GetAmount(item, true));
            return num >= iAmount;
        }

        #endregion Methods

        #region Chat Command

        private void CmdCraftMultiplier(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
            {
                Print(player, Lang("NotAllowed", player.UserIDString));
                return;
            }

            if (!initialized)
            {
                Print(player, Lang("CantUse", player.UserIDString));
                return;
            }

            if (args.Length <= 0)
            {
                if (enabledMultiplier.Remove(player.userID))
                {
                    Timer value;
                    if (autoDisableTimer.TryGetValue(player.userID, out value))
                    {
                        value?.Destroy();
                    }
                    ;
                    Print(player, Lang("DisabledCraftMultiplier", player.UserIDString));
                    return;
                }

                Print(player, Lang("MultiplierNotEnable", player.UserIDString, configData.command));
                return;
            }

            int multiplier;
            if (!int.TryParse(args[0], out multiplier) || multiplier <= 0)
            {
                Print(player, Lang("NotIntValue", player.UserIDString));
                return;
            }

            if (configData.maxMultiplier > 0 && multiplier > configData.maxMultiplier)
            {
                Print(player, Lang("MultiplierLimit", player.UserIDString, configData.maxMultiplier));
                return;
            }
            StringBuilder sb = new StringBuilder();
            if (enabledMultiplier.ContainsKey(player.userID))
            {
                enabledMultiplier[player.userID] = multiplier;
                sb.Append(Lang("ChangedCraftMultiplier", player.UserIDString, multiplier));
            }
            else
            {
                enabledMultiplier.Add(player.userID, multiplier);
                sb.Append(Lang("EnabledCraftMultiplier", player.UserIDString, multiplier));
            }
            Timer value1;
            if (autoDisableTimer.TryGetValue(player.userID, out value1))
            {
                value1?.Destroy();
            }
            if (configData.timeBeforeDisable > 0)
            {
                var playerID = player.userID;
                autoDisableTimer[player.userID] = timer.Once(configData.timeBeforeDisable, () =>
                {
                    autoDisableTimer.Remove(playerID);
                    enabledMultiplier.Remove(playerID);
                });
                sb.Append(Lang("AutoDisable", player.UserIDString, configData.timeBeforeDisable));
            }
            Print(player, sb.ToString());
        }

        #endregion Chat Command

        #region ConfigurationFile

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Chat Command")]
            public string command = "cm";

            [JsonProperty(PropertyName = "Chat Prefix")]
            public string prefix = "<color=#00FFFF>[CraftMultiplier]</color>: ";

            [JsonProperty(PropertyName = "Chat SteamID Icon")]
            public ulong steamIDIcon = 0;

            [JsonProperty(PropertyName = "Maximum Multiplier")]
            public int maxMultiplier = 10;

            [JsonProperty(PropertyName = "Time Before The Multiplier Is Disabled")]
            public float timeBeforeDisable = 120;

            [JsonProperty(PropertyName = "Use Blacklist (If false, a whitelist will be used)")]
            public bool useBlacklist = true;

            [JsonProperty(PropertyName = "Item List (Item short name)")]
            public HashSet<string> itemList = new HashSet<string>();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                    LoadDefaultConfig();
            }
            catch
            {
                PrintError("The configuration file is corrupted");
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(configData);
        }

        #endregion ConfigurationFile

        #region LanguageFile

        private void Print(BasePlayer player, string message)
        {
            Player.Message(player, message, configData.prefix, configData.steamIDIcon);
        }

        private string Lang(string key, string id = null, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this, id), args);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "You don't have permission to use this command.",
                ["NotIntValue"] = "Please use an integer number greater than zero.",
                ["EnabledCraftMultiplier"] = "You have <color=#7FFF00>Enabled</color> craft multiplier, multiplier is <color=#1E90FF>{0}</color>. ",
                ["ChangedCraftMultiplier"] = "Craft multiplier has been changed to <color=#1E90FF>{0}</color>. ",
                ["DisabledCraftMultiplier"] = "You have <color=#FF8C00>Disabled</color> craft multiplier.",
                ["MultiplierNotEnable"] = "You have not enabled the craft multiplier, usage: '<color=#1E90FF>/{0} #</color>' -- # is the multiplier.",
                ["CantAfford"] = "You don't have enough resources to use craft multiplier.",
                ["IsBlocked"] = "This item is blocked by craft multiplier and cannot be multiplied.",
                ["CantUse"] = "Unable to use, please wait for server initialization.",
                ["MultiplierLimit"] = "The craft multiplier cannot be greater than {0}",
                ["AutoDisable"] = "The craft multiplier will disabled after {0} seconds"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "",
                ["NotIntValue"] = "0",
                ["EnabledCraftMultiplier"] = " <color=#7FFF00></color> ,  <color=#1E90FF>{0}</color>",
                ["ChangedCraftMultiplier"] = " <color=#1E90FF>{0}</color>",
                ["DisabledCraftMultiplier"] = " <color=#FF8C00></color> ",
                ["MultiplierNotEnable"] = ", : '<color=#1E90FF>/{0} #</color>' -- #",
                ["CantAfford"] = "",
                ["IsBlocked"] = "",
                ["CantUse"] = ", ",
                ["MultiplierLimit"] = " {0}",
                ["AutoDisable"] = " {0} "
            }, this, "zh-CN");
        }

        #endregion LanguageFile
    }
}

// --- End of file: CraftMultiplier.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/chat-command-prefix ---
// --- Original File Path: C/ChatCommandPrefix/ChatCommandPrefix.cs ---

using System.Collections.Generic;
using ConVar;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Chat Command Prefix", "Clearshot", "1.0.0")]
    [Description("Add prefix for all chat commands")]
    class ChatCommandPrefix : CovalencePlugin
    {
        private PluginConfig _config;

        private object OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            if (player != null && !string.IsNullOrEmpty(message) && _config.prefixes.Contains(message[0]))
            {
                Interface.CallHook("IOnPlayerCommand", player, "/" + message.Remove(0, 1));
                return false;
            }
            return null;
        }

        private Dictionary<string, object> OnBetterChat(Dictionary<string, object> data)
        {
            string message = (string)data?["Message"];
            if (!string.IsNullOrEmpty(message) && _config.prefixes.Contains(message[0]))
            {
                data["CancelOption"] = 1;
            }
            return data;
        }

        #region Config

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<PluginConfig>();
            Config.WriteObject(_config, true);
        }

        private class PluginConfig
        {
            public char[] prefixes = { '!' };
        }

        #endregion
    }
}


// --- End of file: ChatCommandPrefix.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/chat-translator ---
// --- Original File Path: C/ChatTranslator/ChatTranslator.cs ---

//#define DEBUG

// Requires: TranslationAPI

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using ProtoBuf;

namespace Oxide.Plugins
{
    [Info("Chat Translator", "Mr. Blue", "2.2.2")]
    [Description("Translates chat messages to each player's language preference or server default")]
    public class ChatTranslator : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        private class Configuration
        {
            [JsonProperty("Force default server language")]
            public bool ForceServerDefault = false;

            [JsonProperty("Log translated chat messages")]
            public bool LogChatMessages = false;

            [JsonProperty("Show original and translation")]
            public bool ShowBothMessages = false;

            [JsonProperty("Translate message for sender")]
            public bool TranslateForSender = false;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Chat Translation

        [PluginReference]
        private readonly Plugin TranslationAPI, BetterChat, BetterChatFilter, BetterChatMute, ChatFilter;

        private void Translate(string message, string targetId, string senderId, Action<string> callback)
        {
            // Get language code to translate to
            string langTo = "en";
            if (!message.Equals("Translation") && config.ForceServerDefault && CultureInfo.GetCultureInfo(lang.GetServerLanguage()) != null)
            {
                langTo = lang.GetServerLanguage();
            }
            else
            {
                langTo = lang.GetLanguage(targetId);
            }

            // Get language code to translate from
            string langFrom = lang.GetLanguage(senderId) ?? "auto";

#if DEBUG
            LogWarning($"To ({targetId}): {langTo}, From ({senderId}): {langFrom}");
#endif
            // Translate the message
            TranslationAPI.Call("Translate", message, langTo, langFrom, callback);
        }

        private void TranslateChat(IPlayer target, IPlayer sender, string message, int channel = 0)
        {
            if (sender.Equals(target) && !config.TranslateForSender)
            {
                ProcessMessage(sender, sender, message, message, channel);
                return;
            }

            Action<string> callback = translation =>
            {
                if (config.ShowBothMessages && !message.Equals(translation))
                {
                    Action<string> prefixCallback = prefixResponse =>
                    {
                        translation = $"{message}\n{prefixResponse}: {translation}";
                        ProcessMessage(target, sender, translation, message, channel);
                    };
                    Translate("Translation", sender.Id, sender.Id, prefixCallback);
                }
                else
                {
                    ProcessMessage(target, sender, translation, message, channel);
                }
            };
            Translate(message, target.Id, sender.Id, callback);
        }

        private void ProcessMessage(IPlayer target, IPlayer sender, string translation, string original, int channel = 0)
        {
            if (target == null || !target.IsConnected)
            {
                return;
            }

            if (Interface.Oxide.CallHook("OnTranslatedChat", sender, translation, original, channel) != null)
            {
                return;
            }

            // Rust colors: Admin/moderator = #aaff55, Developer = #ffaa55, Player = #55aaff
            string prefixColor = sender.IsAdmin ? "#aaff55" : "#55aaff";

            if (config.LogChatMessages)
            {
                LogToFile("log", translation, this);
#if RUST
                Log($"[{(ConVar.Chat.ChatChannel)channel}] {sender.Name}: {translation}");

                // Create RCON broadcast for Rust
                Facepunch.RCon.Broadcast(Facepunch.RCon.LogType.Chat, new ConVar.Chat.ChatEntry
                {
                    Channel = (ConVar.Chat.ChatChannel)channel,
                    Message = translation,
                    UserId = sender.Id,
                    Username = sender.Name,
                    Color = prefixColor,
                    Time = Facepunch.Math.Epoch.Current
                });
#else
                Log($"{sender.Name}: {translation}");
#endif
            }

            string formatted;
            if (BetterChat != null && BetterChat.IsLoaded)
            {
                formatted = covalence.FormatText(BetterChat.Call<string>("API_GetFormattedMessage", sender, translation));
            }
            else
            {
                formatted = $"{covalence.FormatText($"[{prefixColor}]{sender.Name}[/#]")}: {translation}";
            }

#if RUST
            switch (channel)
            {
                case 1: // Team chat
                    BasePlayer basePlayer = sender.Object as BasePlayer;
                    RelationshipManager.PlayerTeam team = basePlayer.Team;
                    if (team != null && team.members.Count != 0)
                    {
                        // Rust companion app support
                        uint current = (uint)Facepunch.Math.Epoch.Current;
                        ulong targetId = ulong.Parse(target.Id);
                        CompanionServer.Server.TeamChat.Record(team.teamID, targetId, target.Name, translation, prefixColor, current);
                        ProtoBuf.AppBroadcast appBroadcast = Facepunch.Pool.Get<ProtoBuf.AppBroadcast>();
                        appBroadcast.teamMessage = Facepunch.Pool.Get<ProtoBuf.AppNewTeamMessage>();
                        appBroadcast.teamMessage.message = Facepunch.Pool.Get<ProtoBuf.AppTeamMessage>();
                        appBroadcast.ShouldPool = false;
                        AppTeamMessage appChatMessage = appBroadcast.teamMessage.message;
                        appChatMessage.steamId = targetId;
                        appChatMessage.name = target.Name;
                        appChatMessage.message = translation;
                        appChatMessage.color = prefixColor;
                        appChatMessage.time = current;
                        CompanionServer.Server.Broadcast(new CompanionServer.PlayerTarget(targetId), appBroadcast);
                        appBroadcast.ShouldPool = true;
                        appBroadcast.Dispose();
                    }
                    break;
            }
#endif

#if RUST
            target.Command("chat.add", channel, sender.Id, formatted);
#else
            target.Message(formatted);
#endif
        }

        #endregion Chat Translation

        #region Chat Handling

        private object HandleChat(IPlayer sender, string message, int channel = 0, List<string> blockedReceivers = null)
        {
            if (sender == null || string.IsNullOrEmpty(message))
            {
                return null;
            }

            if (ChatFilter != null && ChatFilter.IsLoaded)
            {
                if (ChatFilter.Call<bool>("ContainsAdvertising"))
                {
                    return true; // TODO: Support filtering, not just blocking
                }
            }

            if (BetterChatMute != null && BetterChatMute.IsLoaded)
            {
                if (BetterChatMute.Call<bool>("API_IsMuted", sender))
                {
                    return true;
                }
            }

            if (BetterChatFilter != null && BetterChatFilter.IsLoaded)
            {
                Dictionary<string, object> filteredData = BetterChatFilter.Call<Dictionary<string, object>>("Filter", sender, message);
                if (filteredData != null && filteredData.Count > 0)
                {
                    message = filteredData["Message"].ToString();
                }
            }

            switch (channel)
            {
#if RUST
                case 1: // Team chat
                    BasePlayer basePlayer = sender.Object as BasePlayer;
                    RelationshipManager.PlayerTeam team = basePlayer.Team;
                    if (team != null && team.members.Count != 0)
                    {
                        foreach (ulong member in team.members)
                        {
                            BasePlayer targetBasePlayer = RelationshipManager.FindByID(member);
                            if (targetBasePlayer != null && targetBasePlayer.IsConnected)
                            {
                                if (blockedReceivers == null || !blockedReceivers.Contains(targetBasePlayer.IPlayer.Id))
                                {
                                    TranslateChat(targetBasePlayer.IPlayer, sender, message, channel);
                                }
                            }
                        }
                    }
                    break;
#endif
                default:
                    foreach (IPlayer target in players.Connected)
                    {
                        if (blockedReceivers == null || !blockedReceivers.Contains(target.Id))
                        {
                            TranslateChat(target, sender, message, channel);
                        }
                    }
                    break;
            }

            return true;
        }

        private object OnBetterChat(Dictionary<string, object> data)
        {
            HandleChat(data["Player"] as IPlayer, data["Message"] as string, (int)data["ChatChannel"], data["BlockedReceivers"] as List<string>);
            data["CancelOption"] = 2;
            return data;
        }

#if RUST
        private object OnPlayerChat(BasePlayer basePlayer, string message, ConVar.Chat.ChatChannel channel)
        {
            if (BetterChat == null || !BetterChat.IsLoaded)
            {
                return HandleChat(basePlayer.IPlayer, message, (int)channel);
            }

            return null;
        }
#else
        private object OnUserChat(IPlayer player, string message)
        {
            if (BetterChat == null || !BetterChat.IsLoaded)
            {
                return HandleChat(player, message);
            }

            return null;
        }
#endif

        #endregion Chat Handling
    }
}


// --- End of file: ChatTranslator.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/compost-stacks ---
// --- Original File Path: C/CompostStacks/CompostStacks.cs ---

using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Oxide.Plugins;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core;
using System.IO;
using System.ComponentModel;
using System.Runtime.InteropServices;
using System.Security;
using Newtonsoft.Json;
using System;

namespace Oxide.Plugins
{
    [Info("Compost Stacks", "Tacman", "2.1.1")]
    [Description("Toggle the CompostEntireStack boolean on load and for new Composter entities, which will compost entire stacks of all compostable items.")]
    public class CompostStacks : RustPlugin
    {
        private bool CompostEntireStack = true;
        private const string permissionName = "compoststacks.use"; // Permission name

        private Dictionary<ulong, bool> composterData = new Dictionary<ulong, bool>(); // Stores OwnerID and CompostEntireStack status
        private const string dataFileName = "CompostStacksData";

        private void OnServerInitialized()
        {
            permission.RegisterPermission(permissionName, this);
            UpdateComposters(); // Update all composters based on loaded data
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity is Composter composter)
            {
                ulong ownerID = composter.OwnerID;
                IPlayer ownerPlayer = covalence.Players.FindPlayerById(ownerID.ToString());

                if (ownerPlayer != null)
                {
                    bool hasPermission = HasPermission(ownerPlayer);
                    composter.CompostEntireStack = hasPermission ? CompostEntireStack : false;

                    // Store the status in the dictionary
                    composterData[ownerID] = composter.CompostEntireStack;
                }
                else
                {
                    if (config.debug)
                    {
                    Puts($"Owner player not found for OwnerID: {ownerID}");
                    }
                }
            }
        }

        private void UpdateComposters()
        {
            if (composterData != null && composterData.Count > 0)
            {
                // Update existing composters from the data file
                foreach (var entry in composterData)
                {
                    IPlayer ownerPlayer = covalence.Players.FindPlayerById(entry.Key.ToString());

                    if (ownerPlayer != null)
                    {
                        foreach (Composter composter in BaseNetworkable.serverEntities.Where(x => x is Composter && ((Composter)x).OwnerID == entry.Key))
                        {
                            composter.CompostEntireStack = entry.Value;
                        }
                    }
                }
            }
            else
            {
                // Fallback: Iterate through all composters if data is not loaded
                foreach (Composter composter in BaseNetworkable.serverEntities.Where(x => x is Composter))
                {
                    ulong ownerID = composter.OwnerID;
                    IPlayer ownerPlayer = covalence.Players.FindPlayerById(ownerID.ToString());

                    if (ownerPlayer != null)
                    {
                        bool hasPermission = HasPermission(ownerPlayer);
                        composter.CompostEntireStack = hasPermission ? CompostEntireStack : false;

                        // Store the status in the dictionary
                        composterData[ownerID] = composter.CompostEntireStack;
                    }
                }
            }
        }

        private void OnUserPermissionGranted(string id, string permission)
        {
            if (permission == permissionName)
            {
                Puts($"Permission {permissionName} granted to user {id}");
                UpdateComposters();
            }
        }

        private void OnUserPermissionRevoked(string id, string permission)
        {
            if (permission == permissionName)
            {
                Puts($"Permission {permissionName} revoked for user {id}");
                UpdateComposters();
            }
        }

        private void OnGroupPermissionGranted(string id, string permission)
        {
            if (permission == permissionName)
            {
                Puts($"Permission {permissionName} granted to group {id}");
                UpdateComposters();
            }
        }

        private void OnGroupPermissionRevoked(string id, string permission)
        {
            if (permission == permissionName)
            {
                Puts($"Permission {permissionName} revoked for group {id}");
                UpdateComposters();
            }
        }

        private bool HasPermission(IPlayer player)
        {
            return player.HasPermission(permissionName);
        }


        #region Config
        static Configuration config;
        public class Configuration
        {
            [JsonProperty(PropertyName = "Debug")]
            public bool debug;

            public static Configuration DefaultConfig()
            {
                return new Configuration
                {
                    debug = false
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
                SaveConfig();
            }
            catch (Exception ex)
            {
                Debug.LogException(ex);
                PrintWarning("Creating new configuration file.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => config = Configuration.DefaultConfig();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion
    }
}


// --- End of file: CompostStacks.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/cupboard-range ---
// --- Original File Path: C/CupboardRange/CupboardRange.cs ---

using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("CupboardRange", "DEUSNEXUS", "1.0.0")]
    class CupboardRange : RustPlugin
    {
        private Dictionary<ulong, DateTime> _cooldown = new Dictionary<ulong, DateTime>();

        void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Construction prohibited", "Construction prohibited"}
            }, this);
        }

        private object CanBuild(Planner plan, Construction prefab)
        {
            var player = plan.GetOwnerPlayer();

            var cupboard = player.GetBuildingPrivilege();
            if (cupboard != null && !cupboard.IsAuthed(player))
            {
                if (!_cooldown.ContainsKey(player.userID) || _cooldown[player.userID].AddSeconds(5) < DateTime.Now)
                    PrintToChat(player, Lang("Construction prohibited", player.UserIDString));

                _cooldown[player.userID] = DateTime.Now;
                return false;
            }

            return null;
        }

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

    }
}

// --- End of file: CupboardRange.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/car-setup ---
// --- Original File Path: C/CarSetup/CarSetup.cs ---

// #define DEBUG

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Car Setup", "misticos", "1.0.1")]
    [Description("Manage car options easily")]
    class CarSetup : CovalencePlugin
    {
        #region Variables

        private static CarSetup _ins = null;
        private Dictionary<NetworkableId, BaseController> _controllers = new Dictionary<NetworkableId, BaseController>();

        #endregion

        #region Configuration

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Sedan")]
            public SedanConfiguration BasicCar = new SedanConfiguration();

            [JsonProperty(PropertyName = "Modular Cars", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ModularCarConfiguration> ModularCars = new List<ModularCarConfiguration>
                { new ModularCarConfiguration() };

            public class ModularCarConfiguration : BaseConfiguration
            {
                [JsonProperty(PropertyName = "Selector")]
                public ModularCarSelector Selector = new ModularCarSelector();

                public class ModularCarSelector
                {
                    [JsonProperty(PropertyName = "Modules Available",
                        ObjectCreationHandling = ObjectCreationHandling.Replace)]
                    public HashSet<int> Modules = new HashSet<int> { 1, 2, 3, 4 };

                    public bool Fits(ModularCar car)
                    {
                        return Modules.Contains(car.TotalSockets);
                    }
                }
            }

            public class SedanConfiguration : BaseConfiguration
            {
                [JsonProperty(PropertyName = "Steering Angle")]
                public float Steering = 60f;
            }

            public class BaseConfiguration
            {
                [JsonProperty(PropertyName = "Mass Multiplier")]
                public float MassMultiplier = 1f;

                [JsonProperty(PropertyName = "Wheel Colliders")]
                public WheelColliderData WheelColliders = new WheelColliderData();

                [JsonProperty(PropertyName = "Movement")]
                public MovementData Movement = new MovementData();

                [JsonProperty(PropertyName = "Flipping")]
                public FlipData Flip = new FlipData();

                public class FlipData
                {
                    [JsonProperty(PropertyName = "Minimum Rotation")]
                    public float MinimumRotation = 5f;

                    [JsonProperty(PropertyName = "Torque Applied")]
                    public float Torque = 120f;
                }

                public class MovementData
                {
                    [JsonProperty(PropertyName = "Forward Force")]
                    public float ForceForward = 200f;

                    [JsonProperty(PropertyName = "Backward Force")]
                    public float ForceBackward = 150f;
                }

                public class WheelColliderData
                {
                    [JsonProperty(PropertyName = "Mass Multiplier")]
                    public float WheelMass = 1f;

                    [JsonProperty(PropertyName = "Damping Rate Multiplier")]
                    public float DampingRate = 1f;

                    [JsonProperty(PropertyName = "Motor Torque")]
                    public float TorqueMotor = 400f;

                    [JsonProperty(PropertyName = "Brake Torque")]
                    public float TorqueBrake = 10000f;

                    [JsonProperty(PropertyName = "Suspension")]
                    public SuspensionData Suspension = new SuspensionData();

                    public class SuspensionData
                    {
                        [JsonProperty(PropertyName = "Extension Distance Multiplier")]
                        public float ExtensionDistance = 1f;

                        [JsonProperty(PropertyName = "Damper Force Multiplier")]
                        public float DamperForce = 1f;

                        [JsonProperty(PropertyName = "Sprint Force Multiplier")]
                        public float SpringForce = 1f;
                    }

                    public void Apply(WheelCollider wheel)
                    {
                        wheel.mass *= WheelMass;
                        wheel.suspensionDistance *= Suspension.ExtensionDistance;
                        wheel.wheelDampingRate *= DampingRate;

                        var suspensionSpring = wheel.suspensionSpring;
                        suspensionSpring.damper *= Suspension.DamperForce;
                        suspensionSpring.spring *= Suspension.SpringForce;
                        wheel.suspensionSpring = suspensionSpring;
                    }

                    public void Undo(WheelCollider wheel)
                    {
                        wheel.mass /= WheelMass;
                        wheel.suspensionDistance /= Suspension.ExtensionDistance;
                        wheel.wheelDampingRate /= DampingRate;

                        var suspensionSpring = wheel.suspensionSpring;
                        suspensionSpring.damper /= Suspension.DamperForce;
                        suspensionSpring.spring /= Suspension.SpringForce;
                        wheel.suspensionSpring = suspensionSpring;
                    }
                }
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();

        #endregion

        #region Hooks

        private void Init()
        {
            _ins = this;
        }

        private void OnServerInitialized()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var basicCar = entity as BasicCar;
                if (!ReferenceEquals(basicCar, null))
                {
#if DEBUG
                    Puts($"BasicCar / {basicCar.net.ID} / {basicCar.transform.position}");
#endif
                    OnEntitySpawned(basicCar);
                }

                var car = entity as ModularCar;
                if (!ReferenceEquals(car, null))
                {
#if DEBUG
                    Puts($"BasicCar / {car.net.ID} / {car.transform.position}");
#endif
                    OnEntitySpawned(car);
                }
            }
        }

        private void OnEntitySpawned(BasicCar vehicle)
        {
            vehicle.gameObject.AddComponent<BasicCarController>();
        }

        private void OnEntitySpawned(ModularCar vehicle)
        {
            vehicle.gameObject.AddComponent<ModularCarController>();
        }

        private void Unload()
        {
            foreach (var vehicle in UnityEngine.Object.FindObjectsOfType<BasicCarController>())
                UnityEngine.Object.DestroyImmediate(vehicle);

            foreach (var vehicle in UnityEngine.Object.FindObjectsOfType<ModularCarController>())
                UnityEngine.Object.DestroyImmediate(vehicle);

            _ins = null;
        }

        private void OnEntityMounted(BaseMountable mountable, BasePlayer player)
        {
            var uid = mountable.parentEntity.uid;
            if (!uid.IsValid)
                return;

            BaseController controller;
            if (!_controllers.TryGetValue(uid, out controller))
                return;

            controller.Driver = player;
        }

        private void OnEntityDismounted(BaseMountable mountable, BasePlayer player)
        {
            var uid = mountable.parentEntity.uid;
            if (!uid.IsValid)
                return;

            BaseController controller;
            if (!_controllers.TryGetValue(uid, out controller))
                return;

            controller.Driver = null;
        }

        #endregion

        #region Controller

        [DefaultExecutionOrder(10000)] // Ensure we apply our changes after Facepunch do
        private abstract class BaseController : FacepunchBehaviour
        {
            protected WheelCollider[] Wheels;
            protected Rigidbody Rigidbody;

            public BasePlayer Driver;
        }

        private abstract class BaseController<TVehicle, TConfig> : BaseController where TVehicle : BaseVehicle
            where TConfig : Configuration.BaseConfiguration
        {
            protected TVehicle Car;
            protected TConfig Base;

            private NetworkableId _netId;

            protected virtual void Awake()
            {
                Car = GetComponent<TVehicle>();
                Rigidbody = Car.rigidBody;

                _ins._controllers[_netId = Car.net.ID] = this;
            }

            protected virtual void Start()
            {
                Rigidbody.mass *= Base.MassMultiplier;
                if (Wheels == null || Wheels.Length == 0)
                {
                    Debug.LogWarning(
                        $"There were no wheels found in {nameof(BaseController<TVehicle, TConfig>)}/{nameof(Start)}.");
                    return;
                }

                foreach (var wheel in Wheels)
                    Base.WheelColliders.Apply(wheel);
            }

            protected void OnDestroy()
            {
                _ins?._controllers?.Remove(_netId);

                if (Base == null)
                    return;

                Rigidbody.mass /= Base.MassMultiplier;
                if (Wheels == null || Wheels.Length == 0)
                    return;

                foreach (var wheel in Wheels)
                    Base.WheelColliders.Undo(wheel);
            }

            protected virtual void FixedUpdate()
            {
                ApplyFlip();

                ApplyWheelTorque();
                ApplyMovement();
            }

            protected void ApplyFlip()
            {
                foreach (var wheel in Wheels)
                {
                    if (Math.Abs(wheel.steerAngle) < Base.Flip.MinimumRotation || !wheel.isGrounded)
                        continue;

                    Rigidbody.AddRelativeTorque(
                        new Vector3(0f, 0f, Base.Flip.Torque * Math.Sign(wheel.steerAngle) * -1f), ForceMode.Force);
                }
            }

            protected virtual void ApplyWheelTorque()
            {
                foreach (var wheel in Wheels)
                {
                    ApplyWheelTorque(wheel);
                }
            }

            protected abstract void ApplyWheelTorque(WheelCollider wheel);

            protected void ApplyMovement()
            {
                // This is before wheels check because it is faster
                if (ReferenceEquals(Driver, null))
                    return;

                // Prevent it from pushing you in the sky
                foreach (var wheel in Wheels)
                {
                    if (wheel.isGrounded)
                        continue;

                    return;
                }

                if (Driver.serverInput.IsDown(BUTTON.FORWARD))
                {
                    Rigidbody.AddRelativeForce(Vector3.forward * Base.Movement.ForceForward, ForceMode.Impulse);
                }
                else if (Driver.serverInput.IsDown(BUTTON.BACKWARD))
                {
                    Rigidbody.AddRelativeForce(Vector3.back * Base.Movement.ForceBackward, ForceMode.Impulse);
                }
            }
        }

        private class ModularCarController : BaseController<ModularCar, Configuration.ModularCarConfiguration>
        {
            private VisualCarWheel[] _modularWheels;

            protected override void Awake()
            {
                base.Awake();
                foreach (var option in _ins._config.ModularCars)
                {
                    if (!option.Selector.Fits(Car))
                        continue;

                    Base = option;
                }

                if (Base == null)
                    DestroyImmediate(this);
            }

            protected override void Start()
            {
                _modularWheels = new[] { Car.wheelRR, Car.wheelFL, Car.wheelFR, Car.wheelRL };

                Wheels = new WheelCollider[_modularWheels.Length];

                for (var i = 0; i < Wheels.Length; i++)
                    Wheels[i] = _modularWheels[i].wheelCollider;

                base.Start();
            }

            protected override void ApplyWheelTorque(WheelCollider wheel)
            {
                if (Rigidbody.IsSleeping())
                    return;

                // If no driver and not being pushed, then no motor torque
                wheel.motorTorque = ReferenceEquals(Driver, null) && Car.timeSinceLastPush > 2f
                    ? 0f
                    : Base.WheelColliders.TorqueMotor;

                // If no driver, not being pushed and low velocity, then brake torque
                wheel.brakeTorque = ReferenceEquals(Driver, null) && Rigidbody.velocity.magnitude < 2.5f &&
                                    Car.timeSinceLastPush > 2f
                    ? Base.WheelColliders.TorqueBrake
                    : 0f;
            }
        }

        private class BasicCarController : BaseController<BasicCar, Configuration.SedanConfiguration>
        {
            protected override void Awake()
            {
                base.Awake();
                Base = _ins._config.BasicCar;
            }

            protected override void Start()
            {
                Wheels = new WheelCollider[Car.wheels.Length];

                for (var i = 0; i < Car.wheels.Length; i++)
                {
                    Wheels[i] = Car.wheels[i].wheelCollider;
                }

                base.Start();
            }

            protected override void FixedUpdate()
            {
                base.FixedUpdate();

                if (ReferenceEquals(Driver, null))
                    return;

                if (Driver.serverInput.IsDown(BUTTON.LEFT))
                {
                    Car.steering = Base.Steering;
                }

                if (Driver.serverInput.IsDown(BUTTON.RIGHT))
                {
                    Car.steering = -Base.Steering;
                }
            }

            protected override void ApplyWheelTorque(WheelCollider wheel)
            {
                if (ReferenceEquals(Driver, null))
                    return;

                wheel.motorTorque = Car.gasPedal * Base.WheelColliders.TorqueMotor;
                wheel.brakeTorque = Car.brakePedal * Base.WheelColliders.TorqueBrake;
            }
        }

        #endregion
    }
}

// --- End of file: CarSetup.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/custom-spawn-points ---
// --- Original File Path: C/CustomSpawnPoints/CustomSpawnPoints.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("CustomSpawnPoints", "Reneb / k1lly0u", "1.1.3")]
    [Description("Allows you to set a spawnfile created via SpawnsDatabase to override Rusts default spawn points")]
    class CustomSpawnPoints : RustPlugin
    {
        #region Fields
        [PluginReference] Plugin Spawns;

        private List<Vector3> spawnPoints = new List<Vector3>();

        private List<Vector3> remainingPoints = new List<Vector3>();

        private bool initialized;

        #endregion

        #region Oxide Hooks        
        private void OnServerInitialized()
        {
            LoadVariables();

            if (Spawns)
                LoadSpawnpoints();
        }

        private void OnPluginLoaded(Plugin plugin)
        {
            if (!initialized && plugin?.Title == "Spawns")            
                LoadSpawnpoints();            
        }

        private object OnPlayerRespawn(BasePlayer player)
        {
            if (!initialized)
                return null;

            object position = GetSpawnPoint();
            if (position is Vector3)            
                return new BasePlayer.SpawnPoint() { pos = (Vector3)position, rot = new Quaternion(0, 0, 0, 1) };
            return null;
        }
        #endregion

        #region Functions
        private void LoadSpawnpoints()
        {
            initialized = false;
            if (string.IsNullOrEmpty(configData.Spawnfile))
            {
                PrintError("No spawnfile set in the config. Unable to continue");
                return;
            }

            object success = Spawns?.Call("LoadSpawnFile", configData.Spawnfile);
            if (success is List<Vector3>)
            {
                spawnPoints = success as List<Vector3>;
                if (spawnPoints.Count == 0)
                {
                    PrintError("Loaded spawnfile contains no spawn points. Unable to continue");
                    return;
                }
                PrintWarning($"Successfully loaded {spawnPoints.Count} spawn points");
            }
            else
            {
                PrintError($"Unable to load the specified spawnfile: {configData.Spawnfile}");
                return;
            }
            remainingPoints = new List<Vector3>(spawnPoints);
            initialized = true;
        }

        private object GetSpawnPoint(int attempt = 0)
        {
            if (attempt >= 10)
                return null;

            Vector3 position = remainingPoints.GetRandom();

            List<BaseEntity> entities = Facepunch.Pool.Get<List<BaseEntity>>();
            Vis.Entities(position, configData.Detect, entities, LayerMask.GetMask("Construction", "Deployable"));
            int count = entities.Count;
            Facepunch.Pool.FreeUnmanaged(ref entities);

            remainingPoints.Remove(position);
            if (remainingPoints.Count == 0)            
                remainingPoints = new List<Vector3>(spawnPoints);            

            if (count > 0) 
                return GetSpawnPoint(++attempt);

            return position;
        }
        #endregion

        #region Commands
        [ConsoleCommand("spawns.config")]
        private void ccmdSpawnFile(ConsoleSystem.Arg arg)
        {
            if (arg == null)
                return;
          
            if (arg.Connection == null || (arg.Connection != null && arg.Connection.authLevel == 2))
            {
                if (arg.Args == null || arg.Args.Length == 0)
                {
                    SendReply(arg, "spawns.config \"spawnfile name\" - Set a new spawnfile");
                    return;
                }

                if (!Spawns)
                {
                    SendReply(arg, "Unable to find SpawnsDatabase. Unable to continue...");
                    return;
                }

                object success = Spawns.Call("GetSpawnsCount", new object[] { arg.Args[0] });
                if (success is string)
                {
                    SendReply(arg, $"Unable to load the specified spawnfile: {arg.Args[0]}");
                    return;
                }

                if (success is int)
                {
                    if ((int)success == 0)
                    {
                        PrintError("Loaded spawnfile contains no spawn points. Unable to continue");
                        return;
                    }
                    configData.Spawnfile = arg.Args[0];
                    SaveConfig(configData);
                    LoadSpawnpoints();
                }                
            }
            else SendReply(arg, "You do not have permission to use this command");           
        }
        #endregion

        #region Config        
        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Spawnfile name")]
            public string Spawnfile { get; set; }
            [JsonProperty(PropertyName = "Entity detection radius")]
            public float Detect { get; set; }            
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            ConfigData config = new ConfigData
            {
                Spawnfile = string.Empty,
                Detect = 10
            };
            SaveConfig(config);
        }

        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();

        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion       
    }
}


// --- End of file: CustomSpawnPoints.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/christmas ---
// --- Original File Path: C/Christmas/Christmas.cs ---

using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Christmas", "FastBurst", "2.0.6")]
    [Description("Christmas regardless of the month!")]

    public class Christmas : RustPlugin
    {
        private const string PLAYER_PERM = "christmas.use";
        private static Christmas Instance { get; set; }
        System.Random rand = new System.Random();

        #region Oxide
        private void OnServerInitialized()
        {
            lang.RegisterMessages(Messages, this);
            Instance = this;
            permission.RegisterPermission(PLAYER_PERM, this);
            if (!configData.Automation.enabled)
                return;

            ConVar.XMas.enabled = true;
            ConVar.XMas.spawnRange = configData.Automation.playerDistance;
            ConVar.XMas.giftsPerPlayer = configData.Automation.giftsPerPlayer;

            configData.Automation.RandomTimerMin = Mathf.Max(1, configData.Automation.RandomTimerMin);
            configData.Automation.RandomTimerMax = Mathf.Max(2, configData.Automation.RandomTimerMax);
            if (configData.Automation.EnableTimedEvents)
                StartTimedEvent();
        }

        private void Unload()
        {
            Puts("Disabling the Christmas event...");
            ConVar.XMas.enabled = false;
            Instance = null;
        }
        #endregion

        #region Functions
        private void StartTimedEvent()
        {
            timer.Repeat(rand.Next(configData.Automation.RandomTimerMin, configData.Automation.RandomTimerMax), 0, () =>
            {
                if (RefillPresents())
                    if (configData.Automation.messagesEnabled)
                        SendChatMessage("Christmas Message");
            });
        }

        public bool RefillPresents()
        {
            if (!configData.Automation.enabled)
            {
                PrintWarning("Plugin is disabled in config.");
                return false;
            }

            if (BasePlayer.activePlayerList.Count < configData.Automation.MinRequiredPlayers)
            {
                PrintWarning("Skipping Christmas : Not enough players.");
                return false;
            }

            ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), "xmas.refill");
            return true;
        }
        #endregion

        #region Commands
        [ChatCommand("gift")]
        private void GiftsCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.userID.ToString(), "christmas.use"))
                return;

            bool fail = false;

            if (player.IsAdmin && configData.ManualSettings.AdminBypass)
            {
                ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), "xmas.refill");
                if (configData.Automation.messagesEnabled)
                    SendChatMessage("Christmas Message");
                return;
            }

            // Check for CCTV Amount Required
            if (configData.ManualSettings.cctv > 0)
            {
                int cctv_amount = player.inventory.GetAmount(634478325);
                if (cctv_amount < configData.ManualSettings.cctv)
                {
                    Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.denied.prefab", player.transform.position);
                    SendReply(player, string.Format(msg("RequireCCTV"), configData.ManualSettings.cctv));
                }
            }
            // Check for Targeting Computer amount required
            if (configData.ManualSettings.computer > 0)
            {
                int computer_amount = player.inventory.GetAmount(1523195708);
                if (computer_amount < configData.ManualSettings.computer)
                {
                    Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.denied.prefab", player.transform.position);
                    SendReply(player, string.Format(msg("RequireLaptop"), configData.ManualSettings.computer));
                    fail = true;
                }
            }
            // Check for Santa Hat is required
            if (configData.ManualSettings.santahat)
            {
                int santahat_amount = player.inventory.GetAmount(-575483084);
                if (santahat_amount < 1)
                {
                    Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.denied.prefab", player.transform.position);
                    SendReply(player, msg("RequireSantaHat"));
                    fail = true;
                }
            }

            if (fail)
                return;
            else
            {
                if (RefillPresents())
                {
                    player.inventory.Take(null, 634478325, 1);
                    player.inventory.Take(null, 1523195708, 1);
                    player.inventory.Take(null, -575483084, 1);
                    if (configData.Automation.messagesEnabled)
                        SendChatMessage("Christmas Message");
                }
            }
        }

        [ConsoleCommand("gift")]
        private void GiftsConsole(ConsoleSystem.Arg arg)
        {
            ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), "xmas.refill");
            if (configData.Automation.messagesEnabled)
                SendChatMessage("Christmas Message");
        }
        #endregion

        #region Config
        private static ConfigData configData;
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Event Automation Settings")]
            public AutomationOptions Automation { get; set; }
            [JsonProperty(PropertyName = "Authorized Calling Settings")]
            public ManualOptions ManualSettings { get; set; }

            public class AutomationOptions
            {
                [JsonProperty(PropertyName = "Enable Christmas Gifts Event Plugin")]
                public bool enabled { get; set; }
                [JsonProperty(PropertyName = "Enable random autospawn Christmas Gifts Events on random timer")]
                public bool EnableTimedEvents { get; set; }
                [JsonProperty(PropertyName = "Minimum required players to start events")]
                public int MinRequiredPlayers { get; set; }
                [JsonProperty(PropertyName = "Minimum time in-between presents and stocking refills (seconds)")]
                public int RandomTimerMin { get; set; }
                [JsonProperty(PropertyName = "Maximum time in-between presents and stocking refills (seconds)")]
                public int RandomTimerMax { get; set; }
                [JsonProperty(PropertyName = "Distance a player in which to spawn")]
                public int playerDistance { get; set; }
                [JsonProperty(PropertyName = "Gifts per player")]
                public int giftsPerPlayer { get; set; }
                [JsonProperty(PropertyName = "Broadcast Message enabled to players when gifts sent (true/false)")]
                public bool messagesEnabled { get; set; }
            }

            public class ManualOptions
            {
                [JsonProperty(PropertyName = "Allow Admin to bypass required items to call gift command")]
                public bool AdminBypass { get; set; }
                [JsonProperty(PropertyName = "How many CCTV's needed")]
                public int cctv { get; set; }
                [JsonProperty(PropertyName = "How many Targeting Computer's needed")]
                public int computer { get; set; }
                [JsonProperty(PropertyName = "Require Santa Hat (true/false)")]
                public bool santahat { get; set; }
            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Automation = new ConfigData.AutomationOptions
                {
                    enabled = true,
                    EnableTimedEvents = true,
                    MinRequiredPlayers = 5,
                    RandomTimerMin = 5400,
                    RandomTimerMax = 7200,
                    playerDistance = 50,
                    giftsPerPlayer = 5,
                    messagesEnabled = true
                },
                ManualSettings = new ConfigData.ManualOptions
                {
                    AdminBypass = true,
                    cctv = 1,
                    computer = 1,
                    santahat = true
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new Core.VersionNumber(2, 0, 0))
                configData = baseConfig;

            if (configData.Version < new Core.VersionNumber(2, 0, 5))
            {
                configData.Automation.enabled = true;
                configData.Automation.EnableTimedEvents = true;
                configData.Automation.MinRequiredPlayers = 5;
                configData.Automation.RandomTimerMin = 5400;
                configData.Automation.RandomTimerMax = 7200;
                configData.ManualSettings.AdminBypass = true;
            }

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion

        #region Localization
        private static void SendChatMessage(string key, params object[] args)
        {
            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                BasePlayer player = BasePlayer.activePlayerList[i];
                player.ChatMessage(args != null ? string.Format(msg(key, player.UserIDString), args) : msg(key, player.UserIDString));
            }
        }

        private static string msg(string key, string playerId = null) => Instance.lang.GetMessage(key, Instance, playerId);

        private Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["Christmas Message"] = "This world has been blessed with Christmas Presents!",
            ["RequireCCTV"] = "<color=red>[WARNING]</color> You lack the required <color=orange>({0})</color> CCTV's",
            ["RequireLaptop"] = "<color=red>[WARNING]</color> You lack the required <color=orange>({0})</color> Targeting Computer's",
            ["RequireSantaHat"] = "<color=red>[WARNING]</color> You lack the required Santa Hat"
        };
        #endregion
    }
}

// --- End of file: Christmas.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/corpse-locker ---
// --- Original File Path: C/CorpseLocker/CorpseLocker.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Corpse Locker", "WhiteThunder", "1.0.2")]
    [Description("Adds UI buttons to player corpses to allow quick looting.")]
    internal class CorpseLocker : CovalencePlugin
    {
        #region Fields

        private const string PermissionUse = "corpselocker.use";

        private Configuration _config;
        private ContainerManager _containerManager;
        private List<Item> _tempItemList = new List<Item>();

        public CorpseLocker()
        {
            _containerManager = new ContainerManager(this);
        }

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(PermissionUse, this);
        }

        private void OnServerInitialized()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                var container = player.inventory.loot.containers.FirstOrDefault();
                if (container == null)
                    continue;

                var corpse = container.entityOwner as PlayerCorpse;
                if ((object)corpse == null)
                    continue;

                OnLootEntity(player, corpse);
            }
        }

        private void Unload()
        {
            _containerManager.Unload();
        }

        private void OnLootEntity(BasePlayer looter, PlayerCorpse corpse)
        {
            if (IsCorpseAllowed(corpse, looter) && HasPermission(looter, PermissionUse))
            {
                var corpse2 = corpse;
                var looter2 = looter;

                NextTick(() =>
                {
                    if (!AreValidCorpseContainers(corpse2, looter2.inventory.loot.containers))
                        return;

                    _containerManager.AddCorpseLooter(corpse2, looter2);
                });
            }
        }

        #endregion

        #region Commands

        [Command("corpselocker.take.main")]
        private void CommandTakeMain(IPlayer player)
        {
            HandleTransfer(player, InventoryType.Main);
        }

        [Command("corpselocker.take.clothing")]
        private void CommandTakeClothing(IPlayer player)
        {
            HandleTransfer(player, InventoryType.Wear);
        }

        [Command("corpselocker.take.belt")]
        private void CommandTakeBelt(IPlayer player)
        {
            HandleTransfer(player, InventoryType.Belt);
        }

        [Command("corpselocker.swap.clothing")]
        private void CommandSwapClothing(IPlayer player)
        {
            HandleTransfer(player, InventoryType.Wear, swap: true);
        }

        [Command("corpselocker.swap.belt")]
        private void CommandSwapBelt(IPlayer player)
        {
            HandleTransfer(player, InventoryType.Belt, swap: true);
        }

        #endregion

        #region UI

        [Flags]
        private enum InventoryType
        {
            Main = 1 << 0,
            Belt = 1 << 1,
            Wear = 1 << 2,
        }

        private class CuiElementRecreate : CuiElement
        {
            [JsonProperty("destroyUi", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string DestroyUi { get; set; }
        }

        private static class UI
        {
            private static Dictionary<string, Dictionary<InventoryType, string>> _uiCacheByLanguage =
                new Dictionary<string, Dictionary<InventoryType, string>>();

            public const string Name = "CorpseLocker";

            private const float PanelEndX = 572.5f;
            private const float ButtonSpacingX = 4;
            private const float RightButtonMinX = PanelEndX - ButtonWidth;
            private const float LeftButtonMinX = PanelEndX - 2 * ButtonWidth - ButtonSpacingX;
            private const float ButtonWidth = 70;
            private const float ButtonHeight = 21;

            public static void AddCorpseUI(CorpseLocker plugin, BasePlayer player, InventoryType inventoryTypes)
            {
                var lang = plugin.lang.GetLanguage(player.UserIDString);

                Dictionary<InventoryType, string> jsonByInventoryTypes;
                if (!_uiCacheByLanguage.TryGetValue(lang, out jsonByInventoryTypes))
                {
                    jsonByInventoryTypes = new Dictionary<InventoryType, string>();
                    _uiCacheByLanguage[lang] = jsonByInventoryTypes;
                }

                string cachedJson;
                if (!jsonByInventoryTypes.TryGetValue(inventoryTypes, out cachedJson))
                {
                    var cuiElements = CreatePanel();

                    if (inventoryTypes.HasFlag(InventoryType.Main))
                    {
                        AddButton(cuiElements,  plugin.GetMessage(player.UserIDString, LangEntry.TakeItems), "corpselocker.take.main", RightButtonMinX, 585.5f);
                    }

                    if (inventoryTypes.HasFlag(InventoryType.Wear))
                    {
                        AddButton(cuiElements, plugin.GetMessage(player.UserIDString, LangEntry.SwapItems), "corpselocker.swap.clothing", LeftButtonMinX, 308.5f);
                        AddButton(cuiElements, plugin.GetMessage(player.UserIDString, LangEntry.TakeItems), "corpselocker.take.clothing", RightButtonMinX, 308.5f);
                    }

                    if (inventoryTypes.HasFlag(InventoryType.Belt))
                    {
                        AddButton(cuiElements, plugin.GetMessage(player.UserIDString, LangEntry.SwapItems), "corpselocker.swap.belt", LeftButtonMinX, 175.5f);
                        AddButton(cuiElements, plugin.GetMessage(player.UserIDString, LangEntry.TakeItems), "corpselocker.take.belt", RightButtonMinX, 175.5f);
                    }

                    cachedJson = CuiHelper.ToJson(cuiElements);
                    jsonByInventoryTypes[inventoryTypes] = cachedJson;
                }

                CuiHelper.AddUi(player, cachedJson);
            }

            private static CuiElementContainer CreatePanel()
            {
                return new CuiElementContainer
                {
                    new CuiElementRecreate
                    {
                        Parent = "Hud.Menu",
                        Name = Name,
                        DestroyUi = Name,
                        Components =
                        {
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.5 0",
                                AnchorMax = "0.5 0",
                                OffsetMin = "0 0",
                                OffsetMax = "0 0",
                            }
                        }
                    }
                };
            }

            private static void AddButton(CuiElementContainer container, string text, string command, float offsetX, float offsetY)
            {
                container.Add(new CuiButton
                {
                    Text =
                    {
                        Text = text,
                        Align = TextAnchor.MiddleCenter,
                        Color = "0.659 0.918 0.2 1"
                    },
                    Button =
                    {
                        Command = command,
                        Color = "0.451 0.553 0.271 1"
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.5 0",
                        AnchorMax = "0.5 0",
                        OffsetMin = $"{offsetX} {offsetY}",
                        OffsetMax = $"{offsetX + ButtonWidth} {offsetY + ButtonHeight}",
                    }
                }, Name);
            }
        }

        #endregion

        #region Unity Component

        private class CorpseComponent : FacepunchBehaviour
        {
            public static CorpseComponent AddToCorpse(ContainerManager containerManager, PlayerCorpse corpse)
            {
                var component = corpse.gameObject.AddComponent<CorpseComponent>();
                component._containerManager = containerManager;
                component._corpse = corpse;
                component._activeInventoryTypes = component.DetermineActiveInventoryTypes();

                var handleDirtyDelayed = new Action(component.HandleDirtyDelayed);
                component._handleDirty = () => component.Invoke(handleDirtyDelayed, 0);

                foreach (var container in corpse.containers)
                {
                    container.onDirty += component._handleDirty;
                }

                return component;
            }

            private ContainerManager _containerManager;
            private PlayerCorpse _corpse;
            private List<BasePlayer> _looters = new List<BasePlayer>();
            private Action _handleDirty;
            private InventoryType _activeInventoryTypes;

            public void AddLooter(BasePlayer looter)
            {
                _looters.Add(looter);

                if (_activeInventoryTypes != 0)
                {
                    AddUI(looter);
                }
            }

            private void AddUI(BasePlayer looter)
            {
                UI.AddCorpseUI(_containerManager.Plugin, looter, _activeInventoryTypes);
            }

            private void DestroyUI(BasePlayer looter)
            {
                CuiHelper.DestroyUi(looter, UI.Name);
            }

            private InventoryType DetermineActiveInventoryTypes()
            {
                InventoryType inventoryTypes = 0;

                if (!GetCorpseContainer(_corpse, InventoryType.Main).IsEmpty())
                {
                    inventoryTypes |= InventoryType.Main;
                }

                if (!GetCorpseContainer(_corpse, InventoryType.Belt).IsEmpty())
                {
                    inventoryTypes |= InventoryType.Belt;
                }

                if (!GetCorpseContainer(_corpse, InventoryType.Wear).IsEmpty())
                {
                    inventoryTypes |= InventoryType.Wear;
                }

                return inventoryTypes;
            }

            public void AddUI()
            {
                foreach (var looter in _looters)
                {
                    AddUI(looter);
                }
            }

            public void DestroyUI()
            {
                foreach (var looter in _looters)
                {
                    DestroyUI(looter);
                }
            }

            private void HandleDirtyDelayed()
            {
                var inventoryTypes = DetermineActiveInventoryTypes();

                if (_activeInventoryTypes == inventoryTypes)
                    return;

                _activeInventoryTypes = inventoryTypes;

                if (inventoryTypes == 0)
                {
                    DestroyUI();
                }
                else
                {
                    AddUI();
                }
            }

            private void PlayerStoppedLooting(BasePlayer looter)
            {
                DestroyUI(looter);
                _looters.Remove(looter);
            }

            private void OnDestroy()
            {
                if (_activeInventoryTypes != 0)
                {
                    DestroyUI();
                }

                if (_corpse.containers != null)
                {
                    foreach (var container in _corpse.containers)
                    {
                        container.onDirty -= _handleDirty;
                    }
                }

                _containerManager.Unregister(_corpse);
            }
        }

        private class ContainerManager
        {
            public CorpseLocker Plugin { get; }

            private Dictionary<PlayerCorpse, CorpseComponent> _corpseComponents = new Dictionary<PlayerCorpse, CorpseComponent>();

            public ContainerManager(CorpseLocker plugin)
            {
                Plugin = plugin;
            }

            public void AddCorpseLooter(PlayerCorpse corpse, BasePlayer looter)
            {
                EnsureComponent(corpse)?.AddLooter(looter);
            }

            private CorpseComponent EnsureComponent(PlayerCorpse corpse)
            {
                CorpseComponent corpseComponent;
                if (!_corpseComponents.TryGetValue(corpse, out corpseComponent))
                {
                    corpseComponent = CorpseComponent.AddToCorpse(this, corpse);
                    _corpseComponents[corpse] = corpseComponent;
                }

                return corpseComponent;
            }

            public void Unregister(PlayerCorpse corpse)
            {
                _corpseComponents.Remove(corpse);
            }

            public void Unload()
            {
                foreach (var component in _corpseComponents.Values.ToArray())
                {
                    UnityEngine.Object.DestroyImmediate(component);
                }
            }
        }

        #endregion

        #region Helper Methods

        private static bool VerifyLootingEntity<T>(IPlayer player, out BasePlayer looter, out T entity) where T : BaseEntity
        {
            if (player.IsServer)
            {
                looter = null;
                entity = null;
                return false;
            }

            looter = player.Object as BasePlayer;
            var containers = looter.inventory.loot.containers;

            entity = containers.FirstOrDefault()?.entityOwner as T;
            return (object)entity != null && !entity.IsDestroyed;
        }

        private static ItemContainer GetCorpseContainer(PlayerCorpse corpse, InventoryType inventoryType)
        {
            switch (inventoryType)
            {
                case InventoryType.Main:
                    return corpse.containers[0];

                case InventoryType.Wear:
                    return corpse.containers[1];

                case InventoryType.Belt:
                    return corpse.containers[2];

                default:
                    return null;
            }
        }

        private static ItemContainer GetPlayerContainer(BasePlayer player, InventoryType inventoryType)
        {
            switch (inventoryType)
            {
                case InventoryType.Main:
                    return player.inventory.containerMain;

                case InventoryType.Belt:
                    return player.inventory.containerBelt;

                case InventoryType.Wear:
                    return player.inventory.containerWear;

                default:
                    return null;
            }
        }

        private static bool AreValidCorpseContainers(PlayerCorpse corpse, List<ItemContainer> containers)
        {
            if (containers.Count != 3 || corpse.containers.Length != 3)
                return false;

            // Verify container belongs to the corpse, in case the corpse is being used as a facade.
            for (var i = 0; i < containers.Count; i++)
            {
                if (containers[i] != corpse.containers[i])
                    return false;
            }

            return true;
        }

        private void TransferItems(BasePlayer looter, ItemContainer corpseContainer, ItemContainer playerContainer, bool swap = false)
        {
            if (swap)
            {
                _tempItemList.Clear();

                for (var i = 0; i < playerContainer.capacity; i++)
                {
                    var item = playerContainer.GetSlot(i);
                    if (item == null)
                        continue;

                    item.RemoveFromContainer();
                    item.position = i;
                    _tempItemList.Add(item);
                }
            }

            for (var i = 0; i < corpseContainer.capacity; i++)
            {
                corpseContainer.GetSlot(i)?.MoveToContainer(playerContainer, swap ? i : -1);
            }

            if (swap)
            {
                foreach (var item in _tempItemList)
                {
                    if (!item.MoveToContainer(corpseContainer, item.position) && !item.MoveToContainer(corpseContainer))
                    {
                        looter.GiveItem(item);
                    }
                }

                _tempItemList.Clear();
            }
        }

        private bool IsCorpseAllowed(PlayerCorpse corpse, BasePlayer looter)
        {
            if (corpse.containers?.Length != 3)
                return false;

            if (!corpse.playerSteamID.IsSteamId())
                return false;

            if (_config.RequireCorpseOwnership && corpse.playerSteamID != looter.userID)
                return false;

            if (!HasPermission(looter, PermissionUse))
                return false;

            return true;
        }

        private void HandleTransfer(IPlayer player, InventoryType inventoryType, bool swap = false)
        {
            BasePlayer looter;
            PlayerCorpse corpse;
            if (!VerifyLootingEntity(player, out looter, out corpse))
                return;

            if (!IsCorpseAllowed(corpse, looter))
                return;

            if (!AreValidCorpseContainers(corpse, looter.inventory.loot.containers))
                return;

            var corpseContainer = GetCorpseContainer(corpse, inventoryType);
            var playerContainer = inventoryType == InventoryType.Main || !swap
                ? GetPlayerContainer(looter, InventoryType.Main)
                : GetPlayerContainer(looter, inventoryType);

            TransferItems(looter, corpseContainer, playerContainer, swap);
        }

        private bool HasPermission(BasePlayer player, string perm)
        {
            return permission.UserHasPermission(player.UserIDString, perm);
        }

        #endregion

        #region Configuration

        [JsonObject(MemberSerialization.OptIn)]
        private class Configuration : BaseConfiguration
        {
            [JsonProperty("Require corpse ownership")]
            public bool RequireCorpseOwnership = true;
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #region Configuration Helpers

        [JsonObject(MemberSerialization.OptIn)]
        private class BaseConfiguration
        {
            private string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigSection(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigSection(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigSection(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    PrintWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                PrintError(e.Message);
                PrintWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Puts($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion

        #region Localization

        private class LangEntry
        {
            public static List<LangEntry> AllLangEntries = new List<LangEntry>();

            public static readonly LangEntry TakeItems = new LangEntry("UI.Take", "Take");
            public static readonly LangEntry SwapItems = new LangEntry("UI.Swap", "Swap");

            public string Name;
            public string English;

            public LangEntry(string name, string english)
            {
                Name = name;
                English = english;

                AllLangEntries.Add(this);
            }
        }

        private string GetMessage(string playerId, LangEntry langEntry) =>
            lang.GetMessage(langEntry.Name, this, playerId);

        protected override void LoadDefaultMessages()
        {
            var englishLangKeys = new Dictionary<string, string>();

            foreach (var langEntry in LangEntry.AllLangEntries)
            {
                englishLangKeys[langEntry.Name] = langEntry.English;
            }

            lang.RegisterMessages(englishLangKeys, this, "en");
        }

        #endregion
    }
}


// --- End of file: CorpseLocker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/connection-db ---
// --- Original File Path: C/ConnectionDB/ConnectionDB.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Random = System.Random;
// ReSharper disable UnusedMember.Local

namespace Oxide.Plugins
{
    [Info("Connection DB", "Iv Misticos", "1.0.4")]
    [Description("Connection database for developers.")]
    public class ConnectionDB : RustPlugin
    {
        #region Variables
        
        private Dictionary<ulong, PlayerData> _data = new Dictionary<ulong, PlayerData>();
        private Dictionary<string, string> _pluginData = new Dictionary<string, string>();

        private Random _rnd = new Random();
        private Time _time = GetLibrary<Time>();
        
        #endregion
        
        #region Configuration

        private Configuration _config;
        
        private class Configuration
        {
            [JsonProperty(PropertyName = "Debug")]
            public bool Debug = false;

            [JsonProperty(PropertyName = "Time Between Self-Deletion and Last Connection (sec)")]
            public uint TimeToDelete = 259200;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
            }
            catch
            {
                Config.WriteObject(_config, false, $"{Interface.Oxide.ConfigDirectory}/{Name}.jsonError");
                PrintError("The configuration file contains an error and has been replaced with a default config.\n" +
                           "The error configuration file was saved in the .jsonError extension");
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion
        
        #region Work with Data

        private void SaveData()
        {
            foreach (var kvp in _pluginData)
            {
                Interface.Oxide.DataFileSystem.WriteObject($"ConnectionDB/{kvp.Key}", kvp.Value);
            }
            
            Interface.Oxide.DataFileSystem.WriteObject(Name, _data);
        }

        private void LoadData()
        {
            try
            {
                _data = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, PlayerData>>(Name);
            }
            catch (Exception e)
            {
                PrintError($"Error: {e.Message}\n" +
                          $"Description: {e.StackTrace}");
            }

            if (_data == null) _data = new Dictionary<ulong, PlayerData>();
        }

        private bool LoadCustomData(string key)
        {
            try
            {
                var data = Interface.GetMod().DataFileSystem.ReadObject<string>($"ConnectionDB/{key}");
                if (data == null)
                    return false;

                _pluginData[key] = data;
            }
            catch (Exception)
            {
                return false;
            }

            return true;
        }

        private class PlayerData
        {
            public List<string> Names;
            // ReSharper disable once InconsistentNaming
            public List<string> IPs;
            public List<uint> TimeStamps;
            public uint SecondsPlayed;
        }

        #endregion
        
        #region Hooks

        private void OnServerInitialized()
        {
            LoadData();
            Puts($"Loaded users: {ConnectionsCount()}.");

            var players = BasePlayer.activePlayerList;
            var playersCount = players.Count;
            for (var i = 0; i < playersCount; i++)
                OnPlayerConnected(players[i]);
            
            var users = _data.ToArray();
            var usersCount = users.Length;
            var timeStamp = _time.GetUnixTimestamp();
            var deleted = 0;

            for (var i = 0; i < usersCount; i++)
            {
                var kvp = users[i];
                if (kvp.Value.TimeStamps[kvp.Value.TimeStamps.Count - 1] + _config.TimeToDelete >
                    timeStamp) continue;

                _data.Remove(kvp.Key);
                deleted++;
            }

            PrintDebug($"Deleted old users: {deleted}.");
            SaveData();

            cmd.AddConsoleCommand("connectiondb.wipe", this, CommandConsoleWipe);
            cmd.AddConsoleCommand("connectiondb.debuginfo", this, CommandConsoleDebugInfo);
        }

        private void OnServerSave() => SaveData();
        
        private void Unload() => SaveData();

        private void OnPlayerConnected(BasePlayer player) => InitPlayer(player);
        
        // ReSharper disable once UnusedParameter.Local
        private void OnPlayerDisconnected(BasePlayer player, string reason) => InitPlayer(player, true);

        #endregion
        
        #region Commands

        private bool CommandConsoleDebugInfo(ConsoleSystem.Arg arg)
        {
            if (!arg.IsRcon && !arg.IsConnectionAdmin)
                return false;

            arg.ReplyWith($"Plugin: {Name}\n" +
                          $"Version: {Version}\n" +
                          $"Debug enabled: {_config.Debug}\n" +
                          $"Server IP: {ConVar.Server.ip}\n" +
                          $"Average FPS: {Performance.current.frameRateAverage}\n" +
                          $"Data entries: {ConnectionsCount()}");
            return true;
        }

        private bool CommandConsoleWipe(ConsoleSystem.Arg arg)
        {
            if (!arg.IsRcon && !arg.IsConnectionAdmin)
                return false;

            _data.Clear();
            SaveData();
            
            arg.ReplyWith("Wipe was completed");
            return true;
        }
        
        #endregion
        
        #region Helpers

        private void InitPlayer(BasePlayer player, bool isDisconnect = false)
        {
            var id = player.userID;
            var name = player.displayName;
            var ip = player.net.connection.ipaddress;
            var time = _time.GetUnixTimestamp();
            ip = ip.Substring(0, ip.LastIndexOf(':'));

            PlayerData p;
            if (!_data.TryGetValue(id, out p))
            {
                var info = new PlayerData
                {
                    Names = new List<string> {name},
                    IPs = new List<string> {ip},
                    TimeStamps = new List<uint> {time},
                    SecondsPlayed = 1
                };

                PrintDebug($"Added new user {name} ({id})");
                _data.Add(id, info);
                SaveData();
                return;
            }

            if (!p.Names.Contains(name))
                p.Names.Add(name);
            if (!p.IPs.Contains(ip))
                p.Names.Add(ip);

            if (isDisconnect)
                p.SecondsPlayed += time - p.TimeStamps.Last();
            p.TimeStamps.Add(time);
                

            PrintDebug($"Updated user {name} ({id})");
        }

        private void PrintDebug(string s)
        {
            if (_config.Debug)
                Puts(s);
        }
        
        private bool ConnectionDataExists(ulong steamid) => _data.ContainsKey(steamid);

        private int ConnectionsCount() => _data.Count;

        private string GetStringFromData(object data) => JsonConvert.SerializeObject(data);

        private string GetPluginData(string key)
        {
            PrintDebug($"Getting data from key '{key}'..");
            if (!_pluginData.ContainsKey(key) && !LoadCustomData(key))
                return string.Empty;
            
            return _pluginData[key];
        }
        
        #endregion
        
        #region API
        
        // General API

        private List<string> API_GetNames(ulong id) => ConnectionDataExists(id) ? _data[id].Names : null;

        private string API_GetFirstName(ulong id) => ConnectionDataExists(id) ? _data[id].Names[0] : null;

        private string API_GetLastName(ulong id) => ConnectionDataExists(id) ? _data[id].Names.Last() : null;

        private List<string> API_GetIPs(ulong id) => ConnectionDataExists(id) ? _data[id].IPs : null;

        private string API_GetFirstIP(ulong id) => ConnectionDataExists(id) ? _data[id].IPs[0] : null;

        private string API_GetLastIP(ulong id) => ConnectionDataExists(id) ? _data[id].IPs.Last() : null;

        private List<uint> API_GetTimeStamps(ulong id) => ConnectionDataExists(id) ? _data[id].TimeStamps : null;

        private uint API_GetFirstTimeStamp(ulong id) => ConnectionDataExists(id) ? _data[id].TimeStamps[0] : 0;

        private uint API_GetLastTimeStamp(ulong id) => ConnectionDataExists(id) ? _data[id].TimeStamps.Last() : 0;

        private uint API_GetSecondsPlayed(ulong id) => ConnectionDataExists(id) ? _data[id].SecondsPlayed : 0;
        
        // Custom API

        private void API_SetValue(string key, object value) => _pluginData[key] = GetStringFromData(value);

        private object API_GetValue(string key) => JsonConvert.DeserializeObject(GetPluginData(key), new JsonSerializerSettings
        {
            ObjectCreationHandling = ObjectCreationHandling.Replace
        });
        
        private string API_GetValueRaw(string key) => GetPluginData(key);

        #endregion
    }
}

// --- End of file: ConnectionDB.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/cactus-damage ---
// --- Original File Path: C/CactusDamage/CactusDamage.cs ---

using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Cactus Damage", "birthdates", "1.1.0")]
    [Description("Cacti deal damage to players harvesting/colliding with them.")]
    public class CactusDamage : RustPlugin
    {
        #region Hooks
        void Init() => LoadConfig();

        void OnDispenserGather(ResourceDispenser dispenser, BasePlayer entity)
        {
            if (!dispenser.name.Contains("cactus")) return;
            Hurt(entity, _config.harvestingDamage, dispenser.GetComponent<BaseEntity>() ?? entity);
        }

        void OnEntityTakeDamage(BasePlayer entity, HitInfo info)
        {
            if(info.Initiator?.ShortPrefabName.Contains("cactus") == false || info.damageTypes.Get(Rust.DamageType.Slash) > 0 || info.damageTypes.Get(Rust.DamageType.Bleeding) > 0) return;
            Hurt(entity, _config.collisionDamage, info.Initiator ?? entity);
        }

        void Hurt(BasePlayer Player, Damage Damage, BaseEntity Initiator)
        {
            var Amount = Core.Random.Range(Damage.MinDamage, Damage.MaxDamage);
            Player.Hurt(Amount, Rust.DamageType.Slash, Initiator);
            Player.metabolism.bleeding.value += Amount / 2;
        }
        #endregion

        #region Configuration
        public ConfigFile _config;

        public class Damage
        {
            [JsonProperty("Min Damage")]
            public float MinDamage;
            [JsonProperty("Max Damage")]
            public float MaxDamage;
        }

        public class ConfigFile
        {
            [JsonProperty("Harvesting Damage")]
            public Damage harvestingDamage;

            [JsonProperty("Collision Damage")]
            public Damage collisionDamage;
            public static ConfigFile DefaultConfig() => new ConfigFile()
            {
                harvestingDamage = new Damage
                {
                    MinDamage = 2f,
                    MaxDamage = 5f
                },
                collisionDamage = new Damage
                {
                    MinDamage = 2f,
                    MaxDamage = 5f
                }
            };
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if(_config == null)
            {
                LoadDefaultConfig();
            }
        }
    
        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }

        protected override void SaveConfig() => Config.WriteObject(_config);
        #endregion
    }
}
//Generated with birthdates' Plugin Maker


// --- End of file: CactusDamage.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/compass-gui ---
// --- Original File Path: C/CompassGUI/CompassGUI.cs ---

using UnityEngine;
using Rust;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using System.Reflection;
using System;
using System.Linq;
using System.Data;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Compass GUI", "PaiN", "1.2.1", ResourceId = 1231)]
    [Description("This plugin shows which direction is the player facing in a GUI.")]
    public class CompassGUI : RustPlugin
    {
        List<BasePlayer> gui = new List<BasePlayer>();

        private Timer _timer;
        private bool Changed;
        private bool displaycoords;
        private string xmin;
        private string xmax;
        private string ymin;
        private string ymax;
        private bool enableonconnect;

        void Loaded()
        {
            _timer = timer.Every(1, Test);
            foreach(BasePlayer current in BasePlayer.activePlayerList)
            {
                gui.Add(current);
            }
            LoadVariables();
        }

        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        void LoadVariables()
        {
            xmin = Convert.ToString(GetConfig("GUI", "X min", "0.45"));
            xmax = Convert.ToString(GetConfig("GUI", "X max", "0.56"));
            ymin = Convert.ToString(GetConfig("GUI", "Y min", "0.91"));
            ymax = Convert.ToString(GetConfig("GUI", "Y max", "0.99"));
            enableonconnect = Convert.ToBoolean(GetConfig("Settings", "EnableOnConnect", true));
            displaycoords = Convert.ToBoolean(GetConfig("Settings", "DisplayCoordinates", true));

            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Creating a new configuration file!");
            Config.Clear();
            LoadVariables();
        }

        static string Title = "<color=yellow>Compass</color>";
        #region JSON
        string json = @"[
                       {
                            ""name"": ""EyesPosition"",
                            ""parent"": ""Overlay"",
                            ""components"":
                            [
                                {
                                     ""type"":""UnityEngine.UI.Image"",
                                     ""color"":""0.1 0.1 0.1 0.7"",
                                },
                                {
                                    ""type"":""RectTransform"",
                                    ""anchormin"": ""{xmin} {ymin}"",
                                    ""anchormax"": ""{xmax} {ymax}""
                                }
                            ]
                        },
                        {
                            ""parent"": ""EyesPosition"",
                            ""components"":
                            [
                                {
                                    ""type"":""UnityEngine.UI.Text"",
                                    ""text"":"""+Title+@""",
                                    ""fontSize"":20,
                                    ""align"": ""MiddleCenter"",
                                },
                                {
                                    ""type"":""RectTransform"",
                                    ""anchormin"": ""0 0.40"",
                                    ""anchormax"": ""1 1""
                                }
                            ]
                        },
                        {
                            ""parent"": ""EyesPosition"",
                            ""components"":
                            [
                                {
                                    ""type"":""UnityEngine.UI.Text"",
                                    ""text"":""{eyeposition}"",
                                    ""fontSize"":15,
                                    ""align"": ""MiddleCenter"",
                                },
                                {
                                    ""type"":""RectTransform"",
                                    ""anchormin"": ""0 0.20"",
                                    ""anchormax"": ""1 0.65""
                                }
                            ]
                        },
                        {
                            ""parent"": ""EyesPosition"",
                            ""components"":
                            [
                                {
                                    ""type"":""UnityEngine.UI.Text"",
                                    ""text"":""X: {positionx},  Z: {positionz}"",
                                    ""fontSize"":15,
                                    ""align"": ""MiddleCenter"",
                                },
                                {
                                    ""type"":""RectTransform"",
                                    ""anchormin"": ""0 0.0000001"",
                                    ""anchormax"": ""1 0.4""
                                }
                            ]
                        }
                    ]
                    ";
        #endregion

        // Credits to Mughisi for the Compass plugin
        string GetEyesPosition(BasePlayer player)
        {
            double lookRotation = player.eyes.rotation.eulerAngles.y;

            if (lookRotation > 337.5 || lookRotation < 22.5)
              return "<color=cyan>North</color>";
            else if (lookRotation > 22.5 && lookRotation < 67.5)
                return "<color=cyan>North-East</color>";
            else if (lookRotation > 67.5 && lookRotation < 112.5)
                return "<color=cyan>East</color>";
            else if (lookRotation > 112.5 && lookRotation < 157.5)
                return "<color=cyan>South-East</color>";
            else if (lookRotation > 157.5 && lookRotation < 202.5)
                return "<color=cyan>South</color>";
            else if (lookRotation > 202.5 && lookRotation < 247.5)
                return "<color=cyan>South-West</color>";
            else if (lookRotation > 247.5 && lookRotation < 292.5)
                return "<color=cyan>West</color>";
            else if (lookRotation > 292.5 && lookRotation < 337.5)
                return "<color=cyan>North-West</color>";
            return "None";
        }

        void Test()
        {
            foreach(BasePlayer player in BasePlayer.activePlayerList)
            {
                if (gui.Contains(player))
                {
                    //Debug PrintToChat("Contains " + player.displayName);
                    int posx = Convert.ToInt32(player.transform.position.x);
                    int posy = Convert.ToInt32(player.transform.position.y);
                    int posz = Convert.ToInt32(player.transform.position.z);
                    if (displaycoords == false)
                    {
                        CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "DestroyUI", "EyesPosition");
                        CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "AddUI", json.Replace("{eyeposition}", GetEyesPosition(player)).Replace("{xmin}", xmin).Replace("{xmax}", xmax).Replace("{ymin}", ymin).Replace("{ymax}", ymax));
                    }
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "DestroyUI", "EyesPosition");
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "AddUI", json.Replace("{eyeposition}", GetEyesPosition(player)).Replace("{positionx}", posx.ToString()).Replace("{positionz}", posz.ToString()).Replace("{xmin}", xmin).Replace("{xmax}", xmax).Replace("{ymin}", ymin).Replace("{ymax}", ymax));
                }
            }
        }

        /*NextUpdate[ChatCommand("compassbuy")]
        void cmdBuyCompass(BasePlayer player, string cmd, string[] args)
        {
            if (!plugins.Exists("00-Economics"))
            {
                Puts("Economics plugin is not installed! If you dont wanna use the buy system then do not download it! Get it at http://oxidemod.org/plugins/717/ . ");
                SendReply(player, "<color=orange>CompassGUI</color>" + "You can't buy a compass since the server owner has disabled this feature!");
                return;
            }

            string checkconfig = Config["Compass", "EnableEconomics"].ToString();
            if (checkconfig == "true")
            {
                string steamId = player.userID.ToString();
                if (storedData.Players.Any(p => p.UserId == steamId))
                {
                    SendReply(player, "<color=orange>CompassGUI</color>" + " You already have a compass.");
                    return;
                }
                 var playerMoney = API.GetUserDataFromPlayer(player);
                 int price = Convert.ToInt32(Config["Compass", "Price"]);

                 if (playerMoney[1] >= price)
                 {
                    var info = new PlayerInfo(player);
                    storedData.Players.Add(info);
                    playerMoney.Withdraw(price);
                    SendReply(player, "<color=orange>CompassGUI</color>" + " You have successfully bought a compass for(" + price + "). Use /compass to enable and disable your compass.");

                }
            }
        }*/

        [ChatCommand("showpos")]
        void cmdCopyPos(BasePlayer player, string cmd, string[] args)
        {
            SendReply(player, "<color=orange>CompassGUI</color>" + " To copy your position open the console \"<color=blue>F1</color>\" ");
            player.SendConsoleCommand("echo <color=aqua>CompassGUI</color>");
            player.SendConsoleCommand("echo <color=yellow>Your position is</color>: X: " + player.transform.position.x + " Y: " + player.transform.position.y + " Z: " + player.transform.position.z);
        }

        [ChatCommand("compass")]
        void cmdCompass(BasePlayer player, string cmd, string[] args)
        {
            if (gui.Contains(player))
            {
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "DestroyUI", "EyesPosition");
                SendReply(player, "<color=orange>CompassGUI</color>" + " You have disabled your compass!");
                gui.Remove(player);
            }
            else
            {
                gui.Add(player);
                SendReply(player, "<color=orange>CompassGUI</color>" + " You have enabled your compass!");
            }
        }

        void OnPlayerInit(BasePlayer player)
        {
            if (enableonconnect == true)
            {
                gui.Add(player);
            }
        }

        void Unload()
        {
            foreach(BasePlayer current in BasePlayer.activePlayerList)
            {
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = current.net.connection }, null, "DestroyUI", "EyesPosition");
            }
            gui.Clear();
            _timer.Destroy();
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            gui.Remove(player);
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "DestroyUI", "EyesPosition");
        }
    }
}

// --- End of file: CompassGUI.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/custom-item-drops ---
// --- Original File Path: C/CustomItemDrops/CustomItemDrops.cs ---

using System.Data;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
	[Info("Custom Item Drops", "MACHIN3", "1.1.200")]
	[Description("Drops items from custom lists for gathering, mining, looting, and more.")]
	public class CustomItemDrops : RustPlugin
	{
        #region Update Log

        /*****************************************************
		  
        Website: https://www.rustlevels.com/
        Discord: http://discord.rustlevels.com/
        *****************************************************/
        #region 1.1.200
        /*
		--------------
		Version 1.1.200
		--------------
		 Added option to disable drop chance when using power tools
		 Fix for Rust update

		*/
        #endregion
        #region 1.1.1
        /*
		--------------
		Version 1.1.1
		--------------
		 Fix for Rust May Update

		*/
        #endregion
        #region 1.1.0
        /*
		--------------
		Version 1.1.0
		--------------
		 Fix for OnEntityDeath error

		*/
        #endregion
        #region 1.0.9
        /*
		--------------
		Version 1.0.9
		--------------
		 Added API for player kill item list
		 Fixed OnCollectiblePickup hook changes
		*/
        #endregion
        #region 1.0.8
        /*
		--------------
		Version 1.0.8
		--------------
		 Added custom item list for player kills
		*/
        #endregion
        #region 1.0.7
        /*
		--------------
		Version 1.0.7
		--------------
		 Fixed NPC drop list not dropping correct list items
		*/
        #endregion
        #region 1.0.6
        /*
		--------------
		Version 1.0.6
		--------------
		 Added API for XPerienceAddon support
		*/
        #endregion
        #region 1.0.5
        /*
		--------------
		Version 1.0.5
		--------------
		 Added custom item list for animal kills
		 Option to exclude certain animals
		 Added custom item list for npc kills
		 Option to exclude certain NPCs
		*/
        #endregion
        #region 1.0.4
        /*
		--------------
		Version 1.0.4
		--------------
		 Separated hooks and cleaned up coding
		 Added custom item name option to lists
		 Now shows item names instead of shortnames in chat message
		*/
        #endregion
        #region 1.0.3
        /*
		--------------
		Version 1.0.3
		--------------
		 Added option to enable/disable certain resources within gathering and looting lists
		*/
        #endregion
        #region 1.0.2
        /*
		--------------
		Version 1.0.2
		--------------
		 Added option to add SkinID to custom item lists
		*/
        #endregion
        #region 1.0.1
        /*
		--------------
		Version 1.0.1
		--------------
		 Added option to disable chat message
		 Fixed gathering chance not working on some sources
		*/
        #endregion
        #region 1.0.0
        /*
		--------------
		Version 1.0.0
		--------------
		 Initial Release
		 3 Custom Item Lists (Gathering, Mining, Looting)
		 Percentage drop option for each list
		 Each list has their own permissions
		 VIP chance increase permission
		*/
        #endregion
        #endregion

        #region Fields
        private readonly LootData _CID_lootData;
		private DynamicConfigFile _CID_LootContainData;
		private Dictionary<NetworkableId, Loot> _CID_lootCache;
		private Configuration config;
		private const string PermGatheringChance = "customitemdrops.gathering";
		private const string PermMiningChance = "customitemdrops.mining";
		private const string PermLootingChance = "customitemdrops.looting";
		private const string PermAnimalChance = "customitemdrops.animal";
		private const string PermNPCChance = "customitemdrops.npc";
		private const string PermPlayerChance = "customitemdrops.player";
		private const string PermVIPChance = "customitemdrops.vipchance";
		#endregion

		#region Config
		private class Configuration : SerializableConfiguration
		{
			[JsonProperty("General Settings")]
			public GeneralSettings generalSettings = new GeneralSettings();
			[JsonProperty("Gathering Options / List")]
			public GatheringOptions gatheringoptions = new GatheringOptions();
			[JsonProperty("Mining Options / List")]
			public MiningOptions miningoptions = new MiningOptions();
			[JsonProperty("Looting Options / List")]
			public LootingOptions lootingoptions = new LootingOptions();
			[JsonProperty("Animal Kill Options / List")]
			public AnimalOptions animaloptions = new AnimalOptions();
			[JsonProperty("NPC Kill Options / List")]
			public NPCOptions NPCoptions = new NPCOptions();
			[JsonProperty("Player Kill Options / List")]
			public PlayerOptions Playeroptions = new PlayerOptions();
		}
		public class GeneralSettings
		{
			public bool showchatmessage = true;
			public bool disablepowertoolchance = true;
		}
		public class GatheringOptions
		{
			public int dropchance = 10;
			public int vipdropchance = 20;
			public bool trees = true;
			public bool berries = true;
			public bool wood = true;
			public bool stones = true;
			public bool ore = true;
			public bool hemp = true;
			public bool mushrooms = true;
			public bool pumpkins = true;
			public bool corn = true;
			public bool potatos = true;
			public Dictionary<int, GatheringItemList> gatheringItemList = new Dictionary<int, GatheringItemList>
			{
				[0] = new GatheringItemList
				{
					shortname = "apple",
					displayname = "",
					amount = 1,
					SkinID = 0
				},
				[1] = new GatheringItemList
				{
					shortname = "bandage",
					displayname = "",
					amount = 1,
					SkinID = 0
				},
			};
		}
		public class MiningOptions
		{
			public int dropchance = 10;
			public int vipdropchance = 20;
			public Dictionary<int, MiningItemList> miningItemList = new Dictionary<int, MiningItemList>
			{
				[0] = new MiningItemList
				{
					shortname = "metal.fragments",
					displayname = "",
					amount = 5,
					SkinID = 0
				},
				[1] = new MiningItemList
				{
					shortname = "metal.refined",
					displayname = "",
					amount = 2,
					SkinID = 0
				},
			};
		}
		public class LootingOptions
		{
			public int dropchance = 10;
			public int vipdropchance = 20;
			public bool lootcontainer = true;
			public bool freeablelootcontainer = true;
			public bool lockedbyentcrate = true;
			public bool hackablelockedcrate = true;
			public Dictionary<int, LootingItemList> lootingItemList = new Dictionary<int, LootingItemList>
			{
				[0] = new LootingItemList
				{
					shortname = "scrap",
					displayname = "",
					amount = 2,
					SkinID = 0
				},
				[1] = new LootingItemList
				{
					shortname = "metal.fragments",
					displayname = "",
					amount = 1,
					SkinID = 0
				},
			};
		}
		public class AnimalOptions
		{
			public int dropchance = 10;
			public int vipdropchance = 20;
			public bool chicken = true;
			public bool boar = true;
			public bool stag = true;
			public bool wolf = true;
			public bool bear = true;
			public bool polarbear = true;
			public bool horse = true;
			public bool shark = true;
			public Dictionary<int, AnimalItemList> AnimalItemList = new Dictionary<int, AnimalItemList>
			{
				[0] = new AnimalItemList
				{
					shortname = "scrap",
					displayname = "",
					amount = 2,
					SkinID = 0
				},
				[1] = new AnimalItemList
				{
					shortname = "metal.fragments",
					displayname = "",
					amount = 1,
					SkinID = 0
				},
			};
		}
		public class NPCOptions
		{
			public int dropchance = 10;
			public int vipdropchance = 20;
			public bool scientist = true;
			public bool dweller = true;
			public bool bradley = true;
			public bool heli = true;
			public bool scarcrow = true;
			public bool customnpc = true;
			public bool zombie = true;
			public Dictionary<int, NPCItemList> NPCItemList = new Dictionary<int, NPCItemList>
			{
				[0] = new NPCItemList
				{
					shortname = "scrap",
					displayname = "",
					amount = 2,
					SkinID = 0
				},
				[1] = new NPCItemList
				{
					shortname = "metal.fragments",
					displayname = "",
					amount = 1,
					SkinID = 0
				},
			};
		}
		public class PlayerOptions
		{
			public int dropchance = 10;
			public int vipdropchance = 20;
			public bool enableplayers = true;
			public Dictionary<int, PlayerItemList> PlayerItemList = new Dictionary<int, PlayerItemList>
			{
				[0] = new PlayerItemList
				{
					shortname = "scrap",
					displayname = "",
					amount = 2,
					SkinID = 0
				},
				[1] = new PlayerItemList
				{
					shortname = "metal.fragments",
					displayname = "",
					amount = 1,
					SkinID = 0
				},
			};
		}
		public class GatheringItemList
		{
			public string shortname = "";
			public string displayname = "";
			public int amount = 1;
			public ulong SkinID = 0;
		}
		public class MiningItemList
		{
			public string shortname = "";
			public string displayname = "";
			public int amount = 1;
			public ulong SkinID = 0;
		}
		public class LootingItemList
		{
			public string shortname = "";
			public string displayname = "";
			public int amount = 1;
			public ulong SkinID = 0;
		}
		public class AnimalItemList
		{
			public string shortname = "";
			public string displayname = "";
			public int amount = 1;
			public ulong SkinID = 0;
		}
		public class NPCItemList
		{
			public string shortname = "";
			public string displayname = "";
			public int amount = 1;
			public ulong SkinID = 0;
		}
		public class PlayerItemList
		{
			public string shortname = "";
			public string displayname = "";
			public int amount = 1;
			public ulong SkinID = 0;
		}
		protected override void LoadDefaultConfig() => config = new Configuration();
		protected override void LoadConfig()
		{
			base.LoadConfig();
			try
			{
				config = Config.ReadObject<Configuration>();
				if (config == null)
				{
					throw new JsonException();
				}
				if (MaybeUpdateConfig(config))
				{
					PrintWarning("Configuration appears to be outdated; updating and saving");
					SaveConfig();
				}
			}
			catch
			{
				PrintWarning($"Configuration file {Name}.json is invalid; using defaults");
				LoadDefaultConfig();
			}
		}
		protected override void SaveConfig()
		{
			PrintWarning($"Configuration changes saved to {Name}.json");
			Config.WriteObject(config, true);
		}
		#endregion

		#region UpdateChecker
		internal class SerializableConfiguration
		{
			public string ToJson() => JsonConvert.SerializeObject(this);

			public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
		}
		private static class JsonHelper
		{
			public static object Deserialize(string json) => ToObject(JToken.Parse(json));

			private static object ToObject(JToken token)
			{
				switch (token.Type)
				{
					case JTokenType.Object:
						return token.Children<JProperty>().ToDictionary(prop => prop.Name, prop => ToObject(prop.Value));
					case JTokenType.Array:
						return token.Select(ToObject).ToList();

					default:
						return ((JValue)token).Value;
				}
			}
		}
		private bool MaybeUpdateConfig(SerializableConfiguration config)
		{
			var currentWithDefaults = config.ToDictionary();
			var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
			return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
		}
		private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
		{
			bool changed = false;

			foreach (var key in currentWithDefaults.Keys)
			{
				object currentRawValue;
				if (currentRaw.TryGetValue(key, out currentRawValue))
				{
					var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
					var currentDictValue = currentRawValue as Dictionary<string, object>;

					if (defaultDictValue != null)
					{
						if (currentDictValue == null)
						{
							currentRaw[key] = currentWithDefaults[key];
							changed = true;
						}
						else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
							changed = true;
					}
				}
				else
				{
					currentRaw[key] = currentWithDefaults[key];
					changed = true;
				}
			}

			return changed;
		}
		#endregion

		#region Storage
		private void SaveLoot()
		{
			if (_CID_lootData != null)
			{
				_CID_lootData.CID_LootRecords = _CID_lootCache;
				_CID_LootContainData.WriteObject(_CID_lootData);
			}
		}
		private class LootData
		{
			public Dictionary<NetworkableId, Loot> CID_LootRecords = new Dictionary<NetworkableId, Loot>();
		}
		private class Loot
		{
			public NetworkableId lootcontainer;
			public List<string> id;
		}
		private void AddLootData(BasePlayer player, LootContainer lootcontainer)
		{
			Loot loot;
			if (!_CID_lootCache.TryGetValue(lootcontainer.net.ID, out loot))
			{
				_CID_lootCache.Add(lootcontainer.net.ID, loot = new Loot
				{
					lootcontainer = lootcontainer.net.ID,
					id = new List<string>(),
				});
			}
			if (!loot.id.Contains(player.UserIDString))
			{
				loot.id.Add(player.UserIDString);
			}
		}
		#endregion

		#region Load/Save
		private void Init()
		{
			permission.RegisterPermission(PermGatheringChance, this);
			permission.RegisterPermission(PermMiningChance, this);
			permission.RegisterPermission(PermLootingChance, this);
			permission.RegisterPermission(PermAnimalChance, this);
			permission.RegisterPermission(PermNPCChance, this);
			permission.RegisterPermission(PermPlayerChance, this);
			permission.RegisterPermission(PermVIPChance, this);
			_CID_lootCache = new Dictionary<NetworkableId, Loot>();
		}
		private void OnServerInitialized()
		{
			_CID_LootContainData = Interface.Oxide.DataFileSystem.GetFile(nameof(CustomItemDrops) + "/CIDLootData");
			SaveLoot();
		}
		private void Unload()
        {
			SaveLoot();
		}
		private void OnServerShutdown()
		{
			_CID_lootCache.Clear();
			_CID_LootContainData.Clear();
			SaveLoot();
		}
		private void OnServerSave()
		{
			SaveLoot();
		}
		#endregion

		#region Hooks
		private void OnLootSpawn(LootContainer container)
		{
			if (container != null && _CID_lootCache.ContainsKey(container.net.ID))
			{
				_CID_lootCache[container.net.ID].id.Clear();
			}
		}
		private void OnLootEntity(BasePlayer player, LootContainer lootcontainer)
		{
			// Null Checks
			if (player == null || !player.userID.Get().IsSteamId() || !lootcontainer.IsValid()) return;

			// Check Settings, Permissions, and Data
			if (config.lootingoptions.dropchance == 0) return;
			if (!permission.UserHasPermission(player.UserIDString, PermLootingChance)) return;
			var loot = lootcontainer.GetType().Name.ToLower();
			var lootid = lootcontainer.net.ID;
			if (_CID_lootCache.ContainsKey(lootid) && _CID_lootCache[lootid].id.Contains(player.UserIDString))
			{
				return;
			}
			int chance = config.lootingoptions.dropchance;
			if (permission.UserHasPermission(player.UserIDString, PermVIPChance))
			{
				chance = config.lootingoptions.vipdropchance;
			}

			// Check Container Types
			bool resource = false;
			switch (loot)
			{
				case "lootcontainer":
					if (config.lootingoptions.lootcontainer) resource = true;
					break;
				case "freeablelootcontainer":
					if (config.lootingoptions.freeablelootcontainer) resource = true;
					break;
				case "lockedbyentcrate":
					if (config.lootingoptions.lockedbyentcrate) resource = true;
					break;
				case "hackablelockedcrate":
					if (config.lootingoptions.hackablelockedcrate) resource = true;
					break;
			}

			// Calculate Chance & Give Items
			if ((Random.Range(0, 101) <= chance) == true && resource)
			{
				CreateItemFromList(player, "lootinglist");
			}

			// Add Player & Container to Data to Prevent Exploits
			AddLootData(player, lootcontainer);
		}
		private void OnContainerDropItems(ItemContainer lootcontainer)
		{
			// Null Checks
			if (lootcontainer == null) return;
			var lootentity = lootcontainer.entityOwner as LootContainer;
			if (lootentity == null || lootentity.IsDestroyed) return;
			var player = lootentity.lastAttacker as BasePlayer;
			if (player == null || player.IsNpc) return;

			// Check Settings & Permissions
			if (!permission.UserHasPermission(player.UserIDString, PermLootingChance)) return;
			int chance = config.lootingoptions.dropchance;
			if (permission.UserHasPermission(player.UserIDString, PermVIPChance))
			{
				chance = config.lootingoptions.vipdropchance;
			}

			// Calculate Chance & Give Items
			if ((Random.Range(0, 101) <= chance) == true)
			{
				CreateItemFromList(player, "lootinglist");
			}
		}
		private void OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo)
		{
			// Check for null or Suicide
			if (entity == null || hitInfo == null || hitInfo.Initiator == null || entity == hitInfo.Initiator) return;

			// Get Killer & Ignore NPCs
			var attacker = hitInfo.Initiator as BasePlayer;
			if (attacker == null || !attacker.userID.Get().IsSteamId() || attacker.IsNpc) return;

			// Detect Teamkills
			if (attacker.Team != null)
			{
				foreach (var team in attacker.Team.members)
				{
					if (team == attacker.userID) continue;
					BasePlayer teammember = RelationshipManager.FindByID(team);
					var isteammember = entity as BasePlayer;
					if (isteammember != null && isteammember.userID.Get().IsSteamId()) continue;
					if (teammember == isteammember) return;
				}
			}

			// Detect Kill Type & Pick Proper List
			string KillType = entity?.GetType().Name.ToLower();
			bool animalkill = false;
			bool npckill = false;
			bool playerkill = false;
			string droplist = "none";
			switch (KillType)
			{
				case "chicken":
					if(config.animaloptions.chicken)
                    {
						animalkill = true;
						droplist = "animal";
                    }
					break;
				case "boar":
					if (config.animaloptions.boar)
					{
						animalkill = true;
						droplist = "animal";
					}
					break;
				case "stag":
					if (config.animaloptions.stag)
					{
						animalkill = true;
						droplist = "animal";
					}
					break;
				case "wolf":
					if (config.animaloptions.wolf)
					{
						animalkill = true;
						droplist = "animal";
					}
					break;
				case "bear":
					if (config.animaloptions.bear)
					{
						animalkill = true;
						droplist = "animal";
					}
					break;
				case "polarbear":
					if (config.animaloptions.polarbear)
					{
						animalkill = true;
						droplist = "animal";
					}
					break;
				case "simpleshark":
					if (config.animaloptions.shark)
					{
						animalkill = true;
						droplist = "animal";
					}
					break;
				case "horse":
				case "ridablehorse":
					if (config.animaloptions.horse)
					{
						animalkill = true;
						droplist = "animal";
					}
					break;
				case "scientistnpc":
				case "scientist":
					if (config.NPCoptions.scientist)
					{
						npckill = true;
						droplist = "npc";
					}
					break;
				case "tunneldweller":
				case "underwaterdweller":
					if (config.NPCoptions.dweller)
					{
						npckill = true;
						droplist = "npc";
					}
					break;
				case "bradleyapc":
					if (config.NPCoptions.bradley)
					{
						npckill = true;
						droplist = "npc";
					}
					break;
				case "patrolhelicopter":
					if (config.NPCoptions.heli)
					{
						npckill = true;
						droplist = "npc";
					}
					break;
				case "scarecrownpc":
					if (config.NPCoptions.scarcrow)
					{
						npckill = true;
						droplist = "npc";
					}
					break;
				case "customscientistnpc":
					if (config.NPCoptions.customnpc)
					{
						npckill = true;
						droplist = "npc";
					}
					break;
				case "zombienpc":
					if (config.NPCoptions.zombie)
					{
						npckill = true;
						droplist = "npc";
					}
					break;
				case "baseplayer":
					if(config.Playeroptions.enableplayers)
                    {
						playerkill = true;
						droplist = "player";
                    }
					break;
			}

			// Check Settings & Permissions
			int chance = 0;
			if (animalkill)
			{
				// Check Settings & Permissions
				if (!permission.UserHasPermission(attacker.UserIDString, PermAnimalChance)) return;
				chance = config.animaloptions.dropchance;
				if (permission.UserHasPermission(attacker.UserIDString, PermVIPChance))
				{
					chance = config.animaloptions.vipdropchance;
				}
			}
			else if(npckill)
            {
				if (!permission.UserHasPermission(attacker.UserIDString, PermNPCChance)) return;
				chance = config.NPCoptions.dropchance;
				if (permission.UserHasPermission(attacker.UserIDString, PermVIPChance))
				{
					chance = config.NPCoptions.vipdropchance;
				}
			}
			else if(playerkill)
            {
				if (!permission.UserHasPermission(attacker.UserIDString, PermPlayerChance)) return;
				chance = config.Playeroptions.dropchance;
				if (permission.UserHasPermission(attacker.UserIDString, PermVIPChance))
                {
					chance = config.Playeroptions.vipdropchance;
                }
            }

			// Calculate Chance & Give Items
			if ((Random.Range(0, 101) <= chance) == true && (animalkill || npckill || playerkill))
			{
				CreateItemFromList(attacker, droplist);
			}
		}
		private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
		{
			// Null Checks
			var player = entity.ToPlayer();
			if (player == null || !player.userID.Get().IsSteamId() || dispenser == null || entity == null || item == null) return;
			bool resource = false;
            var tool = player.GetActiveItem().ToString().ToLower();
			if (config.generalSettings.disablepowertoolchance && (tool.Contains("chainsaw") || tool.Contains("jackhammer"))) return;
            switch (dispenser.gatherType)
            {
				// Trees - Gathering
				case ResourceDispenser.GatherType.Tree:
					
					// Check Settings & Permissions
					if (config.gatheringoptions.trees) resource = true;
					if (!permission.UserHasPermission(player.UserIDString, PermGatheringChance)) return;
					if (config.gatheringoptions.dropchance == 0) return;
					int gchance = config.gatheringoptions.dropchance;
					if (permission.UserHasPermission(player.UserIDString, PermVIPChance))
					{
						gchance = config.gatheringoptions.vipdropchance;
					}
					
					// Calculate Chance & Give Items
					if ((Random.Range(0, 101) <= gchance) == true && resource)
					{
						CreateItemFromList(player, "gatheringlist");
					}
					break;

				// Ore - Mining
				case ResourceDispenser.GatherType.Ore:

					// Check Settings & Permissions
					if (!permission.UserHasPermission(player.UserIDString, PermMiningChance)) return;
					if (config.miningoptions.dropchance == 0) return;
					int mchance = config.miningoptions.dropchance;
					if (permission.UserHasPermission(player.UserIDString, PermVIPChance))
					{
						mchance = config.miningoptions.vipdropchance;
					}
					
					// Calculate Chance & Give Items
					if ((Random.Range(0, 101) <= mchance) == true)
					{
						CreateItemFromList(player, "mininglist");
					}
					break;
			}
		}
		private void OnCollectiblePickup(CollectibleEntity collectible, BasePlayer player)
		{
			// Null Checks
			if (player == null || !player.userID.Get().IsSteamId() || collectible == null) return;

			// Check Settings & Permissions
			if (config.gatheringoptions.dropchance == 0) return;
			if (!permission.UserHasPermission(player.UserIDString, PermGatheringChance)) return;
			int gchance = config.gatheringoptions.dropchance;
			if (permission.UserHasPermission(player.UserIDString, PermVIPChance))
			{
				gchance = config.gatheringoptions.vipdropchance;
			}

			// Check Gathering Types
			bool resource = false;
			foreach (var itemAmount in collectible.itemList)
			{
				var name = itemAmount.itemDef.shortname;
				if (name.Contains("berry") && !name.Contains("seed"))
				{
					name = "berry";
				}
				else if (name.Contains("ore"))
				{
					name = "ore";
				}
				switch (name)
				{
					case "wood":
						if (config.gatheringoptions.wood) resource = true;
						break;
					case "ore":
						if (config.gatheringoptions.ore) resource = true;
						break;
					case "stones":
						if (config.gatheringoptions.stones) resource = true;
						break;
					case "berry":
						if (config.gatheringoptions.berries) resource = true;
						break;
					case "mushroom":
						if (config.gatheringoptions.mushrooms) resource = true;
						break;
					case "cloth":
						if (config.gatheringoptions.hemp) resource = true;
						break;
					case "pumpkin":
						if (config.gatheringoptions.pumpkins) resource = true;
						break;
					case "corn":
						if (config.gatheringoptions.corn) resource = true;
						break;
					case "potato":
						if (config.gatheringoptions.potatos) resource = true;
						break;
				}
				// Calculate Chance & Give Items
				if ((Random.Range(0, 101) <= gchance) == true && resource)
				{
					CreateItemFromList(player, "gatheringlist");
				}
			}
		}
		private void OnGrowableGathered(GrowableEntity growable, Item item, BasePlayer player)
		{
			// Null Checks
			if (player == null || !player.userID.Get().IsSteamId() || growable == null || item == null) return;

			// Check Settings & Permissions
			if (config.gatheringoptions.dropchance == 0) return;
			if (!permission.UserHasPermission(player.UserIDString, PermGatheringChance)) return;
			int gchance = config.gatheringoptions.dropchance;
			if (permission.UserHasPermission(player.UserIDString, PermVIPChance))
			{
				gchance = config.gatheringoptions.vipdropchance;
			}

			// Check Gathering Types
			bool resource = false;
			var name = item.info.shortname;
			if (name.Contains("berry") && !name.Contains("seed"))
			{
				name = "berry";
			}
			else if (name.Contains("ore"))
			{
				name = "ore";
			}
			switch (name)
			{
				case "wood":
					if (config.gatheringoptions.wood) resource = true;
					break;
				case "ore":
					if (config.gatheringoptions.ore) resource = true;
					break;
				case "stones":
					if (config.gatheringoptions.stones) resource = true;
					break;
				case "berry":
					if (config.gatheringoptions.berries) resource = true;
					break;
				case "mushroom":
					if (config.gatheringoptions.mushrooms) resource = true;
					break;
				case "cloth":
					if (config.gatheringoptions.hemp) resource = true;
					break;
				case "pumpkin":
					if (config.gatheringoptions.pumpkins) resource = true;
					break;
				case "corn":
					if (config.gatheringoptions.corn) resource = true;
					break;
				case "potato":
					if (config.gatheringoptions.potatos) resource = true;
					break;
			}

			// Calculate Chance & Give Items
			if ((Random.Range(0, 101) <= gchance) == true && resource)
			{
				CreateItemFromList(player, "gatheringlist");
			}
		}
		private void CreateItemFromList(BasePlayer player, string selectedlist)
        {
			if (player == null || selectedlist == null) return;
			switch (selectedlist)
            {
                // Gathering List
                #region Gathering
                case "gatheringlist":

					// Get Random Item From List
					int randomroll = Random.Range(0, config.gatheringoptions.gatheringItemList.Count);
					
					// Check for Valid Item & Get Item Details
					var gselected = config.gatheringoptions.gatheringItemList[randomroll];
					ItemDefinition gdefinition = ItemManager.FindItemDefinition(gselected.shortname);
					if (gdefinition == null)
					{
						Puts($"[Gathering List] Invalid shortname in config for item {gselected.shortname}");
						return;
					}

					// Create Item & Get Skin Needed
					Item gcreateitem = ItemManager.CreateByItemID(gdefinition.itemid, gselected.amount, gselected.SkinID);

					// Change Name if Needed
					var gitemdisplayname = gcreateitem.info.displayName.english;
					if (!string.IsNullOrEmpty(gselected.displayname))
					{
						gcreateitem.name = gselected.displayname;
						gcreateitem.MarkDirty();
						gitemdisplayname = gselected.displayname;
					}

					// Return if Item is Null
					if (gcreateitem == null)
					{
						Puts($"[Looting List] Error creating item with skinid {gselected.SkinID} for item {gselected.shortname}");
						return;
					}

					// Give Item to Player
					player.GiveItem(gcreateitem);

					// Send Chat Message if Enabled
					if (config.generalSettings.showchatmessage)
					{
						player.ChatMessage(CIDLang("giveitem", player.UserIDString, gselected.amount, gitemdisplayname));
					}
					break;
                #endregion
                // Mining List
                #region Mining
                case "mininglist":

					// Get Random Item From List
					randomroll = Random.Range(0, config.miningoptions.miningItemList.Count);

					// Check for Valid Item & Get Item Details
					var mselected = config.miningoptions.miningItemList[randomroll];
					ItemDefinition mdefinition = ItemManager.FindItemDefinition(mselected.shortname);
					if (mdefinition == null)
					{
						Puts($"[Mining List] Invalid shortname in config for item {mselected.shortname}");
						return;
					}

					// Create Item & Get Skin Needed
					Item mcreateitem = ItemManager.CreateByItemID(mdefinition.itemid, mselected.amount, mselected.SkinID);

					// Change Name if Needed
					var mitemdisplayname = mcreateitem.info.displayName.english;
					if (!string.IsNullOrEmpty(mselected.displayname))
					{
						mcreateitem.name = mselected.displayname;
						mcreateitem.MarkDirty();
						mitemdisplayname = mselected.displayname;
					}

					// Return if Item is Null
					if (mcreateitem == null)
					{
						Puts($"[Looting List] Error creating item with skinid {mselected.SkinID} for item {mselected.shortname}");
						return;
					}

					// Give Item to Player
					player.GiveItem(mcreateitem);

					// Send Chat Message if Enabled
					if (config.generalSettings.showchatmessage)
					{
						player.ChatMessage(CIDLang("giveitem", player.UserIDString, mselected.amount, mitemdisplayname));
					}
					break;
                #endregion
                // Looting List
                #region Looting
                case "lootinglist":

					// Get Random Item From List
					randomroll = Random.Range(0, config.lootingoptions.lootingItemList.Count);

					// Check for Valid Item & Get Item Details
					var lselected = config.lootingoptions.lootingItemList[randomroll];
					ItemDefinition ldefinition = ItemManager.FindItemDefinition(lselected.shortname);
					if (ldefinition == null)
					{
						Puts($"[Looting List] Invalid shortname in config for item {lselected.shortname}");
						return;
					}

					// Create Item & Get Skin Needed
					Item lcreateitem = ItemManager.CreateByItemID(ldefinition.itemid, lselected.amount, lselected.SkinID);

					// Change Name if Needed
					var litemdisplayname = lcreateitem.info.displayName.english;
					if (!string.IsNullOrEmpty(lselected.displayname))
					{	
						lcreateitem.name = lselected.displayname;
						lcreateitem.MarkDirty();
						litemdisplayname = lselected.displayname;
					}

					// Return if Item is Null
					if (lcreateitem == null)
					{
						Puts($"[Looting List] Error creating item with skinid {lselected.SkinID} for item {lselected.shortname}");
						return;
					}

					// Give Item to Player
					player.GiveItem(lcreateitem);

					// Send Chat Message if Enabled
					if (config.generalSettings.showchatmessage)
					{
						player.ChatMessage(CIDLang("giveitem", player.UserIDString, lselected.amount, litemdisplayname));
					}
					break;
				#endregion
				// Animal Kills
				#region AnimalKills
				case "animal":

					// Get Random Item From List
					randomroll = Random.Range(0, config.animaloptions.AnimalItemList.Count);

					// Check for Valid Item & Get Item Details
					var aselected = config.animaloptions.AnimalItemList[randomroll];
					ItemDefinition adefinition = ItemManager.FindItemDefinition(aselected.shortname);
					if (adefinition == null)
					{
						Puts($"[Animal List] Invalid shortname in config for item {aselected.shortname}");
						return;
					}

					// Create Item & Get Skin Needed
					Item acreateitem = ItemManager.CreateByItemID(adefinition.itemid, aselected.amount, aselected.SkinID);

					// Change Name if Needed
					var aitemdisplayname = acreateitem.info.displayName.english;
					if (!string.IsNullOrEmpty(aselected.displayname))
					{
						acreateitem.name = aselected.displayname;
						acreateitem.MarkDirty();
						aitemdisplayname = aselected.displayname;
					}

					// Return if Item is Null
					if (acreateitem == null)
					{
						Puts($"[Animal List] Error creating item with skinid {aselected.SkinID} for item {aselected.shortname}");
						return;
					}

					// Give Item to Player
					player.GiveItem(acreateitem);

					// Send Chat Message if Enabled
					if (config.generalSettings.showchatmessage)
					{
						player.ChatMessage(CIDLang("giveitem", player.UserIDString, aselected.amount, aitemdisplayname));
					}

					break;
				#endregion
				// NPC Kills
				#region NPCKills
				case "npc":

					// Get Random Item From List
					randomroll = Random.Range(0, config.NPCoptions.NPCItemList.Count);

					// Check for Valid Item & Get Item Details
					var nselected = config.NPCoptions.NPCItemList[randomroll];
					ItemDefinition ndefinition = ItemManager.FindItemDefinition(nselected.shortname);
					if (ndefinition == null)
					{
						Puts($"[NPC List] Invalid shortname in config for item {nselected.shortname}");
						return;
					}

					// Create Item & Get Skin Needed
					Item ncreateitem = ItemManager.CreateByItemID(ndefinition.itemid, nselected.amount, nselected.SkinID);

					// Change Name if Needed
					var nitemdisplayname = ncreateitem.info.displayName.english;
					if (!string.IsNullOrEmpty(nselected.displayname))
					{
						ncreateitem.name = nselected.displayname;
						ncreateitem.MarkDirty();
						nitemdisplayname = nselected.displayname;
					}

					// Return if Item is Null
					if (ncreateitem == null)
					{
						Puts($"[NPC List] Error creating item with skinid {nselected.SkinID} for item {nselected.shortname}");
						return;
					}

					// Give Item to Player
					player.GiveItem(ncreateitem);

					// Send Chat Message if Enabled
					if (config.generalSettings.showchatmessage)
					{
						player.ChatMessage(CIDLang("giveitem", player.UserIDString, nselected.amount, nitemdisplayname));
					}

					break;


                #endregion
				// Player Kills
				#region PlayerKills
				case "player":

					// Get Random Item From List
					randomroll = Random.Range(0, config.Playeroptions.PlayerItemList.Count);

					// Check for Valid Item & Get Item Details
					var pselected = config.Playeroptions.PlayerItemList[randomroll];
					ItemDefinition pdefinition = ItemManager.FindItemDefinition(pselected.shortname);
					if (pdefinition == null)
					{
						Puts($"[Player List] Invalid shortname in config for item {pselected.shortname}");
						return;
					}

					// Create Item & Get Skin Needed
					Item pcreateitem = ItemManager.CreateByItemID(pdefinition.itemid, pselected.amount, pselected.SkinID);

					// Change Name if Needed
					var pitemdisplayname = pcreateitem.info.displayName.english;
					if (!string.IsNullOrEmpty(pselected.displayname))
					{
						pcreateitem.name = pselected.displayname;
						pcreateitem.MarkDirty();
						pitemdisplayname = pselected.displayname;
					}

					// Return if Item is Null
					if (pcreateitem == null)
					{
						Puts($"[Player List] Error creating item with skinid {pselected.SkinID} for item {pselected.shortname}");
						return;
					}

					// Give Item to Player
					player.GiveItem(pcreateitem);

					// Send Chat Message if Enabled
					if (config.generalSettings.showchatmessage)
					{
						player.ChatMessage(CIDLang("giveitem", player.UserIDString, pselected.amount, pitemdisplayname));
					}

					break;


                #endregion
            }
        }
		#endregion

		#region Lang
		protected override void LoadDefaultMessages()
        {
	        lang.RegisterMessages(new Dictionary<string, string>
	        {
		        ["giveitem"] = "You have received {0} {1} in your inventory.",

			}, this);
        }
        private string CIDLang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
		#endregion

		#region API
		private int GetItemDropChance(string list, string type)
        {
			if (list == null) return 0;
			int chance = 0;
			switch(list)
            {
				case "gathering":
					switch(type)
                    {
						case "default":
							chance = config.gatheringoptions.dropchance;
							break;
						case "vip":
							chance = config.gatheringoptions.vipdropchance;
							break;
                    }
					break;
				case "mining":
					switch (type)
					{
						case "default":
							chance = config.miningoptions.dropchance;
							break;
						case "vip":
							chance = config.miningoptions.vipdropchance;
							break;
					}
					break;
				case "looting":
					switch (type)
					{
						case "default":
							chance = config.lootingoptions.dropchance;
							break;
						case "vip":
							chance = config.lootingoptions.vipdropchance;
							break;
					}
					break;
				case "animal":
					switch (type)
					{
						case "default":
							chance = config.animaloptions.dropchance;
							break;
						case "vip":
							chance = config.animaloptions.vipdropchance;
							break;
					}
					break;
				case "npc":
					switch (type)
					{
						case "default":
							chance = config.NPCoptions.dropchance;
							break;
						case "vip":
							chance = config.NPCoptions.vipdropchance;
							break;
					}
					break;
				case "player":
					switch(type)
                    {
						case "default":
							chance = config.Playeroptions.dropchance;
							break;
						case "vip":
							chance = config.Playeroptions.vipdropchance;
							break;
                    }
					break;
			}
			return chance;
        }
		private string GetItemDropLists(string list)
        {
			if (list == null) return null;
			switch(list)
            {
				case "gathering":
					list = JsonConvert.SerializeObject(config.gatheringoptions.gatheringItemList);
					break;
				case "mining":
					list = JsonConvert.SerializeObject(config.miningoptions.miningItemList);
					break;
				case "looting":
					list = JsonConvert.SerializeObject(config.lootingoptions.lootingItemList);
					break;
				case "animal":
					list = JsonConvert.SerializeObject(config.animaloptions.AnimalItemList);
					break;
				case "npc":
					list = JsonConvert.SerializeObject(config.NPCoptions.NPCItemList);
					break;
				case "player":
					list = JsonConvert.SerializeObject(config.Playeroptions.PlayerItemList);
					break;
			}
			return list;
        }
		#endregion

	}
}

// --- End of file: CustomItemDrops.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/cupboard-list ---
// --- Original File Path: C/CupboardList/CupboardList.cs ---

using System.Collections.Generic;
using System.Text;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

/*********************************************************************************************
 * Thx to Kappasaurus the creator of this plugin upto v1.0.2
 *********************************************************************************************
 * 1.0.4    :   Fixed some formatting
 *          :   Optimised usage of Covalance in the cupowner command
 *          :   Updated the language file ("Player List" is now "AuthedPlayers")
 *          :   Added cfg to change prefix and chaticon instead of hardcoded
 *          :   Added support for the new TC skin
 ********************************************************************************************/



namespace Oxide.Plugins
{
    [Info("CupboardList", "Krungh Crow", "1.0.4")]

    class CupboardList : RustPlugin
    {
        private const string Prefab = "cupboard.tool.deployed";
        private const string Prefab2 = "cupboard.tool.retro.deployed";
        private string msg(string key, string id = null) => lang.GetMessage(key, this, id);
        private string prefix;
        private ulong chaticon;

        private CupboardListConfig config;

        void Init()
        {
            permission.RegisterPermission("cupboardlist.able" , this);
            LoadDefaultConfig();
            LoadConfigValues();
            LoadDefaultMessages();
            prefix = config.Prefix;
            chaticon = config.ChatIcon;
        }

        void LoadConfigValues()
        {
            config = Config.ReadObject<CupboardListConfig>();
        }

        protected override void LoadDefaultConfig()
        {
            config = new CupboardListConfig();
            Config.WriteObject(config , true);
        }

        class CupboardListConfig
        {
            public string Prefix { get; set; } = "<color=yellow>[Cupboard List]</color>";
            public ulong ChatIcon { get; set; } = 0;
        }

        [ChatCommand("cupauth")]
        void AuthCmd(BasePlayer player , string command , string[] args)
        {
            if (!permission.UserHasPermission(player.userID.ToString() , "cupboardlist.able"))
            {
                Player.Message(player , prefix + string.Format(msg("No Permission" , player.UserIDString)) , chaticon);
                return;
            }

            var targetEntity = GetViewEntity(player);

            if (!IsCupboardEntity(targetEntity))
            {
                Player.Message(player , prefix + string.Format(msg("Not a Cupboard" , player.UserIDString)) , chaticon);
                return;
            }

            var cupboard = targetEntity.gameObject.GetComponentInParent<BuildingPrivlidge>();

            if (cupboard.authorizedPlayers.Count == 0)
            {
                Player.Message(player , prefix + string.Format(msg("No Players" , player.UserIDString)) , chaticon);
                return;
            }

            var playerList = new StringBuilder();
            foreach (ProtoBuf.PlayerNameID playerNameOrID in cupboard.authorizedPlayers)
            {
                playerList.AppendLine($"<color=green>{playerNameOrID.username}</color> ({playerNameOrID.userid})");
            }

            Player.Message(player , $"{prefix}{string.Format(msg("AuthedPlayers" , player.UserIDString).Replace("{authList}" , playerList.ToString()))}" , chaticon);
        }

        [ChatCommand("cupowner")]
        void OwnerCmd(BasePlayer player , string command , string[] args)
        {
            if (!permission.UserHasPermission(player.userID.ToString() , "cupboardlist.able"))
            {
                Player.Message(player , prefix + string.Format(msg("No Permission" , player.UserIDString)) , chaticon);
                return;
            }

            var targetEntity = GetViewEntity(player);

            if (!IsCupboardEntity(targetEntity))
            {
                Player.Message(player , prefix + string.Format(msg("Not a Cupboard" , player.UserIDString)) , chaticon);
                return;
            }

            var cupboard = targetEntity.gameObject.GetComponentInParent<BuildingPrivlidge>();

            IPlayer owner = covalence.Players.FindPlayerById(cupboard.OwnerID.ToString());

            Player.Message(player , prefix + msg("Owner" , player.UserIDString).Replace("{player}" , $"\n<color=green>{owner.Name}</color> ({owner.Id})") , chaticon);
        }

        #region Helpers

        private BaseEntity GetViewEntity(BasePlayer player)
        {
            RaycastHit hit;
            bool didHit = Physics.Raycast(player.eyes.HeadRay(), out hit, 5);

            return didHit ? hit.GetEntity() : null;
        }

        private bool IsCupboardEntity(BaseEntity entity) => entity != null && (entity.ShortPrefabName == Prefab || entity.ShortPrefabName == Prefab2);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["No Permission"] = "Sorry, no permission.",
                ["Not a Cupboard"] = "Sorry, that's not a cupboard.",
                ["No Players"] = "Sorry, no players authorized.",
                ["AuthedPlayers"] = "The following player(s) are authorized:\n{authList}",
                ["Owner"] = "Tool cupboard owner: {player}."
            }, this);
        }
        #endregion
    }
}

// --- End of file: CupboardList.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/chainsaw-options ---
// --- Original File Path: C/ChainsawOptions/ChainsawOptions.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Chainsaw Options", "Arainrr", "1.1.1")]
    [Description("Control player's chainsaws")]
    public class ChainsawOptions : RustPlugin
    {
        private const string PREFAB_CHAINSAW = "assets/prefabs/weapons/chainsaw/chainsaw.entity.prefab";

        private int defaultMaxAmmo;
        private float defaultFuelPerSec;
        private float defaultEngineStartChance;

        private void Init()
        {
            foreach (var permissionS in configData.permissionList)
            {
                if (!permission.PermissionExists(permissionS.permission, this))
                    permission.RegisterPermission(permissionS.permission, this);
            }
        }

        private void OnServerInitialized()
        {
            var chainsaw = GameManager.server.FindPrefab(PREFAB_CHAINSAW)?.GetComponent<Chainsaw>();
            if (chainsaw != null)
            {
                defaultMaxAmmo = chainsaw.maxAmmo;
                defaultFuelPerSec = chainsaw.fuelPerSec;
                defaultEngineStartChance = chainsaw.engineStartChance;
            }
            else
            {
                PrintError("An error occurred. please notify the plugin developer");
                NextTick(() => Interface.Oxide.UnloadPlugin(Name));
            }
        }

        private void OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem)
        {
            if (player == null || newItem == null || !player.userID.IsSteamId()) return;
            if (newItem.info.shortname == "chainsaw")
            {
                var chainsaw = newItem.GetHeldEntity() as Chainsaw;
                if (chainsaw == null) return;
                var permissionS = GetPermissionS(player);
                if (permissionS == null)
                {
                    chainsaw.maxAmmo = defaultMaxAmmo;
                    chainsaw.fuelPerSec = defaultFuelPerSec;
                    chainsaw.engineStartChance = defaultEngineStartChance;
                    return;
                }
                chainsaw.engineStartChance = permissionS.chance;
                chainsaw.maxAmmo = permissionS.maxAmmo;
                chainsaw.fuelPerSec = permissionS.fuelPerSec;
            }
        }

        private ConfigData.PermissionS GetPermissionS(BasePlayer player)
        {
            ConfigData.PermissionS permissionS = null;
            int priority = 0;
            foreach (var p in configData.permissionList)
            {
                if (permission.UserHasPermission(player.UserIDString, p.permission) && p.priority >= priority)
                {
                    priority = p.priority;
                    permissionS = p;
                }
            }
            return permissionS;
        }

        #region ConfigurationFile

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Permission List", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<PermissionS> permissionList = new List<PermissionS>
            {
                new PermissionS
                {
                    permission = "chainsawoptions.use",
                    priority = 0,
                    chance = 0.5f,
                    maxAmmo = 70,
                    fuelPerSec = 1,
                },
                new PermissionS
                {
                    permission = "chainsawoptions.vip",
                    priority = 1,
                    chance = 1f,
                    maxAmmo = 100,
                    fuelPerSec = 0.5f,
                },
            };

            public class PermissionS
            {
                [JsonProperty(PropertyName = "Permission")]
                public string permission;

                [JsonProperty(PropertyName = "Priority")]
                public int priority;

                [JsonProperty(PropertyName = "Engine Start Chance")]
                public float chance;

                [JsonProperty(PropertyName = "Max Ammo")]
                public int maxAmmo;

                [JsonProperty(PropertyName = "Fuel Per Seconds")]
                public float fuelPerSec;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                    LoadDefaultConfig();
            }
            catch
            {
                PrintError("The configuration file is corrupted");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        #endregion ConfigurationFile
    }
}

// --- End of file: ChainsawOptions.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/cupboard-for-friends ---
// --- Original File Path: C/CupboardForFriends/CupboardForFriends.cs ---

using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Cupboard for Friends", "LaserHydra", "2.0.0", ResourceId = 1578)]
    [Description("Only allow friends of already authorized people to authorize themselves.")]
    // New manteiner eKiSDe aka j0se
    class CupboardForFriends : RustPlugin
    {
        bool debug = false;
        bool blockDamage = false;

        bool adminByPass = true;

        [PluginReference]
        Plugin Clans, Friends;

        ////////////////////////////////////////
        ///     On Plugin Loaded
        ////////////////////////////////////////

        void Loaded()
        {
            LoadMessages();
            LoadConfig();

            if (Friends == null)
                PrintWarning($"Friends could not be found! Friends is an OPTIONAL addition for '{this.Title}'' to work! Get it here: http://oxidemod.org/plugins/686/");

            if (Clans == null)
                PrintWarning($"Clans could not be found! Clans is an OPTIONAL addition for '{this.Title}'! Get it here: http://oxidemod.org/plugins/842/");

            if (Config["Settings", "Block Damage"] != null)
                blockDamage = (bool)Config["Settings", "Block Damage"];

            if (Config["Settings", "Admin ByPass"] != null)
                adminByPass = (bool)Config["Settings", "Admin ByPass"];
        }

        ////////////////////////////////////////
        ///     Config & Message Loading
        ////////////////////////////////////////

        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Blocked Authorization", "You can not authorize yourself or clear the list of this cupboard as none of the authorized players has you on his friendlist! You can be added as friend by typing /friend add <your name>"},
                {"Blocked Damage", "You can not damage this cupboard as none of the authorized players has you on his friendlist! You can be added as friend by typing /friend add <your name>"}
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Blocked Authorization", "Tu no te puedes autorizar o borrar la lista porque no eres amigo o miembro del clan de los jugadores autorizados."},
                {"Blocked Damage", "Tu no te daar el armario porque no eres amigo o miembro del clan de los jugadores autorizados."}
            }, this, "es");
        }

        new void LoadConfig()
        {
            SetConfig("Settings", "Block Damage", true);
            SetConfig("Settings", "Admin ByPass", true);
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Generating new config file...");
        }

        ////////////////////////////////////////
        ///    Subject Related
        ////////////////////////////////////////

        void OnEntityTakeDamage(BaseCombatEntity vic, HitInfo info)
        {
            if (!blockDamage)
                return;

            if (vic != null && vic is BuildingPrivlidge && info != null && info?.Initiator != null && info?.Initiator?.ToPlayer() != null)
            {
                object blocked = TestForFriends((BuildingPrivlidge)vic, info.Initiator.ToPlayer(), true);
                info.damageTypes.Scale(Rust.DamageType.Heat, 0f);

                if (blocked != null)
                {
                    info?.damageTypes?.ScaleAll(0f);
                    info.HitBone = 0;
                    info.HitEntity = null;
                    info.material = new UnityEngine.PhysicMaterial();
                    info.DidHit = false;
                    info.DoHitEffects = false;

                    SendChatMessage(info.Initiator.ToPlayer(), GetMsg("Blocked Damage", info.Initiator.ToPlayer().UserIDString));
                }
            }
        }

        object OnCupboardClearList(BuildingPrivlidge priviledge, BasePlayer player) => TestForFriends(priviledge, player);

        object OnCupboardAuthorize(BuildingPrivlidge priviledge, BasePlayer player) => TestForFriends(priviledge, player);

        object TestForFriends(BuildingPrivlidge priviledge, BasePlayer player, bool isDamage = false)
        {
            DevMsg($"-------------------------------------------");
            DevMsg($"Any authed: {priviledge.AnyAuthed()}");

            if (adminByPass && player.IsAdmin)
                return null;

            if (priviledge.AnyAuthed())
            {
                bool isFriend = false;

                List<string> ids = (from id in priviledge.authorizedPlayers
                                    select id.userid.ToString()).ToList();

                foreach (string uid in ids)
                {
                    DevMsg($"------------------------");
                    DevMsg($"Current uid: {uid}");

                    if (IsFriend(player, uid))
                    {
                        DevMsg($"Found Friend: {uid}");
                        isFriend = true;
                    }
                    else if (Clans != null && IsClanMember(player, uid))
                    {
                        DevMsg($"Found Clanmember: {uid}");
                        isFriend = true;
                    }
                    else if (IsTeamMember(player, uid)) // comprobar si es del mismo team
                    {
                        DevMsg($"Found Teammember: {uid}");
                        isFriend = true;
                    }
                }

                DevMsg($"isFriend: {isFriend}");

                if (!isFriend)
                {
                    if (!isDamage)
                        SendChatMessage(player, GetMsg("Blocked Authorization", player.UserIDString));

                    return false;
                }
            }

            return null;
        }

        ////////////////////////////////////////
        ///     Friends API
        ////////////////////////////////////////

        bool IsFriend(BasePlayer player, string friendID)
        {
            if (Friends == null)
                return false;



            bool isFriend = (bool)(Friends.Call("HasFriendS", friendID, player.UserIDString) ?? false);

            DevMsg($"IsFriend({player}, {friendID})");
            DevMsg($"IsFriend: returning {isFriend}");

            return isFriend;
        }

        bool IsClanMember(BasePlayer player, string targetID)
        {
            if (Clans == null)
                return false;

            string playerClan = (string)Clans.Call("GetClanOf", player.UserIDString) ?? "";
            string targetClan = (string)Clans.Call("GetClanOf", targetID) ?? "";

            DevMsg($"{player.displayName}: '{playerClan}' (Length: {playerClan.Length}), {targetID}: '{targetClan}' (Length: {targetClan.Length})");

            bool isClanMember = (playerClan == "" || targetClan == "") ? false : playerClan == targetClan;

            DevMsg($"IsClanMember({player}, {targetID})");
            DevMsg($"IsClanMember: returning {isClanMember}");

            return isClanMember;
        }


        bool IsTeamMember(BasePlayer player, string targetID)
        {
            if (player.currentTeam != (long)0)
            {
                RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                if (playerTeam == null) return false;
                if (playerTeam.members.Contains(ulong.Parse(targetID))) return true; // long.Parse ??

            }
            return false;

        }

        ////////////////////////////////////////
        ///     Converting
        ////////////////////////////////////////

        string ListToString(List<string> list, int first, string seperator) => string.Join(seperator, list.Skip(first).ToArray());

        ////////////////////////////////////////
        ///     Config & Message Related
        ////////////////////////////////////////

        void SetConfig(params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList<string>();
            stringArgs.RemoveAt(args.Length - 1);

            if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args);
        }

        string GetMsg(string key, string userID = null) => lang.GetMessage(key, this, userID);

        ////////////////////////////////////////
        ///     Chat Handling
        ////////////////////////////////////////

        void DevMsg(string prefix, string msg = null)
        {
            if (debug && BasePlayer.FindByID(76561198008644030) != null)
                BasePlayer.FindByID(76561198008644030).ConsoleMessage(msg == null ? prefix : "<color=#00FF8D>" + prefix + "</color>: " + msg);
        }

        void SendChatMessage(BasePlayer player, string prefix, string msg = null) => SendReply(player, msg == null ? prefix : "<color=#00FF8D>" + prefix + "</color>: " + msg);
    }
}

// --- End of file: CupboardForFriends.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/clear-weather ---
// --- Original File Path: C/ClearWeather/ClearWeather.cs ---

using System;
using System.Collections.Generic;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Clear Weather", "Rick", "1.1.0")]
    [Description("Always clear weather")]

    public class ClearWeather : RustPlugin
    {
        void OnServerInitialized()
        {
            ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), "weather.load clear");
            ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), "weather.rain 0");
            ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), "weather.fog 0");
			ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), "weather.thunder 0");
            ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), "weather.storm_chance 0");
			ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), "weather.overcast_chance 0");
			ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), "weather.rain_chance 0");
        }

        void Unload()
        {
            ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), "weather.reset");
        }
    }
}

// --- End of file: ClearWeather.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/chest-stack-multiplier ---
// --- Original File Path: C/ChestStackMultiplier/ChestStackMultiplier.cs ---

using System.Collections.Generic;
using System.ComponentModel;

using Newtonsoft.Json;
using UnityEngine;

using Pool = Facepunch.Pool;

namespace Oxide.Plugins
{
    [Info("Chest Stack Multiplier", "MON@H", "1.6.1")]
    [Description("Higher stack sizes in storage containers.")]

    public class ChestStackMultiplier : RustPlugin
    {
        #region Variables

        private const string PermissionUseShift = "cheststackmultiplier.useshift";

        private static readonly object _true = true;

        private readonly Hash<ulong, float> _cacheMultipliers = new();
        private readonly HashSet<ulong> _cacheBackpackContainers = new();
        private readonly HashSet<ulong> _cacheBackpackEntities = new();
        private ItemContainer _targetContainer;
        private uint _backpackPrefabID;
        private uint _playerPrefabID;

        #endregion Variables

        #region Initialization

        private void Init() => HooksUnsubscribe();

        private void OnServerInitialized()
        {
            RegisterPermissions();
            CachePrefabIDs();
            CacheMultipliers();
            HooksSubscribe();
        }

        #endregion Initialization

        #region Configuration

        private PluginConfig _pluginConfig;

        public class PluginConfig
        {
            [JsonProperty(PropertyName = "Default Multiplier for new containers")]
            [DefaultValue(1f)]
            public float DefaultMultiplier { get; set; }

            [JsonProperty(PropertyName = "Containers list (PrefabName: multiplier)")]
            public SortedDictionary<string, float> ContainerMultipliers { get; set; }
        }

        protected override void LoadDefaultConfig() => PrintWarning("Loading Default Config");

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }

        public PluginConfig AdditionalConfig(PluginConfig config)
        {
            if (config.DefaultMultiplier <= 0)
            {
                PrintWarning("LoadConfig: Default Multiplier can't be less than or equal to 0, resetting to 1");
                config.DefaultMultiplier = 1f;
            }
            if (config.ContainerMultipliers == null)
            {
                config.ContainerMultipliers = new();
                foreach (ItemDefinition def in ItemManager.GetItemDefinitions())
                {
                    BoxStorage entity = def.GetComponent<ItemModDeployable>()?.entityPrefab.Get().GetComponent<BoxStorage>();
                    if (!entity || config.ContainerMultipliers.ContainsKey(entity.PrefabName))
                    {
                        continue;
                    }

                    config.ContainerMultipliers[entity.PrefabName] = config.DefaultMultiplier;
                }
            }

            List<string> invalidValues = Pool.GetList<string>();
            foreach (KeyValuePair<string, float> containerMultiplier in config.ContainerMultipliers)
            {
                if (containerMultiplier.Value > 0)
                {
                    continue;
                }

                PrintWarning($"LoadConfig: {containerMultiplier.Key} Multiplier can't be less than or equal to 0, resetting to default");
                invalidValues.Add(containerMultiplier.Key);
            }
            foreach (string invalidValue in invalidValues)
            {
                config.ContainerMultipliers[invalidValue] = config.DefaultMultiplier;
            }
            Pool.FreeList(ref invalidValues);
            return config;
        }

        #endregion Configuration

        #region Oxide Hooks

        private object OnMaxStackable(Item item)
        {
            if (item.info.stackable == 1 || item.info.itemType == ItemContainer.ContentsType.Liquid)
            {
                return null;
            }

            BaseEntity entity;

            if (_targetContainer != null)
            {
                entity = _targetContainer.GetEntityOwner() ?? _targetContainer.GetOwnerPlayer();
                if (entity.IsValid())
                {
                    _targetContainer = null;
                    float stackMultiplier = GetStackMultiplier(entity);
                    if (stackMultiplier == 1f)
                    {
                        return null;
                    }

                    return Mathf.FloorToInt(stackMultiplier * item.info.stackable);
                }
            }

            entity = item.GetEntityOwner() ?? item.GetOwnerPlayer();

            if (entity.IsValid())
            {
                float stackMultiplier;

                if (entity.prefabID == _playerPrefabID && !item.parent.HasFlag(ItemContainer.Flag.IsPlayer))
                {
                    stackMultiplier = _cacheMultipliers[_backpackPrefabID];
                }
                else
                {
                    stackMultiplier = GetStackMultiplier(entity);
                }

                if (stackMultiplier != 1f)
                {
                    return Mathf.FloorToInt(stackMultiplier * item.info.stackable);
                }
            }

            return null;
        }

        private object CanMoveItem(Item movedItem, PlayerInventory playerInventory, ItemContainerId targetContainerID, int targetSlot, int amount)
        {
            if (movedItem == null || playerInventory == null)
            {
                return null;
            }

            BasePlayer player = playerInventory.baseEntity;
            if (!player.IsValid())
            {
                return null;
            }

            BaseEntity sourceEntity = movedItem.GetEntityOwner() ?? movedItem.GetOwnerPlayer();
            if (IsExcluded(sourceEntity, player))
            {
                return null;
            }

            if (targetContainerID.Value == 0)
            {//Moving From Player Inventory
                if (sourceEntity == player)
                {
                    if (playerInventory.loot.containers.Count > 0)
                    {
                        targetContainerID.Value = playerInventory.loot.containers[0].uid.Value;
                        //Puts($"Moving item {movedItem} into looting container {targetContainerID}");
                    }
                    else
                    {
                        return null;
                        //targetContainerID = player.GetIdealContainer(player, movedItem, false);
                        //Puts($"Moving item {movedItem} to another player inventory container {targetContainerID}");
                    }
                }
                else if (sourceEntity == playerInventory.loot.entitySource)
                {
                    targetContainerID = playerInventory.containerMain.uid;
                    //Puts($"Moving item {movedItem} into player inventory from container {targetContainerID}");
                }
            }

            ItemContainer targetContainer = playerInventory.FindContainer(targetContainerID);
            if (targetContainer == null)
            {
                return null;
            }

            BaseEntity targetEntity = targetContainer.GetEntityOwner() ?? targetContainer.GetOwnerPlayer();

            if (sourceEntity == targetEntity || IsExcluded(targetEntity, player))
            {

                return null;
            }

            ItemContainer lootContainer = playerInventory.loot?.FindContainer(targetContainerID);
            _targetContainer = targetContainer;

            //Puts($"TargetSlot {targetSlot} Amount {amount} TargetContainer {targetContainerID}");
            // Right-Click Overstack into Player Inventory
            if (targetSlot == -1)
            {
                if (lootContainer == null)
                {
                    if (movedItem.amount > movedItem.info.stackable)
                    {
                        int loops = 1;
                        if (IsUsingShift(player))
                        {
                            loops = Mathf.CeilToInt((float)movedItem.amount / movedItem.info.stackable);
                        }
                        for (int i = 0; i < loops; i++)
                        {
                            if (movedItem.amount <= movedItem.info.stackable)
                            {
                                if (targetContainer != null)
                                {
                                    movedItem.MoveToContainer(targetContainer);
                                }
                                else
                                {
                                    playerInventory.GiveItem(movedItem);
                                }
                                break;
                            }
                            Item itemToMove = movedItem.SplitItem(movedItem.info.stackable);
                            bool moved;

                            if (targetContainer != null)
                            {
                                moved = itemToMove.MoveToContainer(targetContainer, targetSlot);
                            }
                            else
                            {
                                moved = playerInventory.GiveItem(itemToMove);
                            }
                            if (moved == false)
                            {
                                movedItem.amount += itemToMove.amount;
                                itemToMove.Remove();
                                break;
                            }
                            movedItem?.MarkDirty();
                        }
                        playerInventory.ServerUpdate(0f);
                        return _true;
                    }
                }
                // Shift Right click into storage container
                else
                {
                    if (IsUsingShift(player))
                    {
                        //Puts($"Shift Right click into storage container {lootContainer}");
                        List<Item> itemsToMove = Pool.GetList<Item>();
                        int i = 0;
                        foreach (Item item in playerInventory.containerMain.itemList)
                        {
                            if (item.info.itemid == movedItem.info.itemid && item != movedItem)
                            {
                                itemsToMove.Add(item);
                            }
                        }
                        foreach (Item item in playerInventory.containerBelt.itemList)
                        {
                            if (item.info.itemid == movedItem.info.itemid && item != movedItem)
                            {
                                itemsToMove.Add(item);
                            }
                        }
                        foreach (Item item in itemsToMove)
                        {
                            if (!item.MoveToContainer(lootContainer))
                            {
                                break;
                            }
                            i++;
                        }
                        Pool.FreeList(ref itemsToMove);
                        if (i > 0)
                        {
                            playerInventory.ServerUpdate(0f);
                            return null;
                        }
                    }
                }
            }
            // Moving Overstacks Around In Chest
            if (amount > movedItem.info.stackable && lootContainer != null)
            {
                Item targetItem = targetContainer.GetSlot(targetSlot);
                if (targetItem == null)
                {// Split item into chest
                    if (amount < movedItem.amount)
                    {
                        ItemHelper.SplitMoveItem(movedItem, amount, targetContainer, targetSlot);
                    }
                    else
                    {// Moving items when amount > info.stacksize
                        movedItem.MoveToContainer(targetContainer, targetSlot);
                    }
                }
                else
                {
                    if (!targetItem.CanStack(movedItem) && amount == movedItem.amount)
                    {// Swapping positions of items
                        ItemHelper.SwapItems(movedItem, targetItem);
                    }
                    else
                    {
                        if (amount < movedItem.amount)
                        {
                            ItemHelper.SplitMoveItem(movedItem, amount, playerInventory);
                        }
                        else
                        {
                            movedItem.MoveToContainer(targetContainer, targetSlot);
                        }
                        // Stacking items when amount > info.stacksize
                    }
                }
                playerInventory.ServerUpdate(0f);
                return _true;
            }
            // Prevent Moving Overstacks To Inventory
            if (lootContainer != null)
            {
                Item targetItem = targetContainer.GetSlot(targetSlot);
                if (targetItem != null)
                {
                    if (movedItem.GetOwnerPlayer() == player)
                    {
                        if (!movedItem.CanStack(targetItem))
                        {
                            if (targetItem.amount > targetItem.info.stackable)
                            {
                                return _true;
                            }
                        }
                    }
                }
            }

            return null;
        }

        // Covers dropping overstacks from chests onto the ground
        private void OnItemDropped(Item item, BaseEntity entity)
        {
            if (item == null || !entity.IsValid())
            {
                return;
            }

            item.RemoveFromContainer();
            int stackSize = item.MaxStackable();

            if (item.amount > stackSize)
            {
                int loops = Mathf.FloorToInt((float)item.amount / stackSize);
                if (loops > 20)
                {
                    return;
                }

                for (int i = 0; i < loops; i++)
                {
                    if (item.amount <= stackSize)
                    {
                        break;
                    }

                    Item splitItem = item.SplitItem(stackSize);
                    splitItem?.Drop(entity.transform.position, entity.GetDropVelocity() + Vector3Ex.Range(-1f, 1f));
                }
            }
        }

        private void OnBackpackOpened(BasePlayer player, ulong backpackOwnerID, ItemContainer backpackContainer)
        {
            try
            {
                if (backpackContainer != null && !_cacheBackpackContainers.Contains(backpackContainer.uid.Value))
                {
                    CacheAddBackpack(backpackContainer);
                }
            }
            catch (System.Exception ex)
            {
                PrintError($"OnBackpackOpened threw exception\n:{ex}");
                throw;
            }
        }

        #endregion Oxide Hooks

        #region Core Methods

        public void CachePrefabIDs()
        {
            _playerPrefabID = StringPool.Get("assets/prefabs/player/player.prefab");

            if (!_pluginConfig.ContainerMultipliers.ContainsKey("Backpack"))
            {
                _pluginConfig.ContainerMultipliers["Backpack"] = _pluginConfig.DefaultMultiplier;
                Config.WriteObject(_pluginConfig);
            }

            _backpackPrefabID = StringPool.closest;
            while (StringPool.toString.ContainsKey(_backpackPrefabID))
            {
                _backpackPrefabID++;
            }
        }

        public void CacheMultipliers()
        {
            foreach (KeyValuePair<string, float> container in _pluginConfig.ContainerMultipliers)
            {
                if (container.Key == "Backpack")
                {
                    _cacheMultipliers[_backpackPrefabID] = _pluginConfig.ContainerMultipliers["Backpack"];
                }
                else
                {
                    uint id = StringPool.Get(container.Key);

                    if (id > 0)
                    {
                        _cacheMultipliers[id] = container.Value;
                    }
                }
            }
        }

        public void CacheAddBackpack(ItemContainer itemContainer)
        {
            BaseEntity baseEntity = itemContainer.GetEntityOwner();

            if (baseEntity.IsValid() && !_cacheBackpackEntities.Contains(baseEntity.net.ID.Value))
            {
                _cacheBackpackContainers.Add(itemContainer.uid.Value);
                _cacheBackpackEntities.Add(baseEntity.net.ID.Value);
            }
        }

        public bool IsExcluded(BaseEntity entity, BasePlayer player) => !entity.IsValid() || entity.HasFlag(BaseEntity.Flags.Locked) || entity is BigWheelBettingTerminal || entity is ShopFront || entity is VendingMachine vendingMachine && !vendingMachine.PlayerBehind(player);

        public bool IsUsingShift(BasePlayer player) => permission.UserHasPermission(player.UserIDString, PermissionUseShift) && player.serverInput.IsDown(BUTTON.SPRINT);

        public class ItemHelper
        {
            public static bool SplitMoveItem(Item item, int amount, ItemContainer targetContainer, int targetSlot)
            {
                Item splitItem = item.SplitItem(amount);
                if (splitItem == null)
                {
                    return false;
                }

                if (!splitItem.MoveToContainer(targetContainer, targetSlot))
                {
                    item.amount += splitItem.amount;
                    splitItem.Remove();
                }

                return true;
            }

            public static bool SplitMoveItem(Item item, int amount, PlayerInventory inventory)
            {
                Item splitItem = item.SplitItem(amount);
                if (splitItem == null)
                {
                    return false;
                }

                if (!inventory.GiveItem(splitItem))
                {
                    item.amount += splitItem.amount;
                    splitItem.Remove();
                }

                return true;
            }

            public static void SwapItems(Item item1, Item item2)
            {
                ItemContainer container1 = item1.parent;
                ItemContainer container2 = item2.parent;
                int slot1 = item1.position;
                int slot2 = item2.position;
                item1.RemoveFromContainer();
                item2.RemoveFromContainer();
                item1.MoveToContainer(container2, slot2);
                item2.MoveToContainer(container1, slot1);
            }
        }

        public float GetStackMultiplier(BaseEntity entity)
        {
            switch (entity)
            {
                case LootContainer:
                case BaseCorpse:
                case BasePlayer:
                    return 1f;
            }

            if (_cacheBackpackEntities.Contains(entity.net.ID.Value))
            {
                return _cacheMultipliers[_backpackPrefabID];
            }

            float multiplier = _cacheMultipliers[entity.prefabID];
            if (multiplier == 0)
            {
                if (!_pluginConfig.ContainerMultipliers.TryGetValue(entity.PrefabName, out multiplier))
                {
                    multiplier = _pluginConfig.DefaultMultiplier;
                    _pluginConfig.ContainerMultipliers[entity.PrefabName] = multiplier;
                    Config.WriteObject(_pluginConfig);
                }
                _cacheMultipliers[entity.prefabID] = multiplier;
            }

            return multiplier;
        }

        #endregion Core Methods

        #region Helpers

        public void HooksUnsubscribe()
        {
            Unsubscribe(nameof(CanMoveItem));
            Unsubscribe(nameof(OnBackpackOpened));
            Unsubscribe(nameof(OnItemDropped));
            Unsubscribe(nameof(OnMaxStackable));
        }

        public void HooksSubscribe()
        {
            Subscribe(nameof(CanMoveItem));
            Subscribe(nameof(OnBackpackOpened));
            Subscribe(nameof(OnItemDropped));
            Subscribe(nameof(OnMaxStackable));
        }

        public void RegisterPermissions() => permission.RegisterPermission(PermissionUseShift, this);

        #endregion Helpers
    }
}

// --- End of file: ChestStackMultiplier.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/custom-animal-spawns ---
// --- Original File Path: C/CustomAnimalSpawns/CustomAnimalSpawns.cs ---

using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.SceneManagement;

namespace Oxide.Plugins
{
    [Info("CustomAnimalSpawns", "k1lly0u", "0.1.56")]
    [Description("Creates additional spawn points for animals of your choosing, that re-spawn on a timer")]
    class CustomAnimalSpawns : RustPlugin
    {
        #region Fields
        private CASData casData;
        private DynamicConfigFile casdata;

        private List<BaseEntity> animalCache = new List<BaseEntity>();
        private List<Timer> refreshTimers = new List<Timer>();
        private Dictionary<ulong, int> animalCreators = new Dictionary<ulong, int>();

        private Dictionary<int, string> animalTypes = new Dictionary<int, string>
        {
            {0, "assets/rust.ai/agents/zombie/zombie.prefab" },
            {1, "assets/rust.ai/agents/bear/bear.prefab" },
            {2, "assets/rust.ai/agents/boar/boar.prefab" },
            {3, "assets/rust.ai/agents/chicken/chicken.prefab" },
            {4, "assets/rust.ai/agents/horse/horse.prefab" },
            {5, "assets/rust.ai/agents/stag/stag.prefab" },
            {6, "assets/rust.ai/agents/wolf/wolf.prefab" },
            {7, "assets/rust.ai/nextai/testridablehorse.prefab" }
        };
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            permission.RegisterPermission("customanimalspawns.admin", this);
            lang.RegisterMessages(messages, this);
            casdata = Interface.Oxide.DataFileSystem.GetFile("CustomSpawns/cas_data");
            casdata.Settings.Converters = new JsonConverter[] { new StringEnumConverter(), new UnityVector3Converter() };
        }

        private void OnServerInitialized()
        {
            LoadVariables();
            LoadData();
            InitializeAnimalSpawns();
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null)
                return;

            if (entity.GetComponent<BaseNpc>() != null)
            {
                if (animalCache.Contains(entity as BaseEntity))
                {
                    UnityEngine.Object.Destroy(entity.GetComponent<NPCController>());
                    InitiateRefresh(entity as BaseEntity);
                }
            }
        }
        private void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (animalCreators.ContainsKey(player.userID))
                if (input.WasJustPressed(BUTTON.FIRE_PRIMARY))
                {
                    int type = animalCreators[player.userID];
                    AddSpawn(player, type);
                }
        }
        private void Unload()
        {
            foreach (Timer time in refreshTimers)
                time.Destroy();

            foreach (BaseEntity animal in animalCache)
            {
                if (animal != null)
                {
                    UnityEngine.Object.Destroy(animal.GetComponent<NPCController>());
                    animal.KillMessage();
                }
            }

            NPCController[] objects = UnityEngine.Object.FindObjectsOfType<NPCController>();
            if (objects != null)
            {
                foreach (var gameObj in objects)
                    UnityEngine.Object.Destroy(gameObj);
            }

            animalCache.Clear();
        }
        #endregion

        #region Resource Control
        private void InitializeAnimalSpawns()
        {
            foreach (CLAnimal resource in casData.animals)
            {
                InitializeNewSpawn(resource.Type, resource.Position);
            }
        }

        private void InitiateRefresh(BaseEntity resource)
        {
            Vector3 position = resource.transform.position;

            refreshTimers.Add(timer.Once(configData.RespawnTimer * 60, () =>
            {
                InitializeNewSpawn(resource.PrefabName, position);
            }));

            animalCache.Remove(resource);
        }

        private void InitializeNewSpawn(string type, Vector3 position) => SpawnAnimalEntity(type, position);

        private Vector3 SpawnAnimalEntity(string type, Vector3 pos)
        {
            Vector3 point;
            if (FindPointOnNavmesh(pos, 1, out point))
            {
                BaseEntity entity = InstantiateEntity(type, point);
                entity.enableSaving = false;
                entity.Spawn();

                if (!(entity is RidableHorse))
                {
                    NPCController npc = entity.gameObject.AddComponent<NPCController>();
                    npc.SetHome(point);
                }

                animalCache.Add(entity);
                return point;
            }
            return Vector3.zero;
        }

        private BaseEntity InstantiateEntity(string type, Vector3 position)
        {
            GameObject gameObject = Instantiate.GameObject(GameManager.server.FindPrefab(type), position, new Quaternion());
            gameObject.name = type;

            SceneManager.MoveGameObjectToScene(gameObject, Rust.Server.EntityScene);

            UnityEngine.Object.Destroy(gameObject.GetComponent<Spawnable>());

            if (!gameObject.activeSelf)
                gameObject.SetActive(true);

            BaseEntity component = gameObject.GetComponent<BaseEntity>();
            return component;
        }

        private bool FindPointOnNavmesh(Vector3 center, float range, out Vector3 result)
        {
            for (int i = 0; i < 30; i++)
            {
                Vector3 randomPoint = center + UnityEngine.Random.insideUnitSphere * range;
                NavMeshHit hit;
                if (NavMesh.SamplePosition(randomPoint, out hit, 50f, NavMesh.AllAreas))
                {                    
                    result = hit.position;
                    return true;
                }
            }
            result = Vector3.zero;
            return false;
        }

        private class NPCController : MonoBehaviour
        {
            public BaseNpc npc;
            private Vector3 homePos;

            private void Awake()
            {
                npc = GetComponent<BaseNpc>();
                enabled = false;
            }

            private void OnDestroy()
            {
                InvokeHandler.CancelInvoke(this, CheckLocation);
            }

            public void SetHome(Vector3 homePos)
            {
                this.homePos = homePos;
                InvokeHandler.InvokeRepeating(this, CheckLocation, 1f, 20f);
            }

            private void CheckLocation()
            {
                if (Vector3.Distance(npc.transform.position, homePos) > 100)
                {
                    npc.UpdateDestination(homePos);
                }
            }
        }

        #endregion

        #region Animal Spawning
        private void AddSpawn(BasePlayer player, int type)
        {
            string animal = animalTypes[type];
            Vector3 pos = GetSpawnPos(player);
            pos = SpawnAnimalEntity(animal, pos);
            if (pos != Vector3.zero)
            {
                casData.animals.Add(new CLAnimal { Position = pos, Type = animal });
                SaveData();
            }            
        }        
        #endregion

        #region Helper Methods  
        private Vector3 GetSpawnPos(BasePlayer player)
        {
            Vector3 closestHitpoint;
            Vector3 sourceEye = player.transform.position + new Vector3(0f, 1.5f, 0f);
            Quaternion currentRot = Quaternion.Euler(player.serverInput.current.aimAngles);
            Ray ray = new Ray(sourceEye, currentRot * Vector3.forward);

            RaycastHit[] hits = Physics.RaycastAll(ray);
            float closestdist = 999999f;
            closestHitpoint = player.transform.position;
            foreach (RaycastHit hit in hits)
            {
                if (hit.collider.GetComponentInParent<TriggerBase>() == null)
                {
                    if (hit.distance < closestdist)
                    {
                        closestdist = hit.distance;
                        closestHitpoint = hit.point;
                    }
                }
            }
            return closestHitpoint;
        }  
        
        private List<Vector3> FindInRadius(Vector3 pos, float rad)
        {
            List<Vector3> foundResources = new List<Vector3>();
            foreach (CLAnimal item in casData.animals)
            {
                Vector3 itemPos = item.Position;
                if (GetDistance(pos, itemPos) < rad)
                {
                    foundResources.Add(itemPos);
                }
            }
            return foundResources;
        }       
        private bool RemoveFromData(Vector3 pos)
        {
            foreach (CLAnimal resource in casData.animals)
            {
                if (GetDistance(pos, resource.Position) < 1)
                {
                    casData.animals.Remove(resource);
                    return true;
                }
            }
            return false;
        }

        private float GetDistance(Vector3 v3, Vector3 v32) => Vector3.Distance(v3, v32);

        private void ShowAnimalList(BasePlayer player)
        {
            foreach (KeyValuePair<int, string> entry in animalTypes)
                SendEchoConsole(player.net.connection, string.Format("{0} - {1}", entry.Key, entry.Value));
        }

        private void ShowCurrentAnimals(BasePlayer player)
        {
            foreach (CLAnimal resource in casData.animals)
                SendEchoConsole(player.net.connection, string.Format("{0} - {1}", resource.Position, resource.Type));
        }

        private void SendEchoConsole(Network.Connection cn, string msg)
        {
            if (Network.Net.sv.IsConnected())
            {
                Network.Net.sv.write.Start();
                Network.Net.sv.write.PacketID(Network.Message.Type.ConsoleMessage);
                Network.Net.sv.write.String(msg);
                Network.Net.sv.write.Send(new Network.SendInfo(cn));
            }
        }
        #endregion

        #region Chat Commands
        [ChatCommand("cas")]
        private void chatAnimalSpawn(BasePlayer player, string command, string[] args)
        {
            if (!CanSpawnAnimals(player))
                return;

            if (animalCreators.ContainsKey(player.userID))
            {
                animalCreators.Remove(player.userID);
                SendMSG(player, lang.GetMessage("endAdd", this, player.UserIDString));
                return;
            }

            if (args.Length == 0)
            {
                SendReply(player, lang.GetMessage("synAdd", this, player.UserIDString));
                SendReply(player, lang.GetMessage("synNear", this, player.UserIDString));
                SendReply(player, lang.GetMessage("synRemNear", this, player.UserIDString));
                SendReply(player, lang.GetMessage("synList", this, player.UserIDString));
                SendReply(player, lang.GetMessage("synAnimal", this, player.UserIDString));
                SendReply(player, lang.GetMessage("synWipe", this, player.UserIDString));
                return;
            }

            if (args.Length >= 1)
            {
                switch (args[0].ToLower())
                {
                    case "add":
                        {
                            int type;
                            if (!int.TryParse(args[1], out type))
                            {
                                SendMSG(player, MSG("notNum", player.UserIDString));
                                return;
                            }
                            if (animalTypes.ContainsKey(type))
                            {
                                animalCreators.Add(player.userID, type);
                                SendMSG(player, MSG("adding", player.UserIDString));
                                return;
                            }
                            SendMSG(player, MSG("notType", player.UserIDString));
                        }
                        return;
                    case "remove":
                        {
                            if (args.Length >= 2 && args[1].ToLower() == "near")
                            {
                                float rad = 10f;
                                if (args.Length == 3) float.TryParse(args[2], out rad);

                                List<Vector3> animals = FindInRadius(player.transform.position, rad);
                                if (animals != null)
                                {
                                    int i = 0;
                                    for (int n = 0; n < animals.Count; n++)
                                    {
                                        RemoveFromData(animals[i]);
                                        i++;
                                    }
                                    SaveData();
                                    SendMSG(player, string.Format(MSG("removedNear", player.UserIDString), i, rad));
                                    return;
                                }
                                else
                                    SendMSG(player, string.Format(MSG("noFind", player.UserIDString), rad.ToString()));
                                return;
                            }
                        }
                        return;
                    case "list":
                        ShowCurrentAnimals(player);
                        SendMSG(player, MSG("checkConsole", player.UserIDString));
                        return;
                    case "animals":
                        ShowAnimalList(player);
                        SendMSG(player, MSG("checkConsole", player.UserIDString));
                        return;
                    case "near":
                        {
                            float rad = 10f;
                            if (args.Length == 2) float.TryParse(args[1], out rad);

                            List<Vector3> animals = FindInRadius(player.transform.position, rad);
                            if (animals != null)
                            {
                                SendMSG(player, string.Format(MSG("foundResources", player.UserIDString), animals.Count.ToString()));
                                foreach (Vector3 resource in animals)
                                    player.SendConsoleCommand("ddraw.box", 10f, Color.magenta, resource, 1f);
                            }
                            else
                                SendMSG(player, string.Format(MSG("noFind", player.UserIDString), rad.ToString()));
                        }
                        return;
                    case "wipe":
                        {
                            foreach (BaseEntity resource in animalCache)
                            {
                                resource.KillMessage();
                            }
                            casData.animals.Clear();
                            SaveData();
                            SendMSG(player, string.Format(MSG("wipedAll1", player.UserIDString), casData.animals.Count));
                        }
                        return;
                    default:
                        break;
                }
            }
        }

        private bool CanSpawnAnimals(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "customanimalspawns.admin")) return true;
            SendMSG(player, MSG("noPerms", player.UserIDString));
            return false;
        }
        #endregion

        #region Config        
        private ConfigData configData;

        private class ConfigData
        {
            public int RespawnTimer { get; set; }
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            ConfigData config = new ConfigData
            {
                RespawnTimer = 20
            };
            SaveConfig(config);
        }

        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();

        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Data Management
        private void SaveData() => casdata.WriteObject(casData);

        private void LoadData()
        {
            try
            {
                casData = casdata.ReadObject<CASData>();
            }
            catch
            {
                casData = new CASData();
            }
        }

        private class CASData
        {
            public List<CLAnimal> animals = new List<CLAnimal>();
        }
        #endregion

        #region Classes
        private class CLAnimal
        {
            public string Type;
            public Vector3 Position;
        }

        private class UnityVector3Converter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                Vector3 vector = (Vector3)value;
                writer.WriteValue($"{vector.x} {vector.y} {vector.z}");
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.String)
                {
                    string[] values = reader.Value.ToString().Trim().Split(' ');
                    return new Vector3(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]));
                }
                JObject o = JObject.Load(reader);
                return new Vector3(Convert.ToSingle(o["x"]), Convert.ToSingle(o["y"]), Convert.ToSingle(o["z"]));
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Vector3);
            }
        }
        #endregion

        #region Messaging
        private void SendMSG(BasePlayer player, string message) => SendReply(player, $"<color=orange>{Title}:</color> <color=#939393>{message}</color>");

        private string MSG(string key, string playerid = null) => lang.GetMessage(key, this, playerid);

        private Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"checkConsole", "Check your console for a list of animals" },
            {"noPerms", "You do not have permission to use this command" },
            {"notType", "The number you have entered is not on the list" },
            {"notNum", "You must enter a animal number" },
            {"notBox", "You are not looking at a animal" },
            {"notReg", "This is not a custom placed animal" },
            {"RemovedAnimal", "Resource deleted" },
            {"synAdd", "<color=orange>/cas add id </color><color=#939393>- Adds a new animal spawn</color>" },
            {"synRem", "<color=orange>/cas remove </color><color=#939393>- Remove the animal you are looking at</color>" },
            {"synRemNear", "<color=orange>/cas remove near <radius> </color><color=#939393>- Removes the animal spawns within <radius> (default 10M)</color>" },
            {"synAnimal", "<color=orange>/cas animals </color><color=#939393>- List available animal types and their ID</color>" },
            {"synWipe", "<color=orange>/cas wipe </color><color=#939393>- Wipes all custom placed animal spawns</color>" },
            {"synList", "<color=orange>/cas list </color><color=#939393>- Puts all animal spawn details to console</color>" },
            {"synNear", "<color=orange>/cas near XX </color><color=#939393>- Shows custom animal spawns in radius XX</color>" },
            {"wipedAll1", "Wiped {0} custom animal spawns" },
            {"foundResources", "Found {0} animal spawns near you"},
            {"noFind", "Couldn't find any animal spawns in radius: {0}M" },
            {"adding", "You have activated the animal tool. Look where you want to place and press shoot. Type /crs to end" },
            {"endAdd", "You have de-activated the animal tool" },
            {"removedNear", "Removed {0} animal spawns within a {1}M radius of your position" }
        };

        #endregion
    }
}

// --- End of file: CustomAnimalSpawns.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/clan-tags ---
// --- Original File Path: C/ClanTags/ClanTags.cs ---

// Requires: BetterChat

using System;
using Oxide.Core;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Clan Tags", "klauz24", "1.0.2"), Description("Adds clan tag support for Better Chat")]
    internal class ClanTags : CovalencePlugin
    {
        [PluginReference] readonly Plugin BetterChat, Clans, HWClans;

        private Configuration _config;

        private Dictionary<string, string> _customClanTagColors;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Permission")]
            public string Permission = "clantags.color";

            [JsonProperty(PropertyName = "Default clan tag color")]
            public string DefaultClanTagColor = "#00ff00";

            [JsonProperty(PropertyName = "Formatting")]
            public string Formatting = "<color={color}>[{clanTag}]</color>";

            [JsonProperty(PropertyName = "Incompatible plugins (Plugin name, Author)")]
            public Dictionary<string, string> IncompatiblePlugins = new Dictionary<string, string>()
            {
                {"Clans", "k1lly0u"},
                {"Rust:IO Clans", "playrust.io / dcode"}
            };

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (!_config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    Puts("Configuration appears to be outdated; updating and saving.");
                    SaveConfig();
                }
            }
            catch
            {
                Puts($"Configuration file {Name}.json is invalid; using defaults.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config, true);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Syntax", "Syntax: /clancol <hex>."},
                {"Invalid", "Invalid HEX color code. (Ex: {0})" },
                {"New", "You have setup a new color for your clan tag."},
                {"NoPerm", "You do not have permission to use this command."}
            }, this);
        }

        [Command("clancol")]
        private void ClanColorCommand(IPlayer player, string command, string[] args)
        {
            if (permission.UserHasPermission(player.Id, _config.Permission))
            {
                if (args.Length == 0)
                {
                    player.Message(GetLang(player, "Syntax"));
                }
                else
                {
                    var newColor = args[0];
                    if (newColor.StartsWith("#"))
                    {
                        if (_customClanTagColors.ContainsKey(player.Id))
                        {
                            _customClanTagColors[player.Id] = newColor;
                        }
                        else
                        {
                            _customClanTagColors.Add(player.Id, newColor);
                        }
                        player.Message(GetLang(player, "New"));
                        Interface.Oxide.DataFileSystem.WriteObject("CustomClanTagColors", _customClanTagColors);
                    }
                    else
                    {
                        player.Message(string.Format(GetLang(player, "Invalid"), _config.DefaultClanTagColor));
                    }
                }
            }
            else
            {
                player.Message(GetLang(player, "NoPerm"));
            }
        }

        private void Init()
        {
            permission.RegisterPermission(_config.Permission, this);
            try
            {
                _customClanTagColors = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, string>>("CustomClanTagColors");
            }
            catch
            {
                _customClanTagColors = new Dictionary<string, string>();
            }
        }

        private void OnPluginLoaded()
        {
            foreach(var plugin in Manager.GetPlugins().ToArray())
            {
                if (plugin != null && IsIncompatiblePlugin(plugin))
                {
                    PrintWarning($"{plugin.Name} is not compatible with this plugin as it already provides clan tags through Better Chat.");
                    Interface.Oxide.UnloadPlugin(this.Name);
                }
            }
            BetterChat.CallHook("API_RegisterThirdPartyTitle", this, new Func<IPlayer, string>(GetClanTag));
        }

        private bool IsIncompatiblePlugin(Plugin plugin)
        {
            foreach (var kvp in _config.IncompatiblePlugins)
            {
                if ((plugin.Name == kvp.Key) && (plugin.Author == kvp.Value))
                {
                    return true;
                }
            }
            return false;
        }

        private string GetClanTag(IPlayer player)
        {
            var clansTag = GetClansTag(player.Id);
            if (clansTag != null)
            {
                return GetFormattedTag(player.Id, clansTag);
            }
#if HURTWORLD
            else
            {
                var session = player.Object as PlayerSession;
                var hwClansTag = GetHWClansTag(session);
                if (hwClansTag != null)
                {
                    return GetFormattedTag(player.Id, hwClansTag);
                }
                else
                {
                    var nativeClansTag = GetNativeClansTag(session);
                    if (nativeClansTag != null)
                    {
                        return GetFormattedTag(player.Id, nativeClansTag);
                    }
                }
            }
#endif
            return null;
        }

        private string GetClanTagColor(string id)
        {
            if (_customClanTagColors.ContainsKey(id))
            {
                return _customClanTagColors[id];
            }
            else
            {
                return _config.DefaultClanTagColor;
            }
        }

        private string GetFormattedTag(string id, string clanTag) => _config.Formatting.Replace("{color}", GetClanTagColor(id)).Replace("{clanTag}", clanTag);

        private string GetClansTag(string id) => Clans?.Call<string>("GetClanOf", id);

        private string GetLang(IPlayer player, string str) => lang.GetMessage(str, this, player.Id);

#if HURTWORLD
        private string GetHWClansTag(PlayerSession session) => HWClans?.Call<string>("getClanTag", session);
        
        private string GetNativeClansTag(PlayerSession session) => session.Identity.Clan != null ? session.Identity.Clan.ClanTag : null;
#endif
    }
}

// --- End of file: ClanTags.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/claymore ---
// --- Original File Path: C/Claymore/Claymore.cs ---

using System;
using System.Linq;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;
using Rust;

namespace Oxide.Plugins
{
    [Info("Claymore", "wazzzup", "1.0.0")]
    [Description("Converts land mines to Claymore antipersonnel mines")]
    public class Claymore : RustPlugin
    {
        [PluginReference] Plugin Friends;

        public static Claymore instance;

        protected override void LoadDefaultConfig()
        {
            PrintWarning("New configuration file created");
            Config.Clear();
            LoadVariables();
        }

        private float playerDetectRadius;
        private float minExplosionDistance;
        private float maxExplosionDistance;
        private bool configChanged = false;

        void LoadVariables()
        {
            playerDetectRadius = Convert.ToSingle(GetConfig("playerDetectRadius", 3f));
            minExplosionDistance = Convert.ToSingle(GetConfig("minExplosionDistance", 2f));
            maxExplosionDistance = Convert.ToSingle(GetConfig("maxExplosionDistance", 4f));
            if (configChanged)
            {
                SaveConfig();
                configChanged = false;
            }
        }

        private object GetConfig(string dataValue, object defaultValue)
        {
            object value = Config[dataValue];
            if (value == null)
            {
                value = defaultValue;
                Config[dataValue] = value;
                configChanged = true;
            }
            return value;
        }

        public class ClaymoreTrigger: MonoBehaviour
        {
            ulong ownerID;

            void Awake()
            {
                ownerID = this.GetComponentInParent<BaseEntity>().OwnerID;
                gameObject.layer = (int)Layer.Reserved1;
                gameObject.name = "Claymore";

                var landmine = this.GetComponentInParent<Landmine>();
                landmine.minExplosionRadius = instance.minExplosionDistance;
                landmine.explosionRadius = instance.maxExplosionDistance;

                var sphereCollider = gameObject.AddComponent<SphereCollider>();
                sphereCollider.isTrigger = true;
                sphereCollider.radius = instance.playerDetectRadius;
            }

            private void OnTriggerEnter(Collider col)
            {
                var target = col.GetComponentInParent<BasePlayer>();
                if (target != null)
                {
                    if (target.userID == ownerID) return;
                    else if (Convert.ToBoolean(instance.Friends?.CallHook("AreFriends", target.userID, ownerID))) return;
                    this.GetComponentInParent<Landmine>().Explode();
                }
            }
        }

        void Init()
        {
            instance = this;
            LoadVariables();
        }

        void OnServerInitialized()
        {
            foreach (var ent in UnityEngine.Object.FindObjectsOfType<Landmine>())
            {
                ent.gameObject.AddComponent<ClaymoreTrigger>();
            }
        }

        private void Unload()
        {
            foreach (var ent in UnityEngine.Object.FindObjectsOfType<ClaymoreTrigger>())
            {
                UnityEngine.Object.Destroy(ent);
            }
        }

        void OnEntityBuilt(Planner plan, GameObject obj)
        {
            if (obj == null || obj.GetComponentInParent<Landmine>() == null) return;
            obj.AddComponent<ClaymoreTrigger>();
        }

        object OnTrapTrigger(BaseTrap trap, GameObject obj)
        {
            if (trap is Landmine)
            {
                BasePlayer target = obj.GetComponent<BasePlayer>();
                if (target)
                {
                    if (target.userID == trap.OwnerID)
                        return false;
                    else if (Convert.ToBoolean(Friends?.CallHook("AreFriends", target.userID, trap.OwnerID)))
                        return false;
                }
            }
            return null;
        }

    }
}


// --- End of file: Claymore.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/cupboard-no-decay ---
// --- Original File Path: C/CupboardNoDecay/CupboardNoDecay.cs ---

using System;
using Rust;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using Facepunch;

namespace Oxide.Plugins
{
    [Info("CupboardNoDecay", "Rick", "1.3.0")]
    [Description("Use cupboard to protect from decay without consuming resources.")]
    public class CupboardNoDecay : RustPlugin
    {
        private ConfigData configData;

        void OnServerInitialized()
        {
            LoadVariables();
        }

        #region config
        private class ConfigData
        {
            public bool CheckAuth { get; set; }
            public bool DecayTwig { get; set; }
            public bool DecayWood { get; set; }
            public bool DecayStone { get; set; }
            public bool DecayMetal { get; set; }
            public bool DecayArmor { get; set; }
            public float TwigRate { get; set; }
            public float WoodRate { get; set; }
            public float StoneRate { get; set; }
            public float MetalRate { get; set; }
            public float ArmorRate { get; set; }
            public float EntityRadius { get; set; }
            public string[] NeverDecay { get; set; }
        }

        protected override void LoadDefaultConfig()
        {
            string[] never = { "RHIB", "Rowboat", "HotAirBalloon", "minicopter.entity" };

            SaveConfig(new ConfigData
            {
                CheckAuth = false,
                DecayTwig = true,
                DecayWood = false,
                DecayStone = false,
                DecayMetal = false,
                DecayArmor = false,
                TwigRate = 1.0f,
                WoodRate = 0.0f,
                StoneRate = 0.0f,
                MetalRate = 0.0f,
                ArmorRate = 0.0f,
                EntityRadius = 30f,
                NeverDecay = never
            });
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Main
        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            string entity_name = null;
            if (!info.damageTypes.Has(DamageType.Decay))
            {
                return null;
            }

            try
            {
                entity_name = entity.LookupPrefab().name;
            }
            catch
            {
                return null;
            }

            string pos = entity.transform.position.ToString();
            ulong hitEntityOwnerID = entity.OwnerID != 0 ? entity.OwnerID : info.HitEntity.OwnerID;
            float before = info.damageTypes.Get(Rust.DamageType.Decay);
            float multiplier = 1.0f;

            // First, we check for protected entities (NeverDecay)
            if (configData.NeverDecay.Contains(entity_name))
            {
                multiplier = 0.0f;

                // Apply our damage rules and return
                info.damageTypes.Scale(Rust.DamageType.Decay, multiplier);
                return null;
            }

            // Second, we check for attached (BLOCK) or nearby (ENTITY) cupboard
            BuildingBlock block = entity as BuildingBlock;

            string isblock = "";
            string buildGrade = "";
            bool hascup = false;
            if (block != null)
            {
                isblock = " (building block)";
                hascup = CheckCupboardBlock(block, info, entity_name);

                if (hascup)
                {
                    multiplier = 0.0f;
                    switch (block.grade)
                    {
                        case BuildingGrade.Enum.Twigs:
                            if (configData.DecayTwig == true)
                            {
                                multiplier = configData.TwigRate;
                            }
                            break;
                        case BuildingGrade.Enum.Wood:
                            if (configData.DecayWood == true)
                            {
                                multiplier = configData.WoodRate;
                            }
                            break;
                        case BuildingGrade.Enum.Stone:
                            if (configData.DecayStone == true)
                            {
                                multiplier = configData.StoneRate;
                            }
                            break;
                        case BuildingGrade.Enum.Metal:
                            if (configData.DecayMetal == true)
                            {
                                multiplier = configData.MetalRate;
                            }
                            break;
                        case BuildingGrade.Enum.TopTier:
                            if (configData.DecayArmor == true)
                            {
                                multiplier = configData.ArmorRate;
                            }
                            break;
                    }

                }
                else
                {

                    return null; // Standard damage rates apply
                }
            }
            else if (CheckCupboardEntity(entity, info, entity_name))
            {
                // Unprotected Entity with cupboard
                multiplier = 0.0f;

            }
            else
            {
                // Unprotected Entity with NO Cupboard

                return null; // Standard damage rates apply
            }

            // Apply our damage rules and return
            info.damageTypes.Scale(Rust.DamageType.Decay, multiplier);

            return null;
        }

        // Check that an entity is in range of a cupboard
        private bool CheckCupboardEntity(BaseEntity entity, HitInfo hitInfo, string name)
        {
            int targetLayer = LayerMask.GetMask("Construction", "Construction Trigger", "Trigger", "Deployed");
            Collider[] hit = Physics.OverlapSphere(entity.transform.position, configData.EntityRadius, targetLayer);

            // loop through hit layers and check for 'Building Privlidge'
            foreach (var ent in hit)
            {
                BuildingPrivlidge privs = ent.GetComponentInParent<BuildingPrivlidge>();
                if (privs != null)
                {
                    // cupboard overlap.  Entity safe from decay

                    if (configData.CheckAuth == true)
                    {

                        ulong hitEntityOwnerID = entity.OwnerID != 0 ? entity.OwnerID : hitInfo.HitEntity.OwnerID;
                        return CupboardAuthCheck(privs, hitEntityOwnerID);
                    }
                    else
                    {
                        return true;
                    }
                }
            }

            if (hit.Length > 0)
            {

                return false;
            }
            else
            {

            }
            return true;
        }

        // Check that a building block is owned by/attached to a cupboard
        private bool CheckCupboardBlock(BuildingBlock block, HitInfo hitInfo, string ename = "unknown")
        {
            BuildingManager.Building building = block.GetBuilding();

            if (building != null)
            {
                //if(building.buildingPrivileges == null)
                if (building.GetDominatingBuildingPrivilege() == null)
                {

                    return false;
                }

                // cupboard overlap.  Block safe from decay.  Check auth?
                if (configData.CheckAuth == true)
                {
                    ulong hitEntityOwnerID = block.OwnerID != 0 ? block.OwnerID : hitInfo.HitEntity.OwnerID;
                    foreach (var privs in building.buildingPrivileges)
                    {
                        if (CupboardAuthCheck(privs, hitEntityOwnerID) == true)
                        {
                            return true;
                        }
                    }
                }
                else
                {

                    return true;
                }
            }
            else
            {

            }
            return false;
        }

        private bool CupboardAuthCheck(BuildingPrivlidge priv, ulong hitEntityOwnerID)
        {
            string hitId = null;
            string entowner = null;
            foreach (var auth in priv.authorizedPlayers.Select(x => x.userid).ToArray())
            {

                if (auth == hitEntityOwnerID)
                {

                    return true;
                }
            }

            return false;
        }
        #endregion
    }
}



// --- End of file: CupboardNoDecay.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/clear-repair ---
// --- Original File Path: C/ClearRepair/ClearRepair.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Clear Repair", "Clearshot", "1.3.0")]
    [Description("Display insufficient resources required to repair with hammer or toolgun")]
    class ClearRepair : CovalencePlugin
    {
        private PluginConfig _config;
        private Game.Rust.Libraries.Player _rustPlayer = Interface.Oxide.GetLibrary<Game.Rust.Libraries.Player>("Player");
        private StringBuilder _sb = new StringBuilder();
        private readonly Dictionary<string, string> _shortPrefabNameToBuilding = new Dictionary<string, string>();

        private void SendChatMsg(BasePlayer pl, string msg, string prefix = null) =>
            _rustPlayer.Message(pl, msg, prefix != null ? prefix : lang.GetMessage("ChatPrefix", this, pl.UserIDString), Convert.ToUInt64(_config.chatIconID), Array.Empty<object>());

        private void Init()
        {
            permission.RegisterPermission("clearrepair.use", this);
        }

        private void OnServerInitialized()
        {
            foreach (var entityPath in GameManifest.Current.entities)
            {
                var construction = PrefabAttribute.server.Find<Construction>(StringPool.Get(entityPath));
                if (construction != null && construction.deployable == null && !string.IsNullOrEmpty(construction.info.name.english))
                {
                    var shortname = construction.fullName.Substring(construction.fullName.LastIndexOf('/') + 1).Replace(".prefab", "");
                    if (!_shortPrefabNameToBuilding.ContainsKey(shortname))
                    {
                        _shortPrefabNameToBuilding.Add(shortname, construction.info.name.english);
                    }
                }
            }
        }

        private object OnStructureRepair(BaseCombatEntity ent, BasePlayer pl)
        {
            if (ent == null || pl == null) return null;
            if (_config.usePermission && !permission.UserHasPermission(pl.UserIDString, "clearrepair.use")) return null;

            float num = 30f;
            if (ent.SecondsSinceAttacked <= num)
            {
                return null;
            }
            float num2 = ent.MaxHealth() - ent.health;
            float num3 = num2 / ent.MaxHealth();
            if (num2 <= 0f || num3 <= 0f)
            {
                return null;
            }
            List<ItemAmount> list = ent.RepairCost(num3);
            if (list == null)
            {
                return null;
            }

            float num4 = list.Sum((ItemAmount x) => x.amount);
            if (num4 > 0f)
            {
                float num5 = list.Min((ItemAmount x) => UnityEngine.Mathf.Clamp01(pl.inventory.GetAmount(x.itemid) / x.amount));
                num5 = UnityEngine.Mathf.Min(num5, 50f / num2);
                if (num5 <= 0f)
                {
                    if (_config.defaultChatNotification)
                    {
                        ent.OnRepairFailed(pl, lang.GetMessage("DefaultChatNotification", this, pl.UserIDString));
                    }

                    _sb.Clear();
                    _sb.AppendLine(string.Format(lang.GetMessage("RepairItemName", this, pl.UserIDString), GetEntityItemName(ent, pl.UserIDString)));
                    _sb.AppendLine(lang.GetMessage("InsufficientRes", this, pl.UserIDString));
                    foreach (ItemAmount itemAmount in list)
                    {
                        string color = pl.inventory.GetAmount(itemAmount.itemid) >= itemAmount.amount ? _config.itemFoundColor : _config.itemNotFoundColor;
                        _sb.AppendLine(string.Format(lang.GetMessage("ItemAmount", this, pl.UserIDString), GetItemName(itemAmount.itemDef, pl.UserIDString), color, itemAmount.amount));
                    }

                    SendChatMsg(pl, _sb.ToString());
                    return false;
                }
            }

            return null;
        }

        private string GetEntityItemName(BaseCombatEntity ent, string UserID)
        {
            string itemName;
            string msg = lang.GetMessage(ent.ShortPrefabName, this, UserID);
            if (msg != null && msg != ent.ShortPrefabName)
            {
                itemName = msg;
            }
            else if (ent?.repair.itemTarget != null)
            {
                return GetItemName(ent.repair.itemTarget, UserID);
            }
            else if (_shortPrefabNameToBuilding.ContainsKey(ent.ShortPrefabName))
            {
                itemName = _shortPrefabNameToBuilding[ent.ShortPrefabName];
            }
            else
            {
                itemName = ent.ShortPrefabName;
            }
            return _config.showShortname ? $"{itemName} ({ent.ShortPrefabName})" : itemName;
        }

        private string GetItemName(ItemDefinition item, string UserID)
        {
            string itemName;
            string msg = lang.GetMessage(item.shortname, this, UserID);
            if (msg != null && msg != item.shortname)
            {
                itemName = msg;
            }
            else if (!string.IsNullOrEmpty(item.displayName.english))
            {
                itemName = item.displayName.english;
            }
            else
            {
                itemName = item.shortname;
            }
            return _config.showShortname ? $"{itemName} ({item.shortname})": itemName;
        }

        [Command("clearrepair.generate_lang")]
        private void GenerateLangCommand(IPlayer player, string command, string[] args)
        {
            if (player == null || !player.IsServer) return;

            Dictionary<string, string> sortedList = new Dictionary<string, string>();

            _sb.Clear();
            _sb.AppendLine("\n*** Buildings ***\n");
            foreach (var building in _shortPrefabNameToBuilding.OrderBy(x => x.Key))
            {
                _sb.AppendLine($"{building.Key} - {building.Value}");
                sortedList.Add(building.Key, building.Value);
            }

            _sb.AppendLine("\n*** Items ***\n");
            foreach (var item in ItemManager.itemList.OrderBy(x => x.shortname))
            {
                _sb.AppendLine($"{item.shortname} - {item.displayName.english}");
                sortedList.Add(item.shortname, item.displayName.english);
            }

            Interface.Oxide.DataFileSystem.WriteObject($"{Name}\\GeneratedLang", sortedList);
            _sb.AppendLine($"\nSaved to /oxide/data/{Name}/GeneratedLang.json\n");
            Puts(_sb.ToString());
        }

        [Command("clearrepair.check_lang")]
        private void CheckLangCommand(IPlayer player, string command, string[] args)
        {
            if (player == null || !player.IsServer) return;

            if (args.Length > 0 && !string.IsNullOrEmpty(args[0]))
            {
                _sb.Clear();
                _sb.AppendLine();
                foreach (var l in lang.GetLanguages(this))
                {
                    if (l.ToLower() == args[0].ToLower())
                    {
                        foreach(var msg in lang.GetMessages(l, this))
                        {
                            _sb.AppendLine($"{msg.Key} - {msg.Value}");
                        }
                    }
                }
                Puts(_sb.ToString());
            }
        }

        #region Config

        protected override void LoadDefaultMessages()
        {
            string[] langs = lang.GetLanguages(this);
            foreach(var l in langs)
            {
                Puts($"registered language: {l} ({lang.GetMessages(l, this).Count})");
            }

            if (!langs.Contains("en"))
            {
                lang.RegisterMessages(new Dictionary<string, string>
                {
                    ["ChatPrefix"] = $"<color=#00a7fe>[{Title}]</color>",
                    ["RepairItemName"] = "<line-height=20>{0}",
                    ["InsufficientRes"] = "<size=12>Unable to repair: Insufficient resources.</size><line-indent=5>",
                    ["ItemAmount"] = "<size=12>{0}: <color={1}>{2}</color></size>",
                    ["DefaultChatNotification"] = "Unable to repair: Insufficient resources.",
                    ["minicopter.entity"] = "Minicopter",
                    ["rowboat"] = "Row Boat",
                    ["rhib"] = "RHIB",
                    ["scraptransporthelicopter"] = "Scrap Transport Helicopter"
                }, this);
            } else {
                Dictionary<string, string> msgs = lang.GetMessages("en", this);
                if (msgs.Count < 6 || !msgs.ContainsKey("minicopter.entity"))
                {
                    Puts($"Outdated english language file detected! Delete /oxide/lang/en/{Name}.json and reload the plugin to generate an updated english language file.");
                }
            }
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<PluginConfig>();
            Config.WriteObject(_config, true);
        }

        private class PluginConfig
        {
            public bool usePermission = false;
            public bool defaultChatNotification = false;
            public bool showShortname = false;
            public string chatIconID = "0";
            public string itemFoundColor = "#87b33a";
            public string itemNotFoundColor = "#cb3f2a";
        }

        #endregion
    }
}


// --- End of file: ClearRepair.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/claim-vehicle ---
// --- Original File Path: C/ClaimVehicle/ClaimVehicle.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Claim Vehicle", "WhiteThunder", "1.8.0")]
    [Description("Allows players to claim ownership of unowned vehicles.")]
    internal class ClaimVehicle : CovalencePlugin
    {
        #region Fields

        private Configuration _config;

        private const string Permission_Unclaim = "claimvehicle.unclaim";
        private const string Permission_NoClaimCooldown = "claimvehicle.nocooldown";
        private const string Permission_Claim_AllVehicles = "claimvehicle.claim.allvehicles";

        private readonly VehicleInfoManager _vehicleInfoManager;
        private CooldownManager _cooldownManager;

        public ClaimVehicle()
        {
            _vehicleInfoManager = new VehicleInfoManager(this);
        }

        #endregion

        #region Hooks

        private void Init()
        {
            _config.Init(this);

            _cooldownManager = new CooldownManager(_config.ClaimCooldownSeconds);

            permission.RegisterPermission(Permission_Unclaim, this);
            permission.RegisterPermission(Permission_NoClaimCooldown, this);
            permission.RegisterPermission(Permission_Claim_AllVehicles, this);
        }

        private void OnServerInitialized()
        {
            _vehicleInfoManager.OnServerInitialized();
        }

        #endregion

        #region Exposed Hooks

        private static class ExposedHooks
        {
            public static object OnVehicleClaim(BasePlayer player, BaseCombatEntity vehicle)
            {
                return Interface.CallHook("OnVehicleClaim", player, vehicle);
            }

            public static object OnVehicleUnclaim(BasePlayer player, BaseCombatEntity vehicle)
            {
                return Interface.CallHook("OnVehicleUnclaim", player, vehicle);
            }

            public static void OnVehicleOwnershipChanged(BaseCombatEntity vehicle)
            {
                Interface.CallHook("OnVehicleOwnershipChanged", vehicle);
            }
        }

        #endregion

        #region Commands

        private void ClaimVehicleCommand(IPlayer player, string cmd, string[] args)
        {
            if (player.IsServer)
                return;

            var basePlayer = player.Object as BasePlayer;

            if (!VerifySupportedVehicleFound(player, basePlayer, GetLookEntity(basePlayer), out var vehicle, out var vehicleInfo) ||
                !VerifyPermissionAny(player, Permission_Claim_AllVehicles, vehicleInfo.Permission) ||
                !VerifyVehicleIsNotDead(player, vehicle) ||
                !VerifyNotOwned(player, vehicle) ||
                !VerifyOffCooldown(player) ||
                !VerifyCanBuild(player) ||
                !VerifyNoLockRestriction(player, vehicle) ||
                !VerifyNotMounted(player, vehicle) ||
                ClaimWasBlocked(basePlayer, vehicle))
                return;

            ChangeVehicleOwnership(vehicle, basePlayer.userID);
            _cooldownManager.UpdateLastUsedForPlayer(basePlayer.userID);
            ReplyToPlayer(player, "Claim.Success");
        }

        private void UnclaimVehicleCommand(IPlayer player, string cmd, string[] args)
        {
            if (player.IsServer || !VerifyPermissionAny(player, Permission_Unclaim))
                return;

            var basePlayer = player.Object as BasePlayer;

            if (!VerifySupportedVehicleFound(player, basePlayer, GetLookEntity(basePlayer), out var vehicle, out _) ||
                !VerifyCurrentlyOwned(player, vehicle) ||
                UnclaimWasBlocked(basePlayer, vehicle))
                return;

            ChangeVehicleOwnership(vehicle, 0);
            ReplyToPlayer(player, "Unclaim.Success");
        }

        #endregion

        #region Helper Methods

        private static bool ClaimWasBlocked(BasePlayer player, BaseCombatEntity vehicle)
        {
            return ExposedHooks.OnVehicleClaim(player, vehicle) is false;
        }

        private static bool UnclaimWasBlocked(BasePlayer player, BaseCombatEntity vehicle)
        {
            return ExposedHooks.OnVehicleUnclaim(player, vehicle) is false;
        }

        private static RidableHorse2 GetClosestHorse(HitchTrough hitchTrough, BasePlayer player)
        {
            var closestDistance = float.MaxValue;
            RidableHorse2 closestHorse = null;

            foreach (var hitchSpot in hitchTrough.hitchSpots)
            {
                if (!hitchSpot.IsOccupied())
                    continue;

                var distance = Vector3.Distance(player.transform.position, hitchSpot.tr.position);
                if (distance < closestDistance)
                {
                    closestDistance = distance;
                    if (hitchSpot.hitchableEntRef.Get(serverside: true) is RidableHorse2 ridableHorse)
                    {
                        closestHorse = ridableHorse;
                    }
                }
            }

            return closestHorse;
        }

        private static BaseEntity GetLookEntity(BasePlayer player, float maxDistance = 9)
        {
            return Physics.Raycast(player.eyes.HeadRay(), out var hit, maxDistance, Physics.DefaultRaycastLayers, QueryTriggerInteraction.Ignore)
                ? hit.GetEntity()
                : null;
        }

        private static void ChangeVehicleOwnership(BaseCombatEntity vehicle, ulong userId)
        {
            vehicle.OwnerID = userId;
            ExposedHooks.OnVehicleOwnershipChanged(vehicle);
        }

        private static string FormatDuration(double seconds)
        {
            return TimeSpan.FromSeconds(Math.Ceiling(seconds)).ToString("g");
        }

        private static string[] FindPrefabsOfType<T>() where T : BaseEntity
        {
            var prefabList = new List<string>();

            foreach (var assetPath in GameManifest.Current.entities)
            {
                var entity = GameManager.server.FindPrefab(assetPath)?.GetComponent<T>();
                if (entity == null)
                    continue;

                prefabList.Add(entity.PrefabName);
            }

            return prefabList.ToArray();
        }

        private static BaseCombatEntity GetAppropriateVehicle(BaseEntity entity, BasePlayer player)
        {
            var vehicleModule = entity as BaseVehicleModule;
            if ((object)vehicleModule != null)
                return vehicleModule.Vehicle;

            var carLift = entity as ModularCarGarage;
            if ((object)carLift != null)
                return carLift.carOccupant;

            var hitchTrough = entity as HitchTrough;
            if ((object)hitchTrough != null)
                return GetClosestHorse(hitchTrough, player);

            return entity as BaseCombatEntity;
        }

        private bool VerifySupportedVehicleFound(IPlayer player, BasePlayer basePlayer, BaseEntity entity, out BaseCombatEntity vehicle, out IVehicleInfo vehicleInfo)
        {
            vehicle = GetAppropriateVehicle(entity, basePlayer);
            if ((object)vehicle != null)
            {
                vehicleInfo = _vehicleInfoManager.GetVehicleInfo(vehicle);
                if (vehicleInfo != null)
                    return true;
            }

            vehicleInfo = null;
            ReplyToPlayer(player, "Generic.Error.NoSupportedVehicleFound");
            return false;
        }

        private bool VerifyPermissionAny(IPlayer player, params string[] permissionNames)
        {
            foreach (var perm in permissionNames)
            {
                if (permission.UserHasPermission(player.Id, perm))
                    return true;
            }

            ReplyToPlayer(player, "Generic.Error.NoPermission");
            return false;
        }

        private bool VerifyVehicleIsNotDead(IPlayer player, BaseCombatEntity vehicle)
        {
            if (!vehicle.IsDead())
                return true;

            ReplyToPlayer(player, "Generic.Error.VehicleDead");
            return false;
        }

        private bool VerifyNotOwned(IPlayer player, BaseEntity vehicle)
        {
            if (vehicle.OwnerID == 0)
                return true;

            var basePlayer = player.Object as BasePlayer;
            if (vehicle.OwnerID == basePlayer.userID)
            {
                ReplyToPlayer(player, "Claim.Error.AlreadyOwnedByYou");
            }
            else
            {
                ReplyToPlayer(player, "Claim.Error.DifferentOwner");
            }

            return false;
        }

        private bool VerifyOffCooldown(IPlayer player)
        {
            if (player.HasPermission(Permission_NoClaimCooldown))
                return true;

            var basePlayer = player.Object as BasePlayer;
            var secondsRemaining = _cooldownManager.GetSecondsRemaining(basePlayer.userID);
            if (secondsRemaining > 0)
            {
                ReplyToPlayer(player, "Generic.Error.Cooldown", FormatDuration(secondsRemaining));
                return false;
            }

            return true;
        }

        private bool VerifyCanBuild(IPlayer player)
        {
            if ((player.Object as BasePlayer).CanBuild())
                return true;

            ReplyToPlayer(player, "Generic.Error.BuildingBlocked");
            return false;
        }

        private bool VerifyNoLockRestriction(IPlayer player, BaseCombatEntity vehicle)
        {
            var basePlayer = player.Object as BasePlayer;
            var baseLock = vehicle.GetSlot(BaseEntity.Slot.Lock);
            if (baseLock == null || baseLock.OwnerID == basePlayer.userID)
                return true;

            ReplyToPlayer(player, "Claim.Error.LockedByAnother");
            return false;
        }

        private bool VerifyNotMounted(IPlayer player, BaseCombatEntity entity)
        {
            var vehicle = entity as BaseVehicle;
            if (vehicle == null || !vehicle.AnyMounted())
                return true;

            ReplyToPlayer(player, "Claim.Error.Mounted");
            return false;
        }

        private bool VerifyCurrentlyOwned(IPlayer player, BaseCombatEntity vehicle)
        {
            var basePlayer = player.Object as BasePlayer;
            if (vehicle.OwnerID == basePlayer.userID)
                return true;

            ReplyToPlayer(player, "Unclaim.Error.NotOwned");
            return false;
        }

        #endregion

        #region Helper Classes

        private class CooldownManager
        {
            private readonly Dictionary<ulong, float> _cooldownMap = new();
            private readonly float _cooldownDuration;

            public CooldownManager(float duration)
            {
                _cooldownDuration = duration;
            }

            public void UpdateLastUsedForPlayer(ulong userId)
            {
                _cooldownMap[userId] = Time.realtimeSinceStartup;
            }

            public float GetSecondsRemaining(ulong userId)
            {
                return _cooldownMap.TryGetValue(userId, out var duration)
                    ? duration + _cooldownDuration - Time.realtimeSinceStartup
                    : 0;
            }
        }

        private interface IVehicleInfo
        {
            uint[] PrefabIds { get; }
            string Permission { get; }

            void OnServerInitialized(ClaimVehicle plugin);
            bool IsCorrectType(BaseEntity entity);
        }

        private class VehicleInfo<T> : IVehicleInfo where T : BaseEntity
        {
            public uint[] PrefabIds { get; private set; }
            public string Permission { get; private set; }

            public string VehicleName { get; set; }
            public string[] PrefabPaths { get; set; }

            public void OnServerInitialized(ClaimVehicle plugin)
            {
                Permission = $"{nameof(ClaimVehicle)}.claim.{VehicleName}".ToLower();
                plugin.permission.RegisterPermission(Permission, plugin);

                var prefabIds = new List<uint>(PrefabPaths.Length);

                foreach (var prefabName in PrefabPaths)
                {
                    var prefab = GameManager.server.FindPrefab(prefabName)?.GetComponent<T>();
                    if (prefab == null)
                    {
                        plugin.LogError($"Invalid or incorrect prefab. Please alert the plugin maintainer -- {prefabName}");
                        continue;
                    }

                    prefabIds.Add(prefab.prefabID);
                }

                PrefabIds = prefabIds.ToArray();
            }

            public bool IsCorrectType(BaseEntity entity)
            {
                return entity is T;
            }
        }

        private class VehicleInfoManager
        {
            private readonly ClaimVehicle _plugin;
            private readonly Dictionary<uint, IVehicleInfo> _prefabIdToVehicleInfo = new();
            private IVehicleInfo[] _allVehicles;

            public VehicleInfoManager(ClaimVehicle plugin)
            {
                _plugin = plugin;
            }

            public void OnServerInitialized()
            {
                _allVehicles = new IVehicleInfo[]
                {
                    new VehicleInfo<AttackHelicopter>
                    {
                        VehicleName = "attackhelicopter",
                        PrefabPaths = new[] { "assets/content/vehicles/attackhelicopter/attackhelicopter.entity.prefab" },
                    },
                    new VehicleInfo<Ballista>
                    {
                        VehicleName = "ballista",
                        PrefabPaths = new[] { "assets/content/vehicles/siegeweapons/ballista/ballista.entity.prefab" },
                    },
                    new VehicleInfo<BatteringRam>
                    {
                        VehicleName = "batteringram",
                        PrefabPaths = new[] { "assets/content/vehicles/siegeweapons/batteringram/batteringram.entity.prefab" },
                    },
                    new VehicleInfo<TrainCar>
                    {
                        VehicleName = "caboose",
                        PrefabPaths = new[] { "assets/content/vehicles/trains/caboose/traincaboose.entity.prefab" },
                    },
                    new VehicleInfo<Catapult>
                    {
                        VehicleName = "catapult",
                        PrefabPaths = new[] { "assets/content/vehicles/siegeweapons/catapult/catapult.entity.prefab" },
                    },
                    new VehicleInfo<CH47Helicopter>
                    {
                        VehicleName = "chinook",
                        PrefabPaths = new[] { "assets/prefabs/npc/ch47/ch47.entity.prefab" },
                    },
                    new VehicleInfo<SubmarineDuo>
                    {
                        VehicleName = "duosub",
                        PrefabPaths = new[] { "assets/content/vehicles/submarine/submarineduo.entity.prefab" },
                    },
                    new VehicleInfo<HotAirBalloon>
                    {
                        VehicleName = "hotairballoon",
                        PrefabPaths = new[] { "assets/prefabs/deployable/hot air balloon/hotairballoon.prefab" },
                    },
                    new VehicleInfo<TrainEngine>
                    {
                        VehicleName = "locomotive",
                        PrefabPaths = new[] { "assets/content/vehicles/trains/locomotive/locomotive.entity.prefab" },
                    },
                    new VehicleInfo<Minicopter>
                    {
                        VehicleName = "minicopter",
                        PrefabPaths = new[] { "assets/content/vehicles/minicopter/minicopter.entity.prefab" },
                    },
                    new VehicleInfo<ModularCar>
                    {
                        VehicleName = "modularcar",
                        PrefabPaths = FindPrefabsOfType<ModularCar>(),
                    },
                    new VehicleInfo<Bike>
                    {
                        VehicleName = "motorbike.sidecar",
                        PrefabPaths = new[] { "assets/content/vehicles/bikes/motorbike_sidecar.prefab" },
                    },
                    new VehicleInfo<Bike>
                    {
                        VehicleName = "motorbike",
                        PrefabPaths = new[] { "assets/content/vehicles/bikes/motorbike.prefab" },
                    },
                    new VehicleInfo<Bike>
                    {
                        VehicleName = "pedalbike",
                        PrefabPaths = new[] { "assets/content/vehicles/bikes/pedalbike.prefab" },
                    },
                    new VehicleInfo<Bike>
                    {
                        VehicleName = "pedaltrike",
                        PrefabPaths = new[] { "assets/content/vehicles/bikes/pedaltrike.prefab" },
                    },
                    new VehicleInfo<RHIB>
                    {
                        VehicleName = "rhib",
                        PrefabPaths = new[] { "assets/content/vehicles/boats/rhib/rhib.prefab" },
                    },
                    // Using BaseVehicle since it's the closest base class of RidableHorse and RidableHorse2.
                    new VehicleInfo<BaseVehicle>
                    {
                        VehicleName = "ridablehorse",
                        PrefabPaths = new[]
                        {
                            "assets/content/vehicles/horse/ridablehorse2.prefab",
                            "assets/content/vehicles/horse/_old/testridablehorse.prefab",
                        },
                    },
                    new VehicleInfo<MotorRowboat>
                    {
                        VehicleName = "rowboat",
                        PrefabPaths = new[] { "assets/content/vehicles/boats/rowboat/rowboat.prefab" },
                    },
                    new VehicleInfo<ScrapTransportHelicopter>
                    {
                        VehicleName = "scraptransporthelicopter",
                        PrefabPaths = new[] { "assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab" },
                    },
                    new VehicleInfo<BasicCar>
                    {
                        VehicleName = "sedan",
                        PrefabPaths = new[] { "assets/content/vehicles/sedan_a/sedantest.entity.prefab" },
                    },
                    new VehicleInfo<TrainEngine>
                    {
                        VehicleName = "sedanrail",
                        PrefabPaths = new[] { "assets/content/vehicles/sedan_a/sedanrail.entity.prefab" },
                    },
                    new VehicleInfo<SiegeTower>
                    {
                        VehicleName = "siegetower",
                        PrefabPaths = new[] { "assets/content/vehicles/siegeweapons/siegetower/siegetower.entity.prefab" },
                    },
                    new VehicleInfo<Snowmobile>
                    {
                        VehicleName = "snowmobile",
                        PrefabPaths = new[] { "assets/content/vehicles/snowmobiles/snowmobile.prefab" },
                    },
                    new VehicleInfo<BaseSubmarine>
                    {
                        VehicleName = "solosub",
                        PrefabPaths = new[] { "assets/content/vehicles/submarine/submarinesolo.entity.prefab" },
                    },
                    new VehicleInfo<Snowmobile>
                    {
                        VehicleName = "tomaha",
                        PrefabPaths = new[] { "assets/content/vehicles/snowmobiles/tomahasnowmobile.prefab" },
                    },
                    new VehicleInfo<TrainCar>
                    {
                        VehicleName = "wagona",
                        PrefabPaths = new[] { "assets/content/vehicles/trains/wagons/trainwagona.entity.prefab" },
                    },
                    new VehicleInfo<TrainCar>
                    {
                        VehicleName = "wagonb",
                        PrefabPaths = new[] { "assets/content/vehicles/trains/wagons/trainwagonb.entity.prefab" },
                    },
                    new VehicleInfo<TrainCar>
                    {
                        VehicleName = "wagonc",
                        PrefabPaths = new[] { "assets/content/vehicles/trains/wagons/trainwagonc.entity.prefab" },
                    },
                    new VehicleInfo<TrainEngine>
                    {
                        VehicleName = "workcart",
                        PrefabPaths = new[] { "assets/content/vehicles/trains/workcart/workcart.entity.prefab" },
                    },
                    new VehicleInfo<TrainEngine>
                    {
                        VehicleName = "workcartaboveground",
                        PrefabPaths = new[] { "assets/content/vehicles/trains/workcart/workcart_aboveground.entity.prefab" },
                    },
                    new VehicleInfo<TrainEngine>
                    {
                        VehicleName = "workcartcovered",
                        PrefabPaths = new[] { "assets/content/vehicles/trains/workcart/workcart_aboveground2.entity.prefab" },
                    },
                };

                foreach (var vehicleInfo in _allVehicles)
                {
                    vehicleInfo.OnServerInitialized(_plugin);

                    foreach (var prefabId in vehicleInfo.PrefabIds)
                    {
                        _prefabIdToVehicleInfo[prefabId] = vehicleInfo;
                    }
                }
            }

            public IVehicleInfo GetVehicleInfo(BaseEntity entity)
            {
                return _prefabIdToVehicleInfo.TryGetValue(entity.prefabID, out var vehicleInfo) && vehicleInfo.IsCorrectType(entity)
                    ? vehicleInfo
                    : null;
            }
        }

        #endregion

        #region Configuration

        [JsonObject(MemberSerialization.OptIn)]
        private class Configuration : SerializableConfiguration
        {
            [JsonProperty("ClaimCooldownSeconds")]
            private float DeprecatedClaimCooldownSeconds { set => ClaimCooldownSeconds = value; }

            [JsonProperty("Claim cooldown (seconds)")]
            public float ClaimCooldownSeconds = 3600;

            [JsonProperty("Claim commands")]
            public string[] ClaimCommands = { "vclaim" };

            [JsonProperty("Unclaim commands")]
            public string[] UnclaimCommands = { "vunclaim" };

            public void Init(ClaimVehicle plugin)
            {
                plugin.AddCovalenceCommand(ClaimCommands, nameof(ClaimVehicleCommand));
                plugin.AddCovalenceCommand(UnclaimCommands, nameof(UnclaimVehicleCommand));
            }
        }

        private Configuration GetDefaultConfig() => new();

        #region Configuration Helpers

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                if (currentRaw.TryGetValue(key, out var currentRawValue))
                {
                    var currentDictValue = currentRawValue as Dictionary<string, object>;
                    if (currentWithDefaults[key] is Dictionary<string, object> defaultDictValue)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                        {
                            changed = true;
                        }
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion

        #region Localization

        private void ReplyToPlayer(IPlayer player, string messageName, params object[] args) =>
            player.Reply(string.Format(GetMessage(player, messageName), args));

        private string GetMessage(IPlayer player, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, player.Id);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Generic.Error.NoPermission"] = "You don't have permission to do that.",
                ["Generic.Error.BuildingBlocked"] = "Error: Cannot do that while building blocked.",
                ["Generic.Error.NoSupportedVehicleFound"] = "Error: No supported vehicle found.",
                ["Generic.Error.VehicleDead"] = "Error: That vehicle is dead.",
                ["Generic.Error.Cooldown"] = "Please wait <color=red>{0}</color> and try again.",
                ["Claim.Error.AlreadyOwnedByYou"] = "You already own that vehicle.",
                ["Claim.Error.DifferentOwner"] = "Error: Someone else already owns that vehicle.",
                ["Claim.Error.LockedByAnother"] = "Error: Someone else placed a lock on that vehicle.",
                ["Claim.Error.Mounted"] = "Error: That vehicle is currently occupied.",
                ["Claim.Success"] = "You now own that vehicle.",
                ["Unclaim.Error.NotOwned"] = "Error: You do not own that vehicle.",
                ["Unclaim.Success"] = "You no longer own that vehicle.",
            }, this, "en");
        }

        #endregion
    }
}


// --- End of file: ClaimVehicle.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/chat-to-discord-relay ---
// --- Original File Path: C/ChatToDiscord/ChatToDiscord.cs ---

using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System;
using ConVar;
using System.Text.RegularExpressions;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Chat to Discord Relay", "Psystec", "1.0.9")]
    [Description("Relay chat to Discord")]

    public class ChatToDiscord : CovalencePlugin
    {
        Dictionary<string, SteamPlayerInfo> _steamPlayerInfoCache = new Dictionary<string, SteamPlayerInfo>();
        public const string AdminPermission = "chattodiscord.admin";

        #region Configuration

        private Configuration _configuration;
        private class Configuration
        {
            public string SteamApiKey { get; set; } = "https://steamcommunity.com/dev/apikey";
            public string GlobalChatWebhook { get; set; } = "";
            public string TeamChatWebhook { get; set; } = "";
            public string ConnectionWebhook { get; set; } = "";
            public bool AllowMentions { get; set; } = false;
            public bool AllowSpecialCharacters { get; set; } = true;
            public string GlobalChatFormat { get; set; } = "[{time}] [**GLOBAL**] **{username}**: `{message}`";
            public string TeamChatFormat { get; set; } = "[{time}] [**TEAM**] **{username}**: `{message}`";
            public string ConnectionFormat { get; set; } = "[{time}] **{username}**: {connectionstatus}";
            public string DateFormat { get; set; } = "yyyy-MM-dd HH:mm:ss";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Connected"] = "Connected.",
                ["Disconnected"] = "Disconnected.",
                ["NoPermission"] = "You do not have permission to use this command.",
                ["FileLoaded"] = "File loaded.",
                ["cmdCommand"] = "COMMAND",
                ["cmdDescription"] = "DESCRIPTION",
                ["cmdReload"] = "Reads the config file."
            }, this);
        }

        protected override void SaveConfig() => Config.WriteObject(_configuration);
        private void LoadNewConfig() => _configuration = Config.ReadObject<Configuration>();
        protected override void LoadDefaultConfig() => _configuration = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _configuration = Config.ReadObject<Configuration>();
        }

        #endregion Configuration

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(AdminPermission, this);
        }

        private void Loaded()
        {
            CheckSubscribsions();
        }

        #endregion Hooks

        #region User Connection Hooks

        private void OnUserConnected(IPlayer player)
        {
            string message = _configuration.ConnectionFormat
                .Replace("{time}", DateTime.Now.ToString(_configuration.DateFormat))
                .Replace("{username}", player.Name)
                .Replace("{userid}", player.Id)
                .Replace("{connectionstatus}", Lang("Connected"));

            SendToDiscord(_configuration.ConnectionWebhook, player.Name, player.Id, message);
        }

        private void OnUserDisconnected(IPlayer player)
        {
            string message = _configuration.ConnectionFormat
                .Replace("{time}", DateTime.Now.ToString(_configuration.DateFormat))
                .Replace("{username}", player.Name)
                .Replace("{userid}", player.Id)
                .Replace("{connectionstatus}", Lang("Disconnected"));

            SendToDiscord(_configuration.ConnectionWebhook, player.Name, player.Id, message);
        }

        #endregion User Connection Hooks

        #region User Chat Hooks

        private void OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            //Allow Metions
            if (!_configuration.AllowMentions)
            {
                message = message.Replace("@here", "@.here")
                .Replace("@everyone", "@.everyone");
            }

            //Allow Special Characters
            if (!_configuration.AllowSpecialCharacters)
            {
                message = RemoveSpecialCharacters(message);
            }

            switch (channel)
            {
                case Chat.ChatChannel.Global:
                    if (!string.IsNullOrEmpty(_configuration.GlobalChatWebhook))
                    {
                        message = _configuration.GlobalChatFormat
                            .Replace("{time}", DateTime.Now.ToString(_configuration.DateFormat))
                            .Replace("{username}", player.displayName)
                            .Replace("{userid}", player.UserIDString)
                            .Replace("{message}", message);

                        SendToDiscord(_configuration.GlobalChatWebhook, player.displayName, player.UserIDString, message);
                    }
                    break;

                case Chat.ChatChannel.Team:
                    if (!string.IsNullOrEmpty(_configuration.TeamChatWebhook))
                    {
                        message = _configuration.TeamChatFormat
                            .Replace("{time}", DateTime.Now.ToString(_configuration.DateFormat))
                            .Replace("{username}", player.displayName)
                            .Replace("{userid}", player.UserIDString)
                            .Replace("{message}", message);

                        SendToDiscord(_configuration.TeamChatWebhook, player.displayName, player.UserIDString, message);
                    }
                    break;
            }
        }

        #endregion User Chat Hooks

        #region Commands

        [Command("chattodiscord")]
        private void ChatToDiscordCommands(IPlayer player, string command, string[] args)
        {
            if (player == null)
                return;

            if (!HasPermission(player, AdminPermission))
                return;

            if (args.IsNullOrEmpty())
            {
                player.Reply(Lang("cmdCommand").PadRight(30) + Lang("cmdDescription"));
                player.Reply(("chattodiscord loadconfig").PadRight(30) + Lang("cmdReload"));
                return;
            }

            if (args[0] == "loadconfig")
            {
                player.Reply(Lang("FileLoaded"));
                LoadNewConfig();
                Loaded();
            }
        }

        #endregion Commands

        #region Helpers

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        private bool HasPermission(IPlayer player, string permission)
        {
            if (!player.HasPermission(permission))
            {
                player.Reply(Lang("NoPermission"));
                PrintWarning("UserID: " + player.Id + " | UserName: " + player.Name + " | " + Lang("NoPermission"));
                return false;
            }
            return true;
        }
        public static string RemoveSpecialCharacters(string message)
        {
            string pattern = "[^a-zA-Z0-9._@\\[\\] ]";

            // Replace matched characters (those NOT allowed) with an empty string
            string cleanedMessage = Regex.Replace(message, pattern, "");

            return cleanedMessage;
        }
        private void SendToDiscord(string Webhook, string PlayerName, string PlayerID, string message)
        {
            string steamUrl = $"http://api.steampowered.com/ISteamUser/GetPlayerSummaries/v0002/?key={_configuration.SteamApiKey}&steamids={PlayerID}";
            string defaultImage = "https://images.sftcdn.net/images/t_app-logo-l,f_auto,dpr_auto/p/e8326516-9b2c-11e6-9634-00163ec9f5fa/3905415571/rust-logo.png";
            //string defaultImage = "https://files.facepunch.com/lewis/1b2911b1/rust-marque.svg";
            Dictionary<string, string> headers = new Dictionary<string, string>
            {
                { "Content-Type", "application/json" }
            };


            if (_steamPlayerInfoCache.ContainsKey(PlayerID))
            {
                //User cached Data from SteamPlayerInfo
                foreach (Player p in _steamPlayerInfoCache[PlayerID].response.players)
                {
                    defaultImage = p.avatarfull;
                    DiscordMessage dm = new DiscordMessage();
                    dm.username = PlayerName;
                    dm.avatar_url = defaultImage;
                    dm.content = message;
                    string payload = JsonConvert.SerializeObject(dm);

                    webrequest.Enqueue(Webhook, payload, (dcode, dresponse) =>
                    {
                        if (dcode != 200 && dcode != 204)
                        {
                            if (dresponse == null)
                            {
                                PrintWarning($"Discord didn't respond (down?) Code: {dcode}");
                            }
                        }
                    }, this, Core.Libraries.RequestMethod.POST, headers);
                }
            }
            else
            {
                webrequest.Enqueue(steamUrl, null, (code, response) =>
                {
                    if (code != 200)
                    {
                        PrintWarning($"ERROR: {response}");
                        PrintWarning($"steamUrl: {steamUrl}");
                        PrintWarning($"code: {code}");
                        return;
                    }

                    SteamPlayerInfo steamPlayers = JsonConvert.DeserializeObject<SteamPlayerInfo>(response);

                    _steamPlayerInfoCache.Add(PlayerID, steamPlayers); //Cache SteamPlayerInfo Data from Player

                    foreach (Player p in steamPlayers.response.players)
                    {
                        defaultImage = p.avatarfull;
                        DiscordMessage dm = new DiscordMessage();
                        dm.username = PlayerName;
                        dm.avatar_url = defaultImage;
                        dm.content = message;
                        string payload = JsonConvert.SerializeObject(dm);

                        webrequest.Enqueue(Webhook, payload, (dcode, dresponse) =>
                        {
                            if (dcode != 200 && dcode != 204)
                            {
                                if (dresponse == null)
                                {
                                    PrintWarning($"Discord didn't respond (down?) Code: {dcode}");
                                }
                            }
                        }, this, Core.Libraries.RequestMethod.POST, headers);

                    }
                }, this, Core.Libraries.RequestMethod.GET);
            }
        }
        private void CheckSubscribsions()
        {
            if (string.IsNullOrEmpty(_configuration.GlobalChatWebhook) && string.IsNullOrEmpty(_configuration.TeamChatWebhook))
                Unsubscribe(nameof(OnPlayerChat));
            else
                Subscribe(nameof(OnPlayerChat));

            if (string.IsNullOrEmpty(_configuration.ConnectionWebhook))
            {
                Unsubscribe(nameof(OnUserConnected));
                Unsubscribe(nameof(OnUserDisconnected));
            }
            else
            {
                Subscribe(nameof(OnUserConnected));
                Subscribe(nameof(OnUserDisconnected));
            }
        }

        #endregion Helpers

        #region Classes

        #region Discord Messages
        public class DiscordMessage
        {
            /// <summary>
            /// if used, it overrides the default username of the webhook
            /// </summary>
            public string username { get; set; }
            /// <summary>
            /// if used, it overrides the default avatar of the webhook
            /// </summary>
            public string avatar_url { get; set; }
            /// <summary>
            /// simple message, the message contains (up to 2000 characters)
            /// </summary>
            public string content { get; set; }
            /// <summary>
            /// array of embed objects. That means, you can use more than one in the same body
            /// </summary>
            public Embed[] embeds { get; set; }
        }
        public class Embed
        {
            /// <summary>
            /// embed author object
            /// </summary>
            public Author author { get; set; }
            /// <summary>
            /// title of embed
            /// </summary>
            public string title { get; set; }
            /// <summary>
            /// url of embed. If title was used, it becomes hyperlink
            /// </summary>
            public string url { get; set; }
            /// <summary>
            /// description text
            /// </summary>
            public string description { get; set; }
            /// <summary>
            /// color code of the embed. You have to use Decimal numeral system, not Hexadecimal. Use color picker and converter: https://htmlcolorcodes.com/color-picker/ and https://www.binaryhexconverter.com/hex-to-decimal-converter
            /// </summary>
            public int color { get; set; }
            /// <summary>
            /// rray of embed field objects
            /// </summary>
            public Field[] fields { get; set; }
            /// <summary>
            /// embed thumbnail object
            /// </summary>
            public Thumbnail thumbnail { get; set; }
            /// <summary>
            /// embed image object
            /// </summary>
            public Image image { get; set; }
            /// <summary>
            /// embed footer object
            /// </summary>
            public Footer footer { get; set; }
        }
        public class Author
        {
            /// <summary>
            /// name of author
            /// </summary>
            public string name { get; set; }
            /// <summary>
            /// url of author. If name was used, it becomes a hyperlink
            /// </summary>
            public string url { get; set; }
            /// <summary>
            /// url of author icon
            /// </summary>
            public string icon_url { get; set; }
        }
        public class Thumbnail
        {
            /// <summary>
            /// url of thumbnail
            /// </summary>
            public string url { get; set; }
        }
        public class Image
        {
            /// <summary>
            /// url of image
            /// </summary>
            public string url { get; set; }
        }
        public class Footer
        {
            /// <summary>
            /// footer text, doesn't support Markdown
            /// </summary>
            public string text { get; set; }
            /// <summary>
            /// url of footer icon
            /// </summary>
            public string icon_url { get; set; }
        }
        public class Field
        {
            /// <summary>
            /// name of the field
            /// </summary>
            public string name { get; set; }
            /// <summary>
            /// alue of the field
            /// </summary>
            public string value { get; set; }
            /// <summary>
            /// if true, fields will be displayed in same line, but there can only be 3 max in same line or 2 max if you used thumbnail
            /// </summary>
            public bool inline { get; set; }
        }

        #endregion
        #region Steam Player Info

        public class SteamPlayerInfo
        {
            public Response response { get; set; }
        }

        public class Response
        {
            public Player[] players { get; set; }
        }

        public class Player
        {
            public string steamid { get; set; }
            public int communityvisibilitystate { get; set; }
            public int profilestate { get; set; }
            public string personaname { get; set; }
            public string profileurl { get; set; }
            public string avatar { get; set; }
            public string avatarmedium { get; set; }
            public string avatarfull { get; set; }
            public string avatarhash { get; set; }
            public int lastlogoff { get; set; }
            public int personastate { get; set; }
            public string primaryclanid { get; set; }
            public int timecreated { get; set; }
            public int personastateflags { get; set; }
            public string gameserverip { get; set; }
            public string gameserversteamid { get; set; }
            public string gameextrainfo { get; set; }
            public string gameid { get; set; }
            public string loccountrycode { get; set; }
        }



        #endregion

        #endregion Classes
    }
}


// --- End of file: ChatToDiscord.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/code-commander ---
// --- Original File Path: C/CodeCommander/CodeCommander.cs ---

using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Code Commander", "Hougan", "0.0.3")]
    [Description("Allow customize executable commands when interacting with code-lock")]
    public class CodeCommander : RustPlugin  
    { 
        #region Classes

        private class CodeCommand
        {
            public class Condition 
            {
                [JsonProperty("Action type (Open - on object interact with code, Unlock - on enter code)")]
                public string Action = ""; 
                [JsonProperty("If object type is door (true - only door, false - all objects)")]
                public bool OnlyOnDoor = true;
                [JsonProperty("If code is same with (None - to not check code)")]
                public string Code = "None";
                [JsonProperty("If already authed players amount smaller then (-1 - to not check authed)")]
                public int MaxAuthed = 3;
                [JsonProperty("If already authed players amount bigger then (-1 - to not check authed)")]
                public int MinAuthed = 3;
                
            }
            [JsonProperty("Execute command (vars: %STEAMID%, %NAME%")]
            public string Command = "";
            [JsonProperty("Message on executing command (vars: %STEAMID%, %NAME%")]
            public string Message = "";
            
            [JsonProperty("Conditions to execute command")]
            public Condition Conditions = new Condition(); 
        }
        
        private class Configuration
        {
            [JsonProperty("List of doors with commands")]
            public HashSet<CodeCommand> DoorCommands;

            public static Configuration Generate()
            {
                return new Configuration()
                {
                    DoorCommands = new HashSet<CodeCommand>
                    {
                        new CodeCommand
                        {
                            Command = "env.time 12",
                            Message = "Congratulations, %NAME%, you turned on the sun!",
                            Conditions = new CodeCommand.Condition
                            {
                                Action = "Unlock",
                                Code = "1337",
                                MaxAuthed = 3,
                                MinAuthed = -1
                            }
                        },
                        new CodeCommand
                        {
                            Command = "",
                            Message = "Remember, that according to the rules of the server, you can only play with two friends!",
                            Conditions = new CodeCommand.Condition
                            {
                                Action = "Unlock",
                                Code = "None",
                                MinAuthed = -1,
                                MaxAuthed = 3 
                            }
                        },
                        new CodeCommand
                        {
                            Command = "",
                            Message = "Remember, you are breaking the server rules! Maximum group size - 3 people!",
                            Conditions = new CodeCommand.Condition
                            {
                                Action = "Unlock",
                                Code      = "None",
                                MinAuthed = 3,
                                MaxAuthed = -1
                            }
                        }
                    }
                };
            }
        }
        
        #endregion

        #region Variables

        private static Configuration Settings;

        #endregion

        #region Initialization

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                Settings = Config.ReadObject<Configuration>();
                if (Settings == null) LoadDefaultConfig();
            }
            catch
            {
                PrintError($"An error occurred reading the configuration file!");
                PrintError($"Check it with any JSON Validator!");
                return;
            }
            
            SaveConfig();  
        } 

        protected override void LoadDefaultConfig() => Settings = Configuration.Generate();
        protected override void SaveConfig()        => Config.WriteObject(Settings);

        private void OnServerInitialized()
        {
            int errorsCount = Settings.DoorCommands.Count(p => p.Conditions.Action != "Open" && p.Conditions.Action != "Unlock");
            if (errorsCount > 0) PrintError($"There are {errorsCount} unknown actions types in Configuration!");
        }
        
        #endregion

        #region Hooks
        
        private void CanUseLockedEntity(BasePlayer player, BaseLock baseLock)
        {
            var codeLock = baseLock.GetComponent<CodeLock>();
            if (codeLock == null) return;
            
            var parentEntity = baseLock.GetComponentInParent<BaseEntity>();
            if (parentEntity == null)
            {
                PrintError($"Unknown entity of code-lock!");
                return;
            }
            
            var isDoor = parentEntity is Door;
            var possibleCommands = Settings.DoorCommands.Where(p => p.Conditions.Action == "Open" && (p.Conditions.OnlyOnDoor && isDoor || !p.Conditions.OnlyOnDoor)).ToList();
            if (possibleCommands.Count == 0) return; 
            
            foreach (var check in possibleCommands)
            {
                var conditions = check.Conditions;
                
                if (conditions.Code      != "None" && conditions.Code                 != codeLock.code) continue;
                if (conditions.MinAuthed != -1     && codeLock.whitelistPlayers.Count < conditions.MinAuthed) continue;
                if (conditions.MaxAuthed != -1     && codeLock.whitelistPlayers.Count > conditions.MaxAuthed) continue;
                
                if (!string.IsNullOrEmpty(check.Command)) Server.Command(PrepareString(player,     check.Command));
                if (!string.IsNullOrEmpty(check.Message)) player.ChatMessage(PrepareString(player, check.Message)); 
            }
        }
        
        private void CanChangeCode(BasePlayer player, CodeLock codeLock, string newCode, bool isGuestCode) => OnCodeEntered(codeLock, player, newCode); 
        
        private void OnCodeEntered(CodeLock codeLock, BasePlayer player, string code)
        {
            var parentEntity = codeLock.GetParentEntity();
            if (parentEntity == null)
            {
                PrintError($"Unknown entity of code-lock!");
                return;
            }
            
            var isDoor = parentEntity is Door;
            var possibleCommands = Settings.DoorCommands.Where(p => p.Conditions.Action == "Unlock" && (p.Conditions.OnlyOnDoor && isDoor || !p.Conditions.OnlyOnDoor)).ToList();
            if (possibleCommands.Count == 0) return;

            foreach (var check in possibleCommands)
            {
                var conditions = check.Conditions;
                
                if (conditions.Code != "None" && conditions.Code != code) continue;
                if (conditions.MinAuthed != -1 && codeLock.whitelistPlayers.Count < conditions.MinAuthed) continue;
                if (conditions.MaxAuthed != -1 && codeLock.whitelistPlayers.Count > conditions.MaxAuthed) continue;
                
                if (!string.IsNullOrEmpty(check.Command)) Server.Command(PrepareString(player,     check.Command));
                if (!string.IsNullOrEmpty(check.Message)) player.ChatMessage(PrepareString(player, check.Message)); 
            }
        }

        #endregion

        #region Utils

        private string PrepareString(BasePlayer player, string input) => input.Replace("%STEAMID%", player.UserIDString).Replace("%NAME%", player.displayName);

        #endregion
    }
}

// --- End of file: CodeCommander.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/clans ---
// --- Original File Path: C/Clans/Clans.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    using ClansEx;

    [Info("Clans", "k1lly0u", "0.2.8")]
    public class Clans : CovalencePlugin
    {
        #region Fields        
        private bool isInitialized = false;

        private Regex hexFilter = new Regex("^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$");

        public static Clans Instance { get; private set; }

        private static readonly DateTime Epoch = new DateTime(1970, 1, 1);

        private static readonly double MaxUnixSeconds = (DateTime.MaxValue - Epoch).TotalSeconds;

        private const string COLORED_LABEL = "[{0}]{1}[/#]";
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            Instance = this;
            LoadData();
        }

        protected override void LoadDefaultMessages() => lang.RegisterMessages(Messages, this);

        private void OnServerInitialized()
        {
            if (!configData.Tags.Enabled)
                Unsubscribe(nameof(OnPluginLoaded));

            InitializeClans();
        }

        private void OnPluginLoaded(Plugin plugin)
        {
            if (configData.Tags.Enabled && plugin?.Title == "Better Chat")
                Interface.CallHook("API_RegisterThirdPartyTitle", this, new Func<IPlayer, string>(BetterChat_FormattedClanTag));
        }

        private void OnUserConnected(IPlayer player)
        {            
            Clan clan = storedData?.FindClanByID(player.Id);
            if (clan != null)
            {
                clan.OnPlayerConnected(player);
            }
            else
            {
                List<string> invites;
                if (storedData.playerInvites.TryGetValue(player.Id, out invites))
                {
                    player.Reply(string.Format(Message("Notification.PendingInvites", player.Id), invites.ToSentence(), "clan"));
                }
            }
        }

        private void OnUserDisconnected(IPlayer player) => storedData?.FindClanByID(player.Id)?.OnPlayerDisconnected(player);

        private void Unload()
        {
            SaveData();

            Instance = null;
        }
        #endregion

        #region Functions
        private void InitializeClans()
        {
            Puts("Initializing Clans...");

            List<string> purgedClans = ListPool.Get<string>();

            foreach (KeyValuePair<string, Clan> kvp in storedData.clans)
            {
                Clan clan = kvp.Value;

                if (clan.ClanMembers.Count == 0 || (configData.Purge.Enabled && UnixTimeStampUTC() - clan.LastOnlineTime > (configData.Purge.OlderThanDays * 86400)))
                {
                    purgedClans.Add(kvp.Key);
                    continue;
                }

                if (configData.Clans.Alliance.Enabled)
                {
                    for (int i = clan.AllianceInvites.Count - 1; i >= 0; i--)
                    {
                        KeyValuePair<string, double> allianceInvite = clan.AllianceInvites.ElementAt(i);

                        if (!storedData.clans.ContainsKey(allianceInvite.Key) || (UnixTimeStampUTC() - allianceInvite.Value > configData.Clans.Invites.AllianceInviteExpireTime))
                            clan.AllianceInvites.Remove(allianceInvite.Key);
                    }

                    for (int i = clan.Alliances.Count - 1; i >= 0; i--)
                    {
                        string allyTag = clan.Alliances.ElementAt(i);

                        if (!storedData.clans.ContainsKey(allyTag))
                            clan.Alliances.Remove(allyTag);
                    }
                }

                for (int i = clan.MemberInvites.Count - 1; i >= 0; i--)
                {
                    KeyValuePair<string, Clan.MemberInvite> memberInvite = clan.MemberInvites.ElementAt(i);

                    if (UnixTimeStampUTC() - memberInvite.Value.ExpiryTime > configData.Clans.Invites.MemberInviteExpireTime)
                        clan.MemberInvites.Remove(memberInvite.Key);
                }

                foreach (KeyValuePair<string, Clan.Member> member in clan.ClanMembers)
                    storedData.RegisterPlayer(member.Key, clan.Tag);
            }

            if (purgedClans.Count > 0)
            {
                Puts($"Purging {purgedClans.Count} expired or invalid clans");

                StringBuilder str = new StringBuilder();

                for (int i = 0; i < purgedClans.Count; i++)
                {
                    string tag = purgedClans[i];
                    Clan clan = storedData.clans[tag];
                    if (clan == null)
                        continue;

                    str.Append($"{(i > 0 ? "\n" : "")}Purged - [{tag}] | {clan.Description} | Owner: {clan.OwnerID} | Last Online: {UnixTimeStampToDateTime(clan.LastOnlineTime)}");

                    storedData.clans.Remove(tag);
                }

                if (configData.Purge.ListPurgedClans)
                {
                    Puts(str.ToString());

                    if (configData.Options.LogChanges)
                        LogToFile(Title, str.ToString(), this);
                }
            }

            Puts($"Loaded {storedData.clans.Count} clans!");

            ListPool.Free(ref purgedClans);

            if (configData.Tags.Enabled)
                Interface.CallHook("API_RegisterThirdPartyTitle", this, new Func<Oxide.Core.Libraries.Covalence.IPlayer, string>(BetterChat_FormattedClanTag));

            isInitialized = true;

            foreach (IPlayer player in players.Connected)
                OnUserConnected(player);

            TimedSaveData();
        }

        private bool ClanTagExists(string tag)
        {
            ICollection<string> collection = storedData.clans.Keys;
            for (int i = 0; i < collection.Count; i++)
            {
                if (collection.ElementAt(i).Equals(tag, StringComparison.OrdinalIgnoreCase))
                    return true;
            }

            return false;
        }

        private string FormatTime(double time)
        {
            TimeSpan dateDifference = TimeSpan.FromSeconds((float)time);
            int days = dateDifference.Days;
            int hours = dateDifference.Hours + (days * 24);

            int mins = dateDifference.Minutes;
            int secs = dateDifference.Seconds;

            if (hours > 0)
                return string.Format("{0:00}h:{1:00}m:{2:00}s", hours, mins, secs);
            else if (mins > 0)
                return string.Format("{0:00}m:{1:00}s", mins, secs);
            else return string.Format("{0:00}s", secs);
        }

        private string BetterChat_FormattedClanTag(IPlayer player)
        {            
            Clan clan = storedData.FindClanByID(player.Id);
            if (clan == null)
                return string.Empty;

            return $"[#{(string.IsNullOrEmpty(clan.TagColor) || !configData.Tags.CustomColors ? configData.Tags.TagColor.Replace("#", "") : clan.TagColor.Replace("#", ""))}][+{configData.Tags.TagSize}]{configData.Tags.TagOpen}{clan.Tag}{configData.Tags.TagClose}[/+][/#]";
        }

        private static int UnixTimeStampUTC() => (int)DateTime.UtcNow.Subtract(Epoch).TotalSeconds;

        private static DateTime UnixTimeStampToDateTime(double unixTimeStamp)
        {
            return unixTimeStamp > MaxUnixSeconds
                ? Epoch.AddMilliseconds(unixTimeStamp)
                : Epoch.AddSeconds(unixTimeStamp);
        }
        #endregion

        #region Clan Management   
        [HookMethod("CreateClan")]
        public void CreateClan(IPlayer player, string tag, string description)
        {
            if (player == null)
                return;

            if (storedData.FindClanByID(player.Id) != null)
            {
                player.Reply(Message("Notification.Create.InExistingClan", player.Id));
                return;
            }

            if (tag.Length < configData.Tags.TagLength.Minimum || tag.Length > configData.Tags.TagLength.Maximum)
            {
                player.Reply(string.Format(Message("Notification.Create.InvalidTagLength", player.Id), configData.Tags.TagLength.Minimum, configData.Tags.TagLength.Maximum));
                return;
            }

            if (ClanTagExists(tag))
            {
                player.Reply(Message("Notification.Create.ClanExists", player.Id));
                return;
            }

            storedData.clans[tag] = new Clan(player, tag, description);
            storedData.RegisterPlayer(player.Id, tag);

            player.Reply(string.Format(Message("Notification.Create.Success", player.Id), tag));

            Interface.CallHook("OnClanCreate", tag);

            if (configData.Options.LogChanges)
                LogToFile(Title, $"{player.Name} created the clan [{tag}]", this);
        }

        [HookMethod("InvitePlayer")]
        public bool InvitePlayer(IPlayer inviter, string targetId)
        {
            IPlayer invitee = covalence.Players.FindPlayerById(targetId) ?? null;
            if (invitee == null)
            {
                inviter.Reply(string.Format(Message("Notification.Generic.UnableToFindPlayer", inviter.Id), targetId));
                return false;
            }

            return InvitePlayer(inviter, invitee);
        }

        [HookMethod("InvitePlayer")]
        public bool InvitePlayer(IPlayer inviter, IPlayer invitee)
        {
            if (inviter == null || invitee == null)
                return false;

            Clan clan = storedData.FindClanByID(inviter.Id);
            if (clan == null)
            {
                inviter.Reply(Message("Notification.Generic.NoClan", inviter.Id));
                return false;
            }

            Clan other = storedData.FindClanByID(invitee.Id);
            if (other != null)
            {
                inviter.Reply(string.Format(Message("Notification.Invite.InClan", inviter.Id), invitee.Name));
                return false;
            }

            return clan.InvitePlayer(inviter, invitee);
        }

        [HookMethod("WithdrawInvite")]
        public bool WithdrawInvite(IPlayer player, string partialNameOrID)
        {
            if (player == null)
                return false;

            Clan clan = storedData.FindClanByID(player.Id);
            if (clan == null)
            {
                player.Reply(Message("Notification.Generic.NoClan", player.Id));
                return false;
            }

            if (!clan.IsOwner(player.Id) && !clan.IsModerator(player.Id))
            {
                player.Reply(Message("Notification.WithdrawInvite.NoPermissions", player.Id));
                return false;
            }

            foreach (KeyValuePair<string, Clan.MemberInvite> invite in clan.MemberInvites)
            {
                if (partialNameOrID.Equals(invite.Key) || invite.Value.DisplayName.Contains(partialNameOrID))
                {
                    storedData.RevokePlayerInvite(partialNameOrID, clan.Tag);

                    clan.MemberInvites.Remove(invite.Key);
                    clan.Broadcast("Notification.WithdrawInvite.Success", player.Name, invite.Value.DisplayName);
                    return true;
                }
            }

            player.Reply(string.Format(Message("Notification.WithdrawInvite.UnableToFind", player.Id), partialNameOrID));
            return false;
        }

        [HookMethod("RejectInvite")]
        public bool RejectInvite(IPlayer player, string tag)
        {
            if (player == null)
                return false;

            Clan clan = storedData.FindClan(tag);
            if (clan == null)
            {
                player.Reply(string.Format(Message("Notification.Generic.InvalidClan", player.Id), tag));
                return false;
            }

            if (!clan.MemberInvites.ContainsKey(player.Id))
            {
                player.Reply(string.Format(Message("Notification.RejectInvite.InvalidInvite", player.Id), tag));
                return false;
            }

            clan.MemberInvites.Remove(player.Id);

            storedData.OnInviteRejected(player.Id, clan.Tag);

            clan.Broadcast("Notification.RejectInvite.Reply", player.Name);
            player.Reply(string.Format(Message("Notification.RejectInvite.PlayerMessage", player.Id), tag));

            if (configData.Options.LogChanges)
                Instance.LogToFile(Instance.Title, $"{player.Name} rejected their invite to [{tag}]", Instance);

            return true;
        }

        [HookMethod("JoinClan")]
        public bool JoinClan(IPlayer player, string tag)
        {
            if (player == null || string.IsNullOrEmpty(tag))
                return false;

            Clan clan = storedData.FindClanByID(player.Id);
            if (clan != null)
            {
                player.Reply(Message("Notification.Join.InExistingClan", player.Id));
                return false;
            }

            clan = storedData.FindClan(tag);
            if (clan == null)
                return false;

            return clan.JoinClan(player);
        }

        [HookMethod("LeaveClan")]
        public bool LeaveClan(IPlayer player)
        {
            if (player == null)
                return false;

            Clan clan = storedData.FindClanByID(player.Id);
            if (clan == null)
            {
                player.Reply(Message("Notification.Generic.NoClan", player.Id));
                return false;
            }

            return clan.LeaveClan(player);
        }

        [HookMethod("KickPlayer")]
        public bool KickPlayer(IPlayer player, string playerId)
        {
            if (player == null)
                return false;

            Clan clan = storedData.FindClanByID(player.Id);
            if (clan == null)
            {
                player.Reply(Message("Notification.Generic.NoClan", player.Id));
                return false;
            }

            return clan.KickMember(player, playerId);
        }

        [HookMethod("PromotePlayer")]
        public bool PromotePlayer(IPlayer promoter, string targetId)
        {
            if (promoter == null)
                return false;

            Clan clan = storedData.FindClanByID(promoter.Id);
            if (clan == null)
            {
                promoter.Reply(Message("Notification.Generic.NoClan", promoter.Id));
                return false;
            }

            Clan other = storedData.FindClanByID(targetId);
            if (other == null || !clan.Tag.Equals(other.Tag))
            {
                string Name = covalence.Players.FindPlayer(targetId)?.Name ?? targetId;

                promoter.Reply(string.Format(Message("Notification.Promotion.TargetNoClan", promoter.Id), Name));
                return false;
            }

            return clan.PromotePlayer(promoter, targetId);
        }

        [HookMethod("DemotePlayer")]
        public bool DemotePlayer(IPlayer demoter, string targetId)
        {
            if (demoter == null)
                return false;

            Clan clan = storedData.FindClanByID(demoter.Id);
            if (clan == null)
            {
                demoter.Reply(Message("Notification.Generic.NoClan", demoter.Id));
                return false;
            }

            Clan other = storedData.FindClanByID(targetId);
            if (other == null || !clan.Tag.Equals(other.Tag))
            {
                string Name = covalence.Players.FindPlayer(targetId)?.Name ?? targetId;

                demoter.Reply(string.Format(Message("Notification.Promotion.TargetNoClan", demoter.Id), Name));
                return false;
            }

            return clan.DemotePlayer(demoter, targetId);
        }

        [HookMethod("DisbandClan")]
        public bool DisbandClan(IPlayer player)
        {
            Clan clan = storedData.FindClanByID(player.Id);

            if (clan == null)
            {
                player.Reply(Message("Notification.Generic.NoClan", player.Id));
                return false;
            }

            if (!clan.IsOwner(player.Id))
            {
                player.Reply(Message("Notification.Disband.NotOwner", player.Id));
                return false;
            }

            string tag = clan.Tag;

            clan.Broadcast("Notification.Disband.Reply", Array.Empty<object>());
            clan.DisbandClan();

            player.Reply(string.Format(Message("Notification.Disband.Success", player.Id), tag));

            return true;
        }
        #endregion

        #region Alliance Management
        [HookMethod("OfferAlliance")]
        public bool OfferAlliance(IPlayer player, string tag)
        {
            if (!configData.Clans.Alliance.Enabled)
                return false;

            Clan clan = storedData.FindClanByID(player.Id);
            if (clan == null)
            {
                player.Reply(Message("Notification.Generic.NoClan", player.Id));
                return false;
            }

            Clan alliedClan = storedData.FindClan(tag);
            if (alliedClan == null)
            {
                player.Reply(string.Format(Message("Notification.Generic.InvalidClan", player.Id), tag));
                return false;
            }

            if (!clan.IsOwner(player.Id))
            {
                player.Reply(Message("Notification.Alliance.NoPermissions", player.Id));
                return false;
            }

            if (clan.AllianceInvites.ContainsKey(tag) && (UnixTimeStampUTC() - clan.AllianceInvites[tag] < configData.Clans.Invites.AllianceInviteExpireTime))
            {
                player.Reply(string.Format(Message("Notification.Alliance.PendingInvite", player.Id), tag));
                return false;
            }

            if (clan.AllianceInviteCount >= configData.Clans.Invites.AllianceInviteLimit)
            {
                player.Reply(Message("Notification.Alliance.MaximumInvites", player.Id));
                return false;
            }

            if (clan.AllianceCount >= configData.Clans.Alliance.AllianceLimit)
            {
                player.Reply(Message("Notification.Alliance.MaximumAlliances", player.Id));
                return false;
            }

            clan.AllianceInvites[tag] = UnixTimeStampUTC();
            alliedClan.IncomingAlliances.Add(clan.Tag);

            player.Reply(string.Format(Message("Notification.Alliance.InviteSent", player.Id), tag, FormatTime(configData.Clans.Invites.AllianceInviteExpireTime)));

            alliedClan.Broadcast("Notification.Alliance.InviteReceived", clan.Tag, FormatTime(configData.Clans.Invites.AllianceInviteExpireTime), "ally");

            return true;
        }

        [HookMethod("WithdrawAlliance")]
        public bool WithdrawAlliance(IPlayer player, string tag)
        {
            if (!configData.Clans.Alliance.Enabled)
                return false;

            Clan clan = storedData.FindClanByID(player.Id);
            if (clan == null)
            {
                player.Reply(Message("Notification.Generic.NoClan", player.Id));
                return false;
            }

            Clan alliedClan = storedData.FindClan(tag);
            if (alliedClan == null)
            {
                player.Reply(string.Format(Message("Notification.Generic.InvalidClan", player.Id), tag));
                return false;
            }

            if (!clan.IsOwner(player.Id))
            {
                player.Reply(Message("Notification.Alliance.NoPermissions", player.Id));
                return false;
            }

            if (!clan.AllianceInvites.ContainsKey(tag))
            {
                player.Reply(string.Format(Message("Notification.Alliance.NoActiveInvite", player.Id), tag));
                return false;
            }

            clan.AllianceInvites.Remove(tag);
            alliedClan.IncomingAlliances.Remove(clan.Tag);

            clan.Broadcast("Notification.Alliance.WithdrawnClan", player.Name, tag);
            alliedClan.Broadcast("Notification.Alliance.WithdrawnTarget", clan.Tag);

            clan.MarkDirty();

            return true;
        }

        [HookMethod("AcceptAlliance")]
        public bool AcceptAlliance(IPlayer player, string tag)
        {
            if (!configData.Clans.Alliance.Enabled)
                return false;

            Clan clan = storedData.FindClanByID(player.Id);
            if (clan == null)
            {
                player.Reply(Message("Notification.Generic.NoClan", player.Id));
                return false;
            }

            Clan alliedClan = storedData.FindClan(tag);
            if (alliedClan == null)
            {
                player.Reply(string.Format(Message("Notification.Generic.InvalidClan", player.Id), tag));
                return false;
            }

            if (!clan.IsOwner(player.Id))
            {
                player.Reply(Message("Notification.Alliance.NoPermissions", player.Id));
                return false;
            }

            bool noActiveInvite = !alliedClan.AllianceInvites.ContainsKey(clan.Tag);

            if ((UnixTimeStampUTC() - alliedClan.AllianceInvites[clan.Tag] > configData.Clans.Invites.AllianceInviteExpireTime))
            {
                alliedClan.AllianceInvites.Remove(clan.Tag);
                noActiveInvite = true;
            }

            if (noActiveInvite)
            {
                player.Reply(string.Format(Message("Notification.Alliance.NoActiveInviteFrom", player.Id), tag));
                return false;
            }

            if (alliedClan.AllianceCount >= configData.Clans.Alliance.AllianceLimit)
            {
                player.Reply(string.Format(Message("Notification.Alliance.AtLimitTarget", player.Id), tag));
                return false;
            }

            if (clan.AllianceCount >= configData.Clans.Alliance.AllianceLimit)
            {
                player.Reply(string.Format(Message("Notification.Alliance.AtLimitSelf", player.Id), tag));
                return false;
            }

            clan.Alliances.Add(tag);
            clan.IncomingAlliances.Remove(tag);

            alliedClan.Alliances.Add(clan.Tag);
            alliedClan.AllianceInvites.Remove(clan.Tag);

            clan.MarkDirty();
            alliedClan.MarkDirty();

            clan.Broadcast("Notification.Alliance.Formed", clan.Tag, alliedClan.Tag);
            alliedClan.Broadcast("Notification.Alliance.Formed", clan.Tag, alliedClan.Tag);

            Interface.Oxide.CallHook("OnClanUpdate", clan.Tag);
            Interface.Oxide.CallHook("OnClanUpdate", alliedClan.Tag);

            return true;
        }

        [HookMethod("RejectAlliance")]
        public bool RejectAlliance(IPlayer player, string tag)
        {
            if (!configData.Clans.Alliance.Enabled)
                return false;

            Clan clan = storedData.FindClanByID(player.Id);
            if (clan == null)
            {
                player.Reply(string.Format(Message("Notification.Generic.InvalidClan", player.Id), tag));
                return false;
            }

            Clan alliedClan = storedData.FindClan(tag);
            if (alliedClan == null)
            {
                player.Reply(Message("Notification.Generic.InvalidClan", player.Id));
                return false;
            }

            if (!clan.IsOwner(player.Id))
            {
                player.Reply(Message("Notification.Alliance.NoPermissions", player.Id));
                return false;
            }

            if (!alliedClan.AllianceInvites.ContainsKey(clan.Tag) || (UnixTimeStampUTC() - alliedClan.AllianceInvites[clan.Tag] > configData.Clans.Invites.AllianceInviteExpireTime))
            {
                player.Reply(string.Format(Message("Notification.Alliance.NoActiveInvite", player.Id), tag));
                return false;
            }

            clan.IncomingAlliances.Remove(tag);

            alliedClan.AllianceInvites.Remove(clan.Tag);
            alliedClan.MarkDirty();

            clan.Broadcast("Notification.Alliance.Rejected", clan.Tag, alliedClan.Tag);
            alliedClan.Broadcast("Notification.Alliance.Rejected", clan.Tag, alliedClan.Tag);

            return true;
        }

        [HookMethod("RevokeAlliance")]
        public bool RevokeAlliance(IPlayer player, string tag)
        {
            if (!configData.Clans.Alliance.Enabled)
                return false;

            Clan clan = storedData.FindClanByID(player.Id);
            if (clan == null)
            {
                player.Reply(string.Format(Message("Notification.Generic.InvalidClan", player.Id), tag));
                return false;
            }

            Clan alliedClan = storedData.FindClan(tag);
            if (alliedClan == null)
            {
                player.Reply(Message("Notification.Generic.InvalidClan", player.Id));
                return false;
            }

            if (!clan.IsOwner(player.Id))
            {
                player.Reply(Message("Notification.Alliance.NoPermissions", player.Id));
                return false;
            }

            if (!clan.Alliances.Contains(alliedClan.Tag))
            {
                player.Reply(string.Format(Message("Notification.Alliance.NoActiveAlliance", player.Id), alliedClan.Tag));
                return false;
            }

            alliedClan.Alliances.Remove(clan.Tag);
            clan.Alliances.Remove(alliedClan.Tag);

            alliedClan.MarkDirty();
            clan.MarkDirty();

            clan.Broadcast("Notification.Alliance.Revoked", clan.Tag, alliedClan.Tag);
            alliedClan.Broadcast("Notification.Alliance.Revoked", clan.Tag, alliedClan.Tag);

            return true;
        }
        #endregion

        #region Chat
        private void ClanChat(IPlayer player, string message)
        {
            if (player == null)
                return;

            Clan clan = storedData.FindClanByID(player.Id);
            if (clan == null)
                return;

            string str = string.Format(Message("Chat.Alliance.Format"), clan.Tag, clan.GetRoleColor(player.Id), player.Name, message);

            clan.Broadcast(string.Format(Message("Chat.Clan.Prefix"), str));

            Interface.CallHook("OnClanChat", player, message, clan.Tag);
        }

        private void AllianceChat(IPlayer player, string message)
        {
            Clan clan = storedData.FindClanByID(player.Id);
            if (clan == null)
                return;

            string str = string.Format(Message("Chat.Alliance.Format"), clan.Tag, clan.GetRoleColor(player.Id), player.Name, message);

            clan.Broadcast(string.Format(Message("Chat.Alliance.Prefix"), str));

            for (int i = 0; i < clan.AllianceCount; i++)
            {
                Clan alliedClan = storedData.FindClan(clan.Alliances.ElementAt(i));
                if (alliedClan != null)
                {
                    alliedClan.Broadcast(string.Format(Message("Chat.Alliance.Prefix"), str));
                }
            }

            Interface.CallHook("OnAllianceChat", player, message, clan.Tag);
        }
        #endregion

        #region Chat Commands
        [Command("a")]
        private void cmdAllianceChat(IPlayer player, string command, string[] args)
        {
            if (!configData.Clans.Alliance.Enabled || args?.Length == 0)
                return;

            AllianceChat(player, string.Join(" ", args));
        }

        [Command("c")]
        private void cmdClanChat(IPlayer player, string command, string[] args)
        {
            if (args?.Length == 0)
                return;

            ClanChat(player, string.Join(" ", args));
        }

        [Command("cinfo")]
        private void cmdChatClanInfo(IPlayer player, string command, string[] args)
        {            
            if (args?.Length == 0)
            {
                player.Reply(Message("Notification.Generic.SpecifyClanTag", player.Id));
                return;
            }

            Clan clan = storedData.FindClan(args[0]);
            if (clan == null)
            {
                player.Reply(string.Format(Message("Notification.Generic.InvalidClan", player.Id), args[0]));
                return;
            }

            clan.PrintClanInfo(player);
        }

        [Command("clanhelp")]
        private void cmdChatClanHelp(IPlayer player, string command, string[] args)
        {
            StringBuilder sb = new StringBuilder();

            Clan clan = storedData.FindClanByID(player.Id);
            if (clan == null)
            {
                sb.Append(Message("Notification.ClanInfo.Title", player.Id));
                sb.Append(string.Format(Message("Notification.ClanHelp.NoClan", player.Id), "clan"));
                player.Reply(sb.ToString());
                return;
            }

            sb.Append(Message("Notification.ClanInfo.Title", player.Id));
            sb.Append(string.Format(Message("Notification.ClanHelp.Basic", player.Id), "clan", "c"));

            if (clan.IsModerator(player.Id) || clan.OwnerID.Equals(player.Id))
            {
                if (configData.Clans.Alliance.Enabled && clan.OwnerID.Equals(player.Id))
                    sb.Append(string.Format(Message("Notification.ClanHelp.Alliance", player.Id), "ally"));

                sb.Append(string.Format(Message("Notification.ClanHelp.Moderator", player.Id), "clan"));
            }

            if (clan.OwnerID.Equals(player.Id))
            {
                sb.Append(string.Format(Message("Notification.ClanHelp.Owner", player.Id), "clan"));

                if (configData.Tags.CustomColors)
                    sb.Append(string.Format(Message("Notification.ClanHelp.TagColor", player.Id), "clan"));
            }

            player.Reply(sb.ToString());

        }

        [Command("ally")]
        private void cmdChatClanAlly(IPlayer player, string command, string[] args)
        {
            if (!configData.Clans.Alliance.Enabled)
                return;

            if (args?.Length < 2)
            {
                player.Reply(string.Format(Message("Notification.ClanHelp.Alliance", player.Id), "ally"));
                return;
            }

            string tag = args[1];

            switch (args[0].ToLower())
            {
                case "invite":
                    OfferAlliance(player, tag);
                    return;
                case "withdraw":
                    WithdrawAlliance(player, tag);
                    return;
                case "accept":
                    AcceptAlliance(player, tag);
                    return;
                case "reject":
                    RejectAlliance(player, tag);
                    return;
                case "revoke":
                    RevokeAlliance(player, tag);
                    return;
                default:
                    player.Reply(string.Format(Message("Notification.ClanHelp.Alliance", player.Id), "ally"));
                    return;
            }
        }

        [Command("clan")]
        private void cmdChatClan(IPlayer player, string command, string[] args)
        {
            Clan clan = storedData.FindClanByID(player.Id);

            if (args?.Length == 0)
            {
                StringBuilder sb = new StringBuilder();
                if (clan == null)
                {
                    sb.Append(Message("Notification.ClanInfo.Title", player.Id));
                    sb.Append(Message("Notification.Clan.NotInAClan", player.Id));
                    sb.Append(string.Format(Message("Notification.Clan.Help", player.Id), "clanhelp"));
                    player.Reply(sb.ToString());
                    sb.Clear();
                }
                else
                {
                    sb.Append(Message("Notification.ClanInfo.Title", player.Id));
                    sb.Append(string.Format(Message((clan.IsOwner(player.Id) ? "Notification.Clan.OwnerOf" : clan.IsModerator(player.Id) ? "Notification.Clan.ModeratorOf" : "Notification.Clan.MemberOf"), player.Id), clan.Tag, clan.OnlineCount, clan.MemberCount));
                    sb.Append(string.Format(Message("Notification.Clan.MembersOnline", player.Id), clan.GetMembersOnline()));

                    sb.Append(string.Format(Message("Notification.Clan.Help", player.Id), "clanhelp"));
                    player.Reply(sb.ToString());
                    sb.Clear();
                }
                return;
            }

            string tag = clan?.Tag ?? string.Empty;

            switch (args[0].ToLower())
            {
                case "create":
                    if (args.Length < 2)
                    {
                        player.Reply(string.Format(Message("Notification.Clan.CreateSyntax", player.Id), "clan"));
                        return;
                    }

                    CreateClan(player, args[1], args.Length > 2 ? string.Join(" ", args.Skip(2)) : string.Empty);
                    return;

                case "leave":
                    LeaveClan(player);
                    return;

                case "invite":
                    if (args.Length < 2)
                    {
                        player.Reply(string.Format(Message("Notification.Clan.InviteSyntax", player.Id), "clan"));
                        return;
                    }

                    IPlayer invitee = players.FindPlayer(args[1]);
                    if (invitee == null)
                    {
                        player.Reply(string.Format(Message("Notification.Generic.UnableToFindPlayer", player.Id), args[1]));
                        return;
                    }

                    if (invitee == player)
                    {
                        player.Reply(Message("Notification.Generic.CommandSelf", player.Id));
                        return;
                    }

                    InvitePlayer(player, invitee);
                    return;

                case "withdraw":
                    if (args.Length < 2)
                    {
                        player.Reply(string.Format(Message("Notification.Clan.WithdrawSyntax", player.Id), "clan"));
                        return;
                    }

                    WithdrawInvite(player, args[1]);
                    return;

                case "accept":
                    if (args.Length < 2)
                    {
                        player.Reply(string.Format(Message("Notification.Clan.AcceptSyntax", player.Id), "clan"));
                        return;
                    }

                    JoinClan(player, args[1]);
                    return;

                case "reject":
                    if (args.Length < 2)
                    {
                        player.Reply(string.Format(Message("Notification.Clan.RejectSyntax", player.Id), "clan"));
                        return;
                    }

                    RejectInvite(player, args[1]);
                    return;

                case "kick":
                    if (args.Length < 2)
                    {
                        player.Reply(string.Format(Message("Notification.Clan.KickSyntax", player.Id), "clan"));
                        return;
                    }

                    string target = clan.FindPlayer(args[1]);
                    if (string.IsNullOrEmpty(target))
                    {
                        player.Reply(Message("Notification.Kick.NoPlayerFound", player.Id));
                        return;
                    }

                    if (target == player.Id)
                    {
                        player.Reply(Message("Notification.Generic.CommandSelf", player.Id));
                        return;
                    }

                    KickPlayer(player, target);
                    return;

                case "promote":
                    if (args.Length < 2)
                    {
                        player.Reply(string.Format(Message("Notification.Clan.PromoteSyntax", player.Id), "clan"));
                        return;
                    }

                    string promotee = clan.FindPlayer(args[1]);
                    if (string.IsNullOrEmpty(promotee))
                    {
                        player.Reply(string.Format(Message("Notification.Generic.UnableToFindPlayer", player.Id), args[1]));
                        return;
                    }

                    if (promotee == player.Id)
                    {
                        player.Reply(Message("Notification.Generic.CommandSelf", player.Id));
                        return;
                    }

                    PromotePlayer(player, promotee);
                    return;

                case "demote":
                    if (args.Length < 2)
                    {
                        player.Reply(string.Format(Message("Notification.Clan.DemoteSyntax", player.Id), "clan"));
                        return;
                    }

                    string demotee = clan.FindPlayer(args[1]);
                    if (string.IsNullOrEmpty(demotee))
                    {
                        player.Reply(string.Format(Message("Notification.Generic.UnableToFindPlayer", player.Id), args[1]));
                        return;
                    }

                    if (demotee == player.Id)
                    {
                        player.Reply(Message("Notification.Generic.CommandSelf", player.Id));
                        return;
                    }

                    DemotePlayer(player, demotee);
                    return;

                case "disband":
                    if (args.Length < 2 || !args[1].Equals("forever", StringComparison.OrdinalIgnoreCase))
                    {
                        player.Reply(string.Format(Message("Notification.Clan.DisbandSyntax", player.Id), "clan"));
                        return;
                    }

                    if (clan == null)
                    {
                        player.Reply(Message("Notification.Generic.NoClan", player.Id));
                        return;
                    }

                    if (!clan.IsOwner(player.Id))
                    {
                        player.Reply(Message("Notification.Disband.NotOwner", player.Id));
                        return;
                    }

                    clan.Broadcast("Notification.Disband.Reply", Array.Empty<object>());
                    clan.DisbandClan();

                    player.Reply(string.Format(Message("Notification.Disband.Success", player.Id), tag));
                    return;

                case "tagcolor":
                    if (!configData.Tags.CustomColors)
                    {
                        player.Reply(Message("Notification.Clan.TagColorDisabled", player.Id));
                        return;
                    }

                    if (args.Length < 2)
                    {
                        player.Reply(string.Format(Message("Notification.Clan.TagColorSyntax", player.Id), "clan"));
                        return;
                    }

                    if (!clan.IsOwner(player.Id))
                    {
                        player.Reply(Message("Notification.Disband.NotOwner", player.Id));
                        return;
                    }

                    string hexColor = args[1].ToUpper();

                    if (hexColor.Equals("RESET"))
                    {
                        clan.TagColor = string.Empty;
                        player.Reply(Message("Notification.Clan.TagColorReset", player.Id));
                        return;
                    }

                    if (hexColor.Length < 6 || hexColor.Length > 6 || !hexFilter.IsMatch(hexColor))
                    {
                        player.Reply(Message("Notification.Clan.TagColorFormat", player.Id));
                        return;
                    }

                    clan.TagColor = hexColor;
                    player.Reply(string.Format(Message("Notification.Clan.TagColorSet", player.Id), clan.TagColor));
                    return;

                default:
                    player.Reply(string.Format(Message("Notification.Clan.Help", player.Id), "clanhelp"));
                    return;
            }
        }

        #endregion

        #region API       
        private JObject GetClan(string tag)
        {
            if (!string.IsNullOrEmpty(tag))
                return storedData.FindClan(tag)?.ToJObject();

            return null;
        }

        private JArray GetAllClans() => new JArray(storedData.clans.Keys);
        
        private string GetClanOf(string playerId) => storedData.FindClanByID(playerId)?.Tag ?? null;

        private string GetClanOf(ulong playerId) => GetClanOf(playerId.ToString());

        private string GetClanOf(IPlayer player) => GetClanOf(player?.Id ?? string.Empty);

        #if RUST
        private string GetClanOf(BasePlayer player) => GetClanOf(player?.UserIDString ?? string.Empty);
        #endif

        #if HURTWORLD
        private string GetClanOf(PlayerSession session) => GetClanOf(session?.SteamId ?? string.Empty);
        #endif

        private List<string> GetClanMembers(ulong playerId) => GetClanMembers(playerId.ToString());
        
        private List<string> GetClanMembers(string playerId) => storedData.FindClanByID(playerId)?.ClanMembers.Keys.ToList() ?? new List<string>();

        private object HasFriend(ulong ownerId, ulong playerId) => HasFriend(ownerId.ToString(), playerId.ToString());
        private object HasFriend(string ownerId, string playerId)
        {
            Clan clanOwner = storedData.FindClanByID(ownerId);
            if (clanOwner == null)
                return null;

            Clan clanFriend = storedData.FindClanByID(playerId);
            if (clanFriend == null)
                return null;

            return clanOwner.Tag.Equals(clanFriend.Tag);
        }

        private bool IsClanMember(ulong playerId, ulong otherId) => IsClanMember(playerId.ToString(), otherId.ToString());
        private bool IsClanMember(string playerId, string otherId)
        {
            Clan clanPlayer = storedData.FindClanByID(playerId);
            if (clanPlayer == null)
                return false;

            Clan clanOther = storedData.FindClanByID(otherId);
            if (clanOther == null)
                return false;

            return clanPlayer.Tag.Equals(clanOther.Tag);
        }

        private bool IsMemberOrAlly(ulong playerId, ulong otherId) => IsMemberOrAlly(playerId.ToString(), otherId.ToString());
        
        private bool IsMemberOrAlly(string playerId, string otherId)
        {
            Clan playerClan = storedData.FindClanByID(playerId);
            if (playerClan == null)
                return false;

            Clan otherClan = storedData.FindClanByID(otherId);
            if (otherClan == null)
                return false;

            if ((playerClan.Tag.Equals(otherClan.Tag)) || playerClan.Alliances.Contains(otherClan.Tag))
                return true;

            return false;
        }
        
        private bool IsAllyPlayer(ulong playerId, ulong otherId) => IsAllyPlayer(playerId.ToString(), otherId.ToString());
        
        private bool IsAllyPlayer(string playerId, string otherId)
        {
            Clan playerClan = storedData.FindClanByID(playerId);
            if (playerClan == null)
                return false;

            Clan otherClan = storedData.FindClanByID(otherId);
            if (otherClan == null)
                return false;

            if (playerClan.Alliances.Contains(otherClan.Tag))
                return true;

            return false;
        }

        private List<string> GetClanAlliances(ulong playerId) => GetClanAlliances(playerId.ToString());

        private List<string> GetClanAlliances(string playerId)
        {
            Clan clan = storedData.FindClanByID(playerId);
            if (clan == null)
                return new List<string>();

            return new List<string>(clan.Alliances);
        }
        #endregion

        #region Clan
        [Serializable]
        public class Clan
        {
            public string Tag { get; set; }

            public string Description { get; set; }

            public string OwnerID { get; set; }

            public double CreationTime { get; set; }

            public double LastOnlineTime { get; set; }

            public Hash<string, Member> ClanMembers { get; set; } = new Hash<string, Member>();

            public Hash<string, MemberInvite> MemberInvites { get; set; } = new Hash<string, MemberInvite>();

            public HashSet<string> Alliances { get; set; } = new HashSet<string>();

            public Hash<string, double> AllianceInvites { get; set; } = new Hash<string, double>();

            public HashSet<string> IncomingAlliances { get; set; } = new HashSet<string>();

            public string TagColor { get; set; } = string.Empty;

            [JsonIgnore]
            public int OnlineCount { get; private set; }

            [JsonIgnore]
            public int ModeratorCount => ClanMembers.Count(x => x.Value.Role == Member.MemberRole.Moderator);

            [JsonIgnore]
            public int MemberCount => ClanMembers.Count;

            [JsonIgnore]
            public int MemberInviteCount => MemberInvites.Count;

            [JsonIgnore]
            public int AllianceCount => Alliances.Count;

            [JsonIgnore]
            public int AllianceInviteCount => AllianceInvites.Count;

            public Clan() { }

            public Clan(IPlayer player, string tag, string description)
            {
                this.Tag = tag;
                this.Description = description;
                CreationTime = LastOnlineTime = UnixTimeStampUTC();
                OwnerID = player.Id;
                ClanMembers.Add(player.Id, new Member(Member.MemberRole.Owner, player.Name));
                OnPlayerConnected(player);
            }

            #region Connection
            internal void OnPlayerConnected(IPlayer player)
            {
                if (player == null)
                    return;

                Member member;
                if (ClanMembers.TryGetValue(player.Id, out member))
                {
                    member.Player = player;                    
                    LastOnlineTime = UnixTimeStampUTC();
                    OnlineCount++;
                }

                MarkDirty();
            }

            internal void OnPlayerDisconnected(IPlayer player)
            {
                if (player == null)
                    return;

                Member member;
                if (ClanMembers.TryGetValue(player.Id, out member))
                {                    
                    member.Player = null;
                    LastOnlineTime = UnixTimeStampUTC();
                    OnlineCount--;
                }

                MarkDirty();
            }
            #endregion

            #region Clan Management
            internal bool InvitePlayer(IPlayer inviter, IPlayer invitee)
            {
                if (!IsOwner(inviter.Id) && !IsModerator(inviter.Id))
                {
                    inviter.Reply(Message("Notification.Invite.NoPermissions", inviter.Id));
                    return false;
                }

                if (ClanMembers.ContainsKey(invitee.Id))
                {
                    inviter.Reply(string.Format(Message("Notification.Invite.IsMember", inviter.Id), invitee.Name));
                    return false;
                }

                if (MemberInvites.ContainsKey(invitee.Id))
                {
                    inviter.Reply(string.Format(Message("Notification.Invite.HasPending", inviter.Id), invitee.Name));
                    return false;
                }

                if (MemberCount >= configData.Clans.MemberLimit)
                {
                    inviter.Reply(Message("Notification.Generic.ClanFull", inviter.Id));
                    return false;
                }

                if (MemberInviteCount >= configData.Clans.Invites.MemberInviteLimit)
                {
                    inviter.Reply(Message("Notification.Invite.InviteLimit", inviter.Id));
                    return false;
                }

                MemberInvites[invitee.Id] = new MemberInvite(invitee);

                Instance.storedData.AddPlayerInvite(invitee.Id, Tag);

                invitee.Reply(string.Format(Message("Notification.Invite.SuccesTarget", invitee.Id), Tag, Description, "clan"));
                Broadcast("Notification.Invite.SuccessClan", inviter.Name, invitee.Name);

                if (configData.Options.LogChanges)
                    Instance.LogToFile(Instance.Title, $"{inviter.Name} invited {invitee.Name} to [{Tag}]", Instance);

                return true;
            }

            internal bool JoinClan(IPlayer player)
            {
                if (!MemberInvites.ContainsKey(player.Id))
                    return false;

                if ((UnixTimeStampUTC() - MemberInvites[player.Id].ExpiryTime > configData.Clans.Invites.AllianceInviteExpireTime))
                {
                    MemberInvites.Remove(player.Id);
                    player.Reply(string.Format(Message("Notification.Join.ExpiredInvite", player.Id), Tag));
                    return false;
                }

                if (MemberCount >= configData.Clans.MemberLimit)
                {
                    player.Reply(Message("Notification.Generic.ClanFull", player.Id));
                    return false;
                }

                Instance.storedData.OnInviteAccepted(player.Id, Tag);

                MemberInvites.Remove(player.Id);
                List<string> currentMembers = ClanMembers.Keys.ToList();

                ClanMembers.Add(player.Id, new Member(Member.MemberRole.Member, player.Name));

                Instance.storedData.RegisterPlayer(player.Id, Tag);

                OnPlayerConnected(player);

                Broadcast("Notification.Join.Reply", player.Name);

                Interface.Oxide.CallHook("OnClanMemberJoined", player.Id, Tag);
                Interface.Oxide.CallHook("OnClanMemberJoined", player.Id, currentMembers);

                #if RUST
                Interface.Oxide.CallHook("OnClanMemberJoined", ulong.Parse(player.Id), Tag);
                Interface.Oxide.CallHook("OnClanMemberJoined", ulong.Parse(player.Id), currentMembers.ConvertAll(x => ulong.Parse(x)));
                #endif
                
                Interface.Oxide.CallHook("OnClanUpdate", Tag);

                if (configData.Options.LogChanges)
                    Instance.LogToFile(Instance.Title, $"{player.Name} joined [{Tag}]", Instance);

                return true;
            }

            internal bool LeaveClan(IPlayer player)
            {
                if (!ClanMembers.ContainsKey(player.Id))
                    return false;

                OnPlayerDisconnected(player);

                ClanMembers.Remove(player.Id);
                Instance.storedData.UnregisterPlayer(player.Id);

                player.Reply(string.Format(Message("Notification.Leave.PlayerMessage", player.Id), Tag));
                Broadcast("Notification.Leave.Reply", player.Name);

                MarkDirty();

                if (ClanMembers.Count == 0)
                {
                    Interface.Oxide.CallHook("OnClanMemberGone", player.Id, Tag);
                    Interface.Oxide.CallHook("OnClanMemberGone", player.Id, new List<string>());
                    
                    #if RUST
                    Interface.Oxide.CallHook("OnClanMemberGone", ulong.Parse(player.Id), Tag);
                    Interface.Oxide.CallHook("OnClanMemberGone", ulong.Parse(player.Id), new List<ulong>());
                    #endif

                    if (configData.Options.LogChanges)
                        Instance.LogToFile(Instance.Title, $"{player.Name} has left [{Tag}]", Instance);

                    DisbandClan();
                    return true;
                }

                if (OwnerID == player.Id)
                {
                    KeyValuePair<string, Member> newOwner = ClanMembers.OrderBy(x => x.Value.Role).First();

                    OwnerID = newOwner.Key;
                    ClanMembers[OwnerID].Role = Member.MemberRole.Owner;

                    Broadcast("Notification.Leave.NewOwner", ClanMembers[OwnerID].DisplayName);
                }
                
                List<string> members = ClanMembers.Keys.ToList();
                #if RUST
                Interface.Oxide.CallHook("OnClanMemberGone", ulong.Parse(player.Id), members.ConvertAll(x => ulong.Parse(x)));
                Interface.Oxide.CallHook("OnClanMemberGone", ulong.Parse(player.Id), Tag);
                #endif

                Interface.Oxide.CallHook("OnClanMemberGone", player.Id, members);
                Interface.Oxide.CallHook("OnClanMemberGone", player.Id, Tag);
                Interface.Oxide.CallHook("OnClanUpdate", Tag);

                if (configData.Options.LogChanges)
                    Instance.LogToFile(Instance.Title, $"{player.Name} has left [{Tag}]", Instance);
                
                return true;
            }

            internal bool KickMember(IPlayer player, string targetId)
            {
                if (!ClanMembers.ContainsKey(targetId))
                {
                    player.Reply(Message("Notification.Kick.NotClanmember", player.Id));
                    return false;
                }

                if (IsOwner(targetId))
                {
                    player.Reply(Message("Notification.Kick.IsOwner", player.Id));
                    return false;
                }

                if (!IsOwner(player.Id) && !IsModerator(player.Id))
                {
                    player.Reply(Message("Notification.Kick.NoPermissions", player.Id));
                    return false;
                }

                if ((IsOwner(targetId) || IsModerator(targetId)) && OwnerID != player.Id)
                {
                    player.Reply(Message("Notification.Kick.NotEnoughRank", player.Id));
                    return false;
                }

                Member member = ClanMembers[targetId];

                if (member.IsConnected && member.Player != null)
                {
                    member.Player.Reply(string.Format(Message("Notification.Kick.PlayerMessage", member.Player.Id), player.Name));

                    OnPlayerDisconnected(member.Player);
                }

                ClanMembers.Remove(targetId);
                Instance.storedData.UnregisterPlayer(targetId);

                Broadcast("Notification.Kick.Reply", player.Name, member.DisplayName);

                List<string> members = ClanMembers.Keys.ToList();
                
                #if RUST
                Interface.Oxide.CallHook("OnClanMemberGone", ulong.Parse(targetId), members.ConvertAll(x => ulong.Parse(x)));
                Interface.Oxide.CallHook("OnClanMemberGone", ulong.Parse(targetId), Tag);
                #endif
                
                Interface.Oxide.CallHook("OnClanMemberGone", targetId, members);
                Interface.Oxide.CallHook("OnClanMemberGone", targetId, Tag);
                Interface.Oxide.CallHook("OnClanUpdate", Tag);

                if (configData.Options.LogChanges)
                    Instance.LogToFile(Instance.Title, $"{member.DisplayName} was kicked from [{Tag}] by {player.Name}", Instance);

                return true;
            }

            internal bool PromotePlayer(IPlayer promoter, string targetId)
            {
                if (!IsOwner(promoter.Id))
                {
                    promoter.Reply(Message("Notification.Promotion.NoPermissions", promoter.Id));
                    return false;
                }

                if (IsOwner(targetId))
                {
                    promoter.Reply(Message("Notification.Promotion.IsOwner", promoter.Id));
                    return false;
                }

                if (IsModerator(targetId))
                {
                    promoter.Reply(Message("Notification.Promotion.IsModerator", promoter.Id));
                    return false;
                }

                if (IsMember(targetId) && ModeratorCount >= configData.Clans.ModeratorLimit)
                {
                    promoter.Reply(Message("Notification.Promotion.ModeratorLimit", promoter.Id));
                    return false;
                }

                Member member = ClanMembers[targetId];
                member.Role = (Member.MemberRole)(Math.Min((int)member.Role - 1, (int)Member.MemberRole.Member));

                MarkDirty();

                Broadcast("Notification.Promotion.Reply", member.DisplayName, string.Format(COLORED_LABEL, GetRoleColor(member.Role), member.Role), string.Format(COLORED_LABEL, GetRoleColor(promoter.Id), promoter.Name));
                Interface.Oxide.CallHook("OnClanUpdate", Tag);

                if (configData.Options.LogChanges)
                    Instance.LogToFile(Instance.Title, $"{member.DisplayName} was promototed to {member.Role} by {promoter.Name}", Instance);

                return true;
            }

            internal bool DemotePlayer(IPlayer demoter, string targetId)
            {
                if (!IsOwner(demoter.Id))
                {
                    demoter.Reply(Message("Notification.Demotion.NoPermissions", demoter.Id));
                    return false;
                }

                Member member = ClanMembers[targetId];
                if (IsMember(targetId))
                {
                    demoter.Reply(string.Format(Message("Notification.Demotion.IsMember", demoter.Id), member.DisplayName));
                    return false;
                }

                member.Role = member.Role + 1;

                MarkDirty();

                Broadcast("Notification.Demotion.Reply", member.DisplayName, string.Format(COLORED_LABEL, GetRoleColor(member.Role), member.Role), string.Format(COLORED_LABEL, GetRoleColor(demoter.Id), demoter.Name));

                Interface.Oxide.CallHook("OnClanUpdate", Tag);

                if (configData.Options.LogChanges)
                    Instance.LogToFile(Instance.Title, $"{member.DisplayName} was demoted to {member.Role} by {demoter.Name}", Instance);
                return true;
            }

            internal void DisbandClan()
            {
                List<string> clanMembers = ClanMembers.Keys.ToList();

                OnUnload();

                Instance.storedData.clans.Remove(Tag);

                foreach (KeyValuePair<string, Clan> kvp in Instance.storedData.clans)
                    kvp.Value.OnClanDisbanded(Tag);

                if (configData.Options.LogChanges)
                    Instance.LogToFile(Instance.Title, $"The clan [{Tag}] was disbanded", Instance);

                #if RUST
                Interface.CallHook("OnClanDisbanded", clanMembers.ConvertAll(x => ulong.Parse(x)));
                #endif
                Interface.CallHook("OnClanDisbanded", clanMembers);
                Interface.CallHook("OnClanDisbanded", Tag);
            }

            internal void OnClanDisbanded(string tag)
            {
                Alliances.Remove(tag);
                AllianceInvites.Remove(tag);
                IncomingAlliances.Remove(tag);
            }

            internal void OnUnload()
            {
                foreach (KeyValuePair<string, Member> kvp in ClanMembers)
                {
                    Instance.storedData.UnregisterPlayer(kvp.Key);

                    if (kvp.Value.Player != null)
                        OnPlayerDisconnected(kvp.Value.Player);
                }
            }

            internal bool IsAlliedClan(string otherClan) => Alliances.Contains(otherClan);

            internal void MarkDirty()
            {
                cachedClanInfo = string.Empty;
                membersOnline = string.Empty;
                serializedClanObject = null;
            }
            #endregion

            #region Clan Chat
            internal void Broadcast(string message)
            {
                foreach (Member member in ClanMembers.Values)
                    member.Player?.Reply(message);
            }

            internal void Broadcast(string key, params object[] args)
            {
                foreach (Member member in ClanMembers.Values)
                    member.Player?.Reply(string.Format(Message(key, member.Player.Id), args));
            }
            #endregion

            #region Clan Info
            [JsonIgnore]
            private string cachedClanInfo = string.Empty;

            [JsonIgnore]
            private string membersOnline = string.Empty;

            #if RUST
            internal void PrintClanInfo(BasePlayer player) => PrintClanInfo(player.IPlayer);
            #endif
            internal void PrintClanInfo(IPlayer player)
            {
                if (string.IsNullOrEmpty(cachedClanInfo))
                {
                    StringBuilder str = new StringBuilder();
                    str.Append(Message("Notification.ClanInfo.Title"));
                    str.Append(string.Format(Message("Notification.ClanInfo.Tag"), Tag));

                    if (!string.IsNullOrEmpty(Description))
                        str.Append(string.Format(Message("Notification.ClanInfo.Description"), Description));

                    List<string> online = ListPool.Get<string>();
                    List<string> offline = ListPool.Get<string>();

                    foreach (KeyValuePair<string, Member> kvp in ClanMembers)
                    {
                        string member = string.Format(COLORED_LABEL, GetRoleColor(kvp.Key), kvp.Value.DisplayName);

                        if (kvp.Value.IsConnected)
                            online.Add(member);
                        else offline.Add(member);
                    }

                    if (online.Count > 0)
                        str.Append(string.Format(Message("Notification.ClanInfo.Online"), online.ToSentence()));

                    if (offline.Count > 0)
                        str.Append(string.Format(Message("Notification.ClanInfo.Offline"), offline.ToSentence()));

                    ListPool.Free(ref online);
                    ListPool.Free(ref offline);

                    str.Append(string.Format(Message("Notification.ClanInfo.Established"), UnixTimeStampToDateTime(CreationTime)));
                    str.Append(string.Format(Message("Notification.ClanInfo.LastOnline"), UnixTimeStampToDateTime(LastOnlineTime)));

                    if (configData.Clans.Alliance.Enabled)
                        str.Append(string.Format(Message("Notification.ClanInfo.Alliances"), Alliances.Count > 0 ? Alliances.ToSentence() : Message("Notification.ClanInfo.Alliances.None")));

                    cachedClanInfo = str.ToString();
                }

                player.Reply(cachedClanInfo);
            }

            internal string GetMembersOnline()
            {
                if (string.IsNullOrEmpty(membersOnline))
                {
                    List<string> list = ListPool.Get<string>();

                    foreach (KeyValuePair<string, Member> kvp in ClanMembers)
                    {
                        if (kvp.Value.IsConnected)
                        {
                            string member = string.Format(COLORED_LABEL, GetRoleColor(kvp.Key), kvp.Value.DisplayName);
                            list.Add(member);
                        }
                    }

                    membersOnline = list.ToSentence();

                    ListPool.Free(ref list);
                }
                return membersOnline;
            }
            #endregion

            #region Roles
            public bool IsOwner(ulong playerId) => IsOwner(playerId.ToString());

            public bool IsOwner(string playerId) => ClanMembers[playerId].Role == Member.MemberRole.Owner;

            public bool IsModerator(ulong playerId) => IsModerator(playerId.ToString());

            public bool IsModerator(string playerId) => ClanMembers[playerId].Role == Member.MemberRole.Moderator;

            public bool IsCouncil(ulong playerId) => false;

            public bool IsMember(ulong playerId) => IsMember(playerId.ToString());

            public bool IsMember(string playerId) => ClanMembers[playerId].Role == Member.MemberRole.Member;

            public Member GetOwner() => ClanMembers[OwnerID];

            public string GetRoleColor(string Id) => GetRoleColor(ClanMembers[Id].Role);

            public string GetRoleColor(Member.MemberRole role)
            {
                if (role == Member.MemberRole.Owner)
                    return configData.Colors.Owner;

                if (role == Member.MemberRole.Moderator)
                    return configData.Colors.Moderator;

                return configData.Colors.Member;
            }
            #endregion

            [Serializable]
            public class Member
            {
                [JsonIgnore]
                public IPlayer Player { get; set; }

                [JsonProperty("Name")]
                public string DisplayName { get; set; } = string.Empty;

                public MemberRole Role { get; set; }

                [JsonIgnore]
                public bool IsConnected => Player?.IsConnected ?? false;

                [JsonIgnore]
                public bool MemberFFEnabled { get; set; } = false;

                [JsonIgnore]
                public bool AllyFFEnabled { get; set; } = false;

                public Member() { }

                public Member(MemberRole role, string name)
                {
                    this.Role = role;
                    this.DisplayName = name;
                }

                public enum MemberRole { Owner, Moderator, Member }
            }

            [Serializable]
            public class MemberInvite
            {
                [JsonProperty("Name")]
                public string DisplayName { get; set; }

                public double ExpiryTime { get; set; }

                public MemberInvite() { }

                public MemberInvite(IPlayer player)
                {
                    DisplayName = player.Name;
                    ExpiryTime = UnixTimeStampUTC();
                }

                public MemberInvite(string name)
                {
                    DisplayName = name;
                    ExpiryTime = UnixTimeStampUTC();
                }
            }

            [JsonIgnore]
            private JObject serializedClanObject;

            internal JObject ToJObject()
            {
                if (serializedClanObject != null)
                    return serializedClanObject;

                serializedClanObject = new JObject();
                serializedClanObject["tag"] = Tag;
                serializedClanObject["description"] = Description;
                serializedClanObject["owner"] = OwnerID;

                JArray jmoderators = new JArray();
                JArray jmembers = new JArray();

                foreach (KeyValuePair<string, Member> kvp in ClanMembers)
                {
                    if (kvp.Value.Role == Member.MemberRole.Moderator)
                        jmoderators.Add(kvp.Key);

                    jmembers.Add(kvp.Key);
                }

                serializedClanObject["moderators"] = jmoderators;
                serializedClanObject["members"] = jmembers;

                JArray jallies = new JArray();

                foreach (string ally in Alliances)
                    jallies.Add(ally);

                serializedClanObject["allies"] = jallies;

                JArray jinvallies = new JArray();

                foreach (KeyValuePair<string, double> ally in AllianceInvites)
                    jinvallies.Add(ally.Key);

                serializedClanObject["invitedallies"] = jinvallies;

                return serializedClanObject;
            }

            internal string FindPlayer(string partialNameOrID)
            {
                foreach (KeyValuePair<string, Member> kvp in ClanMembers)
                {
                    if (kvp.Key.Equals(partialNameOrID))
                        return kvp.Key;

                    if (kvp.Value.DisplayName.Contains(partialNameOrID, CompareOptions.OrdinalIgnoreCase))
                        return kvp.Key;
                }

                return string.Empty;
            }
        }
        #endregion

        #region Config        
        public static ConfigData configData;

        public class ConfigData
        {
            [JsonProperty(PropertyName = "Clan Options")]
            public ClanOptions Clans { get; set; }

            [JsonProperty(PropertyName = "Role Colors")]
            public ColorOptions Colors { get; set; }

            [JsonProperty(PropertyName = "Clan Tag Options")]
            public TagOptions Tags { get; set; }

            [JsonProperty(PropertyName = "Purge Options")]
            public PurgeOptions Purge { get; set; }

            [JsonProperty(PropertyName = "Settings")]
            public OtherOptions Options { get; set; }

            public class ClanOptions
            {
                [JsonProperty(PropertyName = "Member limit")]
                public int MemberLimit { get; set; }

                [JsonProperty(PropertyName = "Moderator limit")]
                public int ModeratorLimit { get; set; }

                [JsonProperty(PropertyName = "Alliance Options")]
                public AllianceOptions Alliance { get; set; }

                [JsonProperty(PropertyName = "Invite Options")]
                public InviteOptions Invites { get; set; }

                [JsonIgnore]
                public bool MemberFF => false;

                [JsonIgnore]
                public bool OwnerFF => false;

                public class AllianceOptions
                {
                    [JsonProperty(PropertyName = "Enable clan alliances")]
                    public bool Enabled { get; set; }

                    [JsonProperty(PropertyName = "Alliance limit")]
                    public int AllianceLimit { get; set; }

                    [JsonIgnore]
                    public bool AllyFF => false;

                    [JsonIgnore]
                    public bool OwnerFF => false;

                }

                public class InviteOptions
                {
                    [JsonProperty(PropertyName = "Maximum allowed member invites at any given time")]
                    public int MemberInviteLimit { get; set; }

                    [JsonProperty(PropertyName = "Member invite expiry time (seconds)")]
                    public int MemberInviteExpireTime { get; set; }

                    [JsonProperty(PropertyName = "Maximum allowed alliance invites at any given time")]
                    public int AllianceInviteLimit { get; set; }

                    [JsonProperty(PropertyName = "Alliance invite expiry time (seconds)")]
                    public int AllianceInviteExpireTime { get; set; }
                }
            }

            public class ColorOptions
            {
                [JsonProperty(PropertyName = "Clan owner color (hex)")]
                public string Owner { get; set; }

                [JsonProperty(PropertyName = "Clan moderator color (hex)")]
                public string Moderator { get; set; }

                [JsonProperty(PropertyName = "Clan member color (hex)")]
                public string Member { get; set; }

                [JsonProperty(PropertyName = "General text color (hex)")]
                public string TextColor { get; set; }
            }

            public class TagOptions
            {
                [JsonProperty(PropertyName = "Enable clan tags (requires BetterChat)")]
                public bool Enabled { get; set; }

                [JsonProperty(PropertyName = "Tag opening character")]
                public string TagOpen { get; set; }

                [JsonProperty(PropertyName = "Tag closing character")]
                public string TagClose { get; set; }

                [JsonProperty(PropertyName = "Tag color (hex)")]
                public string TagColor { get; set; }

                [JsonProperty(PropertyName = "Allow clan leaders to set custom tag colors (BetterChat only)")]
                public bool CustomColors { get; set; }

                [JsonProperty(PropertyName = "Tag size")]
                public int TagSize { get; set; }

                [JsonProperty(PropertyName = "Tag character limits")]
                public Range TagLength { get; set; }
            }

            public class PurgeOptions
            {
                [JsonProperty(PropertyName = "Enable clan purging")]
                public bool Enabled { get; set; }

                [JsonProperty(PropertyName = "Purge clans that havent been online for x amount of day")]
                public int OlderThanDays { get; set; }

                [JsonProperty(PropertyName = "List purged clans in console when purging")]
                public bool ListPurgedClans { get; set; }
            }

            public class OtherOptions
            {
                [JsonProperty(PropertyName = "Log clan and member changes")]
                public bool LogChanges { get; set; }

                [JsonProperty(PropertyName = "Data save interval (seconds)")]
                public int SaveInterval { get; set; }
            }

            public class Range
            {
                public int Minimum { get; set; }
                public int Maximum { get; set; }

                public Range() { }

                public Range(int minimum, int maximum)
                {
                    this.Minimum = minimum;
                    this.Maximum = maximum;
                }
            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Clans = new ConfigData.ClanOptions
                {
                    Alliance = new ConfigData.ClanOptions.AllianceOptions
                    {
                        AllianceLimit = 2,                        
                        Enabled = true
                    },
                    Invites = new ConfigData.ClanOptions.InviteOptions
                    {
                        AllianceInviteExpireTime = 86400,
                        AllianceInviteLimit = 2,
                        MemberInviteExpireTime = 86400,
                        MemberInviteLimit = 8
                    },                   
                    MemberLimit = 8,
                    ModeratorLimit = 2,                    
                },
                Colors = new ConfigData.ColorOptions
                {
                    Member = "#fcf5cb",
                    Moderator = "#74c6ff",
                    Owner = "#a1ff46",
                    TextColor = "#e0e0e0"
                },                
                Options = new ConfigData.OtherOptions
                {
                    LogChanges = false,
                    SaveInterval = 900,
                },               
                Purge = new ConfigData.PurgeOptions
                {
                    Enabled = true,
                    ListPurgedClans = true,
                    OlderThanDays = 14,
                },
                Tags = new ConfigData.TagOptions
                {                    
                    CustomColors = false,
                    Enabled = true,
                    TagClose = "]",
                    TagColor = "#aaff55",
                    TagLength = new ConfigData.Range(2, 5),
                    TagOpen = "[",
                    TagSize = 15,
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new VersionNumber(0, 2, 0))
                configData = baseConfig;

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion

        #region Data Management
        public StoredData storedData;

        private DynamicConfigFile data;

        private void TimedSaveData()
        {
            timer.In(configData.Options.SaveInterval, () =>
            {
                SaveData();
                TimedSaveData();
            });
        }

        private void SaveData() => data.WriteObject(storedData);

        private void LoadData()
        {
            if (!Interface.Oxide.DataFileSystem.ExistsDatafile("clan_data") && Interface.Oxide.DataFileSystem.ExistsDatafile("clans_data"))
            {
                DynamicConfigFile oldData = Interface.Oxide.DataFileSystem.GetFile("clans_data");

                Dictionary<string, OldClan> clanData = oldData.ReadObject<Dictionary<string, OldClan>>();
                if (clanData != null && clanData.Count > 0)
                    RestoreClanData(clanData);
            }
            else
            {
                data = Interface.Oxide.DataFileSystem.GetFile("clan_data");
                storedData = data.ReadObject<StoredData>();
                
                if (storedData == null)
                    storedData = new StoredData();
            }
        }

        private void RestoreClanData(Dictionary<string, OldClan> clanData)
        {
            data = Interface.Oxide.DataFileSystem.GetFile("clan_data");
            storedData = new StoredData();

            foreach (KeyValuePair<string, OldClan> kvp in clanData)
            {
                Clan clan = storedData.clans[kvp.Key] = new Clan();

                clan.Tag = kvp.Key;
                clan.OwnerID = kvp.Value.ownerID;
                clan.CreationTime = clan.LastOnlineTime = UnixTimeStampUTC();

                foreach (KeyValuePair<string, string> memberKVP in kvp.Value.members)
                {
                    Clan.Member.MemberRole role = kvp.Value.ownerID == memberKVP.Key ? Clan.Member.MemberRole.Owner :
                                                  kvp.Value.moderators.Contains(memberKVP.Key) ? Clan.Member.MemberRole.Moderator :
                                                  Clan.Member.MemberRole.Member;

                    clan.ClanMembers[memberKVP.Key] = new Clan.Member(role, memberKVP.Value);
                }

                foreach(string alliance in kvp.Value.clanAlliances)
                    clan.Alliances.Add(alliance);

                foreach (string allianceInvite in kvp.Value.invitedAllies)
                    clan.AllianceInvites[allianceInvite] = UnixTimeStampUTC();

                foreach (KeyValuePair<string, string> memberInvite in kvp.Value.invitedPlayers)
                {
                    clan.MemberInvites[memberInvite.Key] = new Clan.MemberInvite(memberInvite.Value);
                    storedData.AddPlayerInvite(memberInvite.Key, clan.Tag);
                }

                foreach (string incomingAlliance in kvp.Value.pendingInvites)
                    clan.IncomingAlliances.Add(incomingAlliance);
            }

            SaveData();
        }

        [Serializable]
        public class StoredData
        {
            public Hash<string, Clan> clans = new Hash<string, Clan>();

            public Hash<string, List<string>> playerInvites = new Hash<string, List<string>>();

            [JsonIgnore]
            private Hash<string, string> playerLookup = new Hash<string, string>();

            public Clan FindClan(string tag)
            {
                Clan clan;
                if (clans.TryGetValue(tag, out clan))
                    return clan;

                string lower = tag.ToLower();

                foreach (KeyValuePair<string, Clan> kvp in clans)
                {
                    if (kvp.Key.ToLower().Equals(lower))
                        return kvp.Value;
                }

                return null;
            }

            public Clan FindClanByID(ulong playerId) => FindClanByID(playerId.ToString());

            public Clan FindClanByID(string playerId)
            {
                string tag;
                if (!playerLookup.TryGetValue(playerId, out tag))
                    return null;

                return FindClan(tag);
            }

            public Clan.Member FindMemberByID(ulong playerId) => FindMemberByID(playerId.ToString());

            public Clan.Member FindMemberByID(string playerId)
            {
                Clan.Member member = null;
                FindClanByID(playerId)?.ClanMembers.TryGetValue(playerId, out member);
                return member;
            }

            internal void RegisterPlayer(string playerId, string tag) => playerLookup[playerId] = tag;

            internal void UnregisterPlayer(string playerId) => playerLookup.Remove(playerId);

            internal void AddPlayerInvite(string target, string tag)
            {
                List<string> invites;
                if (!playerInvites.TryGetValue(target, out invites))
                    invites = playerInvites[target] = new List<string>();

                if (!invites.Contains(tag))
                    invites.Add(tag);
            }

            internal void RevokePlayerInvite(string target, string tag)
            {
                List<string> invites;
                if (!playerInvites.TryGetValue(target, out invites))
                    return;

                invites.Remove(tag);

                if (invites.Count == 0)
                    playerInvites.Remove(target);
            }

            internal void OnInviteAccepted(string target, string tag)
            {
                List<string> invites;
                if (!playerInvites.TryGetValue(target, out invites))
                    return;

                for (int i = invites.Count - 1; i >= 0; i--)
                {
                    string t = invites[i];

                    if (!t.Equals(tag))
                        FindClan(t)?.MemberInvites.Remove(target);

                    invites.RemoveAt(i);
                }

                if (invites.Count == 0)
                    playerInvites.Remove(target);
            }

            internal void OnInviteRejected(string target, string tag)
            {
                List<string> invites;
                if (!playerInvites.TryGetValue(target, out invites))
                    return;

                invites.Remove(tag);

                if (invites.Count == 0)
                    playerInvites.Remove(target);
            }
        }
        #endregion

        #region Data Conversion
        public class OldClan
        {
            public string clanTag = string.Empty;
            public string ownerID = string.Empty;

            public List<string> moderators = new List<string>();
            public Dictionary<string, string> members = new Dictionary<string, string>();
            public List<string> clanAlliances = new List<string>();

            public Dictionary<string, string> invitedPlayers = new Dictionary<string, string>();
            public List<string> invitedAllies = new List<string>();
            public List<string> pendingInvites = new List<string>();
        }
        #endregion

        #region Localization
        private static string Message(string key, string playerId = null) => string.Format(COLORED_LABEL, configData.Colors.TextColor, Instance.lang.GetMessage(key, Instance, playerId));

        private readonly Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["Notification.ClanInfo.Title"] = "[#ffa500]Clans[/#]",
            ["Notification.ClanInfo.Tag"] = "\nClanTag: [#b2eece]{0}[/#]",
            ["Notification.ClanInfo.Description"] = "\nDescription: [#b2eece]{0}[/#]",
            ["Notification.ClanInfo.Online"] = "\nMembers Online: {0}",
            ["Notification.ClanInfo.Offline"] = "\nMembers Offline: {0}",
            ["Notification.ClanInfo.Established"] = "\nEstablished: [#b2eece]{0}[/#]",
            ["Notification.ClanInfo.LastOnline"] = "\nLast Online: [#b2eece]{0}[/#]",
            ["Notification.ClanInfo.Alliances"] = "\nAlliances: [#b2eece]{0}[/#]",
            ["Notification.ClanInfo.Alliances.None"] = "None",

            ["Notification.Create.InExistingClan"] = "You are already a member of a clan",
            ["Notification.Create.NoPermission"] = "You do not have permission to create a clan",
            ["Notification.Create.InvalidTagLength"] = "The tag you have chosen is invalid. It must be between {0} and {1} characters long",
            ["Notification.Create.ClanExists"] = "A clan with that tag already exists",
            ["Notification.Create.Success"] = "You have formed the clan [#aaff55][{0}][/#]",

            ["Notification.Kick.IsOwner"] = "You can not kick the clan owner",
            ["Notification.Kick.NoPermissions"] = "You do not have sufficient permission to kick clan members",
            ["Notification.Kick.NotClanmember"] = "The target is not a member of your clan",
            ["Notification.Kick.Self"] = "You can not kick yourself",
            ["Notification.Kick.NotEnoughRank"] = "Only the clan owner can kick another ranking member",
            ["Notification.Kick.NoPlayerFound"] = "Unable to find a player with the specified name of ID",
            ["Notification.Kick.Reply"] = "{0} kicked {1} from the clan!",
            ["Notification.Kick.PlayerMessage"] = "{0} kicked you from the clan!",
            ["Notification.Kick.NoPermission"] = "You do not have permission to kick clan members",

            ["Notification.Leave.Reply"] = "{0} has left the clan!",
            ["Notification.Leave.PlayerMessage"] = "You have left the clan [#aaff55][{0}][/#]!",
            ["Notification.Leave.NewOwner"] = "{0} is now the clan leader!",
            ["Notification.Leave.NoPermission"] = "You do not have permission to leave this clan",

            ["Notification.Join.NoPermission"] = "You do not have permission to join a clan",
            ["Notification.Join.ExpiredInvite"] = "Your invite to {0} has expired!",
            ["Notification.Join.InExistingClan"] = "You are already a member of another clan",
            ["Notification.Join.Reply"] = "{0} has joined the clan!",

            ["Notification.Invite.NoPermissions"] = "You do not have sufficient permissions to invite other players",
            ["Notification.Invite.InviteLimit"] = "You already have the maximum number of invites allowed",
            ["Notification.Invite.HasPending"] = "{0} all ready has a pending clan invite",
            ["Notification.Invite.IsMember"] = "{0} is already a clan member",
            ["Notification.Invite.InClan"] = "{0} is already a member of another clan",
            ["Notification.Invite.NoPermission"] = "{0} does not have the required permission to join a clan",
            ["Notification.Invite.SuccesTarget"] = "You have been invited to join the clan: [#aaff55][{0}][/#] '{1}'\nTo join, type: [#ffd479]/{2} accept {0}[/#]",
            ["Notification.Invite.SuccessClan"] = "{0} has invited {1} to join the clan",
            ["Notification.PendingInvites"] = "You have pending clan invites from: {0}\nYou can join a clan type: [#ffd479]/{1} accept <tag>[/#]",

            ["Notification.WithdrawInvite.NoPermissions"] = "You do not have sufficient permissions to withdraw member invites",
            ["Notification.WithdrawInvite.UnableToFind"] = "Unable to find a invite for the player with {0}",
            ["Notification.WithdrawInvite.Success"] = "{0} revoked the member invitation for {0}",

            ["Notification.RejectInvite.InvalidInvite"] = "You do not have a invite to join [#aaff55][{0}][/#]",
            ["Notification.RejectInvite.Reply"] = "{0} has rejected their invition to join your clan",
            ["Notification.RejectInvite.PlayerMessage"] = "You have rejected the invitation to join [#aaff55][{0}][/#]",

            ["Notification.Promotion.NoPermissions"] = "You do not have sufficient permissions to promote other players",
            ["Notification.Promotion.TargetNoClan"] = "{0} is not a member of your clan",
            ["Notification.Promotion.IsOwner"] = "You can not promote the clan leader",          
            ["Notification.Promotion.ModeratorLimit"] = "You already have the maximum amount of moderators",
            ["Notification.Promotion.IsModerator"] = "You can not promote higher than the rank of moderator",
            ["Notification.Promotion.Reply"] = "{0} was promoted to rank of {1} by {2}",

            ["Notification.Demotion.NoPermissions"] = "You do not have sufficient permissions to demote other players",
            ["Notification.Demotion.IsOwner"] = "You can not demote the clan leader",
            ["Notification.Demotion.IsMember"] = "{0} is already at the lowest rank",
            ["Notification.Demotion.Reply"] = "{0} was demoted to rank of {1} by {2}",

            ["Notification.Alliance.NoPermissions"] = "You do not have sufficient permissions to manage alliances",
            ["Notification.Alliance.PendingInvite"] = "[#aaff55][{0}][/#] already has a pending alliance invite",
            ["Notification.Alliance.MaximumInvites"] = "You already have the maximum amount of alliance invites allowed",
            ["Notification.Alliance.MaximumAlliances"] = "You already have the maximum amount of alliances formed",
            ["Notification.Alliance.InviteSent"] = "You have sent a clan alliance invitation to [#aaff55][{0}][/#]\nThe invitation will expire in: {1}",
            ["Notification.Alliance.InviteReceived"] = "You have received a clan alliance invitation from [#aaff55][{0}][/#]\nTo accept, type: [#ffd479]/{2} accept {0}[/#]\nThe invitation will expire in: {1}",
            ["Notification.Alliance.NoActiveInvite"] = "You do not have an active alliance invitation for [#aaff55][{0}][/#]",
            ["Notification.Alliance.NoActiveInviteFrom"] = "You do not have an active alliance invitation from [#aaff55][{0}][/#]",
            ["Notification.Alliance.WithdrawnClan"] = "{0} has withdrawn an alliance invitation to [#aaff55][{1}][/#]",
            ["Notification.Alliance.WithdrawnTarget"] = "[#aaff55][{0}][/#] has withdrawn their alliance invitation",
            ["Notification.Alliance.AtLimitTarget"] = "[#aaff55][{0}][/#] currently has the maximum amount of alliances allowed",
            ["Notification.Alliance.AtLimitSelf"] = "Your clan currently has the maximum amount of alliances allowed",
            ["Notification.Alliance.Formed"] = "[#aaff55][{0}][/#] has formed an alliance with [#aaff55][{1}][/#]",
            ["Notification.Alliance.Rejected"] = "[#aaff55][{0}][/#] has rejected calls to form an alliance with [#aaff55][{1}][/#]",
            ["Notification.Alliance.Revoked"] = "[#aaff55][{0}][/#] has revoked their alliance with [#aaff55][{1}][/#]",
            ["Notification.Alliance.NoActiveAlliance"] = "You do not currently have an alliance with [#aaff55][{0}][/#]",

            ["Notification.ClanHelp.NoClan"] = "\nAvailable Commands:\n[#ffd479]/{0} create <tag> \"description\"[/#] - Create a new clan\n[#ffd479]/{0} accept <tag>[/#] - Join a clan by invitation\n[#ffd479]/{0} reject <tag>[/#] - Reject a clan invitation",
            ["Notification.ClanHelp.Basic"] = "\nAvailable Commands:\n[#ffd479]/{0}[/#] - Display your clan information\n[#ffd479]/{1} <message>[/#] - Send a message via clan chat\n[#ffd479]/{0} leave[/#] - Leave your current clan",
            ["Notification.ClanHelp.Alliance"] = "\n\n[#45b6fe]<size=14>Alliance Commands:</size>[/#]\n[#ffd479]/{0} invite <tag>[/#] - Invite a clan to become allies\n[#ffd479]/{0} withdraw <tag>[/#] - Withdraw an alliance invitation\n[#ffd479]/{0} accept <tag>[/#] - Accept an alliance invitation\n[#ffd479]/{0} reject <tag>[/#] - Reject an alliance invitation\n[#ffd479]/{0} revoke <tag>[/#] - Revoke an alliance",
            ["Notification.ClanHelp.Moderator"] = "\n\n[#b573ff]<size=14>Moderator Commands:</size>[/#]\n[#ffd479]/{0} invite <name or ID>[/#] - Invite a player to your clan\n[#ffd479]/{0} withdraw <name or ID>[/#] - Revoke a invitation\n[#ffd479]/{0} kick <name or ID>[/#] - Kick a member from your clan",
            ["Notification.ClanHelp.Owner"] = "\n\n[#a1ff46]<size=14>Owner Commands:</size>[/#]\n[#ffd479]/{0} promote <name or ID>[/#] - Promote a clan member\n[#ffd479]/{0} demote <name or ID>[/#] - Demote a clan member\n[#ffd479]/{0} disband forever[/#] - Disband your clan",

            ["Notification.Clan.NotInAClan"] = "\nYou are currently not a member of a clan",
            ["Notification.Clan.Help"] = "\nTo see available commands type: [#ffd479]/{0}[/#]",
            ["Notification.Clan.OwnerOf"] = "\nYou are the owner of: [#aaff55]{0}[/#] ({1}/{2})",
            ["Notification.Clan.ModeratorOf"] = "\nYou are a moderator of: [#aaff55]{0}[/#] ({1}/{2})",
            ["Notification.Clan.MemberOf"] = "\nYou are a member of: [#aaff55]{0}[/#] ({1}/{2})",
            ["Notification.Clan.MembersOnline"] = "\nMembers Online: {0}",

            ["Notification.Clan.CreateSyntax"] = "[#ffd479]/{0} create <tag> \"description\"[/#] - Create a new clan",
            ["Notification.Clan.InviteSyntax"] = "[#ffd479]/{0} invite <partialNameOrID>[/#] - Invite a player to your clan",
            ["Notification.Clan.WithdrawSyntax"] = "[#ffd479]/{0} withdraw <partialNameOrID>[/#] - Revoke a member invitation",
            ["Notification.Clan.AcceptSyntax"] = "[#ffd479]/{0} accept <tag>[/#] - Join a clan by invitation",
            ["Notification.Clan.RejectSyntax"] = "[#ffd479]/{0} reject <tag>[/#] - Reject a clan invitation",
            ["Notification.Clan.PromoteSyntax"] = "[#ffd479]/{0} promote <partialNameOrID>[/#] - Promote a clanFreb member to the next rank",
            ["Notification.Clan.DemoteSyntax"] = "[#ffd479]/{0} demote <partialNameOrID>[/#] - Demote a clan member to the next lowest rank",
            ["Notification.Clan.DisbandSyntax"] = "[#ffd479]/{0} disband forever[/#] - Disband your clan (this can not be undone)",
            ["Notification.Clan.KickSyntax"] = "[#ffd479]/{0} kick <partialNameOrID>[/#] - Kick a member from your clan",

            ["Notification.Clan.TagColorSyntax"] = "<color=#ffd479>/{0} tagcolor <hex (XXXXXX)></color> - Set a custom clan tag color",
            ["Notification.Clan.TagColorFormat"] = "<color=#ffd479>The hex string must be 6 characters long, and be a valid hex color</color>",
            ["Notification.Clan.TagColorReset"] = "<color=#ffd479>You have reset your clan's tag color</color>",
            ["Notification.Clan.TagColorSet"] = "<color=#ffd479>You have set your clan's tag color to</color> <color=#{0}>{0}</color>",
            ["Notification.Clan.TagColorDisabled"] = "<color=#ffd479>Custom tag colors are disabled on this server</color>",

            ["Notification.Disband.NotOwner"] = "You must be the clan owner to use this command",
            ["Notification.Disband.Success"] = "You have disbanded the clan [#aaff55][{0}][/#]",
            ["Notification.Disband.Reply"] = "The clan has been disbanded",
            ["Notification.Disband.NoPermission"] = "You do not have permission to disband this clan",

            ["Notification.Generic.ClanFull"] = "The clan is already at maximum capacity",
            ["Notification.Generic.NoClan"] = "You are not a member of a clan",
            ["Notification.Generic.InvalidClan"] = "The clan [#aaff55][{0}][/#] does not exist!",
            ["Notification.Generic.NoPermissions"] = "You have insufficient permission to use that command",
            ["Notification.Generic.SpecifyClanTag"] = "Please specify a clan tag",
            ["Notification.Generic.UnableToFindPlayer"] = "Unable to find a player with the name or ID {0}",
            ["Notification.Generic.CommandSelf"] = "You can not use this command on yourself",

            ["Chat.Alliance.Prefix"] = "[#a1ff46][ALLY CHAT][/#]: {0}",
            ["Chat.Clan.Prefix"] = "[#a1ff46][CLAN CHAT][/#]: {0}",
            ["Chat.Alliance.Format"] = "[{0}] [{1}]{2}[/#]: {3}",
        };
        #endregion

        #region ClansUI  
        #if RUST
        public bool HasFFEnabled(ulong playerID) => false;

        public void ToggleFF(ulong playerID) { }

        public void CreateClan(BasePlayer player, string tag, string description) => CreateClan(player.IPlayer, tag, description);

        public bool PromotePlayer(BasePlayer promoter, ulong targetId) => PromotePlayer(promoter.IPlayer, targetId.ToString());

        public bool DemotePlayer(BasePlayer demoter, ulong targetId) => DemotePlayer(demoter.IPlayer, targetId.ToString());

        public bool KickPlayer(BasePlayer player, ulong targetId) => KickPlayer(player.IPlayer, targetId.ToString());

        public bool InvitePlayer(BasePlayer player, ulong targetId) => InvitePlayer(player.IPlayer, targetId.ToString());

        public bool WithdrawInvite(BasePlayer player, string partialNameOrID) => WithdrawInvite(player.IPlayer, partialNameOrID);

        public bool OfferAlliance(BasePlayer player, string tag) => OfferAlliance(player.IPlayer, tag);

        public bool RevokeAlliance(BasePlayer player, string tag) => RevokeAlliance(player.IPlayer, tag);

        public bool WithdrawAlliance(BasePlayer player, string tag) => WithdrawAlliance(player.IPlayer, tag);

        public bool RejectAlliance(BasePlayer player, string tag) => RejectAlliance(player.IPlayer, tag);

        public bool AcceptAlliance(BasePlayer player, string tag) => AcceptAlliance(player.IPlayer, tag);

        public bool LeaveClan(BasePlayer player) => LeaveClan(player.IPlayer);

        public bool DisbandClan(BasePlayer player) => DisbandClan(player.IPlayer);
        #endif
        #endregion
    }

    namespace ClansEx
    {
        public static class StringExtensions
        {
            public static bool Contains(this string haystack, string needle, CompareOptions options)
            {
                return CultureInfo.InvariantCulture.CompareInfo.IndexOf(haystack, needle, options) >= 0;
            }
        }

        public static class ListPool
        {
            public static Dictionary<Type, object> directory = new Dictionary<Type, object>();

            public static void CreateCollection<T>(int capacity)
            {
                if (directory.ContainsKey(typeof(T)))
                    return;

                object obj = new ListCollection<T>(capacity);
                directory.Add(typeof(T), obj);
            }

            public static ListCollection<T> FindCollection<T>()
            {
                object obj;
                if (!directory.TryGetValue(typeof(T), out obj))
                {
                    obj = new ListCollection<T>();
                    directory.Add(typeof(T), obj);
                }

                return (ListCollection<T>)obj;
            }

            public static List<T> Get<T>() => GetList<List<T>>();
            
            public static List<T> Get<T>(int capacity)
            {
                List<T> list = GetList<List<T>>();
                list.Capacity = capacity;
                return list;
            }

            private static T GetList<T>() where T : class, new()
            {
                ListCollection<T> poolCollection = FindCollection<T>();
                if (poolCollection != null)
                {
                    if (poolCollection.stack.Count > 0)
                        return poolCollection.stack.Pop();
                }
                return Activator.CreateInstance<T>();
            }

            public static void Free<T>(ref List<T> list)
            {
                if (list == null)
                    return;

                list.Clear();

                FreeList<List<T>>(ref list);
            }

            private static void FreeList<T>(ref T t) where T : class
            {
                if (t == null)
                    return;

                ListCollection<T> poolCollection = FindCollection<T>();
                if (poolCollection != null && poolCollection.HasSpace)
                {
                    poolCollection.stack.Push(t);
                    t = default(T);
                }
                else
                {
                    t = null;
                }
            }

            public static void ClearPool()
            {
                directory.Clear();
            }

            public class ListCollection<T>
            {
                public Stack<T> stack;

                private readonly int maximumSize;

                public bool HasSpace { get { return stack.Count < maximumSize; } }

                public ListCollection(int maximumSize = 7)
                {
                    this.maximumSize = maximumSize;
                    stack = new Stack<T>(maximumSize + 1);
                }
            }
        }
    }
}


// --- End of file: Clans.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/code-entry ---
// --- Original File Path: C/CodeEntry/CodeEntry.cs ---

namespace Oxide.Plugins
{
    [Info("Code Entry", "Wulf", "1.1.0")]
    [Description("Makes code locks always require code input for entry")]
    class CodeEntry : CovalencePlugin
    {
        private void CanUseLockedEntity(BasePlayer basePlayer, CodeLock codeLock)
        {
            // Check if entity is unlocked or already open
            if (!codeLock.IsLocked() || codeLock.GetParentEntity().IsOpen())
            {
                return;
            }

            // Remove player from whitelists so they are prompted for input
            if (codeLock.whitelistPlayers.Contains(basePlayer.userID))
            {
                codeLock.whitelistPlayers.Remove(basePlayer.userID);
            }
            else if (codeLock.guestPlayers.Contains(basePlayer.userID))
            {
                codeLock.guestPlayers.Remove(basePlayer.userID);
            }
        }

        private void OnCodeEntered(CodeLock codeLock, BasePlayer basePlayer, string code)
        {
            if (codeLock.code == code)
            {
                // Open doors on code acceptance
                BaseEntity entity = codeLock.GetParentEntity();
                if (entity != null && !entity.IsOpen())
                {
                    entity.SetFlag(BaseEntity.Flags.Open, true);
                    entity.SendNetworkUpdate();
                }

                // Open loot panels on code acceptance
                if (entity is StorageContainer)
                {
                    (entity as StorageContainer).PlayerOpenLoot(basePlayer);
                }
            }
        }
    }
}


// --- End of file: CodeEntry.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/chat-impersonator ---
// --- Original File Path: C/ChatImpersonator/ChatImpersonator.cs ---

using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Chat Impersonator", "LaserHydra", "3.0.0")]
    [Description("Allows you to impersonate another player in chat")]
    public class ChatImpersonator : CovalencePlugin
    {
        private const string Permission = "chatimpersonator.use";

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Syntax"] = "Syntax: /ci <player> <message>",
                ["Player Not Found"] = "The player could not be found."
            }, this);
        }

        [Command("ci"), Permission(Permission)]
        private void Cmd_Impersonate(IPlayer player, string command, string[] args)
        {
            if (args.Length < 2)
            {
                SendLocalizedReply(player, "Syntax");
                return;
            }
            
            var targetPlayer = FindPlayer(args[0]);

            if (targetPlayer == null)
            {
                SendLocalizedReply(player, "Player Not Found");
                return;
            }

            ForcePlayerChat(targetPlayer, string.Join(" ", args.Skip(1).ToArray()));
        }

        private void ForcePlayerChat(BasePlayer target, string message) =>
            target.SendConsoleCommand($"chat.say \"{message}\"");

        private void SendLocalizedReply(IPlayer player, string key) => 
            player.Reply(lang.GetMessage(key, this, player.Id));

        private BasePlayer FindPlayer(string nameOrId) =>
            covalence.Players.FindPlayer(nameOrId)?.Object as BasePlayer;
    }
}

// --- End of file: ChatImpersonator.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/cui-generator ---
// --- Original File Path: C/CuiGenerator/CuiGenerator.cs ---

namespace Oxide.Plugins
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Text.RegularExpressions;
    using Oxide.Core;
    using Oxide.Core.Configuration;
    using Oxide.Core.Plugins;
    using UnityEngine;
    using Newtonsoft.Json.Linq;
    using Network;
    using System.ComponentModel;
    using Newtonsoft.Json.Converters;
    using UnityEngine.UI;

    [Info("Cui Generator", "bazuka5801", "3.1.60"), Description("Helps developer manage GUI manipulations in single line of code")]
    public class CuiGenerator : RustPlugin
    {
        public class CuiElementComparer : IEqualityComparer<CuiElement>
        {
            bool IEqualityComparer<CuiElement>.Equals(CuiElement x, CuiElement y) => EqualElement(x, y);

            int IEqualityComparer<CuiElement>.GetHashCode(CuiElement obj) => 0;

            public static bool EqualElement(CuiElement e1, CuiElement e2)
            {
                if (e1.Name != e2.Name)
                {
                    return false;
                }

                if (e1.Parent != e2.Parent)
                {
                    return false;
                }

                if (Math.Abs(e1.FadeOut - e2.FadeOut) > 0.01)
                {
                    return false;
                }

                if (e1.Components.Count != e2.Components.Count)
                {
                    return false;
                }

                return !e1.Components.Where((t, i) => !EqualComponent(t, e2.Components[i])).Any();
            }

            private static bool EqualComponent(ICuiComponent e1, ICuiComponent e2)
            {
                if (e1.Type != e2.Type)
                {
                    return false;
                }

                switch (e1.Type)
                {
                    case "RectTransform":
                        return EqualComponent((CuiRectTransformComponent)e1, (CuiRectTransformComponent)e2);
                    case "CountDown":
                        return EqualComponent((CuiCountdownComponent)e1, (CuiCountdownComponent)e2);
                    case "UnityEngine.UI.RawImage":
                        return EqualComponent((CuiRawImageComponent)e1, (CuiRawImageComponent)e2);
                    case "UnityEngine.UI.Text":
                        return EqualComponent((CuiTextComponent)e1, (CuiTextComponent)e2);
                    case "UnityEngine.UI.Image":
                        return EqualComponent((CuiImageComponent)e1, (CuiImageComponent)e2);
                    case "UnityEngine.UI.Button":
                        return EqualComponent((CuiButtonComponent)e1, (CuiButtonComponent)e2);
                    case "UnityEngine.UI.Outline":
                        return EqualComponent((CuiOutlineComponent)e1, (CuiOutlineComponent)e2);
                    case "UnityEngine.UI.InputField":
                        return EqualComponent((CuiInputFieldComponent)e1, (CuiInputFieldComponent)e2);
                }

                return false;
            }

            private static bool EqualComponent(CuiCountdownComponent e1, CuiCountdownComponent e2)
            {
                if (e1.Step != e2.Step)
                {
                    return false;
                }

                if (e1.StartTime != e2.StartTime)
                {
                    return false;
                }

                if (e1.EndTime != e2.EndTime)
                {
                    return false;
                }

                return e1.Command == e2.Command;
            }

            private static bool EqualComponent(CuiRectTransformComponent e1, CuiRectTransformComponent e2)
            {
                if (e1.AnchorMin != e2.AnchorMin)
                {
                    return false;
                }

                if (e1.AnchorMax != e2.AnchorMax)
                {
                    return false;
                }

                if (e1.OffsetMin != e2.OffsetMin)
                {
                    return false;
                }

                return e1.OffsetMax == e2.OffsetMax;
            }

            private static bool EqualComponent(CuiTextComponent e1, CuiTextComponent e2)
            {
                if (e1.Align != e2.Align)
                {
                    return false;
                }

                if (e1.Color != e2.Color)
                {
                    return false;
                }

                if (e1.Font != e2.Font)
                {
                    return false;
                }

                if (e1.Text != e2.Text)
                {
                    return false;
                }

                return !(Math.Abs(e1.FadeIn - e2.FadeIn) > 0.01);
            }

            private static bool EqualComponent(CuiButtonComponent e1, CuiButtonComponent e2)
            {
                if (e1.Command != e2.Command)
                {
                    return false;
                }

                if (e1.Close != e2.Close)
                {
                    return false;
                }

                if (e1.Color != e2.Color)
                {
                    return false;
                }

                if (e1.Sprite != e2.Sprite)
                {
                    return false;
                }

                if (e1.Material != e2.Material)
                {
                    return false;
                }

                if (e1.ImageType != e2.ImageType)
                {
                    return false;
                }

                return !(Math.Abs(e1.FadeIn - e2.FadeIn) > 0.01);
            }

            private static bool EqualComponent(CuiRawImageComponent e1, CuiRawImageComponent e2)
            {
                if (e1.Sprite != e2.Sprite)
                {
                    return false;
                }

                if (e1.Color != e2.Color)
                {
                    return false;
                }

                if (e1.Material != e2.Material)
                {
                    return false;
                }

                if (e1.Png != e2.Png)
                {
                    return false;
                }

                if (e1.Url != e2.Url)
                {
                    return false;
                }

                return !(Math.Abs(e1.FadeIn - e2.FadeIn) > 0.01);
            }

            private static bool EqualComponent(CuiImageComponent e1, CuiImageComponent e2)
            {
                if (e1.Sprite != e2.Sprite)
                {
                    return false;
                }

                if (e1.Color != e2.Color)
                {
                    return false;
                }

                if (e1.Png != e2.Png)
                {
                    return false;
                }

                if (e1.Material != e2.Material)
                {
                    return false;
                }

                if (e1.ImageType != e2.ImageType)
                {
                    return false;
                }

                return !(Math.Abs(e1.FadeIn - e2.FadeIn) > 0.01);
            }

            private static bool EqualComponent(CuiOutlineComponent e1, CuiOutlineComponent e2)
            {
                if (e1.Color != e2.Color)
                {
                    return false;
                }

                if (e1.Distance != e2.Distance)
                {
                    return false;
                }

                return e1.UseGraphicAlpha == e2.UseGraphicAlpha;
            }

            private static bool EqualComponent(CuiInputFieldComponent e1, CuiInputFieldComponent e2)
            {
                if (e1.Text != e2.Text)
                {
                    return false;
                }

                if (e1.Command != e2.Command)
                {
                    return false;
                }

                if (e1.Font != e2.Font)
                {
                    return false;
                }

                if (e1.FontSize != e2.FontSize)
                {
                    return false;
                }

                if (e1.CharsLimit != e2.CharsLimit)
                {
                    return false;
                }

                if (e1.Align != e2.Align)
                {
                    return false;
                }

                if (e1.IsPassword != e2.IsPassword)
                {
                    return false;
                }

                return true;
            }
        }
        [Serializable]
        internal class CuiFunction
        {
            public readonly List<List<CuiElement>> cacheArgs = new List<List<CuiElement>>();

            private int _argc = -1;
            public string GUI = "";

            public int argc()
            {
                if (_argc >= 0)
                {
                    return _argc;
                }

                _argc = 0;
                while (GUI.Contains("{" + _argc + "}"))
                {
                    _argc++;
                }

                return _argc;
            }
        }

        internal class CuiFunctionConverter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                var data = (CuiFunction)value;
                writer.WriteValue(data.GUI);
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue,
                                            JsonSerializer serializer) =>
                new CuiFunction { GUI = reader.Value.ToString() };

            public override bool CanConvert(Type objectType) => objectType == typeof(CuiFunction);
        }

        private readonly HashSet<ulong> connected = new HashSet<ulong>();

        private readonly Dictionary<ulong, List<string>> uiCache = new Dictionary<ulong, List<string>>();

        private void OnServerInitialized()
        {
            CommunityEntity.ServerInstance.StartCoroutine(LoadFunctions());
            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }

            foreach (var player in BasePlayer.sleepingPlayerList)
            {
                OnPlayerConnected(player);
            }

            timer.Every(1f, () =>
            {
                if (isDebug)
                {
                    Puts($"CuiDraw: {draw}\nCuiDrawCache: {drawCache}");
                    draw = drawCache = 0;
                }
            });
        }

        private void Unload()
        {
            foreach (var player in players)
            {
                DestroyAllUI(player.Key);
            }
        }

        private void CacheUI(ulong userId, string json)
        {
            if (!uiCache.ContainsKey(userId))
            {
                uiCache[userId] = new List<string>();
            }

            var list = uiCache[userId];
            list.Add(json);
            if (list.Count > 5)
            {
                list.RemoveAt(0);
            }
        }

        private void PutsCacheUI(ulong userId)
        {
            if (!uiCache.ContainsKey(userId))
            {
                return;
            }

            var msg = string.Join("\n", uiCache[userId].ToArray());
            PrintError("AddUi error:\n" + msg);
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            if (player == null)
            {
                return;
            }

            if (connected.Contains(player.userID))
            {
                connected.Remove(player.userID);
            }
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            connected.Add(player.userID);
            player.displayName = CleanName(player.displayName);
        }

        private static string CleanName(string strIn)
        {
            // Replace invalid characters with empty strings.
            try
            {
                return Regex.Replace(strIn, @"\$|\@|\\|\/", "",
                    RegexOptions.None);
            }
            // If we timeout when replacing invalid characters,
            // we should return Empty.
            catch
            {
                return strIn;
            }
        }

        private void OnPlayerAddUiDisconnected(ulong userId, string reason)
        {
            if (reason.ToLower().Contains("addui"))
            {
                PutsCacheUI(userId);
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (!players.ContainsKey(player))
            {
                return;
            }

            players.Remove(player);
        }

        //[HookMethod("OnPluginLoaded")]
        //void OnPluginLoaded(Plugin plugin)
        //{
        //    if (!string.IsNullOrEmpty(Net.sv.ip))
        //    {
        //        NextTick(()=>plugin.CallHook( "OnServerInitialized" ));
        //    }
        //}

        private void OnPluginUnloaded(Plugin plugin)
        {
            if (plugin.Name == Name)
            {
                return;
            }

            foreach (var playerPair in players)
            {
                for (var i = playerPair.Value.Count - 1; i >= 0; i--)
                {
                    var data = playerPair.Value[i];
                    if (data.plugin == plugin.Name)
                    {
                        IDestroyUI(playerPair.Key, data);
                    }
                }
            }
        }

        #region EXTERNAL CALLS

        internal void onCuiGeneratorInitialized()
        {
            isLoaded = true;
            Puts($"{nameof(CuiGenerator)} is ready!");
            Interface.CallHook("OnCuiGeneratorInitialized");
        }

        #endregion

        #region Fields

        private Dictionary<string, Dictionary<string, CuiFunction>> functions;
        private readonly Dictionary<BasePlayer, List<UIData>> players = new Dictionary<BasePlayer, List<UIData>>();

        private readonly CuiElementComparer CuiComparer = new CuiElementComparer();

        private bool isLoaded;

        private bool isDebug;
        private int drawCache;
        private int draw;

        #endregion

        #region Data

        private readonly DynamicConfigFile uiDB = Interface.Oxide.DataFileSystem.GetFile("CuiGenerator/CuiDB");
        private readonly DynamicConfigFile imagesDB = Interface.Oxide.DataFileSystem.GetFile("CuiGenerator/Images");

        #endregion

        #region UI

        private void IDrawUI(BasePlayer player, UIData data)
        {
            var now = DateTime.Now;
            if (!players.ContainsKey(player))
            {
                players.Add(player, new List<UIData>());
            }

            var funcs = players[player];
            for (var i = funcs.Count - 1; i >= 0; i--)
            {
                var func = funcs[i];
                if (func.plugin != data.plugin || func.funcName != data.funcName)
                {
                    continue;
                }

                players[player][i] = data;
                DrawUIWithoutCache(player, func, data);
                return;
            }

            var json = functions[data.plugin][data.funcName].GUI;
            if (data.args.Length > 0)
            {
                json = HandleArgs(json, data.args);
            }

            players[player].Add(data);
            if (data.additionalContainer.Count > 0)
            {
                var elements = CuiHelper.FromJson(json);
                elements.AddRange(data.additionalContainer);
                json = CuiHelper.ToJson(elements);
            }

            CacheUI(player.userID, json);
            CuiHelper.AddUi(player, json);
            if (isDebug)
            {
                draw++;
                Puts(json);
            }
        }

        private void DrawUIWithoutCache(BasePlayer player, UIData dataOld, UIData dataNew)
        {
            if (isDebug)
            {
                Puts($"AdditionalOldList => {string.Join(", ", dataOld.additionalContainer.Select(p => p.Name))}");
                Puts($"AdditionalNewList => {string.Join(", ", dataNew.additionalContainer.Select(p => p.Name))}");
            }

            var func = functions[dataOld.plugin][dataOld.funcName];

            var changedArgs = new List<int>();
            for (var i = 0; i < func.argc(); i++)
            {
                if (dataOld.args[i].ToString() != dataNew.args[i].ToString())
                {
                    changedArgs.Add(i);
                }
            }

            var destroylist = new List<CuiElement>();
            foreach (var arg in changedArgs)
            {
                destroylist.AddRange(func.cacheArgs[arg]);
            }

            // Additional container
            var additionalDestroyList =
                dataOld.additionalContainer.Except(dataNew.additionalContainer, CuiComparer).ToList();
            destroylist.AddRange(additionalDestroyList);
            if (isDebug)
            {
                Puts($"AdditionalDestroyList => {string.Join(", ", additionalDestroyList.Select(p => p.Name))}");
            }

            var additionalReCreatingItems = new List<CuiElement>();

            if (destroylist.Count > 0)
            {
                foreach (var e in additionalDestroyList)
                {
                    var destroyItems = dataOld.additionalContainer.Where(
                        o => o != e &&
                             o.Parent == e.Parent && Intersect(GetRect(e), GetRect(o)) &&
                             !destroylist.Contains(o)).ToList();
                    destroylist.AddRange(destroyItems);
                    additionalReCreatingItems.AddRange(destroyItems);

                    foreach (var cuiElement in destroyItems)
                    {
                        var recursiveChildren = GetChildsRecursive(dataNew.additionalContainer, cuiElement.Name)
                            .Where(p => !destroylist.Contains(p)).ToList();
                        destroylist.AddRange(recursiveChildren);
                        additionalReCreatingItems.AddRange(recursiveChildren);
                    }

                    var elementChildren = GetChildsRecursive(dataOld.additionalContainer, e.Name);
                    destroylist.AddRange(elementChildren);
                    additionalReCreatingItems.AddRange(elementChildren);
                }

                destroylist = destroylist.Distinct(CuiComparer).ToList();
                destroylist = SortHierarchy(destroylist);
                if (isDebug)
                {
                    Puts($"DestroyListFull => {string.Join(", ", destroylist.Select(p => p.Name))}");
                }

                for (var i = destroylist.Count - 1; i >= 0; i--)
                {
                    CuiHelper.DestroyUi(player, destroylist[i].Name);
                }
            }

            var createlist = new List<CuiElement>();
            foreach (var arg in changedArgs)
            {
                createlist.AddRange(func.cacheArgs[arg]);
            }

            // Additional container
            var additionalCreateList =
                dataNew.additionalContainer.Except(dataOld.additionalContainer, CuiComparer).ToList();

            if (isDebug)
            {
                Puts($"AdditionalCreateList => {string.Join(", ", additionalCreateList.Select(p => p.Name))}");
            }

            createlist.AddRange(additionalCreateList);
            foreach (var e in additionalCreateList)
            {
                var addedItems = dataNew.additionalContainer.Where(
                    o => o != e &&
                         o.Parent == e.Parent && Intersect(GetRect(e), GetRect(o)) &&
                         !createlist.Contains(o)).ToList();
                createlist.AddRange(addedItems);

                foreach (var cuiElement in addedItems)
                {
                    createlist.AddRange(
                        GetChildsRecursive(dataNew.additionalContainer, cuiElement.Name)
                            .Where(p => !createlist.Contains(p)));
                }

                createlist.AddRange(GetChildsRecursive(dataNew.additionalContainer, e.Name));
            }

            createlist.AddRange(additionalReCreatingItems);

            if (createlist.Count > 0)
            {
                createlist = createlist.Distinct(CuiComparer).ToList();
                createlist = SortHierarchy(createlist);
                if (isDebug)
                {
                    Puts($"CreateListFull => {string.Join(", ", createlist.Select(p => p.Name))}");
                }

                var json = CuiHelper.ToJson(createlist);
                if (dataNew.args.Length > 0)
                {
                    json = HandleArgs(json, dataNew.args);
                }

                CacheUI(player.userID, json);
                CuiHelper.AddUi(player, json);
                if (isDebug)
                {
                    Puts(json);
                    drawCache++;
                }
            }
        }

        private void GetHierarchy(CuiElement element, List<CuiElement> function, List<CuiElement> hierarchy = null)
        {
            if (hierarchy == null)
            {
                hierarchy = new CuiElementContainer();
            }

            hierarchy.Add(element);

            var elementChilds = function.Where(child => child.Parent == element.Name).ToList();
            if (elementChilds.Count <= 0)
            {
                return;
            }

            foreach (var child in elementChilds)
            {
                GetHierarchy(child, function, hierarchy);
            }
        }

        private int GetDept(CuiElement obj)
        {
            if (obj == null || obj.Parent == "Hud" || obj.Parent == "Overlay")
            {
                return 0;
            }

            return GetDept(sortContainer.Find(p => p.Name == obj.Parent)) + 1;
        }

        private List<CuiElement> sortContainer;

        private List<CuiElement> SortHierarchy(List<CuiElement> container) => SortHierarchy(container, container);

        private List<CuiElement> SortHierarchy(List<CuiElement> container, List<CuiElement> allElements)
        {
            sortContainer = allElements;
            return container.OrderBy(GetDept).ToList();
        }

        private Rect GetRect(CuiElement e)
        {
            var transform = (CuiRectTransformComponent)e.Components.Find(c => c.Type == "RectTransform");
            return IntersectCore.GetRect(transform);
        }


        private bool Intersect(Rect a, Rect b) => IntersectCore.Intersects(a, b);

        public static Vector2 ParseVector(string p)
        {
            var strArrays = p.Split(' ');
            if (strArrays.Length != 2)
            {
                return Vector2.zero;
            }

            return new Vector2(float.Parse(strArrays[0]), float.Parse(strArrays[1]));
        }

        private string HandleArgs(string json, object[] args)
        {
            for (var i = 0; i < args.Length; i++)
            {
                json = json.Replace("{" + i + "}", args[i].ToString());
            }

            return json;
        }

        private void IDestroyUI(BasePlayer player, UIData data)
        {
            if (player == null)
            {
                PrintError("DestroyUI - player = null");
                return;
            }

            var uid = player.userID;

            var json = functions[data.plugin][data.funcName].GUI;
            if (data.args.Length > 0)
            {
                json = HandleArgs(json, data.args).Replace("$", "");
            }

            var container = CuiHelper.FromJson(json);
            container.AddRange(data.additionalContainer);
            container.Reverse();
            container.ForEach(e =>
            {
                if (e.Name != "AddUI CreatedPanel")
                {
                    CuiHelper.DestroyUi(player, e.Name);
                }
            });

            players[player].Remove(data);
        }

        private void DestroyAllUI(BasePlayer player)
        {
            var data = players[player];
            for (var i = data.Count - 1; i >= 0; i--)
            {
                IDestroyUI(player, data[i]);
            }
        }

        #endregion

        #region [Methods] Draw & Destroy

        internal void DrawUI_Internal(BasePlayer player, string plugin, string funcName, params object[] args)
        {
            DrawUIWIthEx_Internal(player, plugin, funcName, new CuiElementContainer(), args);
        }

        internal void DrawUIWIthEx_Internal(BasePlayer player, string plugin, string funcName,
            CuiElementContainer additionalContainer, params object[] args)
        {
            if (!isLoaded)
            {
                timer.Once(0.1f, () => DrawUI_Internal(player, plugin, funcName, args));
                return;
            }

            var data = new UIData(plugin, funcName, additionalContainer, args);
            Dictionary<string, CuiFunction> pluginFuncs;
            if (!functions.TryGetValue(plugin, out pluginFuncs))
            {
                PrintError(
                    $"Draw UI:\r {plugin} not found for {player.userID}:{player.displayName} \nDebug: {data}");
                return;
            }

            CuiFunction func;
            if (!functions[plugin].TryGetValue(funcName, out func))
            {
                PrintError(
                    $"Draw UI:\r {plugin} doesn't contains \"{funcName}\" {player.userID}:{player.displayName} \nDebug: {data}");
                return;
            }

            IDrawUI(player, data);
        }

        internal void DestroyUI_Internal(BasePlayer player, string plugin, string funcName)
        {
            if (!isLoaded)
            {
                timer.Once(0.1f, () => DestroyUI_Internal(player, plugin, funcName));
                return;
            }

            List<UIData> uiList;
            if (!players.TryGetValue(player, out uiList))
            {
                PrintError(
                    $"Destroy UI:\r{player.userID}:{player.displayName} doesn't have Cui\nDebug: Plugin \"{plugin}\" Function \"{funcName}\"");
                return;
            }

            var uiData = players[player];
            var data = uiData.Find(f => f.plugin == plugin && f.funcName == funcName);
            if (data == null)
            {
                return;
            }

            IDestroyUI(player, data);
        }

        #endregion

        #region Functions

        private IEnumerator LoadFunctions()
        {
            yield return AddImages(imagesDB.ReadObject<Dictionary<string, string>>() ??
                                   new Dictionary<string, string>());

            uiDB.Settings.Converters = new List<JsonConverter> { new CuiFunctionConverter() };
            var funcs = uiDB.ReadObject<Dictionary<string, CuiFunction>>();
            functions = new Dictionary<string, Dictionary<string, CuiFunction>>();

            var comparer = new CuiElementComparer();

            foreach (var funcPair in funcs)
            {
                var func = funcPair.Key;
                string plugin, funcName;
                SplitFunc(func, out plugin, out funcName);

                if (!functions.ContainsKey(plugin))
                {
                    functions[plugin] = new Dictionary<string, CuiFunction>();
                }

                functions[plugin].Add(funcName, funcPair.Value);

                var function = functions[plugin][funcName];
                var argc = function.argc();
                var json = function.GUI;
                if (string.IsNullOrEmpty(json))
                {
                    continue;
                }

                var elements = CuiHelper.FromJson(json);

                foreach (var e in elements)
                {
                    var component = e.Components.FirstOrDefault(c => c.Type == "UnityEngine.UI.RawImage");
                    var rawImage = component as CuiRawImageComponent;
                    if (!string.IsNullOrEmpty(rawImage?.Png))
                    {
                        rawImage.Sprite = "assets/content/textures/generic/fulltransparent.tga";

                        if (rawImage.Png.StartsWith("{"))
                        {
                            // if (rawImage.Png == "{colon}")
                            // {
                            //     rawImage.Png = GetImage("colon");
                            // }
                        }
                        else
                        {
                            var loadingTask = AddImageCoroutine(rawImage.Png, rawImage.Png);
                            while (loadingTask.MoveNext())
                            {
                                yield return loadingTask.Current;
                            }

                            rawImage.Png = GetImage(rawImage.Png);
                        }
                    }
                    else if (rawImage != null && string.IsNullOrEmpty(rawImage.Url) &&
                             rawImage.Sprite == "Assets/Icons/rust.png")
                    {
                        rawImage.Sprite = "assets/content/ui/ui.background.tile.psd";
                    }
                }

                function.GUI = json = CuiHelper.ToJson(elements);

                var jsonArgs = json;
                if (argc == 0)
                {
                    function.cacheArgs.Add(elements);
                    continue;
                }

                for (var j = 0; j < argc; j++)
                {
                    jsonArgs = jsonArgs.Replace("{" + j + "}", "");
                }

                var elementsArgs = CuiHelper.FromJson(jsonArgs);

                var argEleement = elementsArgs.Except(elements, comparer).ToList();
                var changedElements = elements.Except(elementsArgs, comparer).ToList();

                var argsElements = changedElements
                    .Select(element => CuiHelper.ToJson(new List<CuiElement> { element })).ToList();
                var argNumbers = new List<int>();
                for (var j = 0; j < argc; j++)
                    for (var k = 0; k < argsElements.Count; k++)
                    {
                        if (argsElements[k].Contains("{" + j + "}"))
                        {
                            argNumbers.Add(k);
                        }
                    }

                for (var j = 0; j < argNumbers.Count; j++)
                {
                    var e = changedElements[argNumbers[j]];
                    var argsReferences = elements.Where(
                        o => o != e &&
                             o.Parent == e.Parent && Intersect(GetRect(e), GetRect(o)) &&
                             !argEleement.Contains(o)).ToList();
                    argsReferences.Insert(0, e);
                    var newReferences = new List<CuiElement>();
                    for (var index = 0; index < argsReferences.Count; index++)
                    {
                        var element = argsReferences[index];
                        newReferences.AddRange(GetChildsRecursive(elements, element.Name));
                    }

                    argsReferences.AddRange(newReferences);
                    argsReferences = argsReferences.Distinct(comparer).ToList();
                    argsReferences = SortHierarchy(argsReferences, elements);
                    function.cacheArgs.Add(argsReferences);
                }
            }

            foreach (var pluginFunctions in functions)
                foreach (var func in pluginFunctions.Value)
                {
                    var funcAspect = func.Value.GUI;
                    if (string.IsNullOrEmpty(funcAspect))
                    {
                        continue;
                    }

                    var elements = CuiHelper.FromJson(funcAspect);
                }

            Interface.Oxide.LogInfo($"[Core] [CuiGenerator] Loaded <{funcs.Count}> functions.");
            onCuiGeneratorInitialized();
        }

        private List<CuiElement> GetChildsRecursive(List<CuiElement> elements, string name)
        {
            var childs = new List<CuiElement>();
            foreach (var element in elements)
            {
                if (element.Parent == name)
                {
                    childs.Add(element);
                    childs.AddRange(GetChildsRecursive(elements, element.Name));
                }
            }

            return childs;
        }

        private void SplitFunc(string func, out string plugin, out string funcName)
        {
            plugin = funcName = string.Empty;
            try
            {
                plugin = func.Substring(0, func.IndexOf('_'));
                funcName = func.Substring(func.IndexOf('_') + 1, func.Length - func.IndexOf('_') - 1);
            }
            catch (Exception e)
            {
                Debug.LogError($"'{func}' dont have separator");
            }
        }

        #endregion

        private void DrawUI(BasePlayer player, string plugin, string funcName, params object[] args)
        {
            DrawUI_Internal(player, plugin, funcName, args);
        }

        private void DrawUIWIthEx(BasePlayer player, string plugin,
                                  string funcName,
                                  Oxide.Game.Rust.Cui.CuiElementContainer additionalContainer, params object[] args)
        {
            DrawUIWIthEx_Internal(player, plugin, funcName, new CuiElementContainer(CuiHelper.FromJson(additionalContainer.ToJson())), args);
        }

        private void DestroyUI(BasePlayer player, string plugin, string funcName)
        {
            DestroyUI_Internal(player, plugin, funcName);
        }

        [ConsoleCommand("cui.debug")]
        private void cmdDebug(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
            {
                return;
            }

            isDebug = !isDebug;
            Puts($"Cui Debug: {isDebug}");
        }

        [ConsoleCommand("cui.args")]
        private void cmdArgs(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
            {
                return;
            }

            if (arg.HasArgs(2))
            {
                var i = 0;
                foreach (var argumentRefs in functions[arg.Args[0]][arg.Args[1]].cacheArgs)
                {
                    Puts($"Argument {i++}:\n{CuiHelper.ToJson(argumentRefs, true)}");
                }
            }
        }

        public static class IntersectCore
        {
            public static Rect GetRect(CuiRectTransformComponent transform)
            {
                var anchorMin = Vector2Ex.Parse(transform.AnchorMin);
                var anchorMax = Vector2Ex.Parse(transform.AnchorMax);

                var offsetMin = Vector2Ex.Parse(transform.OffsetMin);
                var offsetMax = Vector2Ex.Parse(transform.OffsetMax);

                var rectMin = anchorMin + offsetMin * 0.00078125F;
                var rectMax = anchorMax + offsetMax * 0.001388889F;
                return new Rect(rectMin, rectMax - rectMin);
            }

            private static bool ValueInRange(float value, float min, float max) => value >= min && value <= max;

            public static bool Intersects(Rect a, Rect b)
            {
                // Check bounds
                /*
                var xOverlap = ValueInRange(a.x, b.x, b.x + b.width) ||
                               ValueInRange(b.x, a.x, a.x + a.width);
    
                var yOverlap = ValueInRange(a.y, b.y, b.y + b.height) ||
                               ValueInRange(b.y, a.y, a.y + a.height);
                */

                // Check center overlap
                var centerxOverlap = ValueInRange(a.center.x, b.x, b.x + b.width) ||
                                     ValueInRange(b.center.x, a.x, a.x + a.width);
                var centeryOverlap = ValueInRange(a.center.y, b.y, b.y + b.height) ||
                                     ValueInRange(b.center.y, a.y, a.y + a.height);

                return centerxOverlap && centeryOverlap;
            }
        }
        internal class UIData
        {
            public CuiElementContainer additionalContainer;
            public object[] args;
            public string funcName;
            public string plugin;

            public UIData(string plugin, string funcName, params object[] args)
            {
                this.plugin = plugin;
                this.funcName = funcName;
                this.args = args;
            }

            public UIData(string plugin, string funcName, CuiElementContainer additionalContainer, params object[] args)
            {
                this.plugin = plugin;
                this.funcName = funcName;
                this.additionalContainer = additionalContainer;
                this.args = args;
            }

            public override string ToString()
            {
                return
                    $"Plugin \"{plugin}\" Function \"{funcName}\" Args \"{string.Join(", ", args.Select(arg => arg.ToString()).ToArray())}\"";
            }
        }
        public class ComponentConverter : JsonConverter
        {
            public override bool CanWrite => false;

            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                throw new NotImplementedException();
            }

            public override object ReadJson(
                JsonReader reader,
                Type objectType,
                object existingValue,
                JsonSerializer serializer)
            {
                var jobject = JObject.Load(reader);
                Type type;
                switch (jobject["type"].ToString())
                {
                    case "NeedsCursor":
                        type = typeof(CuiNeedsCursorComponent);
                        break;
                    case "Countdown":
                        type = typeof(CuiCountdownComponent);
                        break;
                    case "RectTransform":
                        type = typeof(CuiRectTransformComponent);
                        break;
                    case "UnityEngine.UI.Button":
                        type = typeof(CuiButtonComponent);
                        break;
                    case "UnityEngine.UI.Image":
                        type = typeof(CuiImageComponent);
                        break;
                    case "UnityEngine.UI.InputField":
                        type = typeof(CuiInputFieldComponent);
                        break;
                    case "UnityEngine.UI.Outline":
                        type = typeof(CuiOutlineComponent);
                        break;
                    case "UnityEngine.UI.RawImage":
                        type = typeof(CuiRawImageComponent);
                        break;
                    case "UnityEngine.UI.Text":
                        type = typeof(CuiTextComponent);
                        break;
                    default:
                        return null;
                }

                var instance = Activator.CreateInstance(type);
                serializer.Populate(jobject.CreateReader(), instance);
                return instance;
            }

            public override bool CanConvert(Type objectType) => objectType == typeof(ICuiComponent);
        }
        public class CuiButton
        {
            public CuiButtonComponent Button { get; } = new CuiButtonComponent();
            public CuiRectTransformComponent RectTransform { get; } = new CuiRectTransformComponent();
            public CuiTextComponent Text { get; } = new CuiTextComponent();
            public float FadeOut { get; set; }
        }

        public class CuiPanel
        {
            public CuiImageComponent Image { get; set; } = new CuiImageComponent();
            public CuiRawImageComponent RawImage { get; set; }
            public CuiRectTransformComponent RectTransform { get; } = new CuiRectTransformComponent();
            public bool CursorEnabled { get; set; }
            public float FadeOut { get; set; }
        }

        public class CuiLabel
        {
            public CuiTextComponent Text { get; } = new CuiTextComponent();
            public CuiRectTransformComponent RectTransform { get; } = new CuiRectTransformComponent();
            public float FadeOut { get; set; }
        }


        public class CuiElementContainer : List<CuiElement>
        {
            public CuiElementContainer() { }

            public CuiElementContainer(List<CuiElement> elements)
                : base(elements)
            { }

            public string Add(CuiButton button, string parent = "Hud", string name = null)
            {
                if (string.IsNullOrEmpty(name))
                {
                    name = CuiHelper.GetGuid();
                }

                Add(new CuiElement
                {
                    Name = name,
                    Parent = parent,
                    FadeOut = button.FadeOut,
                    Components =
                    {
                        button.Button,
                        button.RectTransform
                    }
                });
                if (!string.IsNullOrEmpty(button.Text.Text))
                {
                    Add(new CuiElement
                    {
                        Parent = name,
                        FadeOut = button.FadeOut,
                        Components =
                        {
                            button.Text,
                            new CuiRectTransformComponent()
                        }
                    });
                }

                return name;
            }

            public string Add(CuiLabel label, string parent = "Hud", string name = null)
            {
                if (string.IsNullOrEmpty(name))
                {
                    name = CuiHelper.GetGuid();
                }

                Add(new CuiElement
                {
                    Name = name,
                    Parent = parent,
                    FadeOut = label.FadeOut,
                    Components =
                    {
                        label.Text,
                        label.RectTransform
                    }
                });
                return name;
            }

            public string Add(CuiPanel panel, string parent = "Hud", string name = null)
            {
                if (string.IsNullOrEmpty(name))
                {
                    name = CuiHelper.GetGuid();
                }

                var element = new CuiElement
                {
                    Name = name,
                    Parent = parent,
                    FadeOut = panel.FadeOut
                };
                if (panel.Image != null)
                {
                    element.Components.Add(panel.Image);
                }

                if (panel.RawImage != null)
                {
                    element.Components.Add(panel.RawImage);
                }

                element.Components.Add(panel.RectTransform);
                if (panel.CursorEnabled)
                {
                    element.Components.Add(new CuiNeedsCursorComponent());
                }

                Add(element);
                return name;
            }

            public string ToJson() => ToString();

            public override string ToString() => CuiHelper.ToJson(this);
        }


        public static class CuiHelper
        {
            public static string ToJson(List<CuiElement> elements, bool format = false) =>
                JsonConvert.SerializeObject(elements, format ? Formatting.Indented : Formatting.None,
                                            new JsonSerializerSettings
                                            {
                                                DefaultValueHandling = DefaultValueHandling.Ignore
                                            }).Replace("\\n", "\n");

            public static List<CuiElement> FromJson(string json) =>
                JsonConvert.DeserializeObject<List<CuiElement>>(json);

            public static string GetGuid() => Guid.NewGuid().ToString().Replace("-", string.Empty);

            public static bool AddUi(BasePlayer player, List<CuiElement> elements) => AddUi(player, ToJson(elements));

            public static bool AddUi(BasePlayer player, string json)
            {
                if (player?.net != null && Interface.CallHook("CanUseUI", player, json) == null)
                {
                    CommunityEntity.ServerInstance.ClientRPCEx(new SendInfo { connection = player.net.connection }, null,
                                                               "AddUI", json);
                    return true;
                }

                return false;
            }

            public static bool DestroyUi(BasePlayer player, string elem)
            {
                if (player?.net != null)
                {
                    Interface.CallHook("OnDestroyUI", player, elem);
                    CommunityEntity.ServerInstance.ClientRPCEx(new SendInfo { connection = player.net.connection }, null,
                                                               "DestroyUI", elem);
                    return true;
                }

                return false;
            }

            public static void SetColor(ICuiColor elem, Color color)
            {
                elem.Color = $"{color.r} {color.g} {color.b} {color.a}";
            }

            public static Color GetColor(ICuiColor elem) => ColorEx.Parse(elem.Color);
        }
        public interface ICuiColor
        {
            [DefaultValue("1.0 1.0 1.0 1.0")]
            [JsonProperty("color")]
            string Color { get; set; }
        }
        public class CuiButtonComponent : ICuiComponent, ICuiColor
        {
            public string Type => "UnityEngine.UI.Button";

            [JsonProperty("command")]
            public string Command { get; set; }

            [JsonProperty("close")]
            public string Close { get; set; }

            // The sprite that is used to render this image.
            [DefaultValue("Assets/Content/UI/UI.Background.Tile.psd")]
            [JsonProperty("sprite")]
            public string Sprite { get; set; } = "Assets/Content/UI/UI.Background.Tile.psd";

            // The Material set by the player.
            [DefaultValue("Assets/Icons/IconMaterial.mat")]
            [JsonProperty("material")]
            public string Material { get; set; } = "Assets/Icons/IconMaterial.mat";

            public string Color { get; set; } = "1.0 1.0 1.0 1.0";

            // How the Image is draw.
            [DefaultValue(Image.Type.Simple)]
            [JsonConverter(typeof(StringEnumConverter))]
            [JsonProperty("imagetype")]
            public Image.Type ImageType { get; set; } = Image.Type.Simple;

            [JsonProperty("fadeIn")]
            public float FadeIn { get; set; }
        }
        public class CuiCountdownComponent : ICuiComponent
        {
            public string Type => "Countdown";

            [JsonProperty("startTime"), DefaultValue(0)]
            public int StartTime = 0;

            [JsonProperty("endTime"), DefaultValue(0)]
            public int EndTime = 0;

            [JsonProperty("step"), DefaultValue(1)]
            public int Step = 1;

            [JsonProperty("command"), DefaultValue("")]
            public string Command = "";
        }
        public class CuiElement
        {
            [DefaultValue("AddUI CreatedPanel")]
            [JsonProperty("name")]
            public string Name { get; set; } = "AddUI CreatedPanel";

            [JsonProperty("parent")]
            public string Parent { get; set; } = "Hud";

            [JsonProperty("components")]
            public List<ICuiComponent> Components { get; } = new List<ICuiComponent>();

            [JsonProperty("fadeOut")]
            public float FadeOut { get; set; }
        }
        public class CuiImageComponent : ICuiComponent, ICuiColor
        {
            public string Type => "UnityEngine.UI.Image";

            [DefaultValue("Assets/Content/UI/UI.Background.Tile.psd")]
            [JsonProperty("sprite")]
            public string Sprite { get; set; } = "Assets/Content/UI/UI.Background.Tile.psd";

            [DefaultValue("Assets/Icons/IconMaterial.mat")]
            [JsonProperty("material")]
            public string Material { get; set; } = "Assets/Icons/IconMaterial.mat";

            public string Color { get; set; } = "1.0 1.0 1.0 1.0";

            [DefaultValue(Image.Type.Simple)]
            [JsonConverter(typeof(StringEnumConverter))]
            [JsonProperty("imagetype")]
            public Image.Type ImageType { get; set; } = Image.Type.Simple;

            [JsonProperty("png")]
            public string Png { get; set; }

            [JsonProperty("fadeIn")]
            public float FadeIn { get; set; }
        }
        public class CuiInputFieldComponent : ICuiComponent, ICuiColor
        {
            public string Type => "UnityEngine.UI.InputField";

            // The string value this text will display.
            [DefaultValue("Text")]
            [JsonProperty("text")]
            public string Text { get; set; } = "Text";

            // The size that the Font should render at.
            [DefaultValue(14)]
            [JsonProperty("fontSize")]
            public int FontSize { get; set; } = 14;

            // The Font used by the text.
            [DefaultValue("RobotoCondensed-Bold.ttf")]
            [JsonProperty("font")]
            public string Font { get; set; } = "RobotoCondensed-Bold.ttf";

            // The positioning of the text reliative to its RectTransform.
            [DefaultValue(TextAnchor.UpperLeft)]
            [JsonConverter(typeof(StringEnumConverter))]
            [JsonProperty("align")]
            public TextAnchor Align { get; set; } = TextAnchor.UpperLeft;

            public string Color { get; set; } = "1.0 1.0 1.0 1.0";

            [DefaultValue(100)]
            [JsonProperty("characterLimit")]
            public int CharsLimit { get; set; } = 100;

            [JsonProperty("command")]
            public string Command { get; set; }

            [DefaultValue(false)]
            [JsonProperty("password")]
            public bool IsPassword { get; set; }
        }
        public class CuiNeedsCursorComponent : ICuiComponent
        {
            public string Type => "NeedsCursor";
        }
        public class CuiOutlineComponent : ICuiComponent, ICuiColor
        {
            public string Type => "UnityEngine.UI.Outline";

            // Color for the effect.
            public string Color { get; set; } = "1.0 1.0 1.0 1.0";

            // How far is the shadow from the graphic.
            [DefaultValue("1.0 -1.0")]
            [JsonProperty("distance")]
            public string Distance { get; set; } = "1.0 -1.0";

            // Should the shadow inherit the alpha from the graphic?
            [DefaultValue(false)]
            [JsonProperty("useGraphicAlpha")]
            public bool UseGraphicAlpha { get; set; }
        }
        public class CuiRawImageComponent : ICuiComponent, ICuiColor
        {
            public string Type => "UnityEngine.UI.RawImage";

            [DefaultValue("Assets/Icons/rust.png")]
            [JsonProperty("sprite")]
            public string Sprite { get; set; } = "Assets/Icons/rust.png";

            public string Color { get; set; } = "1.0 1.0 1.0 1.0";

            [JsonProperty("material")]
            public string Material { get; set; }

            [JsonProperty("url")]
            public string Url { get; set; }

            [JsonProperty("png")]
            public string Png { get; set; }

            [JsonProperty("fadeIn")]
            public float FadeIn { get; set; }
        }
        public class CuiRectTransformComponent : ICuiComponent
        {
            public string Type => "RectTransform";

            // The normalized position in the parent RectTransform that the lower left corner is anchored to.
            [DefaultValue("0.0 0.0")]
            [JsonProperty("anchormin")]
            public string AnchorMin { get; set; } = "0.0 0.0";

            // The normalized position in the parent RectTransform that the upper right corner is anchored to.
            [DefaultValue("1.0 1.0")]
            [JsonProperty("anchormax")]
            public string AnchorMax { get; set; } = "1.0 1.0";

            // The offset of the lower left corner of the rectangle relative to the lower left anchor.
            [DefaultValue("0.0 0.0")]
            [JsonProperty("offsetmin")]
            public string OffsetMin { get; set; } = "0.0 0.0";

            // The offset of the upper right corner of the rectangle relative to the upper right anchor.
            [DefaultValue("0.0 0.0")]
            [JsonProperty("offsetmax")]
            public string OffsetMax { get; set; } = "0 0";
        }
        public class CuiTextComponent : ICuiComponent, ICuiColor
        {
            public string Type => "UnityEngine.UI.Text";

            // The string value this text will display.
            [DefaultValue("Text")]
            [JsonProperty("text")]
            public string Text { get; set; } = "Text";

            // The size that the Font should render at.
            [DefaultValue(14)]
            [JsonProperty("fontSize")]
            public int FontSize { get; set; } = 14;

            // The Font used by the text.
            [DefaultValue("RobotoCondensed-Bold.ttf")]
            [JsonProperty("font")]
            public string Font { get; set; } = "RobotoCondensed-Bold.ttf";

            // The positioning of the text reliative to its RectTransform.
            [DefaultValue(TextAnchor.UpperLeft)]
            [JsonConverter(typeof(StringEnumConverter))]
            [JsonProperty("align")]
            public TextAnchor Align { get; set; } = TextAnchor.UpperLeft;

            public string Color { get; set; } = "1.0 1.0 1.0 1.0";

            [JsonProperty("fadeIn")]
            public float FadeIn { get; set; }
        }
        [JsonConverter(typeof(ComponentConverter))]
        public interface ICuiComponent
        {
            [JsonProperty("type")]
            string Type { get; }
        }
        [PluginReference] private Plugin ImageLibrary;

        bool AddImage(string url, string imageName, ulong imageId = 0, Action callback = null)
        {
            if (ImageLibrary == null)
                return false;
            return (bool)ImageLibrary.Call("AddImage", url, imageName, imageId, callback);
        }

        string GetImage(string imageName, ulong imageId = 0, bool returnUrl = false)
        {
            return (string)ImageLibrary?.Call("GetImage", imageName, imageId, returnUrl);
        }

        bool HasImage(string imageName, ulong imageId = 0)
        {
            if (ImageLibrary == null)
                return false;
            return (bool)ImageLibrary.Call("HasImage", imageName, imageId);
        }

        IEnumerator AddImageCoroutine(string imagename, string url)
        {
            AddImage(url, imagename);

            while (HasImage(imagename) == false)
            {
                yield return CoroutineEx.waitForSeconds(.1f);
            }
        }

        IEnumerator AddImages(Dictionary<string, string> images)
        {
            foreach (var keyImage in images)
            {
                AddImage(keyImage.Key, keyImage.Value);
            }

            while (images.All(img => HasImage(img.Key)) == false)
            {
                yield return CoroutineEx.waitForSeconds(.1f);
            }
        }
    }
}

// --- End of file: CuiGenerator.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/command-block ---
// --- Original File Path: C/CommandBlock/CommandBlock.cs ---

/***********************************************************************************************************************/
/*** DO NOT edit this file! Edit the files under `oxide/config` and/or `oxide/lang`, created once plugin has loaded. ***/
/*** Please note, support cannot be provided if the plugin has been modified. Please use a fresh copy if modified.   ***/
/***********************************************************************************************************************/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Command Block", "Wulf", "0.5.3")]
    [Description("Blocks configured commands from being executed on the server")]
    public class CommandBlock : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        private class Configuration
        {
            [JsonProperty("Block commands sent by players")]
            public bool BlockPlayers = true;

            /*[JsonProperty("Block commands sent by RCON")]
            public bool BlockRcon = true;*/

            [JsonProperty("Block commands sent by server")]
            public bool BlockServer = false;

            [JsonProperty("List of commands to block", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> BlockedCommands = new List<string> { "spectate", "kill", "status" };

            [JsonProperty("Blocked commands (full or short commands)")] // TODO: From version 0.3.1; remove eventually
            private List<string> BlockedCommandsOld
            { set { BlockedCommands = value; } }

            [JsonProperty("Log blocked command attempts")]
            public bool LogAttempts = false;

            [JsonProperty("Log blocked command attempts (true/false)")] // TODO: From version 0.3.1; remove eventually
            private bool LogAttemptsOld
            { set { LogAttempts = value; } }

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["BlockCommand"] = "blockcommand",
                ["BlockCommandAdd"] = "add",
                ["BlockCommandList"] = "list",
                ["BlockCommandRemove"] = "remove",
                ["BlockCommandAddUsage"] = "Usage: {0} add <command>",
                ["BlockCommandListUsage"] = "Usage: {0} list",
                ["BlockCommandRemoveUsage"] = "Usage: {0} remove <command>",
                ["CommandAdded"] = "Command '{0}' was added to the command block list",
                ["CommandAttempted"] = "{0} ({1}) attempted to use blocked command: {2}",
                ["CommandBlocked"] = "Sorry, the '{0}' command is blocked",
                ["CommandListed"] = "Command '{0}' is already in the command block list",
                ["CommandNotListed"] = "Command '{0}' is not in the command block list",
                ["CommandRemoved"] = "Command '{0}' was removed from the command block list",
                ["CommandsBlocked"] = "Blocked commands: {0}",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command"
            }, this);
        }

        #endregion Localization

        #region Initialization

        private const string permAdmin = "commandblock.admin";
        private const string permBypass = "commandblock.bypass";

        private void Init()
        {
            AddLocalizedCommand(nameof(BlockCommand));

            permission.RegisterPermission(permAdmin, this);
            permission.RegisterPermission(permBypass, this);

            if (!config.BlockPlayers)
            {
                Unsubscribe(nameof(OnUserCommand));
            }
#if RUST
            if (!config.BlockServer && !config.BlockPlayers)
#else
            if (!config.BlockServer)
#endif
            {
                Unsubscribe(nameof(OnServerCommand));
            }
        }

        #endregion Initialization

        #region Commands

        private bool IsValidSubCommand(string subCommand, IPlayer player)
        {
            return subCommand.Equals(GetLang("BlockCommandAdd", player.Id), StringComparison.OrdinalIgnoreCase)
                || subCommand.Equals(GetLang("BlockCommandRemove", player.Id), StringComparison.OrdinalIgnoreCase)
                || subCommand.Equals(GetLang("BlockCommandList", player.Id), StringComparison.OrdinalIgnoreCase);
        }

        private void BlockCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args.Length < 1 || !IsValidSubCommand(args[0], player))
            {
                ShowHelp(player, command);
                return;
            }

            string commandArg = string.Join(" ", args.Skip(1).Select(x => x.TrimStart('/')).ToArray());

            if (args.Length > 1 && args[0].Equals(GetLang("BlockCommandAdd", player.Id), StringComparison.OrdinalIgnoreCase))
            {
                if (config.BlockedCommands.Contains(commandArg))
                {
                    Message(player, "CommandListed", commandArg);
                    return;
                }

                config.BlockedCommands.Add(commandArg);
                SaveConfig();

                Message(player, "CommandAdded", commandArg);
            }
            else if (args.Length > 1 && args[0].Equals(GetLang("BlockCommandRemove", player.Id), StringComparison.OrdinalIgnoreCase))
            {
                if (!config.BlockedCommands.Contains(commandArg))
                {
                    Message(player, "CommandNotListed", commandArg);
                    return;
                }

                config.BlockedCommands.Remove(commandArg);
                SaveConfig();

                Message(player, "CommandRemoved", commandArg);
            }
            else if (args[0].Equals(GetLang("BlockCommandList", player.Id), StringComparison.OrdinalIgnoreCase))
            {
                Message(player, "CommandsBlocked", string.Join(", ", config.BlockedCommands.ToArray()));
            }
            else
            {
                ShowHelp(player, command, args[0]);
            }
        }

        #endregion Commands

        #region Command Blocking

        private bool IsCommandBlocked(string command, string[] args)
        {
            if (config.BlockedCommands.Contains(command, StringComparer.OrdinalIgnoreCase)
                || config.BlockedCommands.Contains(string.Concat(command, args), StringComparer.OrdinalIgnoreCase))
            {
                return true;
            }

            string splitCommand = command.Substring(command.IndexOf(".", StringComparison.Ordinal) + 1);
            if (config.BlockedCommands.Contains(splitCommand, StringComparer.OrdinalIgnoreCase)
                || config.BlockedCommands.Contains(string.Concat(splitCommand, args), StringComparer.OrdinalIgnoreCase))
            {
                return true;
            }

            return false;
        }

        // TODO: Add support for OnRconCommand once IRemoteClient is added
        /*private object OnRconCommand(IRemoteClient client, string command, string[] args)
        {
            return null;
        }*/

#if RUST

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            IPlayer player = (arg.Connection?.player as BasePlayer)?.IPlayer;
            if (IsCommandBlocked(arg.cmd.FullName, Oxide.Game.Rust.Libraries.Covalence.RustCommandSystem.ExtractArgs(arg)))
            {
                if (config.BlockPlayers && player != null && !player.HasPermission(permBypass))
                {
                    if (config.LogAttempts)
                    {
                        LogWarning(GetLang("CommandAttempted", null, player.Name, player.Id, arg.cmd.FullName));
                    }

                    Message(player, "CommandBlocked", arg.cmd.FullName);
                    return true;
                }
                else if (config.BlockServer)
                {
                    if (config.LogAttempts)
                    {
                        LogWarning(GetLang("CommandAttempted", null, arg.cmd.FullName));
                    }

                    Log(GetLang("CommandBlocked", null, arg.cmd.FullName));
                    return true;
                }
            }

            return null;
        }

#else
        private object OnServerCommand(string command, string[] args)
        {
            if (IsCommandBlocked(command, args))
            {
                if (config.LogAttempts)
                {
                    LogWarning(GetLang("CommandAttempted", null, command));
                }

                Log(GetLang("CommandBlocked", null, command));
                return true;
            }

            return null;
        }
#endif

        private object OnUserCommand(IPlayer player, string command, string[] args)
        {
            if (IsCommandBlocked(command, args) && !player.HasPermission(permBypass))
            {
                if (config.LogAttempts)
                {
                    LogWarning(GetLang("CommandAttempted", null, player.Name, player.Id, command));
                }

                Message(player, "CommandBlocked", command);
                return true;
            }

            return null;
        }

        #endregion Command Blocking

        #region Helpers

        private void ShowHelp(IPlayer player, string command, string subCommand = null)
        {
            if (player.LastCommand.Equals(CommandType.Chat))
            {
                command = "/" + command; // TODO: Switch to prefix option when available
            }

            if (string.IsNullOrEmpty(subCommand))
            {
                MessageBlock(player, new Dictionary<string, string[]>
                {
                    ["BlockCommandAddUsage"] = new[] { command },
                    ["BlockCommandRemoveUsage"] = new[] { command },
                    ["BlockCommandListUsage"] = new[] { command },
                });
                return;
            }

            if (subCommand.Equals(GetLang("BlockCommandAdd", player.Id), StringComparison.OrdinalIgnoreCase))
            {
                Message(player, "BlockCommandAddUsage", command);
            }
            else if (subCommand.Equals(GetLang("BlockCommandRemove", player.Id), StringComparison.OrdinalIgnoreCase))
            {
                Message(player, "BlockCommandRemoveUsage", command);
            }
            else if (subCommand.Equals(GetLang("BlockCommandList", player.Id), StringComparison.OrdinalIgnoreCase))
            {
                Message(player, "BlockCommandListUsage", command);
            }
        }

        private void SendHelpText(object obj)
        {
            IPlayer player = players.FindPlayerByObj(obj);
            if (player != null && player.HasPermission(permAdmin))
            {
                ShowHelp(player, GetLang(nameof(BlockCommand), player.Id));
            }
        }

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages)
                {
                    if (message.Key.Equals(command))
                    {
                        if (!string.IsNullOrEmpty(message.Value))
                        {
                            AddCovalenceCommand(message.Value, command);
                        }
                    }
                }
            }
        }

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void Message(IPlayer player, string textOrLang, params object[] args)
        {
            if (player.IsConnected)
            {
                string message = GetLang(textOrLang, player.Id, args);
                player.Reply(message != textOrLang ? message : textOrLang);
            }
        }

        private void MessageBlock(IPlayer player, Dictionary<string, string[]> textsOrLang)
        {
            if (player.IsConnected)
            {
                StringBuilder combinedText = new StringBuilder();
                foreach (KeyValuePair<string, string[]> textOrLang in textsOrLang)
                {
                    string message = GetLang(textOrLang.Key, player.Id, textOrLang.Value);
                    combinedText.AppendLine(message != textOrLang.Key ? message : string.Format(textOrLang.Key, textOrLang.Value));
                }
                if (combinedText.Length > 0)
                {
                    player.Reply(combinedText.ToString());
                }
            }
        }

        #endregion Helpers
    }
}


// --- End of file: CommandBlock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/clan-ban ---
// --- Original File Path: C/ClanBan/ClanBan.cs ---

using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("ClanBan", "Slut", "1.3.0")]
    internal class ClanBan : CovalencePlugin
    {
        [PluginReference] private Plugin Clans, DiscordMessages, EnhancedBanSystem, BetterChatMute;

        private bool AnnounceToServer = true;
        private int type;

        private void Init()
        {
            LoadConfiguration();
            RegisterPermissions();
        }

        private void LoadConfiguration()
        {
            CheckCfg("Clan Ban - Ban Type (Disabled = 0, EBS = 1, Vanilla = 2, DiscordMessages = 3)", ref type);
            CheckCfg("Clan Ban - Announce To Server", ref AnnounceToServer);

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Generating new config.");
        }

        private void RegisterPermissions()
        {
            permission.RegisterPermission("clanban.ban", this);
        }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
            {
                var = (T)Config[Key];
            }
            else
            {
                Config[Key] = var;
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["SyntaxError"] = "Syntax error.",
                ["Disabled"] = "This feature is disabled, please change the config.",
                ["PlayerBanned"] = "{0} was banned for {1}",
                ["PlayerUnbanned"] = "{0} was unbanned.",
                ["AlreadyBanned"] = "{0} is already banned.",
                ["AlreadyUnbanned"] = "{0} is already unbanned.",
                ["BanMessage"] = "The clan ({0}) was banned for {1}.",
                ["UnbanMessage"] = "The clan ({0}) was unbanned.",
                ["MuteMessage"] = "The clan ({0}) was muted permanently muted.",
                ["TimeMuteMessage"] = "The clan ({0}) was muted for {1}",
                ["UnmuteMessage"] = "The clan ({0}) was unmuted.",
                ["KickedMessage"] = "The clan ({0}) was kicked.",
                ["NoClan"] = "The clan ({0}) doesn't exist.",
                ["DefaultBanReason"] = "Your clan was banned from the server.",
                ["DefaultKickReason"] = "Your clan was kicked from the server.",
                ["NoValidFunction"] = "You must specify a function, /cb (function) (clan) <reason/time>"
            }, this, "en");
        }
        [Command("clanban", "cb"), Permission("clanban.ban")]
        private void ClanBanCommand(IPlayer player, string command, string[] args)
        {
            if (type == 0)
            {
                SendMessage(player, GetLang("Disabled", player.Id));
                return;
            }
            if (args.Length < 2)
            {
                SendMessage(player, GetLang("SyntaxError", player.Id));
                return;
            }
            var clan = GetClan(args[1], player);
            if (clan != null)
            {
                switch (args[0])
                {
                    case "ban":
                        string reason = args.Length == 2 ? GetLang("DefaultBanReason", player.Id) : string.Join(" ", args.Skip(2).ToArray());
                        ProcessBan(player, clan, reason);
                        break;
                    case "unban":
                        ProcessUnban(player, clan);
                        break;
                    case "mute":
                        ProcessMute(player, clan, args.Length > 2 ? args[2] : null);
                        break;
                    case "unmute":
                        ProcessUnmute(player, clan);
                        break;
                    case "kick":
                        string reason1 = args.Length == 2 ? GetLang("DefaultKickReason", player.Id) : string.Join(" ", args.Skip(2).ToArray());
                        ProcessKick(player, clan, reason1);
                        break;
                    default:
                        player.Reply(GetLang("NoValidFunction", player.Id));
                        break;
                }
            }
        }
        private JObject GetClan(string tag, IPlayer player)
        {
            JObject clan = (JObject)Clans.Call("GetClan", tag);
            if (clan == null)
            {
                SendMessage(player, GetLang("NoClan", player.Id, tag));
                return null;
            }
            return clan;
        }
        private void ProcessBan(IPlayer player, JObject clan, string reason)
        {
            string reason1 = "CLAN BAN (" + clan["tag"] + ") : " + reason;
            foreach (var member in clan["members"])
            {
                var target = covalence.Players.FindPlayerById(Convert.ToString(member));
                if (type == 1)
                {
                    EnhancedBanSystem.Call("BanPlayer", player.Name, target, reason1, 0.0);
                }

                if (type == 2)
                {
                    if (target.IsBanned)
                    {
                        SendMessage(player, GetLang("AlreadyBanned", player.Id, target.Name));
                        return;
                    }
                    target.Ban(reason1);
                    server.Broadcast(GetLang("PlayerBanned", null, target.Name, reason));
                    if (target.IsConnected)
                    {
                        target.Kick(reason);
                    }
                }
                if (type == 3)
                {
                    DiscordMessages.Call("ExecuteBan", target, player, reason1);
                }
            }
            if (AnnounceToServer)
            {
                server.Broadcast(GetLang("BanMessage", null, clan["tag"], reason));
            }
        }
        private void ProcessUnban(IPlayer player, JObject clan)
        {
            foreach (var member in clan["members"])
            {
                var target = covalence.Players.FindPlayerById(Convert.ToString(member));
                if (type == 1)
                {
                    EnhancedBanSystem.Call("TryUnBan", player.Name, new string[1] { target.Id });
                }
                else
                {
                    if (!target.IsBanned)
                    {
                        SendMessage(player, GetLang("AlreadyUnbanned", player.Id, target.Name));
                        return;
                    }
                    target.Unban();
                    server.Broadcast(GetLang("PlayerUnbanned", null, target.Name));
                }
            }
            if (AnnounceToServer)
            {
                server.Broadcast(GetLang("UnbanMessage", null, clan["tag"]));
            }
        }

        string FormatTime(TimeSpan time) => $"{(time.Days == 0 ? string.Empty : $"{time.Days} day(s)")}{(time.Days != 0 && time.Hours != 0 ? $", " : string.Empty)}{(time.Hours == 0 ? string.Empty : $"{time.Hours} hour(s)")}{(time.Hours != 0 && time.Minutes != 0 ? $", " : string.Empty)}{(time.Minutes == 0 ? string.Empty : $"{time.Minutes} minute(s)")}{(time.Minutes != 0 && time.Seconds != 0 ? $", " : string.Empty)}{(time.Seconds == 0 ? string.Empty : $"{time.Seconds} second(s)")}";

        private bool TryParseTimeSpan(string source, out TimeSpan timeSpan)
        {
            int seconds = 0, minutes = 0, hours = 0, days = 0;

            Match s = new Regex(@"(\d+?)s", RegexOptions.IgnoreCase).Match(source);
            Match m = new Regex(@"(\d+?)m", RegexOptions.IgnoreCase).Match(source);
            Match h = new Regex(@"(\d+?)h", RegexOptions.IgnoreCase).Match(source);
            Match d = new Regex(@"(\d+?)d", RegexOptions.IgnoreCase).Match(source);

            if (s.Success)
            {
                seconds = Convert.ToInt32(s.Groups[1].ToString());
            }

            if (m.Success)
            {
                minutes = Convert.ToInt32(m.Groups[1].ToString());
            }

            if (h.Success)
            {
                hours = Convert.ToInt32(h.Groups[1].ToString());
            }

            if (d.Success)
            {
                days = Convert.ToInt32(d.Groups[1].ToString());
            }

            source = source.Replace(seconds + "s", string.Empty);
            source = source.Replace(minutes + "m", string.Empty);
            source = source.Replace(hours + "h", string.Empty);
            source = source.Replace(days + "d", string.Empty);

            if (!string.IsNullOrEmpty(source) || (!s.Success && !m.Success && !h.Success && !d.Success))
            {
                timeSpan = default(TimeSpan);
                return false;
            }

            timeSpan = new TimeSpan(days, hours, minutes, seconds);

            return true;
        }
        private void ProcessMute(IPlayer player, JObject clan, string time)
        {
            if (BetterChatMute != null)
            {
                TimeSpan _timespan;
                if (!TryParseTimeSpan(time, out _timespan))
                {
                    foreach (var member in clan["members"])
                    {
                        IPlayer target = covalence.Players.FindPlayerById(Convert.ToString(member));
                        if (target != null)
                        {
                            BetterChatMute?.Call("API_Mute", target, player, true, false);
                        }
                    }
                    if (AnnounceToServer)
                    {
                        server.Broadcast(GetLang("MuteMessage", null, clan["tag"]));
                    }
                }
                else if (_timespan != null)
                {
                    foreach (var member in clan["members"])
                    {
                        IPlayer target = covalence.Players.FindPlayerById(Convert.ToString(member));
                        if (target != null)
                        {
                            BetterChatMute?.Call("API_TimeMute", target, player, _timespan, true, false);
                        }
                    }
                    if (AnnounceToServer)
                    {
                        server.Broadcast(GetLang("TimeMuteMessage", null, clan["tag"], FormatTime(_timespan)));
                    }
                }
            }
            else
            {
                player.Reply("BetterChatMute is not loaded!");
            }
        }
        private void ProcessUnmute(IPlayer player, JObject clan)
        {
            if (BetterChatMute != null)
            {
                foreach (var member in clan["members"])
                {
                    IPlayer target = covalence.Players.FindPlayerById(Convert.ToString(member));
                    if (target != null)
                    {
                        BetterChatMute.Call("API_Unmute", target, player, true, false);
                    }
                }
                if (AnnounceToServer)
                {
                    server.Broadcast(GetLang("UnmuteMessage", null, clan["tag"]));
                }
            }
            else
            {
                player.Reply("BetterChatMute is not loaded!");
            }
        }
        private void ProcessKick(IPlayer player, JObject clan, string reason)
        {
            foreach (var member in clan["members"])
            {
                IPlayer target = covalence.Players.FindPlayerById(Convert.ToString(member));
                target.Kick(reason);
            }
            if (AnnounceToServer)
            {
                server.Broadcast(GetLang("KickedMessage", null, clan["tag"]));
            }
        }

        private void SendMessage(IPlayer player, string message)
        {
            player.Reply(message);
        }

        private string GetLang(string key, string id = null, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this, id), args);
        }
    }
}

// --- End of file: ClanBan.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/cupboard-home ---
// --- Original File Path: C/CupboardPlus/CupboardPlus.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Cupboard Plus", "Mevent", "1.0.0")]
    [Description("Destroys the home and runs commands after cupboard destroying")]
    public class CupboardPlus : RustPlugin
    {
        #region Config

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Commands List", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Commands = new List<string>
            {
                "cmd 1 {ownerId}",
                "cmd 2"
            };

            [JsonProperty(PropertyName = "Destroy the home?")]
            public bool HomeDestroy = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();

        #endregion
        
        #region Hooks
        
        private void OnEntityDeath(BuildingPrivlidge cupboard, HitInfo info)
        {
            if (cupboard == null) return;
            
            if (_config.HomeDestroy) 
                ServerMgr.Instance.StartCoroutine(DestroyEntities(cupboard.children));
            
            _config.Commands.ForEach(command =>
            {
                command = command.Replace("{ownerId}", cupboard.OwnerID.ToString());
                if (string.IsNullOrEmpty(command)) return;
                
                Server.Command(command);
            });
        }

        #endregion

        #region Utils

        private IEnumerator DestroyEntities(List<BaseEntity> entities)
        {
            var i = 0;
            foreach (var entity in entities)
            {
                if (entity != null && !entity.IsDestroyed)
                    entity.Kill();

                if (i++ == 10)
                {
                    i = 0;
                    yield return CoroutineEx.waitForFixedUpdate;
                }
            }
        }

        #endregion
    }
}

// --- End of file: CupboardPlus.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/chinook-drop-randomizer ---
// --- Original File Path: C/ChinookDropRandomizer/ChinookDropRandomizer.cs ---

using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Chinook Drop Randomizer", "shinnova/Arainrr", "1.5.1")]
    [Description("Make the chinook drop location more random")]
    public class ChinookDropRandomizer : RustPlugin
    {
        private bool initialized = false;
        private readonly static int GROUND_LAYER = LayerMask.GetMask("Terrain", "World", "Construction", "Deployed");
        private Dictionary<string, List<MonumentInfo>> monumentList = new Dictionary<string, List<MonumentInfo>>();

        private readonly Dictionary<string, float> defaultMonumentSizes = new Dictionary<string, float>()
        {
            ["Harbor"] = 125f,
            ["Giant Excavator Pit"] = 180f,
            ["Launch Site"] = 265f,
            ["Train Yard"] = 130f,
            ["Power Plant"] = 150f,
            ["Junkyard"] = 150f,
            ["Airfield"] = 200f,
            ["Water Treatment Plant"] = 190f,
            ["Bandit Camp"] = 80f,
            ["Sewer Branch"] = 80f,
            ["Oxum's Gas Station"] = 40f,
            ["Satellite Dish"] = 95f,
            ["Abandoned Supermarket"] = 30f,
            ["The Dome"] = 65f,
            ["Abandoned Cabins"] = 50f,
            ["Large Oil Rig"] = 100f,
            ["Oil Rig"] = 50f,
            ["Lighthouse"] = 40f,
            ["Outpost"] = 115f,
            ["HQM Quarry"] = 30f,
            ["Stone Quarry"] = 30f,
            ["Sulfur Quarry"] = 30f,
            ["Mining Outpost"] = 40f,
            ["Military Tunnel"] = 120f,
        };

        private void OnServerInitialized()
        {
            monumentList = TerrainMeta.Path?.Monuments?.Where(x => x.shouldDisplayOnMap)?.GroupBy(x => x.displayPhrase.english.Replace("\n", ""))?.ToDictionary(x => x.Key, y => y.ToList());
            UpdateConfig();
            initialized = true;
            foreach (var chinook in BaseNetworkable.serverEntities.OfType<CH47HelicopterAIController>())
                OnEntitySpawned(chinook);
        }

        private void UpdateConfig()
        {
            foreach (var monumentName in monumentList.Keys)
            {
                float monumentSize = 0f;
                defaultMonumentSizes.TryGetValue(monumentName, out monumentSize);
                if (!configData.monumentsSettings.ContainsKey(monumentName))
                    configData.monumentsSettings.Add(monumentName, new ConfigData.Monument { enabled = true, monumentSize = monumentSize });
            }
            SaveConfig();
        }

        private void OnEntitySpawned(CH47HelicopterAIController chinook)
        {
            if (chinook == null || !initialized) return;
            if (chinook.landingTarget != Vector3.zero) return;
            timer.Once(configData.dropDelay, () => TryDropCrate(chinook));
        }

        private object CanHelicopterDropCrate(CH47HelicopterAIController chinook)
        {
            if (configData.blockDefaultDrop) return false;
            return null;
        }

        private Vector3 GetGroundPosition(Vector3 position)
        {
            RaycastHit hitInfo;
            if (Physics.Raycast(position, Vector3.down, out hitInfo, 300f, GROUND_LAYER)) position.y = hitInfo.point.y;
            else position.y = TerrainMeta.HeightMap.GetHeight(position);
            return position;
        }

        private bool AboveWater(Vector3 location)
        {
            if (GetGroundPosition(location).y <= 0) return true;
            return false;
        }

        private bool AboveMonument(Vector3 location)
        {
            foreach (var entry in monumentList)
            {
                var monumentName = entry.Key;
                if (configData.monumentsSettings.ContainsKey(monumentName) && configData.monumentsSettings[monumentName].enabled)
                    foreach (var monumentInfo in entry.Value)
                        if (Vector3Ex.Distance2D(monumentInfo.transform.position, location) < configData.monumentsSettings[monumentName].monumentSize)
                            return true;
            }
            return false;
        }

        private void TryDropCrate(CH47HelicopterAIController chinook)
        {
            timer.Once(Random.Range(configData.minTime, configData.maxTime), () =>
            {
                if (chinook == null || chinook.IsDestroyed) return;
                if (chinook.numCrates > 0)
                {
                    if (configData.checkWater ? !AboveWater(chinook.transform.position) : true)
                    {
                        if (configData.checkMonument ? !AboveMonument(chinook.transform.position) : true)
                        {
                            if (BasePlayer.activePlayerList.Count >= configData.minPlayers)
                            {
                                chinook.DropCrate();
                                if (chinook.numCrates == 0) return;
                            }
                        }
                    }
                    TryDropCrate(chinook);
                }
            });
        }

        #region ConfigurationFile

        private ConfigData configData;

        public class ConfigData
        {
            [JsonProperty(PropertyName = "Prevent the game from handling chinook drops")]
            public bool blockDefaultDrop = false;

            [JsonProperty(PropertyName = "Time before chinook starts trying to drop (seconds)")]
            public float dropDelay = 200f;

            [JsonProperty(PropertyName = "Minimum time until drop (seconds)")]
            public float minTime = 40f;

            [JsonProperty(PropertyName = "Maximum time until drop (seconds)")]
            public float maxTime = 60f;

            [JsonProperty(PropertyName = "Minimum number of online players to drop")]
            public int minPlayers = 0;

            [JsonProperty(PropertyName = "Don't drop above water")]
            public bool checkWater = true;

            [JsonProperty(PropertyName = "Don't drop above monuments")]
            public bool checkMonument = false;

            [JsonProperty(PropertyName = "What monuments to check (only works if monument checking is enabled)")]
            public Dictionary<string, Monument> monumentsSettings = new Dictionary<string, Monument>();

            public class Monument
            {
                [JsonProperty(PropertyName = "Enabled")]
                public bool enabled;

                [JsonProperty(PropertyName = "Monument size")]
                public float monumentSize;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                    LoadDefaultConfig();
            }
            catch
            {
                PrintError("Config has corrupted or incorrectly formatted");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        #endregion ConfigurationFile
    }
}

// --- End of file: ChinookDropRandomizer.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/chat-to-console ---
// --- Original File Path: C/ChatToConsole/ChatToConsole.cs ---

using System;
using System.Collections.Generic;
using ConVar;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Chat To Console", "Purples", "1.1.1")] // Works with: BetterChat
    [Description("Copies the in-game chat to the console.")]

    internal class ChatToConsole : RustPlugin
    {
        #region Commands

        private void CmdToggle(IPlayer player, string command, string[] args)
        {
            if (player.IsServer)
            {
                player.Message(GetMsg("OnlyPlayer", player.Id));
                return;
            }

            if (!CanUse(player.Id))
            {
                player.Message(GetMsg("NoPermission", player.Id));
                return;
            }

            if (_listedUsers.Contains(player.Id))
            {
                _listedUsers.Remove(player.Id);
                SaveData();
                player.Message(GetMsg(_enabledByDefault ? "On" : "Off", player.Id));
                return;
            }

            player.Message(GetMsg(_enabledByDefault ? "Off" : "On", player.Id));
            _listedUsers.Add(player.Id);
            SaveData();
        }

        #endregion

        #region Chat Format

        private class ChatFormat
        {
            private readonly Chat.ChatChannel? _channel;
            private readonly string _formattedMessage;
            private readonly string _formattedPrefixes;
            private readonly string _formattedUsername;
            private readonly BasePlayer _sender;

            private ChatFormat(BasePlayer sender, string formattedUsername, string formattedPrefixes,
                string formattedMessage, Chat.ChatChannel? channel)
            {
                _sender = sender;
                _formattedUsername = formattedUsername;
                _formattedPrefixes = formattedPrefixes;
                _formattedMessage = formattedMessage;
                _channel = channel;
            }

            public string ChatLang => _channel.HasValue ? _channel.Value.ToString("F") : "Chat";

            private static string GetFormattedText(string text, string color = "#fff")
            {
                return Formatter.ToUnity($"<color={color}>{text}</color>");
            }

            public static ChatFormat FromRust(BasePlayer player, string message, Chat.ChatChannel channel)
            {
                var color = "#5af";
                if (player.IsAdmin) color = "#af5";
                if (player.IsDeveloper || DeveloperList.Contains(player.UserIDString)) color = "#fa5";
                var formattedName = GetFormattedText(player.displayName.EscapeRichText(), color);
                var formattedMessage = GetFormattedText(message ?? "");

                return new ChatFormat(player, formattedName, "", formattedMessage, channel);
            }

            public static ChatFormat FromBetterChat(Dictionary<string, object> data)
            {
                var player = (IPlayer) data["Player"];
                var message = data["Message"] as string;
                var messageColor = ((Dictionary<string, object>) data["MessageSettings"])["Color"] as string;
                var usernameColor = ((Dictionary<string, object>) data["UsernameSettings"])["Color"] as string;
                var prefixes = string.Join(" ", (List<string>) data["Titles"]);
                var channel = (Chat.ChatChannel) data["ChatChannel"];

                var formattedName = GetFormattedText(player.Name.EscapeRichText(), usernameColor);
                var formattedPrefix = GetFormattedText(prefixes);
                var formattedMessage = GetFormattedText(message, messageColor);
                return new ChatFormat(player.Object as BasePlayer, formattedName, formattedPrefix, formattedMessage,
                    channel);
            }

            public static ChatFormat FromChatPlus(Dictionary<string, object> data)
            {
                var player = (IPlayer) data["Player"];
                var username = GetFormattedText(player.Name.EscapeRichText());
                var message = data["Message"] as string;
                var prefixes = data["Prefixes"] as string;
                return new ChatFormat(player.Object as BasePlayer, username, Formatter.ToUnity(prefixes),
                    Formatter.ToUnity(message), null);
            }

            public bool ShouldSee(ulong playerid = 3182592)
            {
                if (_channel != Chat.ChatChannel.Team)
                    return true;

                var team = _sender.Team;
                if (team == null || team.members.Count == 0)
                    return true;

                return team.members.Contains(playerid);
            }

            public string GetFormatted()
            {
                return _format.Replace("{Time}", DateTime.Now.ToShortTimeString())
                    .Replace("{Titles}", _formattedPrefixes)
                    .Replace("{Name}", _formattedUsername)
                    .Replace("{SteamID}", _sender.UserIDString)
                    .Replace("{Message}", _formattedMessage);
            }
        }

        #endregion

        #region Vars

        private string _permission = "ChatToConsole.See";
        private string _permissionAdmin = "ChatToConsole.Admin";
        private static string _command = "/ctc";
        private static string _format = "{Time}: [{ChatLang}] {Titles}{Name}({SteamID}): {Message}";
        private static string _pmFormat = "{Time}: [{PM}] {From}->{To}: {Message}";
        private static bool _enabledByDefault = true;
        [PluginReference] private Plugin ChatPlus, BetterChat;

        #endregion

        #region Data

        private List<string> _listedUsers;

        private void LoadData()
        {
            try
            {
                _listedUsers = Interface.Oxide.DataFileSystem.ReadObject<List<string>>(Title);
            }
            catch (Exception e)
            {
                PrintError($"Failed to load active admins data file (is the file corrupt?) ({e.Message})");
                _listedUsers = new List<string>();
            }
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Title, _listedUsers);
        }

        #endregion

        #region Config and data initalization

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating new config file...");
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            var changed = GetConfig("Permission to use command and get the chat to console", ref _permission) |
                          GetConfig("Permission to see all team's chat and all PM", ref _permissionAdmin) |
                          GetConfig("Chat command to toggle printing chat to console", ref _command) |
                          GetConfig("Messages format", ref _format) |
                          GetConfig("Private messages format", ref _pmFormat) |
                          GetConfig("Chat to console enabled by default", ref _enabledByDefault);
            if (changed)
            {
                PrintWarning("Config file was updated");
                SaveConfig();
            }

            permission.RegisterPermission(_permission, this);
            permission.RegisterPermission(_permissionAdmin, this);
            LoadData();
        }

        private void Init()
        {
            AddCovalenceCommand(_command.Replace("/", string.Empty), "CmdToggle", _permission);
        }

        #endregion

        #region localization

        private string GetMsg(string key)
        {
            return lang.GetMessage(key, this);
        }

        private string GetMsg(string key, string playerId)
        {
            return lang.GetMessage(key, this, playerId);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["OnlyPlayer"] = "This command can only be executed from the game client!",
                ["Off"] = "Chat would no longer be displayed in your console.",
                ["On"] = "You would receive all chat messages to your console.",
                ["NoPermission"] = "You don't have the permission to use this command.",
                ["Chat"] = "Chat",
                ["Global"] = "Global",
                ["Team"] = "Team",
                ["Server"] = "Server",
                ["WrongDict"] =
                    "{0} dictionary has wrong format. Please, contact the developer - https://vk.com/arsgo",
                ["PM"] = "PM"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["OnlyPlayer"] = "      !",
                ["Off"] = "       .",
                ["On"] = "         .",
                ["NoPermission"] = "    .",
                ["Chat"] = "",
                ["Global"] = "",
                ["Team"] = "",
                ["Server"] = "",
                ["WrongDict"] =
                    " {0}   . ,    - https://vk.com/arsgo",
                ["PM"] = ""
            }, this, "ru");
        }

        #endregion

        #region Hooks

        private void OnPlayerChat(BasePlayer sender, string message, Chat.ChatChannel channel)
        {
            if (BetterChat || ChatPlus)
                return;
            if (sender == null)
                return;
            SendChatToConsole(ChatFormat.FromRust(sender, message, channel));
        }

        private void OnBetterChat(Dictionary<string, object> data)
        {
            try
            {
                SendChatToConsole(ChatFormat.FromBetterChat(data));
            }
            catch (Exception)
            {
                PrintError(GetMsg("WrongDict"), "BetterChat");
            }
        }

        private void OnChatPlusMessage(Dictionary<string, object> data)
        {
            try
            {
                SendChatToConsole(ChatFormat.FromChatPlus(data));
            }
            catch (Exception)
            {
                PrintError(GetMsg("WrongDict"), "ChatPlus");
            }
        }

        [HookMethod("OnPMProcessed")]
        private void OnPrivateMessage(IPlayer sender, IPlayer receiver, string message)
        {
            var formatted = _pmFormat.Replace("{Time}", DateTime.Now.ToShortTimeString())
                .Replace("{From}", sender.Name)
                .Replace("{To}", receiver.Name)
                .Replace("{Message}", message);
            SendPmToConsole(formatted, sender.Id, receiver.Id);
        }

        #endregion

        #region Helpers

        private void SendChatToConsole(ChatFormat message)
        {
            var formatted = message.GetFormatted();
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (!CheckEnabled(player.UserIDString))
                    continue;
                if (!CanAdmin(player.UserIDString) && !message.ShouldSee(player.userID))
                    continue;
                var msg = formatted.Replace("{ChatLang}", GetMsg(message.ChatLang, player.UserIDString));
                player.ConsoleMessage(msg);
            }
        }

        private void SendPmToConsole(string message, params string[] participants)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (!CheckEnabled(player.UserIDString))
                    continue;
                if (!CanAdmin(player.UserIDString) && !participants.Contains(player.UserIDString))
                    continue;
                var msg = message.Replace("{PM}", GetMsg("PM", player.UserIDString));
                player.ConsoleMessage(msg);
            }
        }

        private bool CheckEnabled(string id)
        {
            if (!CanUse(id))
                return false;

            var contains = _listedUsers.Contains(id);
            return _enabledByDefault ? !contains : contains;
        }

        private bool CanUse(string id)
        {
            return permission.UserHasPermission(id, _permission) || CanAdmin(id);
        }

        private bool CanAdmin(string id)
        {
            return permission.UserHasPermission(id, _permissionAdmin);
        }

        private bool GetConfig<T>(string key, ref T var)
        {
            if (Config[key] != null)
            {
                var = (T) Convert.ChangeType(Config[key], typeof(T));
                return false;
            }

            Config[key] = var;
            return true;
        }

        #endregion
    }
}


// --- End of file: ChatToConsole.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/checkpoints ---
// --- Original File Path: C/Checkpoints/Checkpoints.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Checkpoints", "Ryan", "1.0.1")]
    [Description("Restore points for players to teleport to when the server restarts")]
    class Checkpoints : RustPlugin
    {
        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private static StoredData sData;

        private static Checkpoints Instance;

        private const string Perm = "checkpoints.allow";

        #region Data

        private class StoredData
        {
            public Dictionary<ulong, PlayerData> Players = new Dictionary<ulong, PlayerData>();
        }

        private class PlayerData
        {
            public float PosX { get; set; }
            public float PosY { get; set; }
            public float PosZ { get; set; }
            public uint ID { get; set; }

            public PlayerData()
            {
            }

            public PlayerData(SleepingBag bag)
            {
                PosX = bag.transform.position.x;
                PosY = bag.transform.position.y;
                PosZ = bag.transform.position.z;
                ID = bag.net.ID;
            }
        }

        private class Data
        {
            public static void Add(BasePlayer player, PlayerData data)
            {
                if (!Exists(player.userID))
                {
                    sData.Players.Add(player.userID, data);
                    Save();
                }
            }

            public static void Remove(ulong id)
            {
                if (Exists(id))
                {
                    sData.Players.Remove(id);
                    Save();
                }
            }

            public static bool Exists(ulong id)
            {
                return sData.Players.ContainsKey(id);
            }

            private static void Save() => Interface.Oxide.DataFileSystem.WriteObject(Instance.Name, sData);
        }

        #endregion

        #region Lang

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Checkpoint_NotExist"] = "You have no checkpoint set, to set a checkpoint use <color=#55aaff>/checkpoint set</color> at your desired position.",
                ["Checkpoint_Exists"] = "Your checkpoint is <color=#55aaff>{0}</color>m away",
                ["Checkpoint_AlreadyExists"] = "You already have a checkpoint set, it's <color=#55aaff>{0}</color>m away",
                ["Checkpoint_Set"] = "You've set your checkpoint at <color=#55aaff>X</color>: {0}, <color=#55aaff>Y</color>: {1}, <color=#55aaff>Z</color>: {2}",
                ["Checkpoint_NotFound"] = "You don't seem to have a checkpoint to remove",
                ["Checkpoint_Removed"] = "You've removed your checkpoint at <color=#55aaff>X</color>: {0}, <color=#55aaff>Y</color>: {1}, <color=#55aaff>Z</color>: {2} (<color=#55aaff>{3}</color>m away)",
                ["Checkpoint_Killed"] = "Your checkpoint <color=#55aaff>{0}</color>m away from you has been reset because your bag has been removed!",

                ["NoPermission"] = "You don't have permission to use that command",

                ["SleepingBag_NotOwner"] = "You do not own the sleeping bag you're looking at",

                ["Raycast_NotFound"] = "Didn't find a valid sleeping bag"
            }, this);
        }

        #endregion

        #region Methods

        private class Checks
        {
            public static bool HasPermission(string id)
            {
                return Instance.permission.UserHasPermission(id, Perm);
            }

            public static bool CanUseSleepingBag(BasePlayer player, SleepingBag bag)
            {
                if (player.userID == bag.deployerUserID)
                    return true;

                return false;
            }
        }

        private SleepingBag FindBag(BasePlayer player)
        {
            RaycastHit hit;
            if (!Physics.Raycast(player.eyes.HeadRay(), out hit, Mathf.Infinity))
            {
                PrintToChat(player, Lang("Raycast_NotFound", player.UserIDString));
                return null;
            }
            if (hit.GetEntity() is SleepingBag)
                return hit.GetEntity() as SleepingBag;

            PrintToChat(player, Lang("Raycast_NotFound", player.UserIDString));
            return null;
        }

        #endregion

        #region Hooks

        private void Init()
        {
            Instance = this;
            sData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            permission.RegisterPermission(Perm, this);
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (reason.ToLower().Contains("restarting") && Data.Exists(player.userID))
            {
                var data = sData.Players[player.userID];
                player.Teleport(new Vector3(data.PosX, data.PosY, data.PosZ));
            }
        }

        private void OnEntityKill(BaseNetworkable networkable)
        {
            var bag = networkable as SleepingBag;
            if (bag != null && Data.Exists(bag.OwnerID) && sData.Players[bag.OwnerID].ID == bag.net.ID)
            {
                Data.Remove(bag.OwnerID);
                var player = BasePlayer.FindByID(bag.OwnerID);
                if (player != null && player.IsConnected)
                {
                    var data = sData.Players[player.userID];
                    PrintToChat(player, Lang("Checkpoint_Killed", player.UserIDString,
                            Vector3.Distance(player.transform.position, new Vector3(data.PosX, data.PosY, data.PosZ))));
                }
            }
        }

        #endregion

        #region Commands

        [ChatCommand("checkpoint")]
        private void checkpointCmd(BasePlayer player, string command, string[] args)
        {
            if (!Checks.HasPermission(player.UserIDString))
            {
                PrintToChat(player, Lang("NoPermission", player.UserIDString));
                return;
            }
            if (args.Length == 0)
            {
                if (Data.Exists(player.userID))
                {
                    var data = sData.Players[player.userID];
                    PrintToChat(player, Lang("Checkpoint_Exists", player.UserIDString,
                        Math.Round(Vector3.Distance(player.transform.position, new Vector3(data.PosX, data.PosY, data.PosZ)))));
                    return;
                }
                PrintToChat(player, Lang("Checkpoint_NotExist", player.UserIDString));
                return;
            }
            switch (args[0].ToLower())
            {
                case "set":
                    if (!Data.Exists(player.userID))
                    {
                        var bag = FindBag(player);
                        if (bag == null)
                            return;
                        if (!Checks.CanUseSleepingBag(player, bag))
                        {
                            PrintToChat(player, Lang("SleepingBag_NotOwner", player.UserIDString));
                            return;
                        }
                        Data.Add(player, new PlayerData(bag));
                        PrintToChat(player, Lang("Checkpoint_Set", player.UserIDString, Math.Round(bag.transform.position.x, 2),
                            Math.Round(bag.transform.position.y, 2), Math.Round(bag.transform.position.z, 2)));
                    }
                    PrintToChat(player, Lang("Checkpoint_AlreadyExists", player.UserIDString, Math.Round(Vector3.Distance(player.transform.position,
                        new Vector3(sData.Players[player.userID].PosX, sData.Players[player.userID].PosY, sData.Players[player.userID].PosZ)))));
                    return;

                case "remove":
                    if (Data.Exists(player.userID))
                    {
                        var data = sData.Players[player.userID];
                        Data.Remove(player.userID);
                        PrintToChat(player, Lang("Checkpoint_Removed", player.UserIDString, Math.Round(data.PosX, 2), Math.Round(data.PosY, 2), Math.Round(data.PosZ, 2),
                            Math.Round(Vector3.Distance(player.transform.position, new Vector3(data.PosX, data.PosY, data.PosZ)))));
                        return;
                    }
                    PrintToChat(player, Lang("Checkpoint_NotFound", player.UserIDString));
                    return;
            }
        }

        #endregion
    }
}

// --- End of file: Checkpoints.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/compound-teleport ---
// --- Original File Path: C/CompoundTeleport/CompoundTeleport.cs ---

using System;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Compound Teleport", "kwamaking", "2.0.2")]
    [Description("Teleport through the death screen to Bandit Camp, Outpost, or any configured monument.")]
    class CompoundTeleport : RustPlugin
    {
        #region Variables

        private const string UsePermission = "compoundteleport.use";
        private const string OutPostPrefab = "assets/bundled/prefabs/autospawn/monument/medium/compound.prefab";
        private const string BanditTownPrefab = "assets/bundled/prefabs/autospawn/monument/medium/bandit_town.prefab";
        private const int TeleportLayer = ~(1 << 8 | 1 << 10 | 1 << 18 | 1 << 21 | 1 << 24 | 1 << 28 | 1 << 29);
        private const int TeleportRadius = 50;
        private const int Timer = 150;
        private const int MaxAttemptsToFindTeleportLocation = 25;
        private const float MaxDistance = 100f;
        private const float MaxDistanceFromGround = 100f;
        private readonly string[] ValidTeleportColliders = { "carpark", "concrete_slabs", "road", "train_track", "pavement", "platform", "walkway", "helipad" };
        private Dictionary<ulong, List<SleepingBag>> playerTeleportLocations = new Dictionary<ulong, List<SleepingBag>>();
        private CompoundTeleportConfiguration pluginConfiguration = new CompoundTeleportConfiguration();

        #endregion

        #region Oxide Hooks

        private void Init()
        {
            try
            {
                permission.RegisterPermission(UsePermission, this);
                pluginConfiguration = Config.ReadObject<CompoundTeleportConfiguration>();
            }
            catch (Exception e)
            {
                base.LoadConfig();
                Puts($"Failed to load Compound Teleport configuration, using default configuration: {e.Message} {e.StackTrace}");
            }

            CreateTeleportLocationsForActivePlayers();

        }

        protected override void LoadDefaultConfig()
        {
            pluginConfiguration = CompoundTeleportConfiguration.BuildDefaultConfiguration();
            SaveConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(pluginConfiguration);

        private void OnPlayerConnected(BasePlayer player) => CreateTeleportLocations(player);

        private void OnPlayerDisconnected(BasePlayer player) => DestroyTeleportLocations(player);

        private void OnPlayerRespawn(BasePlayer player, SleepingBag bag)
        {
            if (!permission.UserHasPermission(player.UserIDString, UsePermission)) return;

            if (!playerTeleportLocations.ContainsKey(player.userID)) return;

            if (playerTeleportLocations[player.userID].Any(b => b.net.ID == bag.net.ID))
            {
                bag.transform.position = AttemptToFindTeleportPosition(player, bag.transform.position);
                RemoveHostility(player);
            }
        }

        void Unload()
        {
            playerTeleportLocations.Keys.ToList().ForEach(
                playerId => playerTeleportLocations[playerId].ForEach(bag => bag.Kill())
            );

            playerTeleportLocations.Clear();
        }

        #endregion

        #region Helpers

        private void RemoveHostility(BasePlayer player)
        {
            if (player.IsHostile() && pluginConfiguration.removeHostility)
            {
                player.State.unHostileTimestamp = 0.0;
                player.DirtyPlayerState();
            }
        }

        private void CreateTeleportLocationsForActivePlayers()
        {
            try
            {
                BasePlayer
                .activePlayerList
                .ToList()
                .ForEach(player => CreateTeleportLocations(player));
            }
            catch (Exception e)
            {
                Puts($"Failed to create teleport locations for active players: {e.Message} {e.StackTrace} ");
            }
        }

        private void CreateTeleportLocations(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, UsePermission)) return;

            DestroyTeleportLocations(player);

            playerTeleportLocations.Add(player.userID, new List<SleepingBag>());

            pluginConfiguration.teleportLocations.ForEach(teleportLocation =>
            {
                var teleportPosition = FindMonumentPosition(teleportLocation.monumentPrefab);
                if (null != teleportPosition && teleportLocation.enabled)
                    playerTeleportLocations[player.userID].Add(
                        CreateTeleportLocation(player, teleportLocation, (Vector3)teleportPosition)
                    );
            });
        }

        private void DestroyTeleportLocations(BasePlayer player)
        {
            if (!playerTeleportLocations.ContainsKey(player.userID))
                return;

            playerTeleportLocations[player.userID].ForEach(bag => bag.Kill());
            playerTeleportLocations.Remove(player.userID);
        }

        private Vector3 FindMonumentPosition(string monumentPrefab)
        {

            var monumentPosition = TerrainMeta.Path.Monuments
            .Where(m => m.name.ToLower() == monumentPrefab)
            .FirstOrDefault()?
            .transform
            .position;

            if (null == monumentPosition)
                Puts($"Failed to find a location for Monument: {monumentPrefab}");

            return monumentPosition ?? new Vector3();
        }

        private Vector3 AttemptToFindTeleportPosition(BasePlayer player, Vector3 monumentLocation)
        {
            for (int i = 0; i < MaxAttemptsToFindTeleportLocation; i++)
            {
                RaycastHit rayHit;
                Vector3 positionAttempt = monumentLocation + (UnityEngine.Random.insideUnitSphere * TeleportRadius);
                positionAttempt.y = monumentLocation.y + MaxDistanceFromGround;
                if (Physics.Raycast(positionAttempt, Vector3.down, out rayHit, MaxDistance, TeleportLayer, QueryTriggerInteraction.Ignore))
                {
                    if (rayHit.collider is TerrainCollider)
                        return rayHit.point;
                    else if (ValidTeleportColliders.Any(c => rayHit.collider.name.Contains(c)))
                        return rayHit.point;
                }
            }

            Puts($"Failed to find a teleport location for {player.displayName}, using default spawn.");

            return ServerMgr.FindSpawnPoint(player).pos;
        }

        private SleepingBag CreateTeleportLocation(BasePlayer player, TeleportLocation teleportLocation, Vector3 position)
        {
            GameObject gameObject = new GameObject();
            SleepingBag sleepingBag = gameObject.AddComponent<SleepingBag>();

            sleepingBag.deployerUserID = player.userID;
            sleepingBag.net = Network.Net.sv.CreateNetworkable();
            sleepingBag.niceName = teleportLocation.name;
            sleepingBag.secondsBetweenReuses = teleportLocation.timer;
            sleepingBag.transform.position = position;
            sleepingBag.RespawnType = ProtoBuf.RespawnInformation.SpawnOptions.RespawnType.Bed;
            sleepingBag.unlockTime = 0;

            SleepingBag.sleepingBags.Add(sleepingBag);

            return sleepingBag;
        }

        #endregion

        #region Config Classes

        private class CompoundTeleportConfiguration
        {
            [JsonProperty("removeHostility")]
            public bool removeHostility { get; set; }

            [JsonProperty("teleportLocations")]
            public List<TeleportLocation> teleportLocations { get; set; }

            public static CompoundTeleportConfiguration BuildDefaultConfiguration()
            {
                return new CompoundTeleportConfiguration
                {
                    removeHostility = true,
                    teleportLocations = TeleportLocation.BuildDefaultTeleportLocations()
                };
            }
        }

        private class TeleportLocation
        {
            [JsonProperty("name")]
            public string name { get; set; }
            [JsonProperty("timer")]
            public int timer { get; set; }
            [JsonProperty("monumentPrefab")]
            public string monumentPrefab { get; set; }
            [JsonProperty("enabled")]
            public bool enabled { get; set; }

            public static List<TeleportLocation> BuildDefaultTeleportLocations()
            {

                return new List<TeleportLocation>
                {
                    new TeleportLocation
                    {
                        name = "Outpost",
                        timer = Timer,
                        monumentPrefab = OutPostPrefab,
                        enabled = true
                    },
                    new TeleportLocation
                    {
                        name = "Bandit Camp",
                        timer = Timer,
                        monumentPrefab = BanditTownPrefab,
                        enabled = true
                    }
                };
            }
        }

        #endregion

        #region API

        private bool umodversion() => true;
        // distinguish between free and paid versions
        // https://umod.org/community/nteleportation/41710-conflit-with-plugin-compound-teleport
        // https://umod.org/community/compound-teleport/40072-conflicts-with-nteleport

        #endregion
    }
}

// --- End of file: CompoundTeleport.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/connect-messages ---
// --- Original File Path: C/ConnectMessages/ConnectMessages.cs ---

using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using Oxide.Core.Libraries;
using Newtonsoft.Json;
using System;

namespace Oxide.Plugins {
    [Info("ConnectMessages", "Mroczny", "1.2.3")]
    [Description("Custom connect and disconnect messages.")]
    class ConnectMessages : CovalencePlugin {
        private class Response {
            [JsonProperty("country")]
            public string Country { get; set; }
            [JsonProperty("countryCode")]
            public string CountryCode { get; set; }
        }

        private void OnServerInitialized() {
            permission.RegisterPermission("connectmessages.hidden", this);
#if HURTWORLD
            GameManager.Instance.ServerConfig.ChatConnectionMessagesEnabled = false;
#endif
        }

        protected override void LoadDefaultConfig() {
            LogWarning("Creating a new configuration file");
            Config["Show Join Message"] = true;
            Config["Show Leave Message"] = true;
            Config["Show Disconnect Reason"] = true;
            Config["Show Admin Join Message"] = true;
            Config["Show Admin Leave Message"] = true;
            Config["Country Settings", "Show Country Message"] = true;
            Config["Country Settings", "Use Country Code"] = false;
#if RUST
            Config["Chat Icon", "Default (SteamID64)"] = 0;
            Config["Chat Icon", "Use Steam Avatar"] = false;
            Config["Chat Icon", "Hidden"] = false;
#endif
        }

        protected override void LoadDefaultMessages() {
            lang.RegisterMessages(new Dictionary<string, string> {
                ["Join Country Message"] = "[{1}] {0} joined the game.",
                ["Join Message"] = "{0} joined the game.",
                ["Leave Message"] = "{0} left the game. ({1})",
                ["Local Network"] = "Local Network"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string> {
                ["Join Country Message"] = "[{1}] {0} doczy do gry.",
                ["Join Message"] = "{0} doczy do gry.",
                ["Leave Message"] = "{0} opuci nas. ({1})",
                ["Local Network"] = "Lokalna sie"
            }, this, "pl");
            lang.RegisterMessages(new Dictionary<string, string> {
                ["Join Country Message"] = "[{1}] {0}   .",
                ["Join Message"] = "{0}   .",
                ["Leave Message"] = "{0}  . ({1})",
                ["Local Network"] = " "
            }, this, "uk");
            lang.RegisterMessages(new Dictionary<string, string> {
                ["Join Country Message"] = "[{1}] {0}   .",
                ["Join Message"] = "{0}   .",
                ["Leave Message"] = "{0}  . ({1})",
                ["Local Network"] = " "
            }, this, "ru");
        }

        private void OnUserConnected(IPlayer player) {
            if ((player.IsAdmin && !Convert.ToBoolean(Config["Show Admin Join Message"])) || !Convert.ToBoolean(Config["Show Join Message"]) || (!player.IsAdmin && player.HasPermission("connectmessages.hidden"))) {
                return;
            }

            if (Convert.ToBoolean(Config["Country Settings", "Show Country Message"])) {
                string country = string.Empty;
                if (player.Address.StartsWith("10.") || player.Address.StartsWith("172.16.") || player.Address.StartsWith("192.168.") || player.Address.StartsWith("127.0.0.1")) {
                    if (Convert.ToBoolean(Config["Country Settings", "Use Country Code"])) {
                        country = "LAN";
                    } else {
                        country = lang.GetMessage("Local Network", this);
                    }
                    Broadcast("Join Country Message", player, country);
                    return;
                }

                string apiUrl = "http://ip-api.com/json/";
                webrequest.Enqueue(apiUrl + player.Address, null, (code, response) => {
                    if (code != 200 || response == null) {
                        PrintWarning($"WebRequest to {apiUrl} failed, sending connect message without the country.");
                        Broadcast("Join Message", player);
                        return;
                    }

                    if (Convert.ToBoolean(Config["Use Country Code"])) {
                        country = JsonConvert.DeserializeObject<Response>(response).CountryCode;
                    } else {
                        country = JsonConvert.DeserializeObject<Response>(response).Country;
                    }
                    Broadcast("Join Country Message", player, country);
                }, this, RequestMethod.GET);

            } else {
                Broadcast("Join Message", player);
            }
        }

        private void OnUserDisconnected(IPlayer player, string reason) {
            if ((player.IsAdmin && !Convert.ToBoolean(Config["Show Admin Leave Message"])) || !Convert.ToBoolean(Config["Show Leave Message"]) || (!player.IsAdmin && player.HasPermission("connectmessages.hidden"))) {
                return;
            } else {
                if (Convert.ToBoolean(Config["Show Disconnect Reason"])) {
                    Broadcast("Leave Message", player, reason);
                } else {
                    Broadcast("Leave Message", player);
                }
            }
        }

        private void Broadcast(string msg, object player, string country = null) {
            var iPlayer = player as IPlayer;
            string format = string.Format(lang.GetMessage(msg, this), iPlayer.Name, country).Replace("()", "");
#if RUST
            if (!Convert.ToBoolean(Config["Chat Icon", "Use Steam Avatar"]) && Convert.ToBoolean(Config["Chat Icon", "Hidden"])) {
                ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 1, format);
            } else if (Convert.ToBoolean(Config["Chat Icon", "Use Steam Avatar"]) && !Convert.ToBoolean(Config["Chat Icon", "Hidden"])) {
                ConsoleNetwork.BroadcastToAllClients("chat.add", 2, iPlayer.Id, format);
            } else {
                ConsoleNetwork.BroadcastToAllClients("chat.add", 2, Convert.ToUInt64(Config["Chat Icon", "Default (SteamID64)"]), format);
            }
#elif HURTWORLD // Send clear message without announcement icon
            ChatManagerServer.Instance.SendChatMessage(new ServerChatMessage(format));
#else
            server.Broadcast(format);
#endif
        }
    }
}

// --- End of file: ConnectMessages.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/cash-system ---
// --- Original File Path: C/CashSystem/CashSystem.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Cash System", "Iv Misticos", "1.0.5")]
    [Description("Rich economics system")]
    class CashSystem : CovalencePlugin
    {
        #region Variables

        private static CashSystem _ins;

        private static PluginData _data;

        private static Time _time = GetLibrary<Time>();
        
        #endregion
        
        #region Configuration
        
        private static Configuration _config = new Configuration();

        private class Configuration
        {
            [JsonProperty(PropertyName = "Currency List", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<Currency> Currencies = new List<Currency>
            {
                new Currency()
            };

            [JsonProperty(PropertyName = "Purge Old Data")]
            public bool Purge = true;

            [JsonProperty(PropertyName = "Time Between Latest Update And Purge")]
            public uint PurgeTime = 604800;
        }

        private class Currency
        {
            [JsonProperty(PropertyName = "Abbreviation")]
            public string Abbreviation = "$";
            
            [JsonProperty(PropertyName = "Start Amount")]
            public double StartAmount = 0f;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);
        
        #endregion
        
        #region Work with Data

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _data);

        private void LoadData()
        {
            try
            {
                _data = Interface.Oxide.DataFileSystem.ReadObject<PluginData>(Name);
            }
            catch (Exception e)
            {
                PrintError(e.ToString());
            }

            if (_data == null) _data = new PluginData();
        }

        private class PluginData
        {
            [JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<PlayerData> Players = new List<PlayerData>();
        }

        private class PlayerData
        {
            [JsonProperty(PropertyName = "SteamID")]
            public string Id;
            
            [JsonProperty(PropertyName = "Last Update")]
            public uint LastUpdate = _time.GetUnixTimestamp();
            
            [JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<CurrencyData> Currencies = new List<CurrencyData>();

            public static PlayerData Find(string id)
            {
                for (var i = 0; i < _data.Players.Count; i++)
                {
                    var data = _data.Players[i];
                    if (data.Id == id)
                        return data;
                }

                return null;
            }

            public CurrencyData FindCurrency(string abbreviation)
            {
                for (var i = 0; i < Currencies.Count; i++)
                {
                    var data = Currencies[i];
                    if (data.Abbreviation == abbreviation)
                        return data;
                }

                return null;
            }

            public void UpdateCurrencies()
            {
                for (var i = 0; i < _config.Currencies.Count; i++)
                {
                    var currency = _config.Currencies[i];
                    var foundCurrency = FindCurrency(currency.Abbreviation);
                    if (foundCurrency == null)
                    {
                        foundCurrency = new CurrencyData
                        {
                            Abbreviation = currency.Abbreviation
                        };

                        foundCurrency.Add(currency.StartAmount, GetMsg("Start Amount Transfer", Id));
                        Currencies.Add(foundCurrency);
                    }
                
                    foundCurrency.RecalculateBalance();
                }
            }

            public void Update()
            {
                LastUpdate = _time.GetUnixTimestamp();
            }
        }

        private class CurrencyData
        {
            public string Abbreviation = "$";

            [JsonIgnore] public double Balance;
            
            [JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<TransactionData> Transactions = new List<TransactionData>();

            public void Add(double amount, string description)
            {
                var transaction = new TransactionData
                {
                    Amount = amount,
                    Description = description
                };
                
                Transactions.Add(transaction);
                Balance += amount;
            }

            public void RecalculateBalance()
            {
                Balance = 0d;
                for (var i = 0; i < Transactions.Count; i++)
                {
                    Balance += Transactions[i].Amount;
                }
            }
        }

        private class TransactionData
        {
            public double Amount;

            // ReSharper disable once NotAccessedField.Local
            public string Description = string.Empty;

            public uint Timestamp = _time.GetUnixTimestamp();
        }

        #endregion
        
        #region Hooks

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "Start Amount Transfer", "Start Amount" },
//                { "Not Enough Permissions", "You don't have enough permissions" },
//                { "Admin Money Transfer", "Admin money transfer" },
//                { "Money Transfer To You", "Money transfer FROM {name} ({id})" },
//                { "Money Transfer From You", "Money transfer TO {name} ({id})" },
//                { "Incorrect Number", "Incorrect number" },
//                { "Balance Get Error", "There was an error while getting this player's balance. Check his ID and the currency twice." },
//                { "Balance Get", "Balance: {balance}" },
//                { "Balance Add Success", "Success. Balance changed!" },
//                { "Balance Add Error", "There was an error." },
//                { "Balance Help", "Help:\n" +
//                                  "get ID Currency - Get player balance\n" +
//                                  "add ID Currency Amount - Add balance" },
            }, this);
        }

        private void Loaded()
        {
            _ins = this;
            
            // Loading, purging, saving

            LoadData();

            if (_config.Purge)
            {
                var currentTime = _time.GetUnixTimestamp();
                for (var i = _data.Players.Count - 1; i >= 0; i--)
                {
                    var data = _data.Players[i];
                    if (data.LastUpdate + _config.PurgeTime < currentTime)
                    {
                        _data.Players.RemoveAt(i);
                        continue;
                    }

                    data.UpdateCurrencies();
                }
            }
            
            SaveData();
        }

        private void OnServerSave() => SaveData();

        private void Unload() => SaveData();

        private void OnUserConnected(IPlayer player)
        {
            var data = PlayerData.Find(player.Id);
            if (data == null)
            {
                data = new PlayerData
                {
                    Id = player.Id
                };
                
                _data.Players.Add(data);
            }
            
            data.UpdateCurrencies();
            data.Update();
        }
        
        #endregion
        
        #region API

        private bool TransferBalance(string idFrom, string idTo, string currencyFrom, string currencyTo, double changeFrom,
            double changeTo, string descriptionFrom, string descriptionTo)
        {
            var playerFrom = PlayerData.Find(idFrom);
            if (playerFrom == null)
                return false;
            
            var playerTo = PlayerData.Find(idTo);
            if (playerTo == null)
                return false;

            var currencyDataFrom = playerFrom.FindCurrency(currencyFrom);
            if (currencyDataFrom == null)
                return false;
            
            var currencyDataTo = playerFrom.FindCurrency(currencyTo);
            if (currencyDataTo == null)
                return false;
            
            currencyDataFrom.Add(changeFrom, descriptionFrom);
            currencyDataTo.Add(changeTo, descriptionTo);
            return true;
        }

        private List<string> GetCurrencies(string id)
        {
            var player = PlayerData.Find(id);
            if (player == null)
                return null;

            var data = new List<string>();
            for (var i = 0; i < player.Currencies.Count; i++)
            {
                data.Add(player.Currencies[i].Abbreviation);
            }

            return data;
        }

        private List<string> GetCurrencies()
        {
            var data = new List<string>();
            for (var i = 0; i < _config.Currencies.Count; i++)
            {
                data.Add(_config.Currencies[i].Abbreviation);
            }

            return data;
        }

        private double GetBalance(string id, string currency)
        {
            var player = PlayerData.Find(id);
            var data = player?.FindCurrency(currency);
            return data?.Balance ?? double.NaN; // Yeah it could be just a one line but I made it bigger for u
        }

        private bool AddTransaction(string id, string currency, double amount, string description)
        {
            var player = PlayerData.Find(id);
            var data = player?.FindCurrency(currency);
            if (data == null)
                return false;
            
            data.Add(amount, description);
            player.Update();
            return true;
        }

        private JObject GetTransactions(string id, string currency)
        {
            var player = PlayerData.Find(id);
            var data = player?.FindCurrency(currency);
            return data == null ? null : JObject.FromObject(data.Transactions);
        }
        
        #endregion
        
        #region Helpers

        private static string GetMsg(string key, string userId = null) => _ins.lang.GetMessage(key, _ins, userId);

        #endregion
    }
}

// --- End of file: CashSystem.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/custom-map-vehicle-vendor-fix ---
// --- Original File Path: C/CustomMapVehicleVendorFix/CustomMapVehicleVendorFix.cs ---

using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Custom Map Vehicle Vendor Fix", "Ryz0r", "1.0.5")]
    [Description("Fixes Airwolf & Boat spawner on custom maps. Previously, a player could buy immediately after completing a transaction.")]
    public class CustomMapVehicleVendorFix : RustPlugin
    {
        private const string AirwolfConversationalistPrefab = "assets/prefabs/npc/bandit/shopkeepers/bandit_conversationalist.prefab";
        private const string BoatVendorPrefab = "assets/prefabs/npc/bandit/shopkeepers/boat_shopkeeper.prefab";

        private void OnServerInitialized()
        {
            var count = 0;
            var vendorEntities = BaseNetworkable.serverEntities.OfType<VehicleVendor>();
            if (!vendorEntities.Any())
            {
                Puts("There were no Vehicle Vendors found on this map. You're good to go!");
                return;
            }
            
            
            foreach (var vendor in vendorEntities)
            {
                if (vendor == null) continue;
                if (vendor.PrefabName != AirwolfConversationalistPrefab && vendor.PrefabName != BoatVendorPrefab) continue;
                if (vendor.GetVehicleSpawner() != null && vendor.vehicleSpawner != null) continue;
                
                var spawners = new List<VehicleSpawner>();
                Vis.Entities(vendor.transform.position, vendor.PrefabName == AirwolfConversationalistPrefab ? 40f : 20f, spawners);

                if (spawners.Count < 1)
                {
                    Puts($"Vehicle Vendor ({vendor.net.ID}) @ {vendor.transform.position} did not have any nearby spawners. Check your map file if possible.");
                    continue;
                }
                
                if (spawners.Count > 1)
                {
                    vendor.spawnerRef.Set(spawners.OrderBy(x => Vector3.Distance(x.transform.position, vendor.transform.position)).First());
                    Puts($"Vehicle Vendor ({vendor.net.ID}) was missing a Vehicle Spawner @ {vendor.transform.position}!");
                    count += 1;
                }
                else
                {
                    vendor.spawnerRef.Set(spawners[0]);
                    Puts($"Vehicle Vendor ({vendor.net.ID}) was missing a Vehicle Spawner @ {vendor.transform.position}!");
                    count += 1;
                }
            }
            
            Puts($"Fixed {count} broken Vehicle Vendors on your map!");
        }
    }
}

// --- End of file: CustomMapVehicleVendorFix.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/crosshair ---
// --- Original File Path: C/Crosshair/Crosshair.cs ---

using System.Collections.Generic;
using System.Globalization;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Crosshair", "MisterPixie", "3.1.0")]
    [Description("Allows the user to toggle a crosshair")]

    class Crosshair : RustPlugin
    {
        private string mainUI = "UI_MAIN";
        private CuiElementContainer _ui;
        private HashSet<string> _crosshairSettings = new HashSet<string>();
        private const string _usePerm = "crosshair.use";

        #region Classes
        private class UI
        {
            public static CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor = false)
            {
                var newElement = new CuiElementContainer
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                            CursorEnabled = cursor
                        },
                        new CuiElement().Parent = "Hud",
                        panelName
                    }
                };

                return newElement;
            }

            public static void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 1f)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = fadein, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                }, panel, CuiHelper.GetGuid());
            }
        }
        #endregion

        #region Methods
        private void ToggleCrosshair(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, _usePerm))
            {
                PrintToChat(player, Lang("No Permission", player.UserIDString));
                return;
            }

            if (_crosshairSettings.Contains(player.UserIDString))
            {
                DestroyCrosshair(player);
                _crosshairSettings.Remove(player.UserIDString);
                player.ChatMessage(Lang("CrosshairOff", player.UserIDString));
                return;
            }

            CuiHelper.AddUi(player, _ui);
            _crosshairSettings.Add(player.UserIDString);
            player.ChatMessage(Lang("CrosshairOn", player.UserIDString));

        }

        private void DestroyCrosshair(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, mainUI);
        }

        private void DestroyAllCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            DestroyCrosshair(player);
        }

        private void CreateUI()
        {
            var container = UI.CreateElementContainer(mainUI, $"{HexToColor("000000")} 0", "0.47 0.47", "0.53 0.53");
            UI.CreateLabel(ref container, mainUI, $"{HexToColor(configData.CrosshairColor)} 0.9", configData.CrosshairText, 25, "0 0", "1 1");
            _ui = container;
        }
        private static string HexToColor(string hexColor)
        {
            if (hexColor.IndexOf('#') != -1) hexColor = hexColor.Replace("#", "");

            var red = 0;
            var green = 0;
            var blue = 0;

            if (hexColor.Length == 6)
            {
                red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
            }
            else if (hexColor.Length == 3)
            {
                red = int.Parse(hexColor[0] + hexColor[0].ToString(), NumberStyles.AllowHexSpecifier);
                green = int.Parse(hexColor[1] + hexColor[1].ToString(), NumberStyles.AllowHexSpecifier);
                blue = int.Parse(hexColor[2] + hexColor[2].ToString(), NumberStyles.AllowHexSpecifier);
            }

            return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255}";
        }
        #endregion

        #region Hooks
        private void Init()
        {
            LoadVariables();
            permission.RegisterPermission("crosshair.use", this);
            cmd.AddChatCommand("crosshair", this, "ToggleCrosshair");
            cmd.AddConsoleCommand("ui_destroy", this, "DestroyAllCommand");
            CreateUI();
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyCrosshair(player);
            }
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            DestroyCrosshair(player);
            _crosshairSettings.Remove(player.UserIDString);
        }
        #endregion

        #region lang
        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"CrosshairOn", "Crosshair turned on."},
                {"CrosshairOff", "Crosshair turned off."},
                {"No Permission", "Error, you lack permission."}
            }, this);
        }
        #endregion

        #region Config
        private ConfigData configData;
        private class ConfigData
        {
            public string CrosshairColor;
            public string CrosshairText;
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                CrosshairColor = "#008000",
                CrosshairText = ""
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion
    }
}

// --- End of file: Crosshair.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/custom-genetics ---
// --- Original File Path: C/CustomGenetics/CustomGenetics.cs ---

using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;
using Newtonsoft.Json;
using UnityEngine;
using System;

namespace Oxide.Plugins
{
	[Info("Custom Genetics", "rostov114 / yoshi2", "0.17.2")]
	[Description("Allows players to change genetics for seeds in their inventory")]

	class CustomGenetics : RustPlugin
	{
		#region Variables
		private GrowableGenes growablegenes = new GrowableGenes();
		private const string CustomGenes = "customgenetics.use";
		private HashSet<char> possibleGenes = new HashSet<char>
		{
			'G',
			'Y',
			'H',
			'X',
			'W'
		};
		#endregion

		#region Configuration
		private Configuration _config;
		public class Configuration
		{
			[JsonProperty(PropertyName = "allowed seeds (full or short names)")]
			public HashSet<string> AllowedPlants = new HashSet<string>
			{
				"seed.black.berry",
				"seed.blue.berry",
				"seed.corn",
				"seed.green.berry",
				"seed.hemp",
				"seed.potato",
				"seed.pumpkin",
				"seed.red.berry",
				"seed.white.berry",
				"seed.yellow.berry",
				"seed.wheat",
				"seed.rose",
				"seed.sunflower",
				"seed.orchid",
				"clone.black.berry",
				"clone.blue.berry",
				"clone.corn",
				"clone.green.berry",
				"clone.hemp",
				"clone.potato",
				"clone.pumpkin",
				"clone.red.berry",
				"clone.white.berry",
				"clone.yellow.berry",
				"clone.wheat",
				"clone.rose",
				"clone.sunflower",
				"clone.orchid"
			};

			[JsonProperty(PropertyName = "admins bypass (true/false)")]
			public bool AdminBypass = true;

			[JsonProperty(PropertyName = "only affect the active item (true/false)")]
			public bool WholeInventory = true;

			[JsonProperty(PropertyName = "command name")]
			public string CommandName = "setgenes";
		}

		protected override void LoadConfig()
		{
			base.LoadConfig();
			try
			{
				_config = Config.ReadObject<Configuration>();
				if (_config == null) throw new Exception();
				SaveConfig();
			}
			catch
			{
				PrintError("Your configuration file contains an error. Using default configuration values.");
				LoadDefaultConfig();
			}
		}

		protected override void SaveConfig() => Config.WriteObject(_config);
		protected override void LoadDefaultConfig() => _config = new Configuration();
		#endregion

		#region Language
		protected override void LoadDefaultMessages()
		{
			// English
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["GenesSet"] = "Your seeds genetics have been set to ",
				["NoPermmision"] = "you're not allowed to use this command",
				["WrongFormat"] = "Syntax error, proper format is \"/setgenes GGGGYY\"",
				["WrongGene"] = "Syntax error, invalid gene type",
				["WrongItem"] = "the item you're holding is not a valid seed",
			}, this, "en");

			// French
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["GenesSet"] = "La gntique de vos graines a t rgle sur ",
				["NoPermmision"] = "vous n'tes pas autoris  utiliser cette commande",
				["WrongFormat"] = "Erreur de syntaxe, le format correct est \"/setgenes GGGGYY\"",
				["WrongGene"] = "Erreur de syntaxe,type de gne non valide",
				["WrongItem"] = "l'article que vous tenez n'est pas une graine valide"
			}, this, "fr");

			// German
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["GenesSet"] = "Ihre Samengenetik wurde eingestellt ",
				["NoPermmision"] = "Sie drfen diesen Befehl nicht verwenden",
				["WrongFormat"] = "Syntaxfehler, das richtige Format ist \"/setgenes GGGGYY\"",
				["WrongGene"] = "Syntaxfehler, ungltiger Gentyp",
				["WrongItem"] = "Der Gegenstand, den Sie halten, ist kein gltiger Samen"
			}, this, "de");

			// Russian
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["GenesSet"] = "     ",
				["NoPermmision"] = "     ",
				["WrongFormat"] = " ,   \"/setgenes GGGGYY\"",
				["WrongGene"] = " ,   ",
				["WrongItem"] = ",   ,    "
			}, this, "ru");

			// Spanish
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["GenesSet"] = "La gentica de tus semillas se ha configurado para ",
				["NoPermmision"] = "no tienes permitido usar este comando",
				["WrongFormat"] = "Error de sintaxis, el formato correcto es \"/setgenes GGGGYY\"",
				["WrongGene"] = "Error de sintaxis, tipo de gen no vlido",
				["WrongItem"] = "el artculo que tienes no es una semilla vlida"
			}, this, "es");

			// Ukrainian
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["GenesSet"] = "     ",
				["NoPermmision"] = "     ",
				["WrongFormat"] = " ,   \"/setgenes GGGGYY\"",
				["WrongGene"] = " ,   ",
				["WrongItem"] = ",   ,   "
			}, this, "uk");
		}

		public void ReplyToPlayer(IPlayer player, string messageName, params object[] args) =>
			player.Reply(string.Format(GetMessage(player, messageName), args));

		public void ChatMessage(BasePlayer player, string messageName, params object[] args) =>
			player.ChatMessage(string.Format(GetMessage(player.IPlayer, messageName), args));

		public string GetMessage(IPlayer player, string messageName, params object[] args)
		{
			var message = lang.GetMessage(messageName, this, player.Id);
			return args.Length > 0 ? string.Format(message, args) : message;
		}
		#endregion

		#region Init
		private void Init()
		{
			permission.RegisterPermission(CustomGenes, this);

			AddCovalenceCommand(_config.CommandName, nameof(GetUserGenes));
		}
		#endregion

		#region manual genes
		private void GetUserGenes(IPlayer player, string command, string[] args)
		{
			BasePlayer basePlayer = player.Object as BasePlayer;

			if (!(_config.AdminBypass && player.IsAdmin) && !player.HasPermission(CustomGenes))
			{
				ReplyToPlayer(player, "NoPermmision");
				return;
			}

			if (_config.WholeInventory)
			{
				Item item = basePlayer.GetActiveItem();
				if (item == null)
				{
					ReplyToPlayer(player, "WrongItem");
					return; 
				}

				if (!_config.AllowedPlants.Contains(item.info.shortname) || _config.AllowedPlants.Contains(item.info.name))
				{
					ReplyToPlayer(player, "WrongItem");
					return;
				}
			}

			if (args.Length != 1 || args[0].Length != 6)
			{
				ReplyToPlayer(player, "WrongFormat");
				return;
			}

			char[] genes = args[0].ToUpper().ToCharArray(0, 6);
			foreach (char gene in genes)
			{
				if (!possibleGenes.Contains(gene))
				{
					ReplyToPlayer(player, "WrongGene");
					return;
				}
			}

			player.Message(lang.GetMessage("GenesSet", this, player.Id) + $" <size=18><color=#006300>{args[0]}</size></color>");
			EditGenes(basePlayer, genes);
		}
		#endregion


		#region Console Hooks
		[ConsoleCommand("customgenetics.give")]
		private void CustomGeneticsGive(ConsoleSystem.Arg args)
		{
			BasePlayer p = args?.Player() ?? null; 
			if (p != null && !p.IsAdmin) 
				return;

			if (!args.HasArgs(2))
			{
				SendReply(args, $"Syntax: customgenetics.give <player|steamid> <shortname> [amount] [gene]");
				return;
			}

			BasePlayer player = args.GetPlayer(0);
			if (player == null)
			{
				SendReply(args, $"Player '{args.Args[0]}' not found!");
				return;
			}

			string shortname = args.GetString(1);
			if (!_config.AllowedPlants.Contains(shortname))
			{
				SendReply(args, $"The item is not a valid seed!");
				SendReply(args, $"Valid seed: " + string.Join(", ", _config.AllowedPlants));
				SendReply(args, $"Syntax: customgenetics.give <player|steamid> <shortname> [gene] [amount]");
				return;
			}

			ItemDefinition definition = ItemManager.FindItemDefinition(shortname);
			if (definition == null)
			{
				SendReply(args, $"The item is not a valid! ItemDefinition not found!");
				return;
			}

			char[] genes = new char[0];
			string geneString = args.GetString(3, null);
			if (!string.IsNullOrEmpty(geneString))
			{
				if (geneString.Length != 6)
				{
					SendReply(args, $"The is not a valid gene string!");
					SendReply(args, $"Exemple valid gene string: XXXXXX");
					SendReply(args, $"Syntax: customgenetics.give <player|steamid> <shortname> [gene] [amount]");

					return;
				}

				genes = geneString.ToUpper().ToCharArray(0, 6);
				foreach (char gene in genes)
				{
					if (!possibleGenes.Contains(gene))
					{
						SendReply(args, $"{gene} - not a valid gene!");
						SendReply(args, $"Valid genes: " + string.Join(", ", possibleGenes));
						SendReply(args, $"Syntax: customgenetics.give <player|steamid> <shortname> [gene] [amount]");

						return;
					}
				}
			}

			int amount = args.GetInt(2, 1);
			Item item = ItemManager.Create(definition, amount);

			if (genes.Length > 0)
			{
				for (int i = 0; i < 6; i++)
				{
					growablegenes.Genes[i].Set(CharToGeneType(genes[i]), true);
				}

				GrowableGeneEncoding.EncodeGenesToItem(GrowableGeneEncoding.EncodeGenesToInt(growablegenes), item);
			}

			player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
		}
		#endregion

		#region Helpers
		public void EditGenes(BasePlayer player, char[] genes)
		{
			if (_config.WholeInventory)
			{
				Item item = player.GetActiveItem();
				if(item == null) 
				{
					ReplyToPlayer(player.IPlayer, "WrongItem");
					return; 
				}

				NewGenes(item, player, genes);
				return;
			}

			List<Item> allItems = Facepunch.Pool.GetList<Item>();
			player.inventory.GetAllItems(allItems);
			foreach (Item item in allItems)
				NewGenes(item, player, genes);

			Facepunch.Pool.Free<Item>(ref allItems, false);
		}

		public void NewGenes(Item item, BasePlayer player, char[] genes)
		{
			if (_config.AllowedPlants.Contains(item.info.shortname) || _config.AllowedPlants.Contains(item.info.name))
			{
				for (int i = 0; i < 6; ++i)
				{
					growablegenes.Genes[i].Set(CharToGeneType(genes[i]), true);
				}

				GrowableGeneEncoding.EncodeGenesToItem(GrowableGeneEncoding.EncodeGenesToInt(growablegenes), item);
				item.MarkDirty();
			}
			else
			{
				if (!_config.WholeInventory) return;
				ReplyToPlayer(player.IPlayer, "WrongItem");
			}
		}

		public GrowableGenetics.GeneType CharToGeneType(char gene)
		{
			switch (gene)
			{
				case 'G': return GrowableGenetics.GeneType.GrowthSpeed;
				case 'Y': return GrowableGenetics.GeneType.Yield;
				case 'H': return GrowableGenetics.GeneType.Hardiness;
				case 'X': return GrowableGenetics.GeneType.Empty;
				case 'W': return GrowableGenetics.GeneType.WaterRequirement;
				default: return GrowableGenetics.GeneType.Empty;
			}
		}
		#endregion
	}
}


// --- End of file: CustomGenetics.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/capacity-controller ---
// --- Original File Path: C/CapacityController/CapacityController.cs ---

using Newtonsoft.Json;

using System;
using System.Collections;
using System.Collections.Generic;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Capacity Controller", "2CHEVSKII", "2.1.0")]
    [Description("Allows capacity modification of certain containers.")]
    class CapacityController : CovalencePlugin
    {
        #region Fields

        Configuration config;
        IEnumerator routine;
        Dictionary<string, string> shortNameToDisplay;

        #endregion

        #region Oxide hooks

        void Init()
        {
            shortNameToDisplay = new Dictionary<string, string>();

            Unsubscribe("OnEntitySpawned");
            Unsubscribe("OnItemAddedToContainer");
        }

        void OnServerInitialized()
        {
            routine = GetContainers(() =>
            {
                Subscribe("OnEntitySpawned");
                Subscribe("OnItemAddedToContainer");

                routine = null;
            });

            ServerMgr.Instance.StartCoroutine(routine);
        }

        void OnEntitySpawned(StorageContainer entity)
        {
            string name;

            if (shortNameToDisplay.TryGetValue(entity.ShortPrefabName, out name) && config.deployables.ContainsKey(name))
            {
                entity.inventory.capacity = config.deployables[name];
                entity.SendNetworkUpdate();
            }
        }

        void OnItemAddedToContainer(ItemContainer _, Item item)
        {
            var def = item.info;

            if (config.weapons.ContainsKey(def.displayName.english))
            {
                item.contents.capacity = config.weapons[def.displayName.english];
            }
        }

        void Unload()
        {
            if (routine != null)
            {
                ServerMgr.Instance.StopCoroutine(routine);
            }
        }

        #endregion

        #region Core

        IEnumerator GetContainers(Action callback)
        {
            var defs = ItemManager.GetItemDefinitions();
            foreach (var def in defs)
            {
                var modDeployable = def.GetComponent<ItemModDeployable>();

                if (modDeployable)
                {
                    var ent = GameManager.server.CreatePrefab(modDeployable.entityPrefab.resourcePath, false)?.GetComponent<StorageContainer>();

                    if (ent)
                    {
                        shortNameToDisplay[ent.ShortPrefabName] = def.displayName.english;
                        if (!config.deployables.ContainsKey(def.displayName.english))
                        {
                            config.deployables[def.displayName.english] = ent.inventorySlots;
                        }
                    }
                    UnityEngine.Object.Destroy(ent);
                }
                else
                {
                    var modContainer = def.GetComponent<ItemModContainer>();

                    if (modContainer)
                    {
                        var item = ItemManager.Create(def);
                        if (item != null && item.GetHeldEntity() is BaseProjectile && modContainer.capacity > 0)
                        {
                            if (!config.weapons.ContainsKey(def.displayName.english))
                            {
                                config.weapons[def.displayName.english] = modContainer.capacity;
                            }
                        }

                        item?.Remove();
                    }
                }
                yield return new WaitForEndOfFrame();
            }

            SaveConfig();

            callback();
        }

        #endregion

        #region Configuration

        protected override void LoadDefaultConfig()
        {
            config = Configuration.Default;
            SaveConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<Configuration>();

                if (config == null) throw new Exception();
            }
            catch
            {
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        class Configuration
        {
            public static Configuration Default => new Configuration
            {
                weapons = new Dictionary<string, int>(),
                deployables = new Dictionary<string, int>()
            };

            [JsonProperty("Weapons")]
            public Dictionary<string, int> weapons;
            [JsonProperty("Deployables")]
            public Dictionary<string, int> deployables;

            public void SetWeaponCapacity(string name, int capacity)
            {
                weapons[name] = capacity;
            }

            public void SetDeployableCapacity(string name, int capacity)
            {
                deployables[name] = capacity;
            }

            public int GetWeaponCapacity(string name)
            {
                if (weapons.ContainsKey(name))
                {
                    return weapons[name];
                }

                return -1;
            }

            public int GetDeployableCapacity(string name)
            {
                if (deployables.ContainsKey(name))
                {
                    return deployables[name];
                }

                return -1;
            }
        }

        #endregion
    }
}


// --- End of file: CapacityController.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/coptor-tracker ---
// --- Original File Path: C/CoptorTracker/CoptorTracker.cs ---

using System;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Chopper Tracker", "Smoosher", "1.6.7", ResourceId = 1468)]
    [Description("Spawns helicopters based on a timer, sets a lifetime, and announcements")]

    class CoptorTracker : RustPlugin
    {
        DateTime TimerStart;
        int ChopperSpawnTime;
        float ChopperLifeTimeOriginal;
        float ChopperLifeTimeCurrent;
        DateTime TimerSpawn;
        DateTime ChopperSpawned;
        bool SpawnedHeli = false;

        #region Config

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file.");
            Config.Clear();
            Config["CoptorRespawnTimeInSeconds"] = 3600;
            Config["CoptorLifetimeInMins"] = 7.5;
        }

        void SetConfig()
        {
            ChopperSpawnTime = Convert.ToInt32(Config["CoptorRespawnTimeInSeconds"]);
            ChopperLifeTimeOriginal = Convert.ToInt32(Config["CoptorLifetimeInMins"]);
        }

        bool TrueorFalse(string input)
        {
            bool output;
            input = input.ToLower();
            switch (input)
            {
                case "true":
                    output = true;
                    return output;


                case "false":
                    output = false;
                    return output;

                default:
                    output = false;
                    return output;
            }
        }

        #endregion

        #region OnLoad

        void Loaded()
        {
            SetConfig();
            permission.RegisterPermission("coptortracker.use", this);
            SetChopperLifetimeMins();
            StartChopperSpawnFreq();
        }

        #endregion

        #region ChatCommands

        [ChatCommand("Nextheli")]
        void NextCoptor(BasePlayer player, string command, string[] args)
        {
            var TimeNow = DateTime.Now;
            TimeSpan t = TimerSpawn.Subtract(TimeNow);

            string TimeLeft = string.Format(string.Format("{0:D2}h:{1:D2}m:{2:D2}s", t.Hours, t.Minutes, t.Seconds));

            SendReply(player, "Next Helicoptor will spawn in " + TimeLeft + "", "");
            int count = 0;
            string UpOrDown = "";
            BaseHelicopter[] allHelicopters = UnityEngine.Object.FindObjectsOfType<BaseHelicopter>();
            foreach (BaseHelicopter helicopter in allHelicopters)
            {
                count++;
            }
            if (count > 0)
            {
                UpOrDown = "Spawned And Hunting";
            }
            else
            {
                UpOrDown = "Not Spawned";
            }
            SendReply(player, "The Helicoptor is currently " + UpOrDown + "", "");
            if (UpOrDown == "Spawned And Hunting")
            {
                var ChopLT = -ChopperLifeTimeCurrent;
                DateTime Duration = ChopperSpawned.AddMinutes(-ChopLT);
                TimeSpan l = Duration.Subtract(TimeNow);
                string DurationLeft = string.Format(string.Format("{0:D2}h:{1:D2}m:{2:D2}s", l.Hours, l.Minutes, l.Seconds));
                SendReply(player, "The Helicoptor Will Leave In " + DurationLeft + "", "");
            }
        }

        [ChatCommand("KillAllHelis")]
        void KillHelis(BasePlayer player, string command, string[] args)
        {
            var perm = new Oxide.Core.Libraries.Permission();
            if (perm.UserHasPermission(player.userID.ToString(), "coptortracker.use"))
            {
                KillCoptor();
            }
            else
            {
                SendReply(player, "You Dont Have Permissions To Do This, Attempt Has Been Logged", "");
            }
        }

        [ChatCommand("SpawnHeli")]
        void SpawnHeli(BasePlayer player, string command, string[] args)
        {
            var perm = new Oxide.Core.Libraries.Permission();
            if (perm.UserHasPermission(player.userID.ToString(), "coptortracker.use"))
            {
                SpawnChopper();
            }
            else
            {
                SendReply(player, "You Dont Have Permissions To Do This, Attempt Has Been Logged", "");
            }

        }

        #endregion

        #region Functions

        void StartChopperSpawnFreq()
        {
            TimerStart = DateTime.Now;
            TimerSpawn = TimerStart.AddSeconds(ChopperSpawnTime);
            timer.In(ChopperSpawnTime, () => SpawnChopper());
        }

        void SetChopperLifetimeMins()
        {
            ConsoleSystem.Run(ConsoleSystem.Option.Server, "heli.lifetimeminutes", new String[] { ChopperLifeTimeOriginal.ToString() });
        }

        void SpawnChopper()
        {
            SpawnedHeli = true;
            SetChopperLifetimeMins();
            ChopperLifeTimeCurrent = ChopperLifeTimeOriginal;
            BaseEntity entity = GameManager.server.CreateEntity("assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab", new Vector3(), new Quaternion(), true);
            if (!(bool)((UnityEngine.Object)entity))
                return;

            ChopperSpawned = DateTime.Now;
            entity.Spawn();

            StartChopperSpawnFreq();
        }

        void OnEntitySpawned(BaseNetworkable entity)
        {

            if (entity.name.Contains("patrolhelicopter.prefab"))
            {
                string thing = entity.PrefabName;
                switch (thing)
                {
                    case "patrolhelicopter.prefab":
                        if (SpawnedHeli == true)
                        {
                            BaseHelicopter Chopper = (BaseHelicopter)entity;
                            PrintToChat("<color=Red> [Coptor Tracker]</color>  Patrol Helicopter Has Spawned Look Out!!");
                            SpawnedHeli = false;
                        }
                        else
                        {
                            KillCoptor(entity);
                        }
                        break;
                }
            }
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            string Victim = "";
            if (entity.ShortPrefabName.Equals("patrolhelicopter.prefab"))
                Victim = "PatrolHeli";

            switch (Victim)
            {
                case "PatrolHeli":
                    var TimeNow = DateTime.Now;
                    var ChopLT = ChopperLifeTimeCurrent;
                    DateTime Duration = ChopperSpawned.AddMinutes(ChopLT);
                    TimeSpan l = Duration.Subtract(TimeNow);
                    if (l.Minutes <= 2)
                    {
                        ChopperLifeTimeCurrent = ChopperLifeTimeCurrent + 5;
                        ConsoleSystem.Run(ConsoleSystem.Option.Server, "heli.lifetimeminutes", new String[] { ChopperLifeTimeCurrent.ToString() });
                        PrintToChat("<color=Red> [Coptor Tracker]</color>  Helicopter Lifetime has been extended as has been engaged");
                    }

                    break;
            }
        }

        void KillCoptor(BaseNetworkable entity)
        {
            //ConsoleSystem.Broadcast("chat.add", 0, "<color=Red> [Coptor Tracker]</color>  Patrol Coptor Has been removed due to lack of something", 1);
            entity.Kill();
        }

        void KillCoptor()
        {
            int coptors = 0;
            BaseHelicopter[] allHelicopters = UnityEngine.Object.FindObjectsOfType<BaseHelicopter>();
            foreach (BaseHelicopter helicopter in allHelicopters)
            {
                helicopter.maxCratesToSpawn = 0;
                coptors++;
                helicopter.DieInstantly();
            }
            if 