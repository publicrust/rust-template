es", "Wounded"].ToString(); }
                else if (player.IsOnFire()) { result = Config["HomeMessages", "Fire"].ToString(); }
                else if (player.IsSwimming()) { result = Config["HomeMessages", "Swimming"].ToString(); }
                else if (!player.IsAlive()) { result = Config["HomeMessages", "Alive"].ToString(); }
                else if (!player.CanBuild() && Convert.ToBoolean(Config["HomeSettings", "TPInBlockedArea"])) { result = Config["HomeMessages", "BuildingBlocked"].ToString(); }
                else if (temperature < 0 && comfort <= 0 && !Convert.ToBoolean(Config["HomeSettings", "BypassCold"]))
                {
                    result = Config["HomeMessages", "TooCold"].ToString();
                    result = result.Replace("{temperature}", temperature.ToString());
                }
                else if (cantp != null) { if (cantp is string) { result = Convert.ToString(cantp); } else { result = Config["HomeMessages", "ExternalReason"].ToString(); } }
                else { result = tp_correct; } if (result.Length == 0) { result = Config["HomeMessages", "Failed"].ToString(); }
            }
            return result;
        }
        private string FindPlayerName(ulong userId)
        {
            BasePlayer player = BasePlayer.FindByID(userId);
            if (player) return player.displayName + " (Online)";

            player = BasePlayer.FindSleeping(userId);
            if (player) return player.displayName + " (Sleeping)";
            return "Unknown";
        }
        private void GetDeployedItemOwner(BasePlayer player, SleepingBag ditem)
        {
            SendReply(player, string.Format("Sleeping Bag '{0}': {1} - {2}", ditem.niceName.ToString(), FindPlayerName(ditem.deployerUserID), ditem.deployerUserID.ToString()));
        }
        private object FindOwnerBlock(BuildingBlock block)
        {
            if (BuildingOwners)
            {
                object returnhook = BuildingOwners?.Call("FindBlockData", block);

                if (returnhook != null)
                {
                    if (!(returnhook is bool))
                    {
                        ulong ownerid = Convert.ToUInt64(returnhook);
                        return ownerid;
                    }
                }
            }
            else
            {
                Puts("To be able to obtain the owner of a building you need to install the BuildingOwner plugin.");
            }
            return false;
        }
        protected override void LoadDefaultConfig()
        {
            // -- [ RESET ] ---

            Puts("No configuration file found, generating...");
            Config.Clear();

            // --- [ GENERAL ] ---

            Config["General", "PopulateDefaults"] = true;
            Config["General", "ShowPluginName"] = false;
            Config["General", "Protocol"] = Protocol.network;
            Config["General", "AuthLevel"] = 2;

            // --- [ DEPENDENCIES ] ---

            Config["Dependencies", "BuildingOwners"] = true;
            Config["Dependencies", "DeadPlayersList"] = true;
            Config["Dependencies", "PopupNotifications"] = false;

            // --- [ SETTINGS ] ---

            Config["Settings", "TPSleepGod"] = true;
            Config["Settings", "UpdateTimerInt"] = 10;
            Config["Settings", "MaxEntitiesPerBuilding"] = 2;
            Config["Settings", "BypassAdmin"] = false;
            Config["Settings", "EntityHeight"] = 2;
            Config["Settings", "RefundEntity"] = true;

            // --- [ TELEPORT SETTINGS ] ---

            Config["TPSettings", "Cooldown"] = 30;
            Config["TPSettings", "TPWait"] = 3;
            Config["TPSettings", "TPInBlockedArea"] = true;
            Config["TPSettings", "BypassCold"] = false;
            Config["TPSettings", "MinimumHealthCheck"] = 51.00;
            Config["TPSettings", "SanityCheck"] = true;

            // --- [ HOME SETTINGS ] ---

            Config["HomeSettings", "MaxHomes"] = 4;
            Config["HomeSettings", "Cooldown"] = 5;
            Config["HomeSettings", "TPWait"] = 8;
            Config["HomeSettings", "MinimumHealthCheck"] = 30.00;
            Config["HomeSettings", "SanityCheck"] = true;
            Config["HomeSettings", "TPInBlockedArea"] = true;
            Config["HomeSettings", "BypassCold"] = false;

            // --- [ COMMANDS ] ---

            Config["Commands", "Main"] = "t"; // Main Command
            Config["Commands", "Home"] = "home"; // Home Teleport
            Config["Commands", "CancelTeleport"] = "cancel"; // Cancel Teleport
            Config["Commands", "Public"] = "list"; // Public Teleports
            Config["Commands", "CreateTeleport"] = "create"; // Create Public Teleports - sub command
            Config["Commands", "RemoveTeleport"] = "remove";
            Config["Commands", "Entities"] = "entity";

            // --- [ MESSAGES ] ---

            Config["GeneralMessages", "Usage"] = "<color=#33CCFF>USAGE:</color> /" + Config["Commands", "Main"].ToString() + " <" + Config["Commands", "Home"].ToString() + " | " + Config["Commands", "Public"].ToString()+ " | " + Config["Commands", "CancelTeleport"].ToString() + ">";
            Config["GeneralMessages", "DBCleared"] = "You have <color=#FF3300>cleared</color> the Magic Homes database.";
            Config["GeneralMessages", "TeleportCancelled"] = "You have <color=#FF3300>cancelled</color> your teleport.";
            Config["GeneralMessages", "NoAuthLevel"] = "You <color=#FF3300>do not</color> have access to this command.";
            Config["GeneralMessages", "HomeDestroyed"] = "You have <color=#FF0000>destroyed</color> your home (<color=#FFFF00>{home}</color>).";
            Config["GeneralMessages", "MaxHomes"] = "You have reached your maximum allowed homes. ({max_homes})";
            Config["GeneralMessages", "SetupHome"] = "You have setup a new home! (Use /" + Config["Commands", "Main"].ToString() + " <" + Config["Commands", "Home"].ToString() + "> at any time).";
            Config["GeneralMessages", "NoHomes"] = "You have <color=red>no</color> homes.";
            Config["GeneralMessages", "NoTeleports"] = "There is currently <color=red>nowhere</color> to teleport to.";
            Config["GeneralMessages", "AdminCmd"] = "<color=yellow>ADMIN:</color> /{command} <{createtp} | {remove} | entity | clean>";
            Config["GeneralMessages", "TeleportInterrupted"] = "Your teleport has been <color=red>interrupted</color>...";
            Config["GeneralMessages", "HomeInfo"] = "[ <color=#33CCFF>{id}</color> ] <color=#FFFF00>{title}</color>, HP: <color=#FF0000>{hp}</color>.";
            Config["GeneralMessages", "TeleportInfo"] = "[ <color=#33CCFF>{id}</color> ] <color=yellow>Name:</color> {title}, <color=yellow>Description:</color> {description}. (<color=#33CCFF>{tpcount}</color>)";
            Config["GeneralMessages", "TPCooldown"] = "You are not currently allowed to teleport. (<color=#FF0000>{cooldown} second cooldown</color>).";
            Config["GeneralMessages", "TPHome"] = "You will be teleported to your home in <color=#FFFF00>{seconds}</color> seconds (<color=#FFFF00>{title}</color>).";
            Config["GeneralMessages", "TPGeneral"] = "You will be teleported to {title} in <color=#FFFF00>{seconds}</color> seconds (<color=#FFFF00>{tpcount}</color>).";
            Config["GeneralMessages", "HomeNoExist"] = "That home does <color=red>not</color> exist. [<color=#FFFF00>{id}</color>]";
            Config["GeneralMessages", "TPNoExist"] = "That teleport does <color=red>not</color> exist. [<color=#FFFF00>{id}</color>]";
            Config["GeneralMessages", "PlayerNoAwake"] = "You <color=red>cannot</color> attack someone who has not woken up from teleporting.";
            Config["GeneralMessages", "TeleportCreated"] = "Created teleport <color=#FF0000>{id}</color> at your current location!\nTitle: {title} : <color=yellow>Description:</color> {description},\n<color=yellow>Sleep God:</color> {sleepgod} | <color=yellow>Auth Level:</color> {authlevel} | Enabled: <color=yellow>{enabled}</color>.";
            Config["GeneralMessages", "CreateTeleport"] = "<color=yellow>USAGE:</color> /{command} {subcommand}\n<color=red>title</color> | <color=red>description</color> | <color=yellow>sleepgod</color> (<color=green>true</color>/<color=red>false</color>) | <color=yellow>authlevel</color> | <color=yellow>enabled</color> (<color=green>true</color>/<color=red>false</color>).";
            Config["GeneralMessages", "RemoveTeleport"] = "<color=yellow>USAGE:</color> /{command} {subcommand} <id>";
            Config["GeneralMessages", "TPCreationFailed"] = "<color=yellow>ERROR:</color> Failed to create teleport.";
            Config["GeneralMessages", "HomeTP"] = "<color=yellow>USAGE:</color> /{command} {subcommand} <id>.";
            Config["GeneralMessages", "PublicTP"] = "<color=yellow>USAGE:</color> /{command} {subcommand} <id>.";
            Config["GeneralMessages", "TeleportPending"] = "You already have a teleport <color=red>pending</color>.";
            Config["GeneralMessages", "TPRemoveSuccess"] = "<color=yellow>INFO:</color> You have removed the teleport: {id}!";

            // --- [ SUB MESSAGES ] ---

            Config["HomeMessages", "MinHP"] = "Your health <color=#FF0000>needs</color> to be above <color=#FF0000>{minhp}</color> to teleport home.";
            Config["HomeMessages", "Wounded"] = "You <color=#FF0000>can't</color> teleport home when you're <color=#FF0000>wounded</color>.";
            Config["HomeMessages", "Fire"] = "You <color=#FF0000>can't</color> teleport home when you're on <color=#FF0000>fire</color>.";
            Config["HomeMessages", "Swimming"] = "You <color=#FF0000>can't</color> teleport home when you're <color=#FF0000>swimming</color>.";
            Config["HomeMessages", "Alive"] = "You <color=#FF0000>can't</color> teleport home when you're not even <color=#FF0000>alive</color>.";
            Config["HomeMessages", "BuildingBlocked"] = "You <color=#FF0000>can't</color> teleport home when you're in a <color=#FF0000>building blocked</color> area.";
            Config["HomeMessages", "TooCold"] = "It's too <color=#FF0000>cold</color> to teleport. (<color=#00E1FF>{temperature}</color>)";
            Config["HomeMessages", "Failed"] = "<color=#FF0000>Failed</color> to teleport, contact an administrator.";
            Config["HomeMessages", "ExternalReason"] = "You <color=#FF0000>can't</color> teleport from here.";

            // --- [ OTHER ] ----

            SaveConfig();
        }
        int PopulateEntityData()
        {
            int r = 0;
            MTData.Entities.Clear();
            foreach (var entity in DEFAULT_HomeEntities)
            {
                HomeEntities z = new HomeEntities();
                z.bEnabled = true;
                z.tPrefab_name = entity.Key.ToString();
                z.tShortname = entity.Value.ToString();
                MTData.Entities.Add(z.tPrefab_name, z);
                SaveData();
                r++;
            }
            return r;
        }
        private void PrintToChatEx(BasePlayer player, string result, string tcolour = "#66FF66")
        {
            if (!Convert.ToBoolean(Config["Dependencies", "PopupNotifications"]))
            {
                if (Convert.ToBoolean(Config["General", "ShowPluginName"]))
                {
                    PrintToChat(player, "<color=\"" + tcolour + "\">[" + this.Title.ToString() + "]</color> " + result);
                }
                else
                {
                    PrintToChat(player, result);
                }
            }
            else
            {
                if (PopupNotifications)
                {
                    if (Convert.ToBoolean(Config["General", "ShowPluginName"]))
                    {
                        PopupNotifications?.Call("CreatePopupNotification", "<color=" + tcolour + ">" + this.Title.ToString() + "</color>\n" + result, player);
                    }
                    else
                    {
                        PopupNotifications?.Call("CreatePopupNotification", result, player);
                    }
                }
            }
        }
    }
}

// --- End of file: MagicTeleportation.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/mini-copter-options ---
// --- Original File Path: M/MiniCopterOptions/MiniCopterOptions.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Mini-Copter Options", "Pho3niX90", "2.5.1")]
    [Description("Provide a number of additional options for Mini-Copters, including storage and seats.")]
    internal class MiniCopterOptions : CovalencePlugin
    {
        #region Fields

        private readonly string minicopterPrefab = "assets/content/vehicles/minicopter/minicopter.entity.prefab";
        private readonly string storagePrefab = "assets/prefabs/deployable/hot air balloon/subents/hab_storage.prefab";
        private readonly string storageLargePrefab = "assets/content/vehicles/boats/rhib/subents/rhib_storage.prefab";
        private readonly string autoturretPrefab = "assets/prefabs/npc/autoturret/autoturret_deployed.prefab";
        private readonly string switchPrefab = "assets/prefabs/deployable/playerioents/simpleswitch/switch.prefab";
        private readonly string searchLightPrefab = "assets/prefabs/deployable/search light/searchlight.deployed.prefab";
        private readonly string flasherBluePrefab = "assets/prefabs/deployable/playerioents/lights/flasherlight/electric.flasherlight.deployed.prefab";
        private readonly string spherePrefab = "assets/prefabs/visualization/sphere.prefab";

        private const string resizableLootPanelName = "generic_resizable";
        private const int MinStorageCapacity = 6;
        private const int MaxStorageCapacity = 48;

        private static readonly Vector3 TurretSwitchPosition = new Vector3(0, 0.36f, 0.32f);

        private readonly object False = false;

        private Configuration config;
        private MiniCopterDefaults copterDefaults;
        private bool lastRanAtNight;
        private int setupTimeHooksAttempts;
        private TOD_Sky time;
        private float sunrise;
        private float sunset;
        private float lastNightCheck;
        private float[] stageFuelPerSec = new float[1];
        private float[] stageLiftFraction = new float[1];

        #endregion

        #region Hooks

        private void Init()
        {
            if (config.storageContainers > 3)
            {
                PrintWarning($"Storage Containers configuration value {config.storageContainers} exceeds the maximum, setting to 3.");
                config.storageContainers = 3;
            }
            else if (config.storageContainers < 0)
            {
                PrintWarning($"Storage Containers cannot be a negative value, setting to 0.");
                config.storageContainers = 0;
            }

            if (config.storageLargeContainers > 2)
            {
                PrintWarning($"Large Storage Containers configuration value {config.storageLargeContainers} exceeds the maximum, setting to 2.");
                config.storageLargeContainers = 2;
            }
            else if (config.storageLargeContainers < 0)
            {
                PrintWarning($"Large Storage Containers cannot be a negative value, setting to 0.");
                config.storageLargeContainers = 0;
            }

            if (config.largeStorageSize > MaxStorageCapacity)
            {
                PrintWarning($"Large Storage Containers Capacity configuration value {config.largeStorageSize} exceeds the maximum, setting to {MaxStorageCapacity}.");
                config.largeStorageSize = MaxStorageCapacity;
            }
            else if (config.largeStorageSize < MinStorageCapacity)
            {
                PrintWarning($"Storage Containers Capacity cannot be a smaller than {MinStorageCapacity}, setting to {MinStorageCapacity}.");
            }

            Unsubscribe(nameof(OnEntitySpawned));

            if (!config.autoturret)
            {
                Unsubscribe(nameof(OnTurretTarget));
            }
        }

        private void OnServerInitialized(bool init)
        {
            StoreMiniCopterDefaults();

            if (config.lightTail)
            {
                SetupTimeHooks();
            }

            if (!config.addSearchLight)
            {
                Unsubscribe(nameof(OnServerCommand));
            }

            foreach (var copter in BaseNetworkable.serverEntities.OfType<Minicopter>())
            {
                if (init)
                {
                    // Destroy problematic components immediately on server boot, since OnEntitySpawned will run changes on a delay.
                    foreach (var meshCollider in copter.GetComponentsInChildren<MeshCollider>())
                    {
                        UnityEngine.Object.DestroyImmediate(meshCollider);
                    }

                    foreach (var groundWatch in copter.GetComponentsInChildren<GroundWatch>())
                    {
                        UnityEngine.Object.DestroyImmediate(groundWatch);
                    }
                }

                OnEntitySpawned(copter);
            }

            Subscribe(nameof(OnEntitySpawned));
        }

        private void Unload()
        {
            if (config.lightTail && time != null)
            {
                time.Components.Time.OnHour -= OnHour;
            }

            // If the plugin is unloaded before OnServerInitialized() ran, don't revert minicopters to 0 values.
            if (copterDefaults != null)
            {
                foreach (var copter in BaseNetworkable.serverEntities.OfType<Minicopter>())
                {
                    if (config.restoreDefaults && CanModifyMiniCopter(copter))
                    {
                        RestoreMiniCopter(copter, config.reloadStorage);
                    }
                }
            }
        }

        private void OnEntitySpawned(Minicopter copter)
        {
            // Only add storage on spawn so we don't stack or mess with
            // existing player storage containers.
            ScheduleModifyMiniCopter(copter);
        }

        private void OnEntityKill(BaseNetworkable entity)
        {
            if (!config.dropStorage || !(entity is Minicopter))
                return;

            var containers = entity.GetComponentsInChildren<StorageContainer>();
            foreach (var container in containers)
            {
                container.DropItems();
            }

            var turrets = entity.GetComponentsInChildren<AutoTurret>();
            foreach (var turret in turrets)
            {
                turret.DropItems();
            }
        }

        private void OnSwitchToggled(ElectricSwitch electricSwitch, BasePlayer player)
        {
            var turret = electricSwitch.GetParentEntity() as AutoTurret;
            if (turret == null)
                return;

            var mini = turret.GetParentEntity() as Minicopter;
            if (mini == null)
            {
                // Ignore if the turret isn't on a mini, to avoid plugin conflicts.
                return;
            }

            if (electricSwitch.IsOn())
            {
                turret.SetFlag(IOEntity.Flag_HasPower, true);
                turret.InitiateStartup();
            }
            else
            {
                turret.SetFlag(IOEntity.Flag_HasPower, false);
                turret.InitiateShutdown();
            }
        }

        private object OnTurretTarget(AutoTurret turret, BaseCombatEntity target)
        {
            if (target == null)
                return null;

            var mini = turret.GetParentEntity() as Minicopter;
            if ((object)mini == null)
                return null;

            if (!config.autoTurretTargetsAnimals && target is BaseAnimalNPC)
                return False;

            var basePlayer = target as BasePlayer;
            if ((object)basePlayer != null)
            {
                if (!config.autoTurretTargetsNPCs && basePlayer.IsNpc)
                    return False;

                if (!config.autoTurretTargetsPlayers && basePlayer.userID.IsSteamId())
                    return False;

                if (basePlayer.InSafeZone() && (basePlayer.IsNpc || !basePlayer.IsHostile()))
                    return False;
            }

            return null;
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.cmd.FullName != "inventory.lighttoggle")
                return null;

            var player = arg.Player();
            if (player == null)
                return null;

            var mini = player.GetMountedVehicle() as Minicopter;
            if (mini == null)
                return null;

            if (!mini.IsDriver(player))
                return null;

            foreach (var child in mini.children)
            {
                var sphere = child as SphereEntity;
                if ((object)sphere == null)
                    continue;

                foreach (var grandChild in sphere.children)
                {
                    var light = grandChild as SearchLight;
                    if ((object)light == null)
                        continue;

                    light.SetFlag(IOEntity.Flag_HasPower, !light.IsPowered());

                    // Prevent other lights from toggling.
                    return False;
                }
            }

            return null;
        }

        private void OnEntityDismounted(BaseNetworkable entity, BasePlayer player)
        {
            if (config.flyHackPause > 0 && entity.GetParentEntity() is Minicopter)
            {
                player.PauseFlyHackDetection(config.flyHackPause);
            }
        }

        private void OnItemDeployed(Deployer deployer, StorageContainer container, BaseLock baseLock)
        {
            if (container == null || baseLock == null)
                return;

            var parent = container.GetParentEntity();
            if (parent == null || !(parent is Minicopter))
                return;

            if (container.PrefabName != storageLargePrefab)
                return;

            baseLock.transform.localPosition = new Vector3(0.0f, 0.3f, 0.298f);
            baseLock.transform.localRotation = Quaternion.Euler(new Vector3(0, 90, 0));
            baseLock.SendNetworkUpdateImmediate();
        }

        // When another plugin wants to modify a specific property, adjust the proposed value, using the delta between
        // the vanilla default and the configured value.
        private void OnMinicopterFuelPerSecChange(Plugin plugin, Minicopter copter, float[] fuelPerSec)
        {
            if (plugin.Name == nameof(MiniCopterOptions)
                || copterDefaults == null
                || config.fuelPerSec < 0
                || !CanModifyMiniCopter(copter))
                return;

            // For example, vanilla is 0.5, configured is 0.1, so multiply by 0.2.
            fuelPerSec[0] *= config.fuelPerSec / copterDefaults.fuelPerSec;
        }

        private void OnMinicopterLiftFractionChange(Plugin plugin, Minicopter copter, float[] liftFraction)
        {
            if (plugin.Name == nameof(MiniCopterOptions)
                || copterDefaults == null
                || config.liftFraction < 0
                || !CanModifyMiniCopter(copter))
                return;

            // For example, vanilla is 0.25, configured is 0.5, so multiply by 2.
            liftFraction[0] *= config.liftFraction / copterDefaults.liftFraction;
        }

        #endregion

        #region Exposed Hooks

        private static class ExposedHooks
        {
            public static object OnMiniCopterOptions(Minicopter copter)
            {
                return Interface.CallHook("OnMiniCopterOptions", copter);
            }

            public static object OnMinicopterFuelPerSecChange(Plugin plugin, Minicopter copter, float[] fuelPerSec)
            {
                return Interface.CallHook("OnMinicopterFuelPerSecChange", plugin, copter, fuelPerSec);
            }

            public static object OnMinicopterLiftFractionChange(Plugin plugin, Minicopter copter, float[] liftFraction)
            {
                return Interface.CallHook("OnMinicopterLiftFractionChange", plugin, copter, liftFraction);
            }
        }

        #endregion

        #region Helpers

        private bool IsNight()
        {
            if (time == null)
                return false;

            var hour = time.Cycle.Hour;
            return hour > sunset || hour < sunrise;
        }

        private void OnHour()
        {
            var hour = time.Cycle.Hour;
            var isNight = IsNight();

            //Puts($"OnHour: hour is now {hour}, and it is night {isNight}");
            if ((isNight == lastRanAtNight) || (lastNightCheck == hour))
                return;

            //Puts($"OnHour Called: Night:{isNight} LastRanAtNight:{lastRanAtNight}");
            lastNightCheck = hour;

            var minis = BaseNetworkable.serverEntities.OfType<Minicopter>().ToArray();
            //Puts($"OnHour Called: Minis to modify {minis.Count}");\
            foreach (var mini in minis)
            {
                var tailLight = mini.GetComponentInChildren<FlasherLight>();
                if (tailLight != null)
                {
                    tailLight.SetFlag(IOEntity.Flag_HasPower, isNight);
                }
            }

            lastRanAtNight ^= true;
        }

        private void SetupTimeHooks()
        {
            time = TOD_Sky.Instance;

            if (time == null)
            {
                if (setupTimeHooksAttempts++ >= 10)
                {
                    PrintError("Unable to detect time system. Tail light will not follow time of day.");;
                    return;
                }

                timer.Once(1, SetupTimeHooks);
                return;
            }

            sunrise = time.SunriseTime;
            sunset = time.SunsetTime;

            time.Components.Time.OnHour += OnHour;
        }

        private StorageContainer[] GetStorage(Minicopter copter)
        {
            return copter.GetComponentsInChildren<StorageContainer>()
                .Where(x => x.name == storagePrefab || x.name == storageLargePrefab)
                .ToArray();
        }

        private void AddLargeStorageBox(Minicopter copter)
        {
            if (config.storageLargeContainers == 1)
            {
                AddStorageBox(copter, storageLargePrefab, new Vector3(0.0f, 0.07f, -1.05f), Quaternion.Euler(0, 180f, 0));
            }
            else if (config.storageLargeContainers >= 2)
            {
                AddStorageBox(copter, storageLargePrefab, new Vector3(-0.48f, 0.07f, -1.05f), Quaternion.Euler(0, 180f, 0));
                AddStorageBox(copter, storageLargePrefab, new Vector3(0.48f, 0.07f, -1.05f), Quaternion.Euler(0, 180f, 0));
            }

        }

        private void AddRearStorageBox(Minicopter copter)
        {
            AddStorageBox(copter, storagePrefab, new Vector3(0, 0.75f, -1f));
        }

        private void AddSideStorageBoxes(Minicopter copter)
        {
            AddStorageBox(copter, storagePrefab, new Vector3(0.6f, 0.24f, -0.35f));
            AddStorageBox(copter, storagePrefab, new Vector3(-0.6f, 0.24f, -0.35f));
        }

        private void AddStorageBox(Minicopter copter, string prefab, Vector3 position)
        {
            AddStorageBox(copter, prefab, position, Quaternion.identity);
        }

        private void SetupStorage(StorageContainer box)
        {
            if (box.PrefabName.Equals(storageLargePrefab))
            {
                box.isLockable = config.largeStorageLockable;
                box.inventory.capacity = config.largeStorageSize;
                box.panelName = resizableLootPanelName;
            }
        }

        private void AddStorageBox(Minicopter copter, string prefab, Vector3 position, Quaternion rotation)
        {
            var box = GameManager.server.CreateEntity(prefab, position, rotation) as StorageContainer;
            if (box == null)
                return;

            box.Spawn();
            box.SetParent(copter);

            SetupStorage(box);
            box.SendNetworkUpdateImmediate();
        }

        private void SetupInvincibility(BaseCombatEntity entity)
        {
            entity._maxHealth = 99999999f;
            entity._health = 99999999f;
            entity.SendNetworkUpdate();
        }

        private void SetupTailLight(FlasherLight tailLight)
        {
            tailLight.pickup.enabled = false;
            DestroyGroundComp(tailLight);
            tailLight.SetFlag(IOEntity.Flag_HasPower, IsNight());
        }

        private void AddTailLight(Minicopter copter)
        {
            var tailLight = GameManager.server.CreateEntity(flasherBluePrefab, new Vector3(0, 1.2f, -2.0f), Quaternion.Euler(33, 180, 0)) as FlasherLight;
            if (tailLight == null)
                return;

            SetupTailLight(tailLight);
            tailLight.SetParent(copter);
            tailLight.Spawn();
            SetupInvincibility(tailLight);
        }

        private void SetupSphereEntity(SphereEntity sphereEntity)
        {
            sphereEntity.EnableSaving(true);
            sphereEntity.EnableGlobalBroadcast(false);
        }

        private void SetupSearchLight(SearchLight searchLight)
        {
            searchLight.pickup.enabled = false;
            DestroyMeshCollider(searchLight);
            DestroyGroundComp(searchLight);
        }

        private void AddSearchLight(Minicopter copter)
        {
            var sphereEntity = GameManager.server.CreateEntity(spherePrefab, new Vector3(0, -100, 0), Quaternion.identity) as SphereEntity;
            if (sphereEntity == null)
                return;

            SetupSphereEntity(sphereEntity);
            sphereEntity.SetParent(copter);
            sphereEntity.Spawn();

            var searchLight = GameManager.server.CreateEntity(searchLightPrefab, sphereEntity.transform.position) as SearchLight;
            if (searchLight == null)
                return;

            SetupSearchLight(searchLight);
            searchLight.Spawn();
            SetupInvincibility(searchLight);
            searchLight.SetFlag(BaseEntity.Flags.Reserved5, true);
            searchLight.SetFlag(BaseEntity.Flags.Busy, true);
            searchLight.SetParent(sphereEntity);
            searchLight.transform.localPosition = Vector3.zero;
            searchLight.transform.localRotation = Quaternion.Euler(-20, 180, 180);

            sphereEntity.currentRadius = 0.1f;
            sphereEntity.lerpRadius = 0.1f;
            sphereEntity.UpdateScale();
            sphereEntity.SendNetworkUpdateImmediate();

            timer.Once(3f, () =>
            {
                if (sphereEntity != null)
                {
                    sphereEntity.transform.localPosition = new Vector3(0, 0.24f, 1.8f);
                }
            });
        }

        private void SetupAutoTurret(AutoTurret turret)
        {
            turret.pickup.enabled = false;
            turret.sightRange = config.turretRange;
            DestroyMeshCollider(turret);
            DestroyGroundComp(turret);
        }

        private void AddTurret(Minicopter copter)
        {
            var turret = GameManager.server.CreateEntity(autoturretPrefab, new Vector3(0, 0, 2.47f)) as AutoTurret;
            if (turret == null)
                return;

            SetupAutoTurret(turret);
            turret.SetParent(copter);
            turret.Spawn();

            var player = BasePlayer.FindByID(copter.OwnerID);
            if (player != null)
            {
                turret.authorizedPlayers.Add(new ProtoBuf.PlayerNameID
                {
                    userid = player.userID,
                    username = player.displayName,
                });
                turret.SendNetworkUpdate();
            }

            AddSwitch(turret);
        }

        private void SetupSwitch(ElectricSwitch electricSwitch)
        {
            electricSwitch.pickup.enabled = false;
            DestroyMeshCollider(electricSwitch);
            DestroyGroundComp(electricSwitch);

            if (electricSwitch.HasParent())
            {
                var transform = electricSwitch.transform;
                if (transform.localPosition != TurretSwitchPosition)
                {
                    transform.localPosition = TurretSwitchPosition;
                    electricSwitch.InvalidateNetworkCache();
                    electricSwitch.SendNetworkUpdate_Position();
                }
            }
        }

        private void AddSwitch(AutoTurret turret)
        {
            var switchPosition = turret.transform.TransformPoint(TurretSwitchPosition);
            var switchRotation = turret.transform.rotation;

            var electricSwitch = GameManager.server.CreateEntity(switchPrefab, switchPosition, switchRotation) as ElectricSwitch;
            if (electricSwitch != null)
            {
                SetupSwitch(electricSwitch);
                electricSwitch.Spawn();
                SetupInvincibility(electricSwitch);

                // Spawning the switch at the desired world position and then parenting it, allows it to render correctly initially.
                electricSwitch.SetParent(turret, worldPositionStays: true);
            }
        }

        private void DestroyGroundComp(BaseEntity ent)
        {
            UnityEngine.Object.DestroyImmediate(ent.GetComponent<DestroyOnGroundMissing>());
            UnityEngine.Object.DestroyImmediate(ent.GetComponent<GroundWatch>());
        }

        private void DestroyMeshCollider(BaseEntity ent)
        {
            foreach (var mesh in ent.GetComponentsInChildren<MeshCollider>())
            {
                UnityEngine.Object.DestroyImmediate(mesh);
            }
        }

        private void RestoreMiniCopter(Minicopter copter, bool removeStorage = false)
        {
            if (copterDefaults != null)
            {
                var proposedFuelPerSec = copterDefaults.fuelPerSec;
                if (config.fuelPerSec >= 0 && CanModifyFuelPerSec(copter, ref proposedFuelPerSec))
                {
                    copter.fuelPerSec = proposedFuelPerSec;
                }

                var proposedLiftFraction = copterDefaults.liftFraction;
                if (config.liftFraction >= 0 && CanModifyLiftFraction(copter, ref proposedLiftFraction))
                {
                    copter.liftFraction = proposedLiftFraction;
                }

                if (config.torqueScalePitch >= 0)
                {
                    copter.torqueScale.x = copterDefaults.torqueScale.x;
                }

                if (config.torqueScaleYaw >= 0)
                {
                    copter.torqueScale.y = copterDefaults.torqueScale.y;
                }

                if (config.torqueScaleRoll >= 0)
                {
                    copter.torqueScale.z = copterDefaults.torqueScale.z;
                }
            }

            if (removeStorage)
            {
                foreach (var child in copter.children.FindAll(child => child.name == storagePrefab || child.name == storageLargePrefab || child.name == autoturretPrefab))
                {
                    child.Kill();
                }
            }
        }

        private void ModifyMiniCopter(Minicopter copter)
        {
            if (copterDefaults != null)
            {
                var proposedFuelPerSec = config.fuelPerSec;
                if (config.fuelPerSec >= 0 && CanModifyFuelPerSec(copter, ref proposedFuelPerSec))
                {
                    copter.fuelPerSec = proposedFuelPerSec;
                }

                var proposedLiftFraction = config.liftFraction;
                if (config.liftFraction >= 0 && CanModifyLiftFraction(copter, ref proposedLiftFraction))
                {
                    copter.liftFraction = proposedLiftFraction;
                }

                if (config.torqueScalePitch >= 0)
                {
                    copter.torqueScale.x = config.torqueScalePitch;
                }

                if (config.torqueScaleYaw >= 0)
                {
                    copter.torqueScale.y = config.torqueScaleYaw;
                }

                if (config.torqueScaleRoll >= 0)
                {
                    copter.torqueScale.z = config.torqueScaleRoll;
                }
            }

            // Override the inertia tensor since if the server had rebooted while there were attachments, it would have been snapshotted to an unreasonable value.
            // This is the vanilla amount while the prevent building object is inactive.
            // To determine this value, simply deactivate the prevent building object, call rigidBody.ResetInertiaTensor(), then print the value.
            copter.rigidBody.inertiaTensor = new Vector3(407.1f, 279.6f, 173.2f);

            if (config.autoturret)
            {
                // Setup existing turret, or add a new one.
                var turret = copter.GetComponentInChildren<AutoTurret>();
                if (turret != null)
                {
                    SetupAutoTurret(turret);

                    // Setup existing switch, but don't add a new one.
                    var turretSwitch = turret.GetComponentInChildren<ElectricSwitch>();
                    if (turretSwitch != null)
                    {
                        SetupSwitch(turretSwitch);
                    }
                }
                else
                {
                    AddTurret(copter);
                }
            }

            var existingStorage = GetStorage(copter);
            if (existingStorage.Length > 0)
            {
                // Existing storage found, update its state and don't add any more storage.
                foreach (var storage in existingStorage)
                {
                    SetupStorage(storage);
                }
            }
            else
            {
                // Add storage since none was found.
                AddLargeStorageBox(copter);

                switch (config.storageContainers)
                {
                    case 1:
                        AddRearStorageBox(copter);
                        break;
                    case 2:
                        AddSideStorageBoxes(copter);
                        break;
                    case 3:
                        AddRearStorageBox(copter);
                        AddSideStorageBoxes(copter);
                        break;
                }
            }

            if (config.addSearchLight)
            {
                // Setup existing search light, or add a new one.
                var searchLight = copter.GetComponentInChildren<SearchLight>();
                if (searchLight != null)
                {
                    SetupSearchLight(searchLight);
                    SetupInvincibility(searchLight);

                    var sphereEntity = searchLight.GetParentEntity() as SphereEntity;
                    if (sphereEntity != null)
                    {
                        SetupSphereEntity(sphereEntity);
                    }
                }
                else
                {
                    AddSearchLight(copter);
                }
            }

            if (config.lightTail)
            {
                // Setup existing tail light, or add a new one.
                var tailLight = copter.GetComponentInChildren<FlasherLight>();
                if (tailLight != null)
                {
                    SetupTailLight(tailLight);
                    SetupInvincibility(tailLight);
                }
                else
                {
                    AddTailLight(copter);
                }
            }
        }

        private bool CanModifyMiniCopter(Minicopter copter)
        {
            var hookResult = ExposedHooks.OnMiniCopterOptions(copter);
            if (hookResult is bool && !(bool)hookResult)
                return false;

            return true;
        }

        private bool CanModifyFuelPerSec(Minicopter copter, ref float proposedFuelPerSec)
        {
            stageFuelPerSec[0] = proposedFuelPerSec;

            var hookResult = ExposedHooks.OnMinicopterFuelPerSecChange(this, copter, stageFuelPerSec);
            if (hookResult is bool && !(bool)hookResult)
                return false;

            proposedFuelPerSec = stageFuelPerSec[0];
            return true;
        }

        private bool CanModifyLiftFraction(Minicopter copter, ref float proposedLiftFraction)
        {
            stageLiftFraction[0] = proposedLiftFraction;

            var hookResult = ExposedHooks.OnMinicopterLiftFractionChange(this, copter, stageLiftFraction);
            if (hookResult is bool && !(bool)hookResult)
                return false;

            proposedLiftFraction = stageLiftFraction[0];
            return true;
        }

        private void ScheduleModifyMiniCopter(Minicopter copter)
        {
            // Delay to allow plugins to detect the Mini and save its ID so they can block modification via hooks.
            NextTick(() =>
            {
                if (copter == null || copter.IsDestroyed)
                    return;

                if (!CanModifyMiniCopter(copter))
                    return;

                ModifyMiniCopter(copter);
            });
        }

        private void StoreMiniCopterDefaults()
        {
            var copter = GameManager.server.FindPrefab(minicopterPrefab)?.GetComponent<Minicopter>();
            if (copter == null)
                return;

            //Puts($"Defaults for copters saved as \nfuelPerSecond = {copter.fuelPerSec}\nliftFraction = {copter.liftFraction}\ntorqueScale = {copter.torqueScale}");
            copterDefaults = new MiniCopterDefaults
            {
                fuelPerSec = copter.fuelPerSec,
                liftFraction = copter.liftFraction,
                torqueScale = copter.torqueScale
            };
        }

        #endregion

        #region Configuration

        private class MiniCopterDefaults
        {
            public float fuelPerSec;
            public float liftFraction;
            public Vector3 torqueScale;
        }

        private class Configuration : SerializableConfiguration
        {
            // Populated with Rust defaults.
            [JsonProperty("Fuel per Second")]
            public float fuelPerSec = 0.5f;

            [JsonProperty("Lift Fraction")]
            public float liftFraction = 0.25f;

            [JsonProperty("Pitch Torque Scale")]
            public float torqueScalePitch = 400f;

            [JsonProperty("Yaw Torque Scale")]
            public float torqueScaleYaw = 400f;

            [JsonProperty("Roll Torque Scale")]
            public float torqueScaleRoll = 200f;

            [JsonProperty("Storage Containers")]
            public int storageContainers = 0;

            [JsonProperty("Large Storage Containers")]
            public int storageLargeContainers = 0;

            [JsonProperty("Restore Defaults")]
            public bool restoreDefaults = true;

            [JsonProperty("Reload Storage")]
            public bool reloadStorage = false;

            [JsonProperty("Drop Storage Loot On Death")]
            public bool dropStorage = true;

            [JsonProperty("Large Storage Lockable")]
            public bool largeStorageLockable = true;

            [JsonProperty("Large Storage Size (Max 48)")]
            public int largeStorageSize = 48;

            [JsonProperty("Large Storage Size (Max 42)")]
            public int largeStorageSizeDeprecated {
                set { largeStorageSize = value; }
            }

            [JsonProperty("Seconds to pause flyhack when dismount from heli.")]
            public int flyHackPause = 1;

            [JsonProperty("Add auto turret to heli")]
            public bool autoturret = false;

            [JsonProperty("Auto turret targets players")]
            public bool autoTurretTargetsPlayers = true;

            [JsonProperty("Auto turret targets NPCs")]
            public bool autoTurretTargetsNPCs = true;

            [JsonProperty("Auto turret targets animals")]
            public bool autoTurretTargetsAnimals = true;

            [JsonProperty("Mini Turret Range (Default 30)")]
            public float turretRange = 30f;

            [JsonProperty("Light: Add Searchlight to heli")]
            public bool addSearchLight = true;

            [JsonProperty("Light: Add Nightitme Tail Light")]
            public bool lightTail = false;
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #region Configuration Helpers

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion

        #endregion
    }
}


// --- End of file: MiniCopterOptions.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/mini-trails ---
// --- Original File Path: M/MiniTrails/MiniTrails.cs ---

/*
                   
                  
                  
               
        
                 
                        
                                  
 Contact Salsa#7717 on Discord for programming/business inquiries
*/

using System.Collections.Generic;
using System.Collections;
using Oxide.Game.Rust.Libraries;
using Newtonsoft.Json;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Plugins;
using System;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Mini Trails", "Salsa", "2.1.4")]
    [Description("Draws trails behind minicopters")]
    class MiniTrails : RustPlugin
    {
        #region Fields

        private static Data data;
        private Dictionary<ulong, MiniT> MountedMinis = new Dictionary<ulong, MiniT>();

        private const string SnowballGunEnt = "assets/prefabs/misc/xmas/snowballgun/snowballgun.entity.prefab";
        private const string AnchorEnt      = "assets/prefabs/visualization/sphere.prefab"; // Looking for invisible alternative
        private const string FlameEnt       = "assets/prefabs/weapons/flamethrower/flamethrower.entity.prefab";
        private const string WooshSound     = "assets/prefabs/npc/patrol helicopter/effects/rocket_fire.prefab";
        private const string SupplyEnt      = "assets/prefabs/tools/supply signal/grenade.supplysignal.deployed.prefab";
        private const string FireworkEnt    = "assets/prefabs/deployable/fireworks/volcanofirework-red.prefab";

        private const string PermUse = "minitrails.use";

        #endregion

        #region Configuration

        private enum trailType
        {
            fire,
            snow, // not working properly
            pink,
            firework
        }

        private class Preferences
        {
            public bool active = false;

            public int count = 1;

            public trailType type = trailType.fire;

            public Preferences() { }
        }

        private class Data
        {
            public Dictionary<ulong, Preferences> preferences = new Dictionary<ulong, Preferences>();

            public Data() { }
        }

        #endregion

        #region Hooks

        private void OnEntityMounted(BaseMountable mountable, BasePlayer player)
        {
            var mini = mountable.GetComponentInParent<BaseVehicle>() ?? null;
            if (mini == null || 
                !(mini is Minicopter) ||
                mini.mountPoints[0].mountable != mountable ||
                !permission.UserHasPermission(player.UserIDString, PermUse)) return;

            mini.OwnerID = player.userID;
            if (MountedMinis.ContainsKey(player.userID))
                MountedMinis.Remove(player.userID);

            MountedMinis.Add(player.userID, new MiniT(mini, player));
        }

        private void OnEntityDismounted(BaseMountable mountable, BasePlayer player)
        {
            var mini = mountable.GetComponentInParent<Minicopter>() ?? null;
            if (mini == null || !MountedMinis.ContainsKey(player.userID)) return;

            try
            {
                MountedMinis[player.userID].clearTrail();
                MountedMinis.Remove(player.userID);
            }
            catch { }

        }

        private void OnEntityKill(Minicopter mini)
        {
            if (!MountedMinis.ContainsKey(mini.OwnerID) || !data.preferences.ContainsKey(mini.OwnerID)) return;
            if (!data.preferences[mini.OwnerID].active) return;
            MountedMinis[mini.OwnerID].clearTrail();
            MountedMinis.Remove(mini.OwnerID);
        }

        private void OnServerSave() => Interface.Oxide.DataFileSystem.WriteObject(Name, data);

        private void Unload()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, data);
            data = null;
        }

        private void Init()
        {
            data = Interface.Oxide.DataFileSystem.ReadObject<Data>(Name);
            if (data == null)
            {
                data = new Data();
                Interface.Oxide.DataFileSystem.WriteObject(Name, data);
            }

            permission.RegisterPermission(PermUse, this);
        }

        #endregion

        private class MiniT // A mini with a trail
        {
            public BaseVehicle mini;
            public BasePlayer driver;
            public List<BaseEntity> anchors = new List<BaseEntity>();
            public List<BaseEntity> trails = new List<BaseEntity>();

            private void spawnFlame(string prefab, Vector3 localPos, Quaternion localRotation)
            {
                BaseEntity trail = GameManager.server.CreateEntity(prefab, mini.transform.position, new Quaternion());
                if (trail == null) return;

                if (data.preferences[driver.userID].type == trailType.snow)
                    trails.Add(trail);

                BaseEntity anchor = GameManager.server.CreateEntity(AnchorEnt, mini.transform.position, new Quaternion(0, 0, 0, 0), true);
                if (anchor == null) return;

                anchor.SetParent(mini);
                anchor.Spawn();
                anchor.transform.localPosition = localPos;
                anchor.transform.localRotation = localRotation;

                trail.SetParent(anchor);
                trail.Spawn();

                trail.SendNetworkUpdateImmediate(true);

                anchors.Add(anchor);
            }

            private void spawnSupplySignal(string prefab, Vector3 localPos, Quaternion localRotation)
            {
                BaseEntity trail = GameManager.server.CreateEntity(prefab, mini.transform.position);
                if (trail == null) return;

                trail.SetParent(mini);
                trail.transform.localPosition = localPos;
                trail.transform.localRotation = localRotation;
                trail.GetComponent<Rigidbody>().useGravity = false;
                trail.GetComponent<Rigidbody>().isKinematic = true;

                trail.Spawn();

                {
                    SupplySignal ss = trail as SupplySignal;

                    ss.CancelInvoke(ss.Explode);
                    ss.Invoke(() =>
                    {
                        ss.SetFlag(BaseEntity.Flags.On, true);
                        ss.SendNetworkUpdateImmediate();
                    }, 0);
                }

                trails.Add(trail);
            }

            private void spawnFirework(string prefab, Vector3 localPos, Quaternion localRotation)
            {

                BaseFirework fw = GameManager.server.CreateEntity(prefab) as BaseFirework;
                if (fw == null) return;

                fw.SetParent(mini);
                fw.transform.localPosition = localPos;
                fw.transform.localRotation = localRotation;

                fw.fuseLength = 0;
                fw.activityLength = 5000;
                fw.Ignite(fw.transform.position);

                fw.Spawn();
                trails.Add(fw);
            }

            public void spawnTrail()
            {
                switch (data.preferences[driver.userID].type)
                {
                    case trailType.fire:
                        switch (data.preferences[driver.userID].count)
                        {
                            case 1:
                                spawnFlame(FlameEnt, new Vector3(0.0f, 0.8f, -1.0f), Quaternion.Euler(0, -75, 0));
                                break;
                            case 2:
                                spawnFlame(FlameEnt, new Vector3(0.0f, 0.8f, -1.0f), Quaternion.Euler(0, -105, 0));
                                spawnFlame(FlameEnt, new Vector3(0.0f, 0.8f, -1.0f), Quaternion.Euler(0, -45, 0));
                                break;
                            case 3:
                                spawnFlame(FlameEnt, new Vector3(0.0f, 0.8f, -1.0f), Quaternion.Euler(0, -105, 0));
                                spawnFlame(FlameEnt, new Vector3(0.0f, 0.8f, -1.0f), Quaternion.Euler(0, -75, 0));
                                spawnFlame(FlameEnt, new Vector3(0.0f, 0.8f, -1.0f), Quaternion.Euler(0, -45, 0));
                                break;
                            default:
                                break;
                        }
                        break;

                    case trailType.snow:
                        switch (data.preferences[driver.userID].count)
                        {
                            case 1:
                                spawnFlame(SnowballGunEnt, new Vector3(0.0f, 1.5f, -1.0f), Quaternion.Euler(0f, -75, 0));
                                break;
                            case 2:
                                spawnFlame(SnowballGunEnt, new Vector3(0.0f, 0.8f, -1.0f), Quaternion.Euler(0, -105, 0));
                                spawnFlame(SnowballGunEnt, new Vector3(0.0f, 0.8f, -1.0f), Quaternion.Euler(0, -45, 0));
                                break;
                            case 3:
                                spawnFlame(SnowballGunEnt, new Vector3(0.0f, 0.8f, -1.0f), Quaternion.Euler(0f, -105, 0));
                                spawnFlame(SnowballGunEnt, new Vector3(0.0f, 0.8f, -1.0f), Quaternion.Euler(0f, -75, 0));
                                spawnFlame(SnowballGunEnt, new Vector3(0.0f, 0.8f, -1.0f), Quaternion.Euler(0f, -45, 0));
                                break;
                            default:
                                break;
                        }
                        break;

                    case trailType.pink:
                        spawnSupplySignal(SupplyEnt, new Vector3(0, 0.8f, -2), Quaternion.Euler(-90, 0, 0));
                        break;

                    case trailType.firework:
                        switch (data.preferences[driver.userID].count)
                        {
                            case 1:
                                spawnFirework(FireworkEnt, new Vector3(0, 0.8f, -2), Quaternion.Euler(-90, 0, 0));
                                break;
                            case 2:
                                spawnFirework(FireworkEnt, new Vector3(0, 0.8f, -2), Quaternion.Euler(-90, -30, 0));
                                spawnFirework(FireworkEnt, new Vector3(0, 0.8f, -2), Quaternion.Euler(-90, 30, 0));
                                break;
                            case 3:
                                spawnFirework(FireworkEnt, new Vector3(0, 0.8f, -2), Quaternion.Euler(-90, -30, 0));
                                spawnFirework(FireworkEnt, new Vector3(0, 0.8f, -2), Quaternion.Euler(-90, 0, 0));
                                spawnFirework(FireworkEnt, new Vector3(0, 0.8f, -2), Quaternion.Euler(-90, 30, 0));
                                break;
                            default:
                                break;
                        }
                        break;

                }

                Effect.server.Run(WooshSound, mini.transform.position + new Vector3(0.0f, 0.9f, -2.0f));
            }

            public void clearTrail()
            {
                switch (data.preferences[driver.userID].type)
                {
                    case trailType.fire:
                        foreach (BaseEntity s in anchors)
                            if (s != null) s.Kill();
                        anchors.Clear();
                        break;

                    case trailType.snow:
                        foreach (BaseEntity s in anchors)
                            if (s != null) s.Kill();
                        anchors.Clear();
                        //looper.Destroy();
                        break;

                    case trailType.firework:
                        foreach (BaseEntity t in trails)
                            if (t != null) t.Kill();
                        trails.Clear();
                        break;

                    case trailType.pink:
                        trails[0].Kill();
                        trails.Clear();
                        break;

                }
            }

            public MiniT(BaseVehicle _mini, BasePlayer _player)
            {
                mini = _mini;
                driver = _player;
                if (data.preferences.ContainsKey(_player.userID))
                    if (data.preferences[_player.userID].active)
                        spawnTrail();
            }
        }

        [ChatCommand("trail")]
        private void cmdTrail(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermUse))
            {
                SendChatMessage(player, lang.GetMessage("NoPerm", this, player.UserIDString));
                return;
            }

            if (!data.preferences.ContainsKey(player.userID))
                data.preferences.Add(player.userID, new Preferences());

            if (args.Length == 0)
            {
                if (data.preferences[player.userID].active)
                {
                    data.preferences[player.userID].active = false;
                    if (MountedMinis.ContainsKey(player.userID))
                        MountedMinis[player.userID].clearTrail();

                    SendChatMessage(player, lang.GetMessage("TrailOff", this, player.UserIDString));
                }
                else
                {
                    data.preferences[player.userID].active = true;
                    if (MountedMinis.ContainsKey(player.userID))
                        MountedMinis[player.userID].spawnTrail();

                    SendChatMessage(player, lang.GetMessage("TrailOn", this, player.UserIDString));
                }

                return;
            }
            else if (args.Length == 1)
            {
                int newCount;
                try
                {
                    newCount = int.Parse(args[0]);
                    if (newCount > 0 && newCount < 4)
                    {
                        if (MountedMinis.ContainsKey(player.userID) && data.preferences[player.userID].active)
                            MountedMinis[player.userID].clearTrail();
                        data.preferences[player.userID].count = newCount;
                        if (MountedMinis.ContainsKey(player.userID) && data.preferences[player.userID].active)
                            MountedMinis[player.userID].spawnTrail();
                        SendChatMessage(player, lang.GetMessage("SetCount", this, player.UserIDString) + $" {args[0]}");
                    }
                    else
                    {
                        SendChatMessage(player, lang.GetMessage("InvalidTrailCount", this, player.UserIDString));
                        return;
                    }
                }

                catch (FormatException)
                {
                    trailType newType = data.preferences[player.userID].type;

                    switch (args[0].ToLower())
                    {
                        case "fire":
                            newType = trailType.fire;
                            SendChatMessage(player, lang.GetMessage("SetFire", this, player.UserIDString));
                            break;

                        case "snow":
                            newType = trailType.snow;
                            SendChatMessage(player, lang.GetMessage("SetSnow", this, player.UserIDString));
                            break;

                        case "pink":
                            newType = trailType.pink;
                            SendChatMessage(player, lang.GetMessage("SetPink", this, player.UserIDString));
                            break;

                        case "firework":
                            newType = trailType.firework;
                            SendChatMessage(player, lang.GetMessage("SetFirework", this, player.UserIDString));
                            break;

                        default:
                            SendChatMessage(player, lang.GetMessage("UnknownArg", this, player.UserIDString) + $" \"{args[0]}\"");
                            return;
                    }

                    if (MountedMinis.ContainsKey(player.userID) && data.preferences[player.userID].active)
                        MountedMinis[player.userID].clearTrail();
                    data.preferences[player.userID].type = newType;
                    if (MountedMinis.ContainsKey(player.userID) && data.preferences[player.userID].active)
                        MountedMinis[player.userID].spawnTrail();
                }
            }
            else SendChatMessage(player, lang.GetMessage("Syntax", this, player.UserIDString));
        }

        /*
        [ChatCommand("test")]
        private void cmdTest(BasePlayer player, string command, string[] args)
        {
        }
        */

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Prefix"] = "Mini Trails",
                ["Syntax"] =
                    "Invalid arguments\n" +
                    "<color=#00FF00>Usage:</color>\n" +
                    "/trail\t\t\t\t\t|   toggle trail\n" +
                    "/trail [1-3]\t\t\t\t|   set number of trails\n" +
                    "/trail [fire | snow | pink]\t|   set trail type",
                ["SetFire"] = "Trail set to fire",
                ["SetSnow"] = "Trail set to snow",
                ["SetPink"] = "Trail set to pink smoke",
                ["SetFirework"] = "Trail set to firework",
                ["UnknownArg"] = "Unknown argument",
                ["InvalidTrailCount"] = "Invalid number of trails. Must be between 1 and 3",
                ["SetCount"] = "Trail count set to",
                ["TrailOn"] = "Trail toggled on!",
                ["TrailOff"] = "Trail toggled off",
                ["NoPerm"] = "You do not have permission to use this command",
                ["MessageHeader"] = "<color=#c21111>Rustic Rejects</color>: "
            }, this);
        }

        void SendChatMessage(BasePlayer player, string msg) =>
            SendReply(player, lang.GetMessage("MessageHeader", this, player.UserIDString) + msg);
    }
}

// --- End of file: MiniTrails.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/master-switch ---
// --- Original File Path: M/MasterSwitch/MasterSwitch.cs ---

using CompanionServer;
using Facepunch;
using System;
using System.Collections.Generic;
using UnityEngine;
using WebSocketSharp;
using static BaseEntity;

namespace Oxide.Plugins
{
    [Info("Master Switch", "Lincoln", "1.1.0")]
    [Description("Toggle things on or off with a command.")]
    public class MasterSwitch : RustPlugin
    {
        private const float MaxValue = 500;
        private const float MinValue = 0f;
        private const string PermUse = "MasterSwitch.use";
        private float radius;
        private int requiredPower;
        private readonly List<Timer> doorTimerList = new List<Timer>();

        #region Permissions

        private void Init()
        {
            permission.RegisterPermission(PermUse, this);
        }

        #endregion

        #region Checks

        private bool HasPermission(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermUse))
            {
                player.ChatMessage(lang.GetMessage("NoPerm", this, player.UserIDString));
                return false;
            }

            return true;
        }

        private bool HasArgs(BasePlayer player, string[] args)
        {
            if (args == null || args.Length < 2 || !float.TryParse(args[1], out radius))
            {
                player.ChatMessage(lang.GetMessage("Syntax", this, player.UserIDString));
                return false;
            }

            return true;
        }

        private bool HasRadius(BasePlayer player, float radius)
        {
            if (radius <= MinValue || radius > MaxValue)
            {
                player.ChatMessage(lang.GetMessage("Radius", this, player.UserIDString));
                return false;
            }

            return true;
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LightTurnOn"] = "<color=#ffc34d>MasterSwitch</color>: {0} Lights/electric items turned on within a {1}f radius.",
                ["LightTurnOff"] = "<color=#ffc34d>MasterSwitch</color>: {0} Lights/electric items turned off within a {1}f radius.",
                ["DoorOpen"] = "<color=#ffc34d>MasterSwitch</color>: {0} Doors opened within a {1}f radius.",
                ["DoorClose"] = "<color=#ffc34d>MasterSwitch</color>: {0} Doors closed within a {1}f radius.",
                ["TurretStart"] = "<color=#ffc34d>MasterSwitch</color>: {0} Turrets started within a {1}f radius.",
                ["TurretStop"] = "<color=#ffc34d>MasterSwitch</color>: {0} Turrets stopped within a {1}f radius.",
                ["BearTrapArm"] = "<color=#ffc34d>MasterSwitch</color>: {0} Bear traps have been armed within a {1}f radius.",
                ["BearTrapDisArm"] = "<color=#ffc34d>MasterSwitch</color>: {0} Bear traps have been disarmed within a {1}f radius.",
                ["MineExplode"] = "<color=#ffc34d>MasterSwitch</color>: {0} Mines have exploded within a {1}f radius.",
                ["IgnitableLit"] = "<color=#ffc34d>MasterSwitch</color>: {0} Ignitables have been lit within a {1}f radius.",
                ["MachinesOn"] = "<color=#ffc34d>MasterSwitch</color>: {0} Fog/snow machines activated within a {1}f radius.",
                ["MachinesOff"] = "<color=#ffc34d>MasterSwitch</color>: {0} Fog/snow machines de-activated within a {1}f radius.",
                ["NoPerm"] = "<color=#ffc34d>MasterSwitch</color>: You do not have permissions to use this.",
                ["Syntax"] = "<color=#ffc34d>MasterSwitch</color>: Incorrect syntax. Example /ms <command> <radius>",
                ["Radius"] = "<color=#ffc34d>MasterSwitch</color>: Radius out of bounds, choose 1 - 500",
            }, this);
        }

        #endregion

        #region Unity

        private List<BaseEntity> FindBaseEntity(Vector3 pos, float radius)
        {
            var hits = Physics.SphereCastAll(pos, radius, Vector3.up);
            var entities = new List<BaseEntity>();
            foreach (var hit in hits)
            {
                var entity = hit.GetEntity()?.GetComponent<BaseEntity>();
                if (entity && !entities.Contains(entity))
                    entities.Add(entity);
            }

            return entities;
        }

        #endregion

        #region Commands

        [ChatCommand("ms")]
        private void ToggleCommand(BasePlayer player, string command, string[] args)
        {
            if (player == null || !HasPermission(player) || !HasArgs(player, args) || !HasRadius(player, radius)) return;

            var baseEntityList = FindBaseEntity(player.transform.position, radius);
            var entityCount = new List<string>();

            switch (args[0].ToLower())
            {
                case "open":
                    ToggleDoors(baseEntityList, entityCount, true);
                    player.ChatMessage(string.Format(lang.GetMessage("DoorOpen", this, player.UserIDString), entityCount.Count, radius));
                    break;

                case "timer":
                    Puts($"{doorTimerList.Count} active timers running.");
                    break;

                case "close":
                    ToggleDoors(baseEntityList, entityCount, false);
                    player.ChatMessage(string.Format(lang.GetMessage("DoorClose", this, player.UserIDString), entityCount.Count, radius));
                    break;

                case "on":
                    ToggleLightsAndDevices(baseEntityList, entityCount, true);
                    player.ChatMessage(string.Format(lang.GetMessage("LightTurnOn", this, player.UserIDString), entityCount.Count, radius));
                    break;

                case "off":
                    ToggleLightsAndDevices(baseEntityList, entityCount, false);
                    player.ChatMessage(string.Format(lang.GetMessage("LightTurnOff", this, player.UserIDString), entityCount.Count, radius));
                    break;

                case "start":
                    ToggleTurrets(baseEntityList, entityCount, true);
                    player.ChatMessage(string.Format(lang.GetMessage("TurretStart", this, player.UserIDString), entityCount.Count, radius));
                    break;

                case "stop":
                    ToggleTurrets(baseEntityList, entityCount, false);
                    player.ChatMessage(string.Format(lang.GetMessage("TurretStop", this, player.UserIDString), entityCount.Count, radius));
                    break;

                case "arm":
                    ToggleBearTraps(baseEntityList, entityCount, true);
                    player.ChatMessage(string.Format(lang.GetMessage("BearTrapArm", this, player.UserIDString), entityCount.Count, radius));
                    break;

                case "disarm":
                    ToggleBearTraps(baseEntityList, entityCount, false);
                    player.ChatMessage(string.Format(lang.GetMessage("BearTrapDisArm", this, player.UserIDString), entityCount.Count, radius));
                    break;

                case "ignite":
                    IgniteEntities(baseEntityList, entityCount);
                    player.ChatMessage(string.Format(lang.GetMessage("IgnitableLit", this, player.UserIDString), entityCount.Count, radius));
                    break;

                case "explode":
                    ExplodeEntities(baseEntityList, entityCount);
                    player.ChatMessage(string.Format(lang.GetMessage("MineExplode", this, player.UserIDString), entityCount.Count, radius));
                    break;

                case "activate":
                    ToggleMachines(baseEntityList, entityCount, true);
                    player.ChatMessage(string.Format(lang.GetMessage("MachinesOn", this, player.UserIDString), entityCount.Count, radius));
                    break;

                case "deactivate":
                    ToggleMachines(baseEntityList, entityCount, false);
                    player.ChatMessage(string.Format(lang.GetMessage("MachinesOff", this, player.UserIDString), entityCount.Count, radius));
                    break;

                default:
                    player.ChatMessage("Not a valid command type");
                    break;
            }
        }

        private void ToggleDoors(List<BaseEntity> entities, List<string> entityCount, bool open)
        {
            foreach (var entity in entities)
            {
                if (entity is Door door)
                {
                    if (door.IsOpen() == open) continue;
                    door.SetOpen(open);
                    entityCount.Add(door.ToString());
                }
                else if (entity is ProgressDoor progressDoor)
                {
                    if (open)
                    {
                        var doorTimer = timer.Every(0.1f, () =>
                        {
                            if (progressDoor == null) return;
                            progressDoor.AddEnergy(1f);
                            progressDoor.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                        });
                        doorTimerList.Add(doorTimer);
                    }
                    else
                    {
                        foreach (var timer in doorTimerList)
                        {
                            timer.Destroy();
                        }
                        doorTimerList.Clear();
                    }
                    entityCount.Add(progressDoor.ToString());
                }
            }
        }

        private void ToggleLightsAndDevices(List<BaseEntity> entities, List<string> entityCount, bool on)
        {
            foreach (var entity in entities)
            {
                if (entity is BaseOven baseOven)
                {
                    if (baseOven.IsOn() == on) continue;
                    if (on) baseOven.StartCooking();
                    else baseOven.StopCooking();
                    entityCount.Add(baseOven.ToString());
                }
                else if (entity is SirenLight sirenLight)
                {
                    if (sirenLight.IsPowered() == on) continue;
                    sirenLight.SetFlag(BaseEntity.Flags.Reserved8, on, true, true);
                    entityCount.Add(sirenLight.ToString());
                }
                else if (entity is CeilingLight ceilingLight)
                {
                    if (ceilingLight.IsOn() == on) continue;
                    ceilingLight.SetFlag(BaseEntity.Flags.On, on);
                    entityCount.Add(ceilingLight.ToString());
                }
                else if (entity is SearchLight searchLight)
                {
                    if (searchLight.IsPowered() == on) continue;
                    searchLight.SetFlag(BaseEntity.Flags.Reserved8, on, false, true);
                    searchLight.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    entityCount.Add(searchLight.ToString());
                }
                else if (entity is Candle candle)
                {
                    if (candle.IsOn() == on) continue;
                    candle.SetFlag(BaseEntity.Flags.On, on);
                    entityCount.Add(candle.ToString());
                }
                else if (entity is AdvancedChristmasLights christmasLights)
                {
                    if (christmasLights.IsPowered() == on) continue;
                    christmasLights.SetFlag(BaseEntity.Flags.Reserved8, on, false, true);
                    christmasLights.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    entityCount.Add(christmasLights.ToString());
                }
                else if (entity is FlasherLight flasherLight)
                {
                    if (flasherLight.IsPowered() == on || flasherLight.IsOn() == on) continue;
                    flasherLight.SetFlag(BaseEntity.Flags.Reserved8, on, false, true);
                    flasherLight.SetFlag(BaseEntity.Flags.On, on, false, true);
                    flasherLight.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    entityCount.Add(flasherLight.ToString());
                }
                else if (entity is SimpleLight simpleLight)
                {
                    if (simpleLight.IsOn() == on) continue;
                    simpleLight.SetFlag(BaseEntity.Flags.On, on, true);
                    simpleLight.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    entityCount.Add(simpleLight.ToString());
                }
                else if (entity is ElectricalHeater heater)
                {
                    if (heater.IsPowered() == on) continue;
                    heater.SetFlag(BaseEntity.Flags.Reserved8, on, false, true);
                    heater.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    entityCount.Add(heater.ToString());
                }
                else if (entity is FuelGenerator fuelGenerator)
                {
                    if (fuelGenerator.IsOn() == on) continue;
                    if (on)
                    {
                        fuelGenerator.currentEnergy = 40;
                        fuelGenerator.outputEnergy = 40;
                        fuelGenerator.fuelPerSec = 0f;
                        fuelGenerator.Init();
                        fuelGenerator.SetFlag(BaseEntity.Flags.On, true, true);
                        var itemDef = ItemManager.FindItemDefinition("lowgradefuel");
                        fuelGenerator.InvokeRepeating(fuelGenerator.UpdateCurrentEnergy, 0f, 1f);
                        fuelGenerator.inventory.AddItem(itemDef, 1);
                    }
                    else
                    {
                        fuelGenerator.SetFlag(BaseEntity.Flags.On, false, true);
                        fuelGenerator.Init();
                    }
                    fuelGenerator.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    entityCount.Add(fuelGenerator.ToString());
                }
                else if (entity is ElectricFurnaceIO electricFurnaceIO)
                {
                    var parentEntity = electricFurnaceIO.GetParentEntity();
                    if (parentEntity is ElectricOven electricOven)
                    {
                        if (on)
                        {
                            electricFurnaceIO.UpdateHasPower(electricFurnaceIO.PowerConsumption, 0);
                        }
                        else
                        {
                            electricFurnaceIO.UpdateHasPower(0, 0);
                        }
                        entityCount.Add(electricOven.ToString());
                    }
                }
                else if (entity is DeployableBoomBox boomBox)
                {
                    if (boomBox.IsOn() == on) continue;
                    boomBox.SetFlag(BaseEntity.Flags.On, on, true);
                    boomBox.SetFlag(BaseEntity.Flags.Reserved8, on, true, true);
                    boomBox.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    entityCount.Add(boomBox.ToString());
                }
                else if (entity is IndustrialConveyor conveyor)
                {
                    if (conveyor.IsOn() == on) continue;
                    conveyor.SetFlag(BaseEntity.Flags.Reserved8, on, false, true);
                    conveyor.SetFlag(BaseEntity.Flags.On, on, true);
                    conveyor.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    entityCount.Add(conveyor.ToString());
                }
                else if (entity is NeonSign neonSign)
                {
                    if (neonSign.IsOn() == on) continue;
                    neonSign.SetFlag(BaseEntity.Flags.On, on, true);
                    neonSign.SetFlag(BaseEntity.Flags.Reserved8, on, false, true);
                    if (on) neonSign.InvokeRepeating(neonSign.animationLoopAction, neonSign.animationSpeed, neonSign.animationSpeed);
                    else neonSign.CancelInvoke(neonSign.animationLoopAction);
                    neonSign.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    entityCount.Add(neonSign.ToString());
                }
                else if (entity is WaterPump waterPump)
                {
                    if (waterPump.IsOn() == on) continue;
                    waterPump.SetFlag(BaseEntity.Flags.On, on, true);
                    waterPump.SetFlag(BaseEntity.Flags.Reserved8, on, false, true);
                    waterPump.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    entityCount.Add(waterPump.ToString());
                }
                else if (entity is StrobeLight strobeLight)
                {
                    if (strobeLight.IsOn() == on) continue;
                    if (on) strobeLight.frequency = 20f;
                    strobeLight.SetFlag(BaseEntity.Flags.On, on, true);
                    strobeLight.SetFlag(BaseEntity.Flags.Reserved8, on, false, true);
                    strobeLight.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    entityCount.Add(strobeLight.ToString());
                }
                else if (entity is FishMount fishMount)
                {
                    if (on) Effect.server.Run("assets/prefabs/misc/decor_dlc/huntingtrophy_fish/effects/hunting-trophy-fish-song.prefab", fishMount.transform.position);
                    fishMount.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    entityCount.Add(fishMount.ToString());
                }
            }
        }


        private void ToggleTurrets(List<BaseEntity> entities, List<string> entityCount, bool on)
        {
            foreach (var entity in entities)
            {
                if (entity is AutoTurret turret)
                {
                    if (turret.IsOn() == on) continue;
                    if (on) turret.InitiateStartup();
                    else turret.InitiateShutdown();
                    entityCount.Add(turret.ToString());
                }
            }
        }

        private void ToggleBearTraps(List<BaseEntity> entities, List<string> entityCount, bool arm)
        {
            foreach (var entity in entities)
            {
                if (entity is BearTrap bearTrap)
                {
                    if (bearTrap.IsOn() == arm) continue;
                    if (arm) bearTrap.Arm();
                    else bearTrap.Fire();
                    entityCount.Add(bearTrap.ToString());
                }
            }
        }

        private void IgniteEntities(List<BaseEntity> entities, List<string> entityCount)
        {
            foreach (var entity in entities)
            {
                if (entity is BaseFirework firework && !firework.IsLit())
                {
                    firework.SetFlag(BaseEntity.Flags.OnFire, true, false, true);
                    firework.Invoke(firework.Begin, firework.fuseLength);
                    entityCount.Add(firework.ToString());
                }
                else if (entity is Igniter igniter)
                {
                    igniter.IgniteRange = 5f;
                    igniter.IgniteStartDelay = 0;
                    igniter.UpdateHasPower(1, 1);
                    igniter.SetFlag(BaseEntity.Flags.Reserved8, true, true, true);
                    entityCount.Add(igniter.ToString());
                }
                else if (entity is ConfettiCannon confettiCannon)
                {
                    confettiCannon.SetFlag(BaseEntity.Flags.OnFire, true, false, true);
                    confettiCannon.Ignite(confettiCannon.transform.position);
                    confettiCannon.DamagePerBlast = 0f;
                    confettiCannon.BlastCooldown = 0f;
                    entityCount.Add(confettiCannon.ToString());
                }
            }
        }

        private void ExplodeEntities(List<BaseEntity> entities, List<string> entityCount)
        {
            foreach (var entity in entities)
            {
                if (entity is Landmine landmine)
                {
                    landmine.Explode();
                    entityCount.Add(landmine.ToString());
                }
            }
        }

        private void ToggleMachines(List<BaseEntity> entities, List<string> entityCount, bool on)
        {
            foreach (var entity in entities)
            {
                if (entity is FogMachine fogMachine)
                {
                    if (fogMachine.IsOn() == on) continue;
                    if (on)
                    {
                        fogMachine.EnableFogField();
                        fogMachine.StartFogging();
                    }
                    else
                    {
                        fogMachine.FinishFogging();
                        fogMachine.DisableNozzle();
                    }
                    fogMachine.SetFlag(BaseEntity.Flags.On, on);
                    entityCount.Add(fogMachine.ToString());
                }
                else if (entity is SnowMachine snowMachine)
                {
                    if (snowMachine.IsOn() == on) continue;
                    if (on)
                    {
                        snowMachine.EnableFogField();
                        snowMachine.StartFogging();
                    }
                    else
                    {
                        snowMachine.FinishFogging();
                        snowMachine.DisableNozzle();
                    }
                    snowMachine.SetFlag(BaseEntity.Flags.On, on);
                    entityCount.Add(snowMachine.ToString());
                }
            }
        }

        #endregion
    }
}


// --- End of file: MasterSwitch.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/monuments-recycler ---
// --- Original File Path: M/MonumentsRecycler/MonumentsRecycler.cs ---

using UnityEngine;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;
using Rust;

namespace Oxide.Plugins
{
    [Info("Monuments Recycler", "Dana", "0.2.6")]
    [Description("Adds recyclers to monuments including the cargo ship.")]
    internal class MonumentsRecycler : RustPlugin
    {
        private bool _serverInitialized = false;
        private const string RecyclerPrefab = "assets/bundled/prefabs/static/recycler_static.prefab";
        private const string SmallOilRigKey = "oil_rig_small";
        private const string LargeOilRigKey = "large_oil_rig";
        private const string DomeKey = "dome_monument_name";
        const string FishingVillageLargePrefab = "assets/bundled/prefabs/autospawn/monument/fishing_village/fishing_village_a.prefab";
        const string FishingVillageSmallBPrefab = "assets/bundled/prefabs/autospawn/monument/fishing_village/fishing_village_b.prefab";
        const string FishingVillageSmallAPrefab = "assets/bundled/prefabs/autospawn/monument/fishing_village/fishing_village_c.prefab";

        private List<BaseEntity> _recyclers = new List<BaseEntity>();
		private SpawnData _domeSpawnData = new SpawnData(new Vector3(19.9f, 37.8f, 16.57f), new Vector3(0, 235, 0));
        private readonly Dictionary<string, SpawnData> _smallOilRigRecyclerPositions = new Dictionary<string, SpawnData>
        {
            {"3",  new SpawnData(new Vector3(21.01f, 22.5f, -30.8f),new Vector3(0, 180, 0) )},
            {"4",new SpawnData(new Vector3(32.1f, 27f, -34.5f),new Vector3(0, 270, 0)) }
        };
        private readonly Dictionary<string, SpawnData> _largeOilRigRecyclerPositions = new Dictionary<string, SpawnData>
        {
            {"4",  new SpawnData(new Vector3(20.57f, 27.1f, -44.52f),new Vector3(0, 0, 0) )},
            {"6",new SpawnData(new Vector3(-13.6f, 36.1f, -3.4f),new Vector3(0, 180, 0)) }
        };
        private readonly Dictionary<string, SpawnData> _fishingVillageRecyclerPositions = new Dictionary<string, SpawnData>
        {
            {"smallB", new SpawnData(new Vector3(-21f,0.3f,6.5f),new Vector3(0f,130f,0f)) },
            {"smallA", new SpawnData(new Vector3(-8.5f,2f,16.06067f),new Vector3(0,90f,0)) },
            {"large", new SpawnData(new Vector3(-20.7f,0.2f,-9.6f), new Vector3(0,45f,0)) }
        };
        private Configuration _config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Cargo Ship - Recycler Position - Front")]
            public bool RecyclerPositionFront = true;

            [JsonProperty(PropertyName = "Cargo Ship - Recycler Position - Back")]
            public bool RecyclerPositionBack = true;

            [JsonProperty(PropertyName = "Cargo Ship - Recycler Position - Bottom")]
            public bool RecyclerPositionBottom = true;

            [JsonProperty(PropertyName = "Large Oil Rig - Recycler Position - Level 4")]
            public bool LargeOilRigRecyclerPositionLevel4 = true;

            [JsonProperty(PropertyName = "Large Oil Rig - Recycler Position - Level 6")]
            public bool LargeOilRigRecyclerPositionLevel6 = true;

            [JsonProperty(PropertyName = "Small Oil Rig - Recycler Position - Level 3")]
            public bool SmallOilRigRecyclerPositionLevel3 = true;

            [JsonProperty(PropertyName = "Small Oil Rig - Recycler Position - Level 4")]
            public bool SmallOilRigRecyclerPositionLevel4 = true;

            [JsonProperty(PropertyName = "Fishing Village - Recycler - Large")]
            public bool FishingVillageRecyclerLarge { get; set; } = true;

            [JsonProperty(PropertyName = "Fishing Village - Recycler - Small A")]
            public bool FishingVillageRecyclerSmallA { get; set; } = true;

            [JsonProperty(PropertyName = "Fishing Village - Recycler - Small B")]
            public bool FishingVillageRecyclerSmallB { get; set; } = true;

            [JsonProperty(PropertyName = "Dome - Recycler")]
            public bool DomeRecycler = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                //if (_config != null && _serverInitialized)
                //{
                //    ShowRecyclers();
                //}
            }
            catch
            {
                PrintError("Loading default config! Error loading your config, it's corrupt!");
                LoadDefaultConfig();
            }

            if (_config == null)
            {
                LoadDefaultConfig();
            }

            SaveConfig();
            var pluginEnabled = _config.RecyclerPositionFront || _config.RecyclerPositionBack || _config.RecyclerPositionBottom ||
                                _config.LargeOilRigRecyclerPositionLevel4 || _config.LargeOilRigRecyclerPositionLevel6 ||
                                _config.SmallOilRigRecyclerPositionLevel3 || _config.SmallOilRigRecyclerPositionLevel4 ||
                                _config.DomeRecycler || _config.FishingVillageRecyclerLarge || _config.FishingVillageRecyclerSmallA
                                || _config.FishingVillageRecyclerSmallB;
            if (!pluginEnabled)
            {
                PrintWarning("No Recycler Position Found");
                Unsubscribe(nameof(OnEntitySpawned));
            }
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        Tuple<Vector3, Quaternion> GetCargoFrontPosition(Vector3 position, Quaternion rotation) => Tuple.Create(new Vector3(position.x - .2172264f, position.y + 9.574753f, position.z + 79.05922f), new Quaternion(rotation.x, rotation.y + 180, rotation.z, rotation.w));

        Tuple<Vector3, Quaternion> GetCargoBackPosition(Vector3 position, Quaternion rotation) => Tuple.Create(new Vector3(position.x + .2407f, position.y + 9.5f, position.z - 36.87305f), rotation);

        Tuple<Vector3, Quaternion> GetCargoBottomPosition(Vector3 position, Quaternion rotation) => Tuple.Create(new Vector3(position.x, position.y + .57767f, position.z + 10f), new Quaternion(rotation.x, rotation.y + 180, rotation.z, rotation.w));

        private void OnEntitySpawned(CargoShip ship)
        {
            if (ship == null) return;
            Vector3 pos = ship.transform.position;
            Quaternion rot = new Quaternion();
            Timer thisTimer = null;

            thisTimer = timer.Every(0.01f, () =>
            {
                if (ship == null || ship.IsDestroyed)
                {
                    thisTimer.Destroy();
                    return;
                }

                ship.transform.position = pos;
                ship.transform.rotation = rot;
            });

            timer.Once(3, () =>
            {
                if (ship == null || ship.IsDestroyed)
                {
                    return;
                }

                if (_config.RecyclerPositionFront)
                {
                    Vector3 position = ship.transform.position;
                    Quaternion rotation = ship.transform.rotation;
                    SpawnRecycler(ship, GetCargoFrontPosition(position, rotation));
                }

                if (_config.RecyclerPositionBack)
                {
                    Vector3 position = ship.transform.position;
                    Quaternion rotation = ship.transform.rotation;
                    SpawnRecycler(ship, GetCargoBackPosition(position, rotation));
                }

                if (_config.RecyclerPositionBottom)
                {
                    Vector3 position = ship.transform.position;
                    Quaternion rotation = ship.transform.rotation;
                    SpawnRecycler(ship, GetCargoBottomPosition(position, rotation));
                }

                thisTimer.Destroy();
            });
        }

        private void OnServerInitialized()
        {
            _serverInitialized = true;
            ShowRecyclers();
        }
        private void ShowRecyclers()
        {
            var oilRigEnabled = _config.LargeOilRigRecyclerPositionLevel4 || _config.LargeOilRigRecyclerPositionLevel6 ||
                               _config.SmallOilRigRecyclerPositionLevel3 || _config.SmallOilRigRecyclerPositionLevel4;
            var fishingVillageEnabled = _config.FishingVillageRecyclerLarge || _config.FishingVillageRecyclerSmallA || _config.FishingVillageRecyclerSmallB;
            if (oilRigEnabled)
            {

                SpawnData spawnData;
                var monuments = TerrainMeta.Path.Monuments?.Where(x => x.shouldDisplayOnMap && x.displayPhrase.english.Contains("Oil Rig")).ToList() ?? new List<MonumentInfo>();
                foreach (var monument in monuments)
                {
                    if (monument.displayPhrase?.token == SmallOilRigKey)
                    {
                        if (_config.SmallOilRigRecyclerPositionLevel3)
                        {
                            if (_smallOilRigRecyclerPositions.TryGetValue("3", out spawnData))
                            {
                                SpawnRecycler(monument.transform, spawnData.Position, spawnData.Rotation);
                            }
                        }
                        if (_config.SmallOilRigRecyclerPositionLevel4)
                        {
                            if (_smallOilRigRecyclerPositions.TryGetValue("4", out spawnData))
                            {
                                SpawnRecycler(monument.transform, spawnData.Position, spawnData.Rotation);
                            }
                        }
                    }
                    else if (monument.displayPhrase?.token == LargeOilRigKey)
                    {
                        if (_config.LargeOilRigRecyclerPositionLevel4)
                        {
                            if (_largeOilRigRecyclerPositions.TryGetValue("4", out spawnData))
                            {
                                SpawnRecycler(monument.transform, spawnData.Position, spawnData.Rotation);
                            }
                        }
                        if (_config.LargeOilRigRecyclerPositionLevel6)
                        {
                            if (_largeOilRigRecyclerPositions.TryGetValue("6", out spawnData))
                            {
                                SpawnRecycler(monument.transform, spawnData.Position, spawnData.Rotation);
                            }
                        }
                    }
                }
            }

            if (_config.DomeRecycler)
            {
                var monuments = TerrainMeta.Path.Monuments?.Where(x => x.shouldDisplayOnMap && x.displayPhrase.english.Contains("Dome")).ToList() ?? new List<MonumentInfo>();
                foreach (var monument in monuments)
                {
                    if (monument.displayPhrase?.token == DomeKey)
                    {
                        SpawnRecycler(monument.transform, _domeSpawnData.Position, _domeSpawnData.Rotation);
                    }
                }
            }
            if (fishingVillageEnabled)
            {
                SpawnData spawnData;
                var monuments = TerrainMeta.Path.Monuments?.Where(x => x.shouldDisplayOnMap && x.displayPhrase.english.ToLower().Contains("fishing")).ToList() ?? new List<MonumentInfo>();
                foreach (var monument in monuments)
                {
                    if (monument.name == FishingVillageLargePrefab)
                    {
                        if (_config.FishingVillageRecyclerLarge)
                        {
                            if (_fishingVillageRecyclerPositions.TryGetValue("large", out spawnData))
                            {
                                SpawnFishingVillageRecycler(monument.transform, spawnData.Position, spawnData.Rotation);
                            }
                        }
                    }
                    else if (monument.name == FishingVillageSmallAPrefab)
                    {
                        if (_config.FishingVillageRecyclerSmallA)
                        {
                            if (_fishingVillageRecyclerPositions.TryGetValue("smallA", out spawnData))
                            {
                                SpawnFishingVillageRecycler(monument.transform, spawnData.Position, spawnData.Rotation);
                            }
                        }
                    }
                    else if (monument.name == FishingVillageSmallBPrefab)
                    {
                        if (_config.FishingVillageRecyclerSmallB)
                        {
                            if (_fishingVillageRecyclerPositions.TryGetValue("smallB", out spawnData))
                            {
                                SpawnFishingVillageRecycler(monument.transform, spawnData.Position, spawnData.Rotation);
                            }
                        }
                    }
                }
            }
        }

        private void SpawnFishingVillageRecycler(Transform objTransform, Vector3 spawnOffset, Vector3 rotationOffset)
        {

            var mtx = objTransform.localToWorldMatrix;
            var finalPos = mtx.MultiplyPoint3x4(spawnOffset);
            var rotation = mtx.rotation * Quaternion.Euler(rotationOffset);
            var entity = GameManager.server.CreateEntity(RecyclerPrefab, finalPos, rotation);
            if (entity != null)
            {
                entity.EnableSaving(false);
                entity.Spawn();
                _recyclers.Add(entity);
            }
        }
        private void SpawnRecycler(Transform objTransform, Vector3 spawnOffset, Vector3 rotationOffset)
        {

            var mtx = objTransform.localToWorldMatrix;
            var finalPos = mtx.MultiplyPoint3x4(spawnOffset);
            var oilRot = mtx.rotation * Quaternion.Euler(rotationOffset);
            if (!GamePhysics.CheckSphere(finalPos, .1f, Layers.Server.Deployed, QueryTriggerInteraction.Ignore))
            {
                var entity = GameManager.server.CreateEntity(RecyclerPrefab, finalPos, oilRot);
                if (entity != null)
                {
                    entity.EnableSaving(false);
                    entity.Spawn();
                    _recyclers.Add(entity);
                }
            }
        }
        private void SpawnRecycler(CargoShip ship, Tuple<Vector3, Quaternion> selectedTransform)
        {
            BaseEntity rec = GameManager.server.CreateEntity(RecyclerPrefab, selectedTransform.Item1, selectedTransform.Item2, true);
            if (rec != null)
            {
                rec.EnableSaving(false);
                rec.Spawn();
                rec.SetParent(ship, true, true);
                Rigidbody comp = rec.GetComponent<Rigidbody>();
                if (comp)
                {
                    comp.isKinematic = true;
                }

                _recyclers.Add(rec);
            }
            else
            {
                Puts("Unable to create RecyclerPrefab for Front position!");
            }
        }

        private void Unload()
        {

            foreach (var recycler in _recyclers)
            {
                if (recycler is Recycler)
                {
                    ((Recycler)recycler).DropItems();
                }
                recycler.Kill();
            }
        }

        private class SpawnData
        {
            public SpawnData(Vector3 position, Vector3 rotation)
            {
                Position = position;
                Rotation = rotation;
            }

            public Vector3 Position { get; set; }
            public Vector3 Rotation { get; set; }
        }
    }
}

// --- End of file: MonumentsRecycler.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-cash-system-panel ---
// --- Original File Path: M/MagicCashSystemPanel/MagicCashSystemPanel.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Magic Cash System Panel", "MJSU", "1.0.3")]
    [Description("Displays players cash system currencies in MagicPanel")]
    public class MagicCashSystemPanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel, CashSystem;

        private PluginConfig _pluginConfig; //Plugin Config
        private string _textFormat;
        private int _currencyIndex;
        private List<string> _currencies = new List<string>();

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }

        private Coroutine _updateRoutine;
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _textFormat = _pluginConfig.Panel.Text.Text;
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 0.33f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/wMq70LyL/3HiDv4G.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.0f, 0.2f, 0.05f)
                },
                Text = new PanelText
                {
                    Enabled = config.Panel?.Text?.Enabled ?? true,
                    Color = config.Panel?.Text?.Color ?? "#FFFFFFFF",  
                    Order = config.Panel?.Text?.Order ?? 1,
                    Width = config.Panel?.Text?.Width ?? 0.67f,
                    FontSize = config.Panel?.Text?.FontSize ?? 14,
                    Padding = config.Panel?.Text?.Padding ?? new TypePadding(0.05f, 0.05f, 0.05f, 0.05f),
                    TextAnchor = config.Panel?.Text?.TextAnchor ?? TextAnchor.MiddleCenter,
                    Text = config.Panel?.Text?.Text ?? "{0}{1:0.00}",
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "leftmiddle",
                Order = config.PanelSettings?.Order ?? 1,
                Width = config.PanelSettings?.Width ?? 0.0625f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            MagicPanelRegisterPanels();
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                return;
            }
            
            if (CashSystem == null)
            {
                PrintError("Missing plugin dependency CashSystem: https://umod.org/plugins/cash-system");
                return;
            }
        
            MagicPanel?.Call("RegisterPlayerPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
            _currencies = CashSystem.Call<List<string>>("GetCurrencies");
            if (_currencies == null || _currencies.Count == 0)
            {
                PrintError("No CashSystem currencies detected. Please set them up and reload the plugin");
                return;
            }
            
            InvokeHandler.Instance.InvokeRepeating(UpdatePlayerCash, Random.Range(0, _pluginConfig.UpdateRate), _pluginConfig.UpdateRate);
        }

        private void Unload()
        {
            InvokeHandler.Instance.CancelInvoke(UpdatePlayerCash);
            if (_updateRoutine != null)
            {
                InvokeHandler.Instance.StopCoroutine(_updateRoutine);
            }
        }
        #endregion
        
        #region Player Cash Update
        private void UpdatePlayerCash()
        {
            _updateRoutine = InvokeHandler.Instance.StartCoroutine(HandleUpdatePlayerCash());
        }

        private IEnumerator HandleUpdatePlayerCash()
        {
            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                BasePlayer player = BasePlayer.activePlayerList[i];
                MagicPanel?.Call("UpdatePanel", player, Name, (int)UpdateEnum.Text);
                yield return null;
            }

            _currencyIndex = (_currencyIndex + 1) % _currencies.Count;
        }
        #endregion

        #region MagicPanel Hook
        private Hash<string, object> GetPanel(BasePlayer player)
        {
            Panel panel = _pluginConfig.Panel;
            PanelText text = panel.Text;
            if (text != null && _currencies.Count > 0)
            {
                string currency = _currencies[_currencyIndex];
                double amount = GetPlayerCash(player.userID, currency);
                text.Text = string.Format(_textFormat, currency, amount);
            }

            return panel.ToHash();
        }
        #endregion

        #region Helper Methods
        private double GetPlayerCash(ulong userId, string currency)
        {
            object checkedPoints = CashSystem?.Call("GetBalance", userId, currency);
            if (checkedPoints is double)
            {
                double val = (double)checkedPoints;
                if (double.IsNaN(val))
                {
                    return 0;
                }
            
                return val;
            }

            return 0;
        }
        #endregion

        #region Classes
        private class PluginConfig
        {
            [DefaultValue(5f)]
            [JsonProperty(PropertyName = "Panel Update Rate (Seconds)")]
            public float UpdateRate { get; set; }
            
            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            public PanelText Text { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                    [nameof(Text)] = Text.ToHash()
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class PanelText : PanelType
        {
            public string Text { get; set; }
            public int FontSize { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            public TextAnchor TextAnchor { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Text)] = Text;
                hash[nameof(FontSize)] = FontSize;
                hash[nameof(TextAnchor)] = TextAnchor;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }
            
            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicCashSystemPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/map-my-players ---
// --- Original File Path: M/MapMyPlayers/MapMyPlayers.cs ---

using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Convert = System.Convert;
using CompanionServer.Handlers;


namespace Oxide.Plugins
{
    [Info("Map My Players", "1AK1", "1.1.1")]
    [Description("Display all players positions with texted markers on ingame map (name/steamID/activ/sleepers) with autorefresh")]

    public class MapMyPlayers : RustPlugin
    {
        string Prefix = "[MMP] :";                       // CHAT PLUGIN PREFIX
        string PrefixColor = "#008000";                 // CHAT PLUGIN PREFIX COLOR
        ulong SteamIDIcon = 76561198190843170;          // SteamID FOR PLUGIN ICON

        bool debug = false;
        float refreshrate = 20;
        float MarkerRadius = 0.2f;
        bool ShowSteamID = false;

        const string MMPAdmin = "mapmyplayers.admin"; 

        bool ConfigChanged;
		private Timer mmptimer;

        public List<MapMarkerGenericRadius> PublicRadMarker = new List<MapMarkerGenericRadius>(); 
        public List<VendingMachineMapMarker> PublicVendMarker = new List<VendingMachineMapMarker>(); 
        public Dictionary<ulong, string> activplayers = new Dictionary<ulong, string>();
        public Dictionary<ulong, string> sleepplayers = new Dictionary<ulong, string>();
        public Dictionary<ulong, Vector3> playerspos = new Dictionary<ulong, Vector3>();

		private void Init()
        {
            LoadVariables();
            permission.RegisterPermission(MMPAdmin, this);
        }

#region CONFIG

    protected override void LoadDefaultConfig()
        {
            LoadVariables();
        }

        private void LoadVariables()
        {
            Prefix = Convert.ToString(GetConfig("Chat Settings", "Prefix", "[MMP] :"));                       // CHAT PLUGIN PREFIX
            PrefixColor = Convert.ToString(GetConfig("Chat Settings", "PrefixColor", "#008000"));                // CHAT PLUGIN PREFIX COLOR
            SteamIDIcon = Convert.ToUInt64(GetConfig("Chat Settings", "SteamIDIcon", "76561198190843170"));  
            refreshrate = Convert.ToSingle(GetConfig("Refresh Rate", "Value in seconds", "20"));
            MarkerRadius = Convert.ToSingle(GetConfig("Markers", "radius size (0.2 by default)", "0.2"));
            ShowSteamID = Convert.ToBoolean(GetConfig("Markers Label", "Show player steam ID", "false"));

            if (!ConfigChanged) return;
            SaveConfig();
            ConfigChanged = false;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                ConfigChanged = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                ConfigChanged = true;
            }
            return value;
        }

#endregion

        void Unload()
        {
            MarkerDisplayingDelete(null, null, null);
			if (mmptimer != null) mmptimer.Destroy();
        }

        object CanNetworkTo(MapMarkerGenericRadius marker, BasePlayer player)
        {
            if (!PublicRadMarker.Contains(marker))
            {
                return null;
            }

            if (player.IPlayer.HasPermission(MMPAdmin) && PublicRadMarker.Contains(marker))
            {
                return null;
            }

            return false;
        }

        object CanNetworkTo(VendingMachineMapMarker marker, BasePlayer player)
        {
            if (!PublicVendMarker.Contains(marker))
            {
                return null;
            }

            if (player.IPlayer.HasPermission(MMPAdmin) && PublicVendMarker.Contains(marker))
            {
                return null;
            }

            return false;
        }

        #region Lang messages

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"NoAdminPermMsg", "Not authorized to control this plugin."},
            }, this, "en");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"NoAdminPermMsg", "Vous n'tes pas autoris  contrler ce plugin."},
            }, this, "fr");
        }


#endregion

        void MarkerDisplayingDelete(BasePlayer player, string command, string[] args)
        { 
            foreach (var Rad in PublicRadMarker)
            {
                if (Rad != null)
                {
                    Rad.Kill();
                    Rad.SendUpdate();   
                }
            }
            if (debug) Puts($"-> DEL ALL RAD MARKER");
            foreach (var Vend in PublicVendMarker)
            {
                if (Vend != null) Vend.Kill();
            }
            if (debug) Puts($"-> DEL ALL VEND MARKER");
            PublicRadMarker.Clear();
            PublicVendMarker.Clear();         
        }

        private void ListPlayers()
        {
#region EACH ACTIV
            activplayers.Clear();
            playerspos.Clear();
            sleepplayers.Clear();
            foreach(BasePlayer player in BasePlayer.activePlayerList.ToList())
            {
                Vector3 pos;
                pos = player.transform.position;
                if (pos == null)
                {           
                    if (debug){Puts($"-> MY MARKER Position update ERROR for {player.UserIDString}");}
                    return;
                }
                string playername = player.displayName.ToString();
                if (playername.Length > 16){playername = playername.Substring(0,16);}
                activplayers.Remove(player.userID);
                activplayers.Add(player.userID, playername);
                playerspos.Remove(player.userID);
                playerspos.Add(player.userID, pos);
            }
#endregion

 #region EACH SLEEPER

            foreach(BasePlayer player in BasePlayer.sleepingPlayerList.ToList())
            {
                Vector3 pos;
                pos = player.transform.position;
                if (pos == null)
                {           
                    if (debug){Puts($"-> MY MARKER Position update ERROR SLEEPER for {player.UserIDString}");}
                    return;
                }
                string playername = player.displayName.ToString();
                if (playername.Length > 16){playername = playername.Substring(0,16);}
                sleepplayers.Remove(player.userID);
                sleepplayers.Add(player.userID, playername);
                playerspos.Remove(player.userID);
                playerspos.Add(player.userID, pos);
            }
#endregion

        }

        [ChatCommand("mmp_stop")] 
        private void MapMyCommandStop(BasePlayer player, string command, string[] args)
        {
            bool isadmin = permission.UserHasPermission(player.UserIDString, MMPAdmin);
            if (isadmin == false)
            {
                Player.Message(player, $"{lang.GetMessage("NoAdminPermMsg", this, player.UserIDString)}",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                return;
            }
            //chat stop
            MarkerDisplayingDelete(null, null, null);
			if (mmptimer != null){mmptimer.Destroy();}

        }

        [ChatCommand("mmp_show")]
        private void MapMyCommand(BasePlayer player, string command, string[] args)
        {
            bool isadmin = permission.UserHasPermission(player.UserIDString, MMPAdmin);
            if (isadmin == false)
            {
                Player.Message(player, $"{lang.GetMessage("NoAdminPermMsg", this, player.UserIDString)}",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                return;
            }
            if (debug) Puts($"-> REFRESH RATE IS {refreshrate}");
            //chat show
            GenerateMarkers();
            mmptimer = timer.Repeat(refreshrate, 0, () =>
            {
                GenerateMarkers();
            });   
        }

#region marker generator

        void GenerateMarkers()
        { 
            ListPlayers();
            MarkerDisplayingDelete(null, null, null);
            MapMarkerGenericRadius MapMarkerCustom; 
            VendingMachineMapMarker MapMarkerVendingCustom;
            Vector3 pos;
            string activname;
            string sleepername;
            foreach (var playeringame in activplayers)
            {
                playerspos.TryGetValue(playeringame.Key, out pos);
                activplayers.TryGetValue(playeringame.Key, out activname);
                if (debug){Puts($"-> LOADED MARKER ACTIV LOCATION");}           
                MapMarkerVendingCustom = GameManager.server.CreateEntity("assets/prefabs/deployable/vendingmachine/vending_mapmarker.prefab", pos) as VendingMachineMapMarker;
                if (MapMarkerVendingCustom == null) return;
                if (ShowSteamID) MapMarkerVendingCustom.markerShopName = $"ACTIVE PLAYER\n{activname}\nSTEAM : {playeringame.Key}";
                else MapMarkerVendingCustom.markerShopName = $"ACTIVE PLAYER\n{activname}";
                PublicVendMarker.Add(MapMarkerVendingCustom);
                if (debug) Puts($"-> VENDING MARKER STORED DICT");
                MapMarkerCustom = GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", pos) as MapMarkerGenericRadius;
                MapMarkerCustom.alpha = 1.0f;
                MapMarkerCustom.color1 = Color.green;
                MapMarkerCustom.color2 = Color.black;
                MapMarkerCustom.radius = MarkerRadius;
                PublicRadMarker.Add(MapMarkerCustom);
                if (debug) {Puts($"-> SPAWN MARKER FOR ACTIV PLAYER {activname}");}      
            }

            foreach (var playersleepin in sleepplayers)
            {
                playerspos.TryGetValue(playersleepin.Key, out pos);
                sleepplayers.TryGetValue(playersleepin.Key, out sleepername);
                if (debug){Puts($"-> LOADED MARKER ACTIV LOCATION");}
                MapMarkerVendingCustom = GameManager.server.CreateEntity("assets/prefabs/deployable/vendingmachine/vending_mapmarker.prefab", pos) as VendingMachineMapMarker;
                if (MapMarkerVendingCustom == null) return;
                if (ShowSteamID) MapMarkerVendingCustom.markerShopName = $"SLEEPER PLAYER\n{sleepername}\nSTEAM : {playersleepin.Key}";
                else MapMarkerVendingCustom.markerShopName = $"SLEEPER PLAYER\n{sleepername}";
                PublicVendMarker.Add(MapMarkerVendingCustom);
                if (debug) Puts($"-> VENDING MARKER STORED DICT");
                MapMarkerCustom = GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", pos) as MapMarkerGenericRadius;
                MapMarkerCustom.alpha = 1.0f;
                MapMarkerCustom.color1 = Color.red;
                MapMarkerCustom.color2 = Color.black;
                MapMarkerCustom.radius = MarkerRadius;
                PublicRadMarker.Add(MapMarkerCustom);
                if (debug) Puts($"-> SPAWN MARKER FOR SLEEPING PLAYER {sleepername}"); 
            }
            foreach (var Vend in PublicVendMarker)
            {
                Vend.Spawn();
                MapMarker.serverMapMarkers.Remove(Vend);
                if (debug){Puts($"-> SPAWN ALL VEND MARKER");}             
            }
            foreach (var Rad in PublicRadMarker)
            {
                Rad.Spawn();
                MapMarker.serverMapMarkers.Remove(Rad);
                Rad.SendUpdate();   
                if (debug){Puts($"-> SPAWN ALL RAD MARKER");}         
            }               
        }
#endregion
    }
}


// --- End of file: MapMyPlayers.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-description ---
// --- Original File Path: M/MagicDescription/MagicDescription.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("Magic Description", "Wulf/lukespragg", "1.4.0")]
    [Description("Adds dynamic information in the server description")]
    public class MagicDescription : RustPlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Server description")]
            public string Description { get; set; } = "Powered by Oxide {magic.version} for Rust {magic.version protocol}";

            [JsonProperty(PropertyName = "Update interval (seconds)")]
            public int UpdateInterval { get; set; } = 300;

            [JsonProperty(PropertyName = "Show loaded plugins (true/false)")]
            public bool ShowPlugins { get; set; } = false;

            [JsonProperty(PropertyName = "Hidden plugins (filename or title)")]
            public List<string> HiddenPlugins { get; set; } = new List<string>();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            string configPath = $"{Interface.Oxide.ConfigDirectory}{Path.DirectorySeparatorChar}{Name}.json";
            PrintWarning($"Could not load a valid configuration file, creating a new configuration file at {configPath}");
            config = new Configuration();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion Configuration

        #region Initialization

        private static readonly Regex varRegex = new Regex(@"\{(.*?)\}");
        private static bool serverInitialized;

        private void OnServerInitialized()
        {
            serverInitialized = true;

            UpdateDescription();
            timer.Every(config.UpdateInterval, () => UpdateDescription());

            if (!config.ShowPlugins)
            {
                Unsubscribe(nameof(OnPluginLoaded));
                Unsubscribe(nameof(OnPluginUnloaded));
            }
        }

        private void OnServerSave() => SaveConfig();

        #endregion Initialization

        #region Description Handling

        private string UpdateDescription(string text = "")
        {
            if (!string.IsNullOrEmpty(text))
            {
                config.Description = text;
            }

            StringBuilder newDescription = new StringBuilder(config.Description);

            foreach (Match match in varRegex.Matches(config.Description))
            {
                string command = match.Groups[1].Value;

                if (!string.IsNullOrEmpty(command))
                {
                    string reply = ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), command);
                    newDescription.Replace(match.ToString(), reply.Replace("\"", "") ?? "");
                }
            }

            if (config.ShowPlugins)
            {
                Plugin[] loadedPlugins = plugins.GetAll();

                if (loadedPlugins.Length != 0)
                {
                    int count = 0;
                    string pluginList = null;

                    foreach (Plugin plugin in loadedPlugins.Where(p => !p.IsCorePlugin))
                    {
                        if (!config.HiddenPlugins.Contains(plugin.Title) && !config.HiddenPlugins.Contains(plugin.Name))
                        {
                            pluginList += plugin.Title + ", ";
                            count++;
                        }
                    }
                    if (pluginList != null)
                    {
                        if (pluginList.EndsWith(", "))
                        {
                            pluginList = pluginList.Remove(pluginList.Length - 2);
                        }
                        newDescription.Append($"\n\nPlugins ({count}): {pluginList}");
                    }
                }
            }

            if (newDescription.ToString() != ConVar.Server.description)
            {
                ConVar.Server.description = newDescription.ToString();
                Puts($"Server description updated: \nmagic.description: \"{config.Description}\"");
            }

            return ConVar.Server.description;
        }

        private void OnPluginLoaded(Plugin plugin)
        {
            if (serverInitialized)
            {
                UpdateDescription();
            }
        }

        private void OnPluginUnloaded(Plugin plugin)
        {
            if (serverInitialized)
            {
                UpdateDescription();
            }
        }

        #endregion Description Handling

        #region Command Handling

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (!serverInitialized || !arg.IsAdmin || arg.cmd.FullName != "server.description")
            {
                return null;
            }

            if (!arg.HasArgs() || arg.Args.GetValue(0) == null)
            {
                return null;
            }

            string magicDescription = string.Join(" ", arg.Args.ToArray());
            arg.ReplyWith($"server.description: \"{UpdateDescription(magicDescription)}\"");

            return true;
        }

        [ConsoleCommand("magic.description")]
        private void DescriptionCommand(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin)
            {
                arg.ReplyWith($"magic.description: \"{config.Description}\"");
            }
        }

        [ConsoleCommand("magic.version")]
        private void VersionCommand(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin)
            {
                switch (arg.FullString.ToLower())
                {
                    case "rust":
                    case "protocol":
                        arg.ReplyWith(Rust.Protocol.printable);
                        break;

                    case "branch":
                        arg.ReplyWith(Facepunch.BuildInfo.Current.Scm.Branch);
                        break;

                    case "date":
                    case "builddate":
                        arg.ReplyWith(Facepunch.BuildInfo.Current.BuildDate.ToLocalTime().ToString());
                        break;

                    default:
                        arg.ReplyWith(OxideMod.Version.ToString());
                        break;
                }
            }
        }

        #endregion Command Handling
    }
}


// --- End of file: MagicDescription.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/my-ch47 ---
// --- Original File Path: M/MyCH47/MyCH47.cs ---

using UnityEngine;
using System.Collections.Generic;
using Oxide.Core;
using Convert = System.Convert;
using System.Linq;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("My CH47", "FastBurst", "1.0.2")]
    [Description("Spawn a CH47 Helicopter")]

    public class MyCH47 : RustPlugin
    {
        #region Vars
        private const string PREFAB_CH47 = "assets/prefabs/npc/ch47/ch47.entity.prefab";
        private const string CH47spawn = "mych47.spawn";
        private const string CH47cooldown = "mych47.cooldown";
        private bool normalch47kill;
        private float trigger = 60;
        private Timer clock;

        public Dictionary<BasePlayer, BaseVehicle> baseplayerch47 = new Dictionary<BasePlayer, BaseVehicle>(); //for FUTURE
        #endregion

        #region Oxide
        private void Init()
        {
            permission.RegisterPermission(CH47spawn, this);
            permission.RegisterPermission(CH47cooldown, this);
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
        }

        private void OnServerInitialized()
        {
            float cooldownsec = (configData.CoolSettings.cooldownmin * 60);
            if (cooldownsec <= 120)
            {
                PrintError("Please set a longer cooldown time. Minimum is 2 min.");
                return;
            }
            clock = timer.Repeat(trigger, 0, () =>
            {
                LetsClock();
            });
        }

        private void Unload()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
            if (!configData.DebrisSettings.withoutdebris)
                return;
            if (normalch47kill == true)
            {
                if (configData.DebugSettings.debug == true)
                    Puts($"IGNORING DEBRIS REMOVAL - NORMAL CH47 KILLED");

                return;
            }
            if (entity == null)
                return;
            var prefabname = entity.ShortPrefabName;
            if (string.IsNullOrEmpty(prefabname))
                return;
            if (entity is HelicopterDebris && prefabname.Contains("ch47"))
            {
                var debris = entity.GetComponent<HelicopterDebris>();
                if (debris == null) return;
                entity.Kill();
                if (configData.DebugSettings.debug == true)
                    Puts($"REMOVED DEBRIS FROM myCH47 KILLED");
            }
        }

        private void OnEntityKill(BaseNetworkable entity)
        {
            if (entity == null)
                return;
            if (entity.net.ID == null)
                return;

            CH47Helicopter check = entity as CH47Helicopter;

            if (check == null)
                return;
            if (storedData.playerch47 == null)
                return;
            ulong todelete = 0uL;

            if (storedData.playerch47.ContainsValue(entity.net.ID.Value) == false)
            {
                if (configData.DebugSettings.debug == true)
                    Puts($"KILLED CH47 not from myCH47");

                normalch47kill = true;
                timer.Once(6f, () =>
                {
                    normalch47kill = false;
                });
            }
            foreach (var item in storedData.playerch47)
            {
                if (item.Value == entity.net.ID.Value)
                {
                    ChatPlayerOnline(item.Key, "killed");
                    foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
                        if (player.userID == item.Key)
                            baseplayerch47.Remove(player);

                    todelete = item.Key;
                }
            }

            if (todelete != 0)
                storedData.playerch47.Remove(todelete);
        }
        #endregion

        #region Functions
        private void ChatPlayerOnline(ulong ailldi, string message)
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
                if (player.userID == ailldi)
                    if (message == "killed")
                        Player.Message(player, $"<color={configData.ChatSettings.ChatColor}>{lang.GetMessage("KilledMsg", this, player.UserIDString)}</color>", $"<color={configData.ChatSettings.PrefixColor}> {configData.ChatSettings.Prefix} </color>", configData.ChatSettings.SteamIDIcon);
        }

        private void LetsClock()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
            {
                float cooldownsec = (configData.CoolSettings.cooldownmin * 60);

                if (configData.DebugSettings.debug)
                    Puts($"cooldown in seconds, calculated from config : {cooldownsec}");

                if (storedData.playercounter.ContainsKey(player.userID) == true)
                {
                    if (configData.DebugSettings.debug)
                        Puts($"player cooldown counter increment");

                    float counting = new float();
                    storedData.playercounter.TryGetValue(player.userID, out counting);
                    storedData.playercounter.Remove(player.userID);
                    counting = counting + trigger;
                    storedData.playercounter.Add(player.userID, counting);

                    if (configData.DebugSettings.debug)
                        Puts($"player {player.userID} newtime {counting}");

                    if (counting >= cooldownsec)
                    {
                        if (configData.DebugSettings.debug)
                            Puts($"player reached cooldown. removing from dict.");

                        storedData.playercounter.Remove(player.userID);
                    }
                    else
                    {
                        if (configData.DebugSettings.debug)
                            Puts($"player new cooldown counter in minutes : {counting / 60} / {configData.CoolSettings.cooldownmin}");

                        storedData.playercounter.Remove(player.userID);
                        storedData.playercounter.Add(player.userID, counting);
                    }
                }
            }
        }
        #endregion

        #region Commands
        [ChatCommand("mych47")]
        private void SpawnMyCH47(BasePlayer player, string command, string[] args)
        {
            bool isspawner = permission.UserHasPermission(player.UserIDString, CH47spawn);
            if (isspawner == false)
            {
                Player.Message(player, $"<color={configData.ChatSettings.ChatColor}><i>{lang.GetMessage("NoPermMsg", this, player.UserIDString)}</i></color>", $"<color={configData.ChatSettings.PrefixColor}> {configData.ChatSettings.Prefix} </color>", configData.ChatSettings.SteamIDIcon);
                return;
            }
            if (storedData.playerch47.ContainsKey(player.userID) == true)
            {
                Player.Message(player, $"<color={configData.ChatSettings.ChatColor}>{lang.GetMessage("AlreadyMsg", this, player.UserIDString)}</color>", $"<color={configData.ChatSettings.PrefixColor}> {configData.ChatSettings.Prefix} </color>", configData.ChatSettings.SteamIDIcon);
                return;
            }

            bool hascooldown = permission.UserHasPermission(player.UserIDString, CH47cooldown);
            float minleft = 0;

            if (hascooldown == true)
            {
                if (storedData.playercounter.ContainsKey(player.userID) == false)
                    storedData.playercounter.Add(player.userID, 0);
                else
                {
                    float count = new float();
                    storedData.playercounter.TryGetValue(player.userID, out count);
                    minleft = configData.CoolSettings.cooldownmin - (count / 60);

                    if (configData.DebugSettings.debug == true)
                        Puts($"Player DID NOT reach cooldown return.");

                    Player.Message(player, $"<color={configData.ChatSettings.ChatColor}>{lang.GetMessage("CooldownMsg", this, player.UserIDString)} ({minleft} min)</color>", $"<color={configData.ChatSettings.PrefixColor}> {configData.ChatSettings.Prefix} </color>", configData.ChatSettings.SteamIDIcon);
                    return;
                }
            }
            else
            {
                if (storedData.playercounter.ContainsKey(player.userID))
                    storedData.playercounter.Remove(player.userID);
            }

            Vector3 position = player.transform.position + (player.transform.forward * 20);
            if (position == null)
                return;
            BaseVehicle vehicleCH47 = (BaseVehicle)GameManager.server.CreateEntity(PREFAB_CH47, position, new Quaternion());
            if (vehicleCH47 == null)
                return;

            BaseEntity CHentity = vehicleCH47 as BaseEntity;
            CHentity.OwnerID = player.userID;

            vehicleCH47.Spawn();

            Player.Message(player, $"<color={configData.ChatSettings.ChatColor}>{lang.GetMessage("SpawnedMsg", this, player.UserIDString)}</color>", $"<color={configData.ChatSettings.PrefixColor}> {configData.ChatSettings.Prefix} </color>", configData.ChatSettings.SteamIDIcon);

            ulong ch47uint = vehicleCH47.net.ID.Value;

            if (configData.DebugSettings.debug == true)
                Puts($"SPAWNED CH47 {ch47uint.ToString()} for player {player.displayName} OWNER {CHentity.OwnerID}");

            storedData.playerch47.Remove(player.userID);
            storedData.playerch47.Add(player.userID, ch47uint);
            baseplayerch47.Remove(player);
            baseplayerch47.Add(player, vehicleCH47);
        }

        [ChatCommand("noch47")]
        private void KillMyCH47(BasePlayer player, string command, string[] args)
        {
            bool isspawner = permission.UserHasPermission(player.UserIDString, CH47spawn);
            if (isspawner == false)
            {
                Player.Message(player, $"<color={configData.ChatSettings.ChatColor}><i>{lang.GetMessage("NoPermMsg", this, player.UserIDString)}</i></color>", $"<color={configData.ChatSettings.PrefixColor}> {configData.ChatSettings.Prefix} </color>", configData.ChatSettings.SteamIDIcon);
                return;
            }
            if (storedData.playerch47.ContainsKey(player.userID) == true)
            {
                ulong deluint;
                storedData.playerch47.TryGetValue(player.userID, out deluint);
                var tokill = BaseNetworkable.serverEntities.Find(new NetworkableId(deluint));
                if (tokill != null)
                    tokill.Kill();

                storedData.playerch47.Remove(player.userID);
                baseplayerch47.Remove(player);
            }
        }
        #endregion

        #region Config
        private static ConfigData configData;
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Chat Settings")]
            public ChatOptions ChatSettings { get; set; }
            [JsonProperty(PropertyName = "Cooldown (on permissions)")]
            public CooldownOptions CoolSettings { get; set; }
            [JsonProperty(PropertyName = "Debris Settings")]
            public DebrisOptions DebrisSettings { get; set; }
            [JsonProperty(PropertyName = "Debug Option")]
            public DebugOptions DebugSettings { get; set; }

            public class ChatOptions
            {
                [JsonProperty(PropertyName = "ChatColor")]
                public string ChatColor { get; set; }
                [JsonProperty(PropertyName = "Prefix")]
                public string Prefix { get; set; }
                [JsonProperty(PropertyName = "Prefix Color")]
                public string PrefixColor { get; set; }
                [JsonProperty(PropertyName = "Chat Icon")]
                public ulong SteamIDIcon { get; set; }
            }

            public class CooldownOptions
            {
                [JsonProperty(PropertyName = "Value in minutes")]
                public float cooldownmin { get; set; }
            }

            public class DebrisOptions
            {
                [JsonProperty(PropertyName = "Remove debris")]
                public bool withoutdebris { get; set; }
            }

            public class DebugOptions
            {
                [JsonProperty(PropertyName = "Enable debug Messages in console")]
                public bool debug { get; set; }
            }
            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                ChatSettings = new ConfigData.ChatOptions
                {
                    ChatColor = "#bbffb1",
                    Prefix = "[My CH47]",
                    PrefixColor = "#149800",
                    SteamIDIcon = 76561198332562475
                },
                CoolSettings = new ConfigData.CooldownOptions
                {
                    cooldownmin = 60
                },
                DebrisSettings = new ConfigData.DebrisOptions
                {
                    withoutdebris = false
                },
                DebugSettings = new ConfigData.DebugOptions
                {
                    debug = false
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new Core.VersionNumber(1, 0, 0))
                configData = baseConfig;

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null) return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }
        #endregion

        #region Localization      
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"AlreadyMsg", "You already have a CH47 helicopter.\nuse command '/noch47' to remove it."},
                {"SpawnedMsg", "Your CH47 has spawned !\nuse command '/noch47' to remove it."},
                {"KilledMsg", "Your CH47 has been removed/killed."},
                {"NoPermMsg", "You are not allowed to do this."},
                {"CooldownMsg", "You must wait before a new CH47"},

            }, this, "en");
        }
        #endregion

        #region Data
        class StoredData
        {
            public Dictionary<ulong, ulong> playerch47 = new Dictionary<ulong, ulong>();
            public Dictionary<ulong, float> playercounter = new Dictionary<ulong, float>();
            public StoredData()
            {
            }
        }

        private StoredData storedData;
        #endregion
    }
}

// --- End of file: MyCH47.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-rain-of-fire-panel ---
// --- Original File Path: M/MagicRainOfFirePanel/MagicRainOfFirePanel.cs ---

using System;
using System.ComponentModel;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Magic Rain Of Fire Panel", "MJSU", "1.0.2")]
    [Description("Displays if the rain of fire event is active")]
    public class MagicRainOfFirePanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel;

        private PluginConfig _pluginConfig; //Plugin Config
        private bool _isRainOfFireActive;
        private Timer _endTimer;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        #endregion

        #region Setup & Loading
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 6,
                    Width = config.Panel?.Image?.Width ?? 1f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/fT5P4K4Y/P01HCi3.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.05f, 0.05f, 0.05f)
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "center",
                Order = config.PanelSettings?.Order ?? 14,
                Width = config.PanelSettings?.Width ?? 0.02f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            MagicPanelRegisterPanels();
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                return;
            }
        
            MagicPanel?.Call("RegisterGlobalPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        }
        #endregion

        #region uMod Hooks

        private void OnEntitySpawned(TimedExplosive explosive)
        {
            NextTick(() =>
            {
                if (!CanShowPanel(explosive))
                {
                    return;
                }

                if (!_isRainOfFireActive)
                {
                    MagicPanel?.Call("UpdatePanel", Name, (int)UpdateEnum.Image);
                }
                
                _isRainOfFireActive = true;
                _endTimer?.Destroy();
                _endTimer = timer.In(_pluginConfig.EventEnd, () =>
                {
                    _isRainOfFireActive = false;
                    MagicPanel?.Call("UpdatePanel", Name, (int) UpdateEnum.Image);
                });
            });
        }
        #endregion

        #region MagicPanel Hook
        private Hash<string, object> GetPanel()
        {
            Panel panel = _pluginConfig.Panel;
            PanelImage image = panel.Image;
            if (image != null)
            {
                image.Color = _isRainOfFireActive ? _pluginConfig.ActiveColor : _pluginConfig.InactiveColor;
            }

            return panel.ToHash();
        }
        #endregion
        
        #region Helper Methods

        private bool CanShowPanel(TimedExplosive explosive)
        {
            if (!(explosive?.IsValid() ?? false))
            {
                return false;
            }
            
            ServerProjectile proj = explosive.GetComponent<ServerProjectile>();
            if (proj == null)
            {
                return false;
            }

            //Rain of Fire checks
            if (proj.gravityModifier != 0f 
                || proj.speed != 25f 
                || explosive.timerAmountMin != 300 
                || explosive.timerAmountMax != 300)
            {
                return false;
            }
            
            object result = Interface.Call("MagicPanelCanShow", Name, explosive);
            if (result is bool)
            {
                return (bool) result;
            }

            return true;
        }
        #endregion

        #region Classes

        private class PluginConfig
        {
            [DefaultValue("#00FF00FF")]
            [JsonProperty(PropertyName = "Active Color")]
            public string ActiveColor { get; set; }

            [DefaultValue("#FFFFFF1A")]
            [JsonProperty(PropertyName = "Inactive Color")]
            public string InactiveColor { get; set; }

            [DefaultValue(5f)]
            [JsonProperty(PropertyName = "Event ends after last rocket (Seconds)")]
            public float EventEnd { get; set; }

            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicRainOfFirePanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/afk-api ---
// --- Original File Path: A/AFKAPI/AFKAPI.cs ---

using System;
using System.Collections.Generic;
using System.Linq;

using Newtonsoft.Json;

using Oxide.Core.Libraries.Covalence;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("AFK API", "2CHEVSKII", "1.0.1")]
    [Description("Complex developer API for 'Away from keyboard' players.")]
    class AFKAPI : CovalencePlugin
    {

        #region -Fields-

        const string BEEP_SOUND_PREFAB = "assets/prefabs/tools/pager/effects/beep.prefab";

        #region [Permissions]

        const string PERMISSION_USE = "afkapi.use";
        const string PERMISSION_KICK = "afkapi.kick";

        #endregion

        #region [Storage]

        IEnumerable<IPlayer> AFKPlayers
        {
            get
            {
                return trackedPlayers.Where(kv => kv.Value.IsAFK).Select(kv => kv.Key);
            }
        }

        static AFKAPI instance;
        Settings settings;
        Dictionary<IPlayer, AFKPlayer> trackedPlayers;

        #endregion

        #endregion

        #region -Configuration-


        protected override void LoadDefaultConfig()
        {
            settings = Settings.Default;
            SaveConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(settings, true);

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                settings = Config.ReadObject<Settings>();
                if (settings == null)
                {
                    throw new JsonException("Unable to read configuration file, it will be reset.");
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
        }

        class Settings
        {
            public static Settings Default
            {
                get
                {
                    return new Settings
                    {
                        GeneralSettings = new Settings.GeneralPluginSettings
                        {
                            SecondsToAFKStatus = 300,
                            StatusRefreshInterval = 5,
                            AllowSetupThroughAPI = true
                        },
                        CompareSettings = new Settings.ComparePluginSettings
                        {
                            CompareBuild = true,
                            CompareCommunication = true,
                            CompareItemActions = true,
                            CompareRotation = true
                        },
                        NotificationSettings = new Settings.NotificationPluginSettings
                        {
                            NotifyPlayer = true,
                            NotifyPlayerSound = true,
                            NotifyPlayerTime = 60
                        }
                    };
                }
            }
            [JsonProperty(PropertyName = "General Settings")]
            public GeneralPluginSettings GeneralSettings { get; set; }
            [JsonProperty(PropertyName = "Accuracy Settings")]
            public ComparePluginSettings CompareSettings { get; set; }
            [JsonProperty(PropertyName = "Notification Settings")]
            public NotificationPluginSettings NotificationSettings { get; set; }
            public class GeneralPluginSettings
            {
                [JsonProperty(PropertyName = "Seconds to consider player is AFK")]
                public int SecondsToAFKStatus { get; set; }
                [JsonProperty(PropertyName = "AFK Check Interval")]
                public int StatusRefreshInterval { get; set; }
                [JsonProperty(PropertyName = "Allow other plugins change settings of this API")]
                public bool AllowSetupThroughAPI { get; set; }
            }
            public class ComparePluginSettings
            {
                [JsonProperty(PropertyName = "Check rotation in pair with position (more accurate)")]
                public bool CompareRotation { get; set; }
                [JsonProperty(PropertyName = "Check for build attempts")]
                public bool CompareBuild { get; set; }
                [JsonProperty(PropertyName = "Check for communication attempts (chat/voice)")]
                public bool CompareCommunication { get; set; }
                [JsonProperty(PropertyName = "Check for item actions (craft/change/use/move)")]
                public bool CompareItemActions { get; set; }
            }
            public class NotificationPluginSettings
            {
                [JsonProperty(PropertyName = "Notify player before considering him AFK")]
                public bool NotifyPlayer { get; set; }
                [JsonProperty(PropertyName = "Notify player X seconds before considering him AFK")]
                public int NotifyPlayerTime { get; set; }
                [JsonProperty(PropertyName = "Notify with sound")]
                public bool NotifyPlayerSound { get; set; }
            }

        }


        #endregion

        #region -Localization-


        const string M_CHAT_PREFIX = "Plugin prefix",
        M_PLAYER_AFK_STATUS = "Player AFK status",
        M_ERROR_NO_ARGS = "No valid arguments error",
        M_OFFLINE_STATUS = "Offline status",
        M_IS_AFK_STATUS = "Is AFK status",
        M_IS_NOT_AFK_STATUS = "Is not AFK status",
        M_AFK_PLAYER_LIST = "AFK player list",
        M_NO_AFK_PLAYERS_FOUND = "No players AFK atm",
        M_NOTIFICATION = "Notification for AFK player",
        M_NO_PERMISSION = "No permission",
        M_KICK_REASON = "Kick reason";

        readonly Dictionary<string, string> defmessages = new Dictionary<string, string>
        {
            { M_CHAT_PREFIX, "<color=#6797e5>[AFK API]</color> " },
            { M_PLAYER_AFK_STATUS, "The player <color=#fff268>{0}</color> AFK status: {1}" },
            { M_ERROR_NO_ARGS, "<color=orange>Wrong command usage, no valid arguments specified</color>" },
            { M_OFFLINE_STATUS, "<color=red>OFFLINE</color>" },
            { M_IS_AFK_STATUS, "<color=yellow>IS AFK</color>" },
            { M_IS_NOT_AFK_STATUS, "<color=lime>NOT AFK</color>" },
            { M_AFK_PLAYER_LIST, "<color=yellow>AFK player list:</color>\n{0}" },
            { M_NO_AFK_PLAYERS_FOUND, "<color=lime>Currently no players are AFK</color>" },
            { M_NOTIFICATION, "<color=red>Start moving, or you will be punished for AFK!</color>" },
            { M_NO_PERMISSION, "<color=red>You have no permission to run this command!</color>" },
            { M_KICK_REASON, "AFK" }
        };

        protected override void LoadDefaultMessages() => lang.RegisterMessages(defmessages, this, "en");

        void MessagePlayer(IPlayer player, string msg, bool prefix = true, params object[] args)
        {
            if (prefix)
            {
                player.Message(lang.GetMessage(M_CHAT_PREFIX, this, player.Id) + string.Format(lang.GetMessage(msg, this, player.Id), args));
            }
            else
            {
                player.Message(string.Format(lang.GetMessage(msg, this, player.Id), args));
            }
        }


        #endregion

        #region -API-


        bool IsPlayerAFK(ulong id)
        {
            return IsPlayerAFK(id.ToString());
        }

        bool IsPlayerAFK(string id)
        {
            var player = players.FindPlayerById(id);

            if (player == null)
            {
                throw new Exception($"Player with id {id} not found.");
            }

            return IsPlayerAFK(player);
        }

        bool IsPlayerAFK(IPlayer player)
        {
            if (player == null)
            {
                throw new ArgumentNullException("Player cannot be null.");
            }

            var list = AFKPlayers;

            if (list.Count() == 0)
            {
                return false;
            }

            return list.Contains(player);
        }

        long GetPlayerAFKTime(ulong id)
        {
            return (long)GetPlayerAFKTime(id.ToString());
        }

        float GetPlayerAFKTime(string id)
        {
            var player = players.FindPlayerById(id);

            if (player == null)
            {
                throw new Exception($"Player with id {id} not found.");
            }

            return GetPlayerAFKTime(player);
        }

        float GetPlayerAFKTime(IPlayer player)
        {
            if (player == null)
            {
                throw new ArgumentNullException("Player cannot be null");
            }

            if (!player.IsConnected)
            {
                return -1f;
            }

            var comp = trackedPlayers[player];

            if (!comp.IsAFK)
            {
                return -1f;
            }

            return comp.TimeAFK;
        }

        List<BasePlayer> GetAFKPlayers()
        {
            return AFKPlayers.Select(p => (BasePlayer)p.Object).ToList();
        }

        bool AFKAPI_Setup(string newSettings, bool needToSave = false)
        {
            if (!settings.GeneralSettings.AllowSetupThroughAPI)
                return false;
            Settings _newSettings = JsonConvert.DeserializeObject<Settings>(newSettings);
            if (_newSettings != null)
            {
                _newSettings.GeneralSettings.AllowSetupThroughAPI = true;
                settings = _newSettings;
                if (needToSave)
                    SaveConfig();
                CheckHookSubscriptions();
                return true;
            }
            else
                return false;
        }


        #endregion

        #region -Helpers-


        void CheckHookSubscriptions()
        {
            if (!settings.CompareSettings.CompareBuild)
            {
                Unsubscribe(nameof(CanBuild));
            }
            if (!settings.CompareSettings.CompareCommunication)
            {
                Unsubscribe(nameof(OnPlayerChat));
                Unsubscribe(nameof(OnPlayerVoice));
            }
            if (!settings.CompareSettings.CompareItemActions)
            {
                Unsubscribe(nameof(CanCraft));
                Unsubscribe(nameof(OnActiveItemChanged));
                Unsubscribe(nameof(OnItemAction));
                Unsubscribe(nameof(CanMoveItem));
            }
        }


        #endregion

        #region -Oxide hooks-


        void Init()
        {
            instance = this;

            permission.RegisterPermission(PERMISSION_USE, this);
            permission.RegisterPermission(PERMISSION_KICK, this);

            AddUniversalCommand("isafk", nameof(CmdIsAFK));
            AddUniversalCommand("getafk", nameof(CmdGetAFK));
            AddUniversalCommand("kickafk", nameof(CmdKickAFK));

            trackedPlayers = new Dictionary<IPlayer, AFKPlayer>();
        }

        void OnServerInitialized()
        {
            CheckHookSubscriptions();

            foreach (var player in players.Connected)
            {
                OnUserConnected(player);
            }
        }

        void Unload()
        {
            foreach (var p in trackedPlayers.Keys)
            {
                OnUserDisconnected(p);
            }

            instance = null;
        }

        void OnUserConnected(IPlayer player)
        {
            var basePlayer = (BasePlayer)player.Object;
            var comp = basePlayer.gameObject.AddComponent<AFKPlayer>();
        }

        void OnUserDisconnected(IPlayer player)
        {
            UnityEngine.Object.Destroy(trackedPlayers[player]);
        }

        void CanBuild(Planner planner)
        {
            BasePlayer player = planner.GetOwnerPlayer();
            if (player != null)
                trackedPlayers[player.IPlayer].OnAction();
        }

        void CanCraft(ItemCrafter itemCrafter)
        {
            var player = itemCrafter.baseEntity;
            if (player != null)
                trackedPlayers[player.IPlayer].OnAction();
        }

        void OnActiveItemChanged(BasePlayer player)
        {
            if (player?.IPlayer == null)
            {
                return;
            }
            trackedPlayers[player.IPlayer].OnAction();
        }

        void OnPlayerChat(BasePlayer player)
        {
            if (player?.IPlayer == null)
            {
                return;
            }
            trackedPlayers[player.IPlayer].OnAction();
        }

        void OnPlayerVoice(BasePlayer player)
        {
            if (player?.IPlayer == null)
            {
                return;
            }
            trackedPlayers[player.IPlayer].OnAction();
        }

        void OnItemAction(Item item, string action, BasePlayer player)
        {
            if (player?.IPlayer == null)
            {
                return;
            }
            trackedPlayers[player.IPlayer].OnAction();
        }

        void CanMoveItem(Item item, PlayerInventory playerLoot, uint targetContainer, int targetSlot, int amount)
        {
            var player = playerLoot.baseEntity;
            if (player?.IPlayer == null)
            {
                return;
            }
            trackedPlayers[player.IPlayer].OnAction();
        }


        #endregion

        #region -Commands-


        void CmdIsAFK(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(PERMISSION_USE))
            {
                MessagePlayer(player, M_NO_PERMISSION);
            }
            else if (args.Length == 0)
            {
                MessagePlayer(player, M_ERROR_NO_ARGS);
            }
            else
            {
                var tPlayer = BasePlayer.Find(args[0]);

                if (!tPlayer || !trackedPlayers.ContainsKey(tPlayer.IPlayer))
                {
                    MessagePlayer(player, M_PLAYER_AFK_STATUS, true, args[0], M_OFFLINE_STATUS);
                }
                else
                {
                    var comp = trackedPlayers[tPlayer.IPlayer];

                    if (comp.IsAFK)
                    {
                        MessagePlayer(player, M_PLAYER_AFK_STATUS, true, tPlayer.displayName, M_IS_AFK_STATUS);
                    }
                    else
                    {
                        MessagePlayer(player, M_PLAYER_AFK_STATUS, true, tPlayer.displayName, M_IS_NOT_AFK_STATUS);
                    }
                }
            }
        }

        void CmdGetAFK(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(PERMISSION_USE))
            {
                MessagePlayer(player, M_NO_PERMISSION);
            }
            else
            {
                var list = AFKPlayers;

                if (list.Count() == 0)
                {
                    MessagePlayer(player, M_NO_AFK_PLAYERS_FOUND);
                }
                else
                {
                    MessagePlayer(player, M_AFK_PLAYER_LIST, false, string.Join("\n", list.Select(p => p.Name)));
                }
            }
        }

        void CmdKickAFK(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(PERMISSION_KICK))
            {
                MessagePlayer(player, M_NO_PERMISSION);
            }
            else
            {
                foreach (var afkPlayer in AFKPlayers)
                {
                    afkPlayer.Kick(lang.GetMessage(M_KICK_REASON, this, afkPlayer.Id));
                }
            }
        }


        #endregion

        #region -Nested types-


        class AFKPlayer : MonoBehaviour
        {
            #region [Fields]

            public bool IsAFK
            {
                get
                {
                    return TimeSinceLastAction >= instance.settings.GeneralSettings.SecondsToAFKStatus;
                }
            }

            public float TimeAFK
            {
                get
                {
                    return Mathf.Max(0f, TimeSinceLastAction - instance.settings.GeneralSettings.SecondsToAFKStatus);
                }
            }

            float TimeSinceLastAction => Time.realtimeSinceStartup - lastActionTime;

            BasePlayer player;
            float lastActionTime;
            Vector3 lastPosition;
            Quaternion lastRotation;
            Dictionary<IPlayer, AFKPlayer> trackedPlayers;

            #endregion

            #region [Public methods]

            public void OnAction()
            {
                lastActionTime = Time.realtimeSinceStartup;
            }

            #endregion

            #region [Lifecycle hooks]

            void Start()
            {
                trackedPlayers = instance.trackedPlayers;

                player = GetComponent<BasePlayer>();
                trackedPlayers[player.IPlayer] = this;

                lastPosition = player.transform.position;
                lastRotation = player.eyes.rotation;

                InvokeRepeating(nameof(CheckPosition), instance.settings.GeneralSettings.StatusRefreshInterval, instance.settings.GeneralSettings.StatusRefreshInterval);
                InvokeRepeating(nameof(CheckNotification), instance.settings.GeneralSettings.StatusRefreshInterval, instance.settings.GeneralSettings.StatusRefreshInterval);
            }

            void OnDestroy()
            {
                CancelInvoke();
                trackedPlayers.Remove(player.IPlayer);
            }

            #endregion

            #region [Position/rotation checks]

            void CheckPosition()
            {
                if (player.transform.position == lastPosition)
                {
                    if (instance.settings.CompareSettings.CompareRotation && RotationChanged())
                        OnAction();
                }
                else
                {
                    lastPosition = player.transform.position;
                    OnAction();
                }
            }
            bool RotationChanged()
            {
                if (player.eyes.rotation != lastRotation)
                {
                    lastRotation = player.eyes.rotation;
                    return true;
                }
                return false;
            }

            #endregion

            #region [Notifications]

            void CheckNotification()
            {
                if (!instance.settings.NotificationSettings.NotifyPlayer)
                {
                    return;
                }

                var tsla = TimeSinceLastAction;

                if (instance.settings.GeneralSettings.SecondsToAFKStatus - TimeSinceLastAction > instance.settings.NotificationSettings.NotifyPlayerTime)
                {
                    return;
                }

                NotifyPlayer();

                if (instance.settings.NotificationSettings.NotifyPlayerSound)
                {
                    DoBeepEffect();
                }
            }

            void NotifyPlayer()
            {
                instance.MessagePlayer(player.IPlayer, M_NOTIFICATION);
            }

            void DoBeepEffect()
            {
                var beep = new Effect();
                beep.Init(Effect.Type.Generic, player.transform.position, Vector3.zero);
                beep.pooledString = BEEP_SOUND_PREFAB;
                EffectNetwork.Send(beep, player.Connection);
            }

            #endregion
        }


        #endregion

    }
}


// --- End of file: AFKAPI.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/anti-drain ---
// --- Original File Path: A/AntiDrain/AntiDrain.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Anti Drain", "Orange", "1.1.1")]
    [Description("Plugin allows to prevent turret draining")]
    public class AntiDrain : RustPlugin
    {
        #region Vars

        private List<uint> checking = new List<uint>();
        
        private List<uint> blocked = new List<uint>();

        #endregion

        #region Oxide Hooks
        
        private object CanBeTargeted(BasePlayer player, StorageContainer turret)
        {
            return CanTarget(turret, player) ? (object) null : false;
        }

        #endregion

        #region Core

        private bool CanTarget(StorageContainer turret, BasePlayer player)
        {
            if (turret == null || player == null) {return true;}
            if (!turret.OwnerID.IsSteamId() || !player.userID.IsSteamId()) {return true;}
            var id = turret.net.ID;
            
            if (blocked.Contains(id))
            {
                return false;
            }

            if (!checking.Contains(id))
            {
                Check(turret);
            }
            
            return true;
        }
        
        private void Check(StorageContainer turret)
        {
            var id = turret.net.ID;
            var was = GetAmmoCount(turret);
            checking.Add(id);
            
            timer.Once(config.checkTime, () =>
            {
                checking.Remove(id);
                var now = GetAmmoCount(turret);

                if (was - now > config.ammoDifference)
                {
                    Block(id);
                }
            });
        }
        
        private void Block(uint id)
        {
            if (blocked.Contains(id)) {return;}
            blocked.Add(id);
            timer.Once(config.blockTime, () => { blocked.Remove(id); });
        }
        
        private int GetAmmoCount(StorageContainer container)
        {
            var i = 0;

            foreach (var item in container.inventory.itemList)
            {
                if (item.info.category == ItemCategory.Ammunition)
                {
                    i += item.amount;
                }
            }

            return i;
        }

        #endregion

        #region Config

        private static ConfigData config;
        
        private class ConfigData
        {    
            [JsonProperty(PropertyName = "1. Time after shooting when will be checked ammo count")]
            public int checkTime;
            
            [JsonProperty(PropertyName = "2. Ammo count difference to block the turret")]
            public int ammoDifference;
            
            [JsonProperty(PropertyName = "3. Time when turret will be blocked to shoot after drain-catch")]
            public int blockTime;
        }
        
        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                blockTime = 60,
                checkTime = 30,
                ammoDifference = 100
            };
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
   
            try
            {
                config = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: AntiDrain.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/angry-time ---
// --- Original File Path: A/AngryTime/AngryTime.cs ---

using System;
using System.Collections.Generic;

using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("AngryTime", "Tori1157", "1.3.1", ResourceId = 2670)]
    [Description("Control & Check time via one plugin.")]

    class AngryTime : CovalencePlugin
    {
        #region Fields

        private bool Changed;
        private bool useRealTime;
        private bool informSkipConsole;
        private bool useSkipTime;
        private bool useRealDate;

        private string messagePrefix;
        private string messagePrefixColor;

        private int sunriseHour;
        private int sunsetHour;

        private const string adminPermission = "angrytime.admin";

        #endregion

        #region Loading

        private void Loaded()
        {
            NoCollideCheck();
            InitDate();
        }

        private void Init()
        {
            permission.RegisterPermission(adminPermission, this);

            LoadVariables();
        }

        private void LoadVariables()
        {
            /// -- GLOBAL -- ///
            messagePrefix = Convert.ToString(GetConfig("Global Options", "Message Prefix", "Angry Time"));
            messagePrefixColor = Convert.ToString(GetConfig("Global Options", "Message Prefix Color", "#ffa500"));

            /// -- REALTIME -- ///
            useRealTime = Convert.ToBoolean(GetConfig("RealTime Options", "Use Server Time", false));
            useRealDate = Convert.ToBoolean(GetConfig("RealTime Options", "Use Server Date", false));

            /// -- TIMESKIP -- ///
            sunriseHour = Convert.ToInt32(GetConfig("Skip Time Options", "Sunrise Hour", 10));
            sunsetHour = Convert.ToInt32(GetConfig("Skip Time Options", "Sunset Hour", 17));
            informSkipConsole = Convert.ToBoolean(GetConfig("Skip Time Options", "Inform Console", true));
            useSkipTime = Convert.ToBoolean(GetConfig("Skip Time Options", "Use Skip Time", false));

            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                /// -- ERROR -- ///
                ["1No Permission"] = "[#add8e6]{0}[/#] you do not have permission to use the [#00ffff]{1}[/#] command.",
                ["1Incorrect Parameter"] = "Parameter [#add8e6]{0}[/#] is invalid or written wrong.",
                ["1Invalid Syntax Set"] = "Invalid syntax!  |  /time set 10 [#00ffff](0 > 23)[/#]",
                ["1Collide Error"] = "You cannot use both 'Use Server Time' and 'Use Skip Time' at the same time!",
                ["1Invalid Time Set"] = "[#add8e6]{0}[/#] is not a valid number  |  /time set 10:30 \n[#00ffff](01 > 23 Hours : 01 > 59 Minutes)[/#]",
                ["1Invalid Time Length"] = "[#add8e6]{0}[/#] is too short, need to be a four digit number  |  [#00ffff]2359[/#] - [#00ffff]23:59[/#]",

                /// -- CONFIRM -- ///
                ["1Time Changed"] = "You have changed the time to [#add8e6]{0}[/#]",
                ["1Time Skipped"] = "Changed time to {0}",

                /// -- INFO -- ///
                ["Current Game Time"] = "[#00ffff]{0}[/#]",
                ["Time Help Command Player"] = "- [#ffa500]/time help[/#] [i](Displays this message)[/i]\n- [#ffa500]/time[/#] [i](This will display the current time and date in-game)[/i]",
                ["Time Help Command Admin"] = "- [#ffa500]/time set 10[/#] [i](This will set the time to a whole number [#00ffff][+12](01 > 23 Hours : 01 > 59 Minutes)[/+][/#])[/i]\n- [#ffa500]/time help[/#] [i](Displays this message)[/i]\n- [#ffa500]/time[/#] [i](This will display the current time and date in-game)[/i]",
                ["Time Help Command Console"] = "\n- time set 10 (This will set the time to a whole number(10:00))\n- time add 1 (This will add one hour to the current time (1 > 23))\n- time (This will display the current time and date in-game)",

                /// -- STORAGE -- ///
                //["Time Help Command Chat Admin"] = "- [#ffa500]/time set 10[/#] [i](This will set the time to a whole number [#00ffff][+12](01 > 23 Hours : 01 > 59 Minutes)[/+][/#])[/i]\n- [#ffa500]/time add 1[/#] [i](This will add one hour to the current time [#00ffff][+12](1 > 23)[/+][/#])[/i]\n- [#ffa500]/time help[/#] [i](Displays this message)[/i]\n- [#ffa500]/time[/#] [i](This will display the current time and date in-game)[/i]",
                //["Invalid Syntax Add Chat"] = "Invalid syntax!  |  /time add 10 [#00ffff](1 > 23)[/#]",
                //["Invalid Time Add Chat"] = "[#add8e6]{time}[/#] is not a number  |  /time add \n[#00ffff](1 > 23)[/#]",
                //["Time Added Chat"] = "You have added [#add8e6]{time}[/#] hours",
            }, this);
        }

        #endregion

        #region Commands

        [Command("time")]
        private void TimeCommand(IPlayer player, string command, string[] args)
        {
            #region Default
            if (args.Length == 0)
            {
                SendChatMessage(player, Lang("Current Game Time", player.Id, server.Time));
                return;
            }
            
            var CommandArg = args[0].ToLower();
            var CommandInfo = ($"{command} {args[0]}");

            var CaseArgs = (new List<object>
            {
                "set", "help"
            });

            if (!CaseArgs.Contains(CommandArg))
            {
                SendChatMessage(player, Lang("1Incorrect Parameter", player.Id, CommandArg));
                return;
            }
            #endregion

            switch (CommandArg)
            {
                #region Set
                case "set":

                    if (!CanAdmin(player) && !player.IsServer)
                    {
                        SendChatMessage(player, Lang("1No Permission", player.Id, player.Name, command));
                        return;
                    }

                    if (args.Length != 2)
                    {
                        SendChatMessage(player, Lang("1Invalid Syntax Set", player.Id));
                        return;
                    }

                    // Checking to see if the parameter put in is a number
                    double Setnumber;
                    string TimeSetParameter = args[1];
                    if (!double.TryParse(TimeSetParameter, out Setnumber))
                    {
                        SendChatMessage(player, Lang("1Invalid Time Set", player.Id, TimeSetParameter));
                        return;
                    }

                    var CleanClock = args[1].Replace(":", "");

                    if (args[1].Length <= 3)
                    {
                        SendChatMessage(player, Lang("1Invalid Time Length", player.Id, TimeSetParameter));
                        return;
                    }

                    var SplitHour = CleanClock.Substring(0, 2);
                    var SplitMinute = CleanClock.Substring(2, 2);

                    var ConvertHour = Convert.ToInt32(SplitHour);
                    var ConvertMinute = Convert.ToInt32(SplitMinute);

                    string ClockInText = $"{SplitHour}:{SplitMinute}:00";

                    if (ConvertHour >= 24 || ConvertMinute >= 60)
                    {
                        SendChatMessage(player, Lang("1Invalid Time Set", player.Id, TimeSetParameter));
                        return;
                    }

                    server.Time = server.Time.Date + TimeSpan.Parse($"{SplitHour}:{SplitMinute}:00");

                    SendChatMessage(player, Lang("1Time Changed", player.Id, ClockInText));

                return;
                #endregion

                #region Add
                /*case "add":

                    if (!HasPerm && !player.IsServer)
                    {
                        SendChatMessage(player, "Angry Time", covalence.FormatText(lang.GetMessage("No Permission", this, player.Id).Replace("{player}", player.Name).Replace("{command}", command)));
                        return;
                    }

                    if (args.Length != 2)
                    {
                        if (!player.IsServer)
                        {
                            SendChatMessage(player, "Angry Time", covalence.FormatText(lang.GetMessage("Invalid Syntax Add Chat", this, player.Id)));
                            return;
                        }

                        SendConsoleMessage(player, "Angry Time", covalence.FormatText(lang.GetMessage("Invalid Syntax Add Console", this, player.Id)));
                        return;
                    }

                    // Checking to see if the parameter put in is a number
                    double number2;
                    string TimeParameter2 = args[1];
                    if (!double.TryParse(TimeParameter2, out number2))
                    {
                        if (!player.IsServer)
                        {
                            SendChatMessage(player, "Angry Time", covalence.FormatText(lang.GetMessage("Invalid Time Add Chat", this, player.Id).Replace("{time}", TimeParameter2)));
                            return;
                        }

                        SendConsoleMessage(player, "Angry Time", covalence.FormatText(lang.GetMessage("Invalid Time Add Console", this, player.Id).Replace("{time}", TimeParameter2)));
                        return;
                    }

                    var ConvertTime = Convert.ToInt32(TimeParameter2);
                    decimal MathTime = ConvertTime / 100m;
                    var UsableTime = Math.Round(MathTime, 2);

                    server.Command("env.addtime " + UsableTime);

                    if (!player.IsServer)
                    {
                        SendChatMessage(player, "Angry Time", covalence.FormatText(lang.GetMessage("Time Added Chat", this, player.Id).Replace("{time}", TimeParameter2)));
                        return;
                    }

                    SendConsoleMessage(player, "Angry Time", covalence.FormatText(lang.GetMessage("Time Added Console", this, player.Id).Replace("{time}", TimeParameter2)));

                return;*/
                #endregion

                #region Help
                case "help":

                    if (!player.IsServer)
                    {
                        if (!CanAdmin(player))
                        {
                            SendInfoMessage(player, Lang("Time Help Command Player", player.Id));
                            return;
                        }

                        SendInfoMessage(player, Lang("Time Help Command Admin", player.Id));
                        return;
                    }

                    SendChatMessage(player, Lang("Time Help Command Console", player.Id));

                return;
                #endregion
            }
        }

        #endregion

        #region Functions

        private void UseRealTimeClock()
        {
            // TODO: Have it so users can add hours
            timer.Once(60, () =>
            {
                if (useRealDate && useRealTime)
                {
                    timer.Repeat(1f, 0, () => { RealDateTime(); });
                    return;
                }

                if (useRealTime)
                {
                    timer.Repeat(1f, 0, () => { RealTime(); });
                }

                if (useRealDate)
                {
                    timer.Repeat(900f, 0, () => { RealDate(); });
                }
            });
        }

        private void CheckTimeCycle()
        {
            if (!useSkipTime) return;

            var TimeAddition = ($":00:00");

            timer.Once(60, () => 
            {
                timer.Repeat(10, 0, () =>
                {
                    if (server.Time.Hour >= sunsetHour || server.Time.Hour < sunriseHour)
                    {
                        server.Time = server.Time.Date + TimeSpan.Parse(sunriseHour + TimeAddition);

                        if (informSkipConsole == true)
                        {
                            Puts(Lang("1Time Skipped", null, server.Time.ToString("HH:mm:ss")));
                        }
                    }
                });
            });
        }

        private void InitDate()
        {
            if (useRealDate)
            {
                timer.Once(60, () => { RealDate(); });
            }
        }

        #region Date & Time

        private void RealDateTime()
        {
            DateTime CurrentDate = new DateTime(DateTime.Now.Year, DateTime.Now.Month, DateTime.Now.Day);
            TimeSpan CurrentTime = new TimeSpan(DateTime.Now.Hour, DateTime.Now.Minute, DateTime.Now.Second);
            server.Time = CurrentDate + CurrentTime;
        }

        private void RealTime()
        {
            TimeSpan CurrentTime = new TimeSpan(DateTime.Now.Hour, DateTime.Now.Minute, DateTime.Now.Second);
            server.Time = server.Time.Date + CurrentTime;
        }

        private void RealDate()
        {
            DateTime CurrentDate = new DateTime(DateTime.Now.Year, DateTime.Now.Month, DateTime.Now.Day);
            server.Time = CurrentDate + server.Time.TimeOfDay;
        }

        #endregion Date & Time

        #region Checkers

        private bool CanAdmin(IPlayer player)
        {
            return (permission.UserHasPermission(player.Id, adminPermission));
        }

        private bool CheckTimes()
        {
            return (useSkipTime && useRealTime);
        }

        private void NoCollideCheck()
        {
            if (!CheckTimes())
            {
                UseRealTimeClock();
                CheckTimeCycle();
            }
            else
            {
                PrintError(Lang("1Collide Error", null));
            }
        }

        #endregion Checkers

        #endregion

        #region Helpers

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;

            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }

            object value;

            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        #endregion

        #region Messages

        private void SendChatMessage(IPlayer player, string message)
        {
            player.Reply(message, covalence.FormatText($"[{messagePrefixColor}]{messagePrefix}[/#]:"));
        }

        private void SendInfoMessage(IPlayer player, string message)
        {
            player.Reply(message, covalence.FormatText($"[+18][{messagePrefixColor}]{messagePrefix}[/#][/+]\n\n"));
        }

        #endregion
    }
}

// --- End of file: AngryTime.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/admin-anti-hack-fix ---
// --- Original File Path: A/AdminAntiHackFix/AdminAntiHackFix.cs ---

namespace Oxide.Plugins
{
    [Info("Admin AntiHack Fix", "Solarix", "1.0.0"), Description("Fix for admin staff getting kicked for AntiHack violation(s).")]
    public class AdminAntiHackFix : RustPlugin
    {
        private object OnPlayerViolation(BasePlayer player, AntiHackType type, float amount)
        {
            if ((type == AntiHackType.FlyHack || type == AntiHackType.InsideTerrain) && (player.IsAdmin || player.IsDeveloper)) return false;
            return null;
        }
    }
}

// --- End of file: AdminAntiHackFix.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/animals-home ---
// --- Original File Path: A/AnimalHome/AnimalHome.cs ---

using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Animal Home", "Krungh Crow", "1.0.3")]
    [Description("Adding a animal roam radius")]
    public class AnimalHome : RustPlugin
    {
    /**********************************************************************
     * 
     * v1.0.3   :   Added a additional check when animal reached home location
     * 
     **********************************************************************/
        public static AnimalHome instance;

        #region Oxide Hooks

        private void OnServerInitialized()
        {
            OnStart();
        }

        private void Unload()
        {
            OnEnd();
        }
        
        private void OnEntitySpawned(BaseNetworkable entity)
        {
            AddLogic(entity);
        }

        #endregion

        #region Helpers

        private void OnStart()
        {
            instance = this;

            foreach (var entity in UnityEngine.Object.FindObjectsOfType<BaseEntity>())
            {
                AddLogic(entity);
            }
        }

        private void OnEnd()
        {
            foreach (var logic in UnityEngine.Object.FindObjectsOfType<OLogic>().ToList())
            {
                logic.DoDestroy();
            }
        }

        private void AddLogic(BaseNetworkable entity)
        {
            var npc = entity.GetComponent<BaseNpc>();
            if (npc == null) {return;}
            if (config.blocked.Contains(entity.ShortPrefabName)) {return;}
            if (entity.GetComponent<OLogic>() != null) {return;}
            entity.gameObject.AddComponent<OLogic>();
            //Puts($"Added logic to : {entity}");
        }

        #endregion

        #region Config

        private static ConfigData config;
        
        private class ConfigData
        {    
            [JsonProperty(PropertyName = "Time between checks")]
            public float timer;
            
            [JsonProperty(PropertyName = "Max distance between Home and NPC")]
            public float distance;
            
            [JsonProperty(PropertyName = "Blocked NPC types (logic will not work for them)")]
            public List<string> blocked;
        }
        
        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                timer = 30f,
                distance = 50f,
                blocked = new List<string>
                {
                    "example.name",
                    "example.name",
                    "example.name"
                }
            };
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
   
            try
            {
                config = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region MonoBehaviour

        private class OLogic: MonoBehaviour
        {
            private Vector3 home;
            private BaseNpc npc;
            private float distance;
            private float time;

            private void Awake()
            {
                npc = GetComponent<BaseNpc>();
                home = npc.transform.position;
                distance = config.distance;
                time = config.timer;
                
                InvokeRepeating("CheckDistance", 1f, time);
            }

            private void CheckDistance()
            {
                if (npc == null || npc.IsDestroyed) return;

                if (Vector3.Distance(home, npc.transform.position) < 1)
                {
                    //instance.Puts($"{npc} is at home spawn point {home}");
                    return;
                }

                if (Vector3.Distance(home, npc.transform.position) > distance)
                {
                    npc.UpdateDestination(home);
                    //instance.Puts($"Sending {npc} home {home}");
                }
            }

            public void DoDestroy()
            {
                Destroy(this);
            }

            private void OnDestroy()
            {
                CancelInvoke("CheckDistance");
            }
        }

        #endregion
    }
}

// --- End of file: AnimalHome.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/auto-lock ---
// --- Original File Path: A/AutoLock/AutoLock.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using JetBrains.Annotations;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using Object = UnityEngine.Object;
using Random = Oxide.Core.Random;

namespace Oxide.Plugins
{
    [Info("Auto Lock", "birthdates", "2.4.5")]
    [Description("Automatically adds a codelock to a lockable entity with a set pin")]
    public class AutoLock : RustPlugin
    {
        #region Variables

        private const string PermissionUse = "autolock.use";
        private const string PermissionItemBypass = "autolock.item.bypass";

        private readonly Dictionary<BasePlayer, TimedCodeLock> _awaitingResponse =
            new Dictionary<BasePlayer, TimedCodeLock>();

        [UsedImplicitly] [PluginReference("NoEscape")]
        private Plugin _noEscape;

        private struct TimedCodeLock
        {
            public CodeLock CodeLock { get; set; }
            public DateTime Expiry { get; set; }
        }

        #endregion

        #region Hooks

        [UsedImplicitly]
        private void Init()
        {
            LoadConfig();
            permission.RegisterPermission(PermissionUse, this);
            permission.RegisterPermission(PermissionItemBypass, this);
            _data = Interface.Oxide.DataFileSystem.ReadObject<Data>(Name);

            cmd.AddChatCommand("autolock", this, ChatCommand);
            cmd.AddChatCommand("al", this, ChatCommand);
            if (_config.CodeLockExpiry <= 0f) Unsubscribe(nameof(OnServerInitialized));
        }

        [UsedImplicitly]
        private void OnServerInitialized()
        {
            timer.Every(3f, () =>
            {
                for (var i = _awaitingResponse.Count - 1; i > 0; i--)
                {
                    var timedLock = _awaitingResponse.ElementAt(i);
                    if (timedLock.Value.Expiry > DateTime.UtcNow) continue;
                    _awaitingResponse.Remove(timedLock.Key);
                }
            });
        }

        [UsedImplicitly]
        private void OnEntityBuilt(HeldEntity plan, GameObject go)
        {
            var player = plan.GetOwnerPlayer();
            if (player == null) return;
            if (!permission.UserHasPermission(player.UserIDString, PermissionUse)) return;
            var entity = go.ToBaseEntity() as DecayEntity;
            if (entity == null || _config.Disabled.Contains(entity.PrefabName)) return;
            var container = entity as StorageContainer;
            if (entity.IsLocked() || container != null && container.inventorySlots < 12 ||
                !container && !(entity is AnimatedBuildingBlock)) return;
            if (_noEscape != null)
            {
                if (_config.NoEscapeSettings.BlockRaid && _noEscape.Call<bool>("IsRaidBlocked", player.UserIDString))
                {
                    player.ChatMessage(lang.GetMessage("RaidBlocked", this, player.UserIDString));
                    return;
                }

                if (_config.NoEscapeSettings.BlockCombat &&
                    _noEscape.Call<bool>("IsCombatBlocked", player.UserIDString))
                {
                    player.ChatMessage(lang.GetMessage("CombatBlocked", this, player.UserIDString));
                    return;
                }
            }


            var playerData = CreateDataIfAbsent(player.UserIDString);
            if (!playerData.Enabled || !HasCodeLock(player)) return;
            var code = GameManager.server.CreateEntity("assets/prefabs/locks/keypad/lock.code.prefab") as CodeLock;
            if (code != null)
            {
                code.gameObject.Identity();
                code.SetParent(entity, entity.GetSlotAnchorName(BaseEntity.Slot.Lock));
                code.Spawn();
                code.code = playerData.Code;
                code.hasCode = true;
                entity.SetSlot(BaseEntity.Slot.Lock, code);
                Effect.server.Run("assets/prefabs/locks/keypad/effects/lock-code-deploy.prefab",
                    code.transform.position);
                code.whitelistPlayers.Add(player.userID);
                code.SetFlag(BaseEntity.Flags.Locked, true);
            }

            TakeCodeLock(player);
            player.ChatMessage(string.Format(lang.GetMessage("CodeAdded", this, player.UserIDString),
                player.net.connection.info.GetBool("global.streamermode") ? "****" : playerData.Code));
        }

        private static string GetRandomCode()
        {
            return Random.Range(1000, 9999).ToString();
        }

        [UsedImplicitly]
        private void OnServerShutdown()
        {
            Unload();
        }

        private void Unload()
        {
            SaveData();
            foreach (var timedLock in _awaitingResponse.Values.Where(timedLock => !timedLock.CodeLock.IsDestroyed))
                timedLock.CodeLock.Kill();
        }

        private PlayerData CreateDataIfAbsent(string id)
        {
            PlayerData playerData;
            if (_data.Codes.TryGetValue(id, out playerData)) return playerData;
            _data.Codes.Add(id, playerData = new PlayerData
            {
                Code = GetRandomCode(),
                Enabled = true
            });
            return playerData;
        }

        #endregion

        #region Command

        private void ChatCommand(BasePlayer player, string label, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionUse))
            {
                player.ChatMessage(lang.GetMessage("NoPermission", this, player.UserIDString));
                return;
            }

            if (args.Length < 1)
            {
                player.ChatMessage(string.Format(lang.GetMessage("InvalidArgs", this, player.UserIDString), label));
                return;
            }

            CreateDataIfAbsent(player.UserIDString);
            switch (args[0].ToLower())
            {
                case "code":
                    OpenCodeLockUI(player);
                    break;
                case "toggle":
                    player.ChatMessage(lang.GetMessage(Toggle(player) ? "Enabled" : "Disabled", this,
                        player.UserIDString));
                    break;
                default:
                    player.ChatMessage(string.Format(lang.GetMessage("InvalidArgs", this, player.UserIDString), label));
                    break;
            }
        }

        private static bool HasCodeLock(BasePlayer player)
        {
            return player.IPlayer.HasPermission(PermissionItemBypass) || player.inventory.FindItemByItemID(1159991980) != null;
        }

        private static void TakeCodeLock(BasePlayer player)
        {
            if (!player.IPlayer.HasPermission(PermissionItemBypass))
                player.inventory.Take(null, 1159991980, 1);
        }

        private void OpenCodeLockUI(BasePlayer player)
        {
            var codeLock = GameManager.server.CreateEntity("assets/prefabs/locks/keypad/lock.code.prefab",
                player.eyes.position + new Vector3(0, -3, 0)) as CodeLock;
            if (codeLock == null) return;
            codeLock.Spawn();
            codeLock.SetFlag(BaseEntity.Flags.Locked, true);
            codeLock.ClientRPCPlayer(null, player, "EnterUnlockCode");
            if (_awaitingResponse.ContainsKey(player)) _awaitingResponse.Remove(player);
            _awaitingResponse.Add(player,
                new TimedCodeLock {CodeLock = codeLock, Expiry = DateTime.UtcNow.AddSeconds(_config.CodeLockExpiry)});
            if (_awaitingResponse.Count == 1) Subscribe("OnCodeEntered");

            timer.In(20f, () =>
            {
                if (!codeLock.IsDestroyed) codeLock.Kill();
            });
        }

        [UsedImplicitly]
        private void OnCodeEntered(Object codeLock, BasePlayer player, string code)
        {
            TimedCodeLock timedCodeLock;
            if (player == null || !_awaitingResponse.TryGetValue(player, out timedCodeLock)) return;
            var playerCodeLock = timedCodeLock.CodeLock;
            if (playerCodeLock != codeLock)
            {
                if (!playerCodeLock.IsDestroyed) playerCodeLock.Kill();
                _awaitingResponse.Remove(player);
                return;
            }

            var pData = _data.Codes[player.UserIDString];
            pData.Code = code;
            player.ChatMessage(string.Format(lang.GetMessage("CodeUpdated", this, player.UserIDString),
                player.net.connection.info.GetBool("global.streamermode") ? "****" : code));

            var prefab = playerCodeLock.effectCodeChanged;
            if (!playerCodeLock.IsDestroyed) playerCodeLock.Kill();
            _awaitingResponse.Remove(player);

            Effect.server.Run(prefab.resourcePath, player.transform.position);
            if (_awaitingResponse.Count < 1) Unsubscribe("OnCodeEntered");
        }

        private bool Toggle(BasePlayer player)
        {
            var data = _data.Codes[player.UserIDString];
            var newToggle = !data.Enabled;
            data.Enabled = newToggle;
            return newToggle;
        }

        #endregion

        #region Configuration & Language

        private ConfigFile _config;
        private Data _data;

        private class PlayerData
        {
            public string Code;
            public bool Enabled;
        }

        private class Data
        {
            public readonly Dictionary<string, PlayerData> Codes = new Dictionary<string, PlayerData>();
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"CodeAdded", "Codelock placed with code {0}."},
                {"Disabled", "You have disabled auto locks."},
                {"Enabled", "You have enabled auto locks."},
                {"CodeUpdated", "Your new code is {0}."},
                {"NoPermission", "You don't have permission."},
                {"InvalidArgs", "/{0} code|toggle|hide"},
                {"RaidBlocked", "The codelock wasn't automatically locked due to you being raid blocked!"},
                {"CombatBlocked", "The codelock wasn't automatically locked due to you being combat blocked!"}
            }, this);
        }

        public class ConfigFile
        {
            [JsonProperty("Code Lock Expiry Time (Seconds, put -1 if you want to disable)")]
            public float CodeLockExpiry;

            [JsonProperty("Disabled Items (Prefabs)")]
            public List<string> Disabled;

            [JsonProperty("No Escape")] public NoEscapeSettings NoEscapeSettings;

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    Disabled = new List<string>
                    {
                        "assets/prefabs/deployable/large wood storage/box.wooden.large.prefab"
                    },
                    CodeLockExpiry = 10f,
                    NoEscapeSettings = new NoEscapeSettings
                    {
                        BlockCombat = true,
                        BlockRaid = true
                    }
                };
            }
        }

        public class NoEscapeSettings
        {
            [JsonProperty("Block Auto Lock whilst in Combat?")]
            public bool BlockCombat;

            [JsonProperty("Block Auto Lock whilst Raid Blocked?")]
            public bool BlockRaid;
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, _data);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if (_config == null) LoadDefaultConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        #endregion
    }
}
//Generated with birthdates' Plugin Maker

// --- End of file: AutoLock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/auto-turret-authorization ---
// --- Original File Path: A/AutoTurretAuth/AutoTurretAuth.cs ---

using System.Collections;
using System.Collections.Generic;
using System.Linq;
using ProtoBuf;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Auto Turret Authorization", "haggbart", "1.2.3")]
    [Description("One-way synchronizing cupboard authorization with auto turrets")]
    class AutoTurretAuth : RustPlugin
    {
        #region Initialization

        private static IEnumerable<AutoTurret> turrets;
        private static HashSet<PlayerNameID> authorizedPlayers;
        private const string PERSISTENT_AUTHORIZATION = "Use persistent authorization?";
        
        protected override void LoadDefaultConfig()
        {
            Config[PERSISTENT_AUTHORIZATION] = true;
        }

        private void Init()
        {
            if ((bool)Config[PERSISTENT_AUTHORIZATION])
            {
                Unsubscribe(nameof(OnCupboardAuthorize));
                Unsubscribe(nameof(OnCupboardDeauthorize));
                Unsubscribe(nameof(OnCupboardClearList));
            }
            else
            {
                Unsubscribe(nameof(OnTurretTarget));
            }
        }

        #endregion Initialization

        #region Hooks
        
        private object OnTurretTarget(AutoTurret turret, BaseCombatEntity entity)
        {
            var player = entity as BasePlayer;
            if (player == null) return null;
            if (!IsAuthed(player, turret)) return null;
            Auth(turret, GetPlayerNameId(player));
            return false;
        }
        
        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            var turret = go.ToBaseEntity() as AutoTurret;
            if (turret == null) return;
            authorizedPlayers = turret.GetBuildingPrivilege()?.authorizedPlayers;
            if (authorizedPlayers == null) return;
            foreach (PlayerNameID playerNameId in authorizedPlayers)
            {
                Auth(turret, playerNameId);
            }
        }

        private void OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player)
        {
            FindTurrets(privilege.buildingID);
            ServerMgr.Instance.StartCoroutine(AddPlayer(GetPlayerNameId(player)));
        }
        
        private void OnCupboardDeauthorize(BuildingPrivlidge privilege, BasePlayer player)
        {
            FindTurrets(privilege.buildingID);
            ServerMgr.Instance.StartCoroutine(RemovePlayer(player.userID));
        }
        
        private void OnCupboardClearList(BuildingPrivlidge privilege, BasePlayer player)
        {
            FindTurrets(privilege.buildingID);
            ServerMgr.Instance.StartCoroutine(RemoveAll());
        }

        #endregion Hooks

        #region Helpers

        private static bool IsAuthed(BasePlayer player, BaseEntity turret)
        {
            authorizedPlayers = turret.GetBuildingPrivilege()?.authorizedPlayers;
            return authorizedPlayers != null && authorizedPlayers.Any(playerNameId => playerNameId != null && playerNameId.userid == player.userID);
        }
        
        private static void Auth(AutoTurret turret, PlayerNameID playerNameId)
        {
            turret.authorizedPlayers.Add(playerNameId);
            turret.SendNetworkUpdate();
        }

        private static PlayerNameID GetPlayerNameId(BasePlayer player)
        {
            var playerNameId = new PlayerNameID()
            {
                userid = player.userID,
                username = player.displayName
            };
            return playerNameId;
        }

        private static void FindTurrets(uint buildingId)
        {
            turrets = UnityEngine.Object.FindObjectsOfType<AutoTurret>()
                .Where(x => x.GetBuildingPrivilege()?.buildingID == buildingId);
        }
        
        private static IEnumerator AddPlayer(PlayerNameID playerNameId)
        {
            foreach (AutoTurret turret in turrets)
            {
                AddPlayer(turret, playerNameId);
                yield return new WaitForFixedUpdate();
            }
        }

        private static void AddPlayer(AutoTurret turret, PlayerNameID playerNameId)
        {
            RemovePlayer(turret, playerNameId.userid);
            turret.authorizedPlayers.Add(playerNameId);
            turret.target = null;
            turret.SendNetworkUpdate();
        }
        
        private static IEnumerator RemovePlayer(ulong userId)
        {
            foreach (AutoTurret turret in turrets)
            {
                RemovePlayer(turret, userId);
                yield return new WaitForFixedUpdate();
            }
        }

        private static void RemovePlayer(AutoTurret turret, ulong userId)
        {
            if (turret.authorizedPlayers.RemoveWhere( x => x.userid == userId) == 0) return;
            turret.SendNetworkUpdate();
        }
        
        private static IEnumerator RemoveAll()
        {
            foreach (AutoTurret turret in turrets)
            {
                turret.authorizedPlayers.Clear();
                turret.SendNetworkUpdate();
                yield return new WaitForFixedUpdate();
            }
        }

        #endregion Helpers
    }
}

// --- End of file: AutoTurretAuth.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/auto-deposit ---
// --- Original File Path: A/AutoDeposit/AutoDeposit.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Auto Deposit", "DC", "1.0.1")]
    [Description("Simply adds items to containers if that container already has that item!")]
    class AutoDeposit : RustPlugin
    {

        #region Variables

        List<BasePlayer> playersSort = new List<BasePlayer>();

        #endregion

        #region Commands

        private void CommandDeposit(BasePlayer player, string commands, string[] args)
        {
            //Checks to see if player has permissions.
            if (!permission.UserHasPermission(player.UserIDString, "autodeposit.use"))
            {
                player.ChatMessage($"{lang.GetMessage("NoPermission", this)}");
                return;
            }

            //Check if player is currently sorting if they are disable the sorting or enable.
            if (!playersSort.Contains(player))
            {
                playersSort.Add(player);
                

                if (config.useTimer)
                {
                    player.ChatMessage($"{lang.GetMessage("DepositActiveTimer", this)}");

                    timer.Once(config.autoDisableTime, () =>
                    {
                        playersSort.Remove(player);
                        player.ChatMessage($"{lang.GetMessage("DepositDeactivated", this)}");
                    });
                }
                else
                {
                    player.ChatMessage($"{lang.GetMessage("DepositActiveNoTimer", this)}");
                }
            }
            else
            {
                playersSort.Remove(player);
                player.ChatMessage($"{lang.GetMessage("DepositDeactivated", this)}");
            }
        }

        #endregion

        #region Lang

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPermission"] = $"You don't have permission to use this command.",
                ["DepositActiveNoTimer"] = $"AutoDeposit active, use /{config.depositCommand} to deactivate.",
                ["DepositActiveTimer"] = $"AutoDeposit active, auto disabling in {config.autoDisableTime} seconds.",
                ["DepositDeactivated"] = $"AutoDeposit deactivated."
            }, this);
        }

        #endregion

        #region Hooks

        private void OnServerInitialized()
        {
            cmd.AddChatCommand(config.depositCommand, this, CommandDeposit);
            permission.RegisterPermission("autodeposit.use", this);
        }

        /*
        Does a simple check on if an entity can be looted if it can it then checks if its on the config block list of containers.
        After it will do a simple compare of the items in both containers.
        If they match it will check if the item is on the config block list of items. If it isn't it will move the item.
        */

        private void OnLootEntity(BasePlayer player, StorageContainer entity)
        {

            if (player == null || entity == null)
                return;

            if (!playersSort.Contains(player))
                return;

            //Checks to see if player has access to storage
            if (entity.CanBeLooted(player))
            {
                //Compares the items and moves them if they can, also checks if container is ignored by config or playerData
                if (config.allowedContainers.Contains(entity.ShortPrefabName))
                {

                    ItemContainer pContainer = player.inventory.containerMain;
                    ItemContainer eContainer = entity.inventory;

                    List<Item> toMove = CompareItemContainers(pContainer, eContainer);

                    foreach (Item item in toMove)
                    {
                        string itemName = item.info.shortname;

                        if (!config.disallowedItemNames.Contains(itemName))
                        {
                            item.MoveToContainer(eContainer);
                        }
                    }
                }
            }
        }

        #endregion

        #region Helpers

        private List<Item> CompareItemContainers(ItemContainer fContainer, ItemContainer sContainer)
        {
            List<Item> itemsToMove = new List<Item>();

            if (fContainer != null && sContainer != null)
            {
                foreach (Item pItem in fContainer.itemList)
                {
                    foreach (Item sItem in sContainer.itemList)
                    {
                        if (pItem.info.itemid != sItem.info.itemid)
                        {
                            continue;
                        }

                        itemsToMove.Add(pItem);
                        break;
                    }
                }
            }
            return itemsToMove;
        }

        #endregion

        #region Config

        private Configuration config;

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<Configuration>();
            }
            catch { }

            if (config == null)
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        public class Configuration
        {
            [JsonProperty(PropertyName = "Allowed Containers")]
            public string[] allowedContainers = new string[]
            {
                "box.wooden.large",
                "woodbox_deployed",
                "coffinstorage",
                "vendingmachine.deployed",
                "dropbox.deployed",
                "cupboard.tool.deployed",
                "fridge.deployed"
            };

            [JsonProperty(PropertyName = "Disallowed Items")]
            public string[] disallowedItemNames = new string[]
            {

            };

            [JsonProperty(PropertyName = "Use Timer")]
            public bool useTimer = true;

            [JsonProperty(PropertyName = "Autodisable Time")]
            public float autoDisableTime = 10f;

            [JsonProperty(PropertyName = "Deposit Command")]
            public string depositCommand = "depo";

        }

        protected override void SaveConfig() => Config.WriteObject(config);

        protected override void LoadDefaultConfig() => config = new Configuration();

        #endregion

    }
}

// --- End of file: AutoDeposit.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/admin-utilities ---
// --- Original File Path: A/AdminUtilities/AdminUtilities.cs ---

using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using CompanionServer.Handlers;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;
using Network;

namespace Oxide.Plugins
{
    [Info("Admin Utilities", "dFxPhoeniX", "2.1.4")]
    [Description("Toggle NoClip, teleport Under Terrain and more")]
    public class AdminUtilities : RustPlugin
    {
        private const string permTerrain = "adminutilities.disconnectteleport";
        private const string permInventory = "adminutilities.saveinventory";
        private const string permHHT = "adminutilities.maxhht";
        private const string permNoClip = "adminutilities.nocliptoggle";
        private const string permGodMode = "adminutilities.godmodetoggle";

        private DataFileSystem dataFile;
        private DataFileSystem dataFileItems;

        private bool newSave;

        ////////////////////////////////////////////////////////////
        // Files
        ////////////////////////////////////////////////////////////

        private class PlayerInfo
        {
            public string Teleport { get; set; } = Vector3.zero.ToString();
            public bool SaveInventory { get; set; } = true;
            public bool UnderTerrain { get; set; } = false;
            public bool NoClip { get; set; } = false;
            public bool GodMode { get; set; } = false;
        }

        private Dictionary<string, PlayerInfo> playerInfoCache = new Dictionary<string, PlayerInfo>();

        private class PlayerInfoItems
        {
            public List<AdminUtilitiesItem> Items { get; set; } = new List<AdminUtilitiesItem>();
        }

        private Dictionary<string, PlayerInfoItems> playerInfoItemsCache = new Dictionary<string, PlayerInfoItems>();

        private class AdminUtilitiesItem
        {
            public List<AdminUtilitiesItem> contents { get; set; }
            public string container { get; set; } = "main";
            public int ammo { get; set; }
            public int amount { get; set; }
            public string ammoType { get; set; }
            public float condition { get; set; }
            public float fuel { get; set; }
            public int frequency { get; set; }
            public int itemid { get; set; }
            public float maxCondition { get; set; }
            public string name { get; set; }
            public int position { get; set; } = -1;
            public ulong skin { get; set; }
            public string text { get; set; }
            public int blueprintAmount { get; set; }
            public int blueprintTarget { get; set; }
            public int dataInt { get; set; }
            public ulong subEntity { get; set; }
            public bool shouldPool { get; set; }

            public AdminUtilitiesItem() { }

            public AdminUtilitiesItem(string container, Item item)
            {
                this.container = container;
                itemid = item.info.itemid;
                name = item.name;
                text = item.text;
                amount = item.amount;
                condition = item.condition;
                maxCondition = item.maxCondition;
                fuel = item.fuel;
                position = item.position;
                skin = item.skin;

                if (item.instanceData != null)
                {
                    dataInt = item.instanceData.dataInt;
                    blueprintAmount = item.instanceData.blueprintAmount;
                    blueprintTarget = item.instanceData.blueprintTarget;
                    subEntity = item.instanceData.subEntity.Value;
                    shouldPool = item.instanceData.ShouldPool;
                }

                if (item.GetHeldEntity() is HeldEntity e)
                {
                    if (e is BaseProjectile baseProjectile)
                    {
                        ammo = baseProjectile.primaryMagazine.contents;
                        ammoType = baseProjectile.primaryMagazine.ammoType.shortname;
                    }
                    else if (e is FlameThrower flameThrower)
                    {
                        ammo = flameThrower.ammo;
                    }
                }

                if (ItemModAssociatedEntity<PagerEntity>.GetAssociatedEntity(item) is PagerEntity pagerEntity)
                {
                    frequency = pagerEntity.GetFrequency();
                }

                if (item.contents?.itemList?.Count > 0)
                {
                    contents = new();

                    foreach (var mod in item.contents.itemList)
                    {
                        contents.Add(new("default", mod));
                    }
                }
            }

            public static Item Create(AdminUtilitiesItem aui)
            {
                if (aui.itemid == 0 || string.IsNullOrEmpty(aui.container))
                {
                    return null;
                }

                Item item;
                if (aui.blueprintTarget != 0)
                {
                    item = ItemManager.Create(Workbench.GetBlueprintTemplate());
                    item.blueprintTarget = aui.blueprintTarget;
                    item.amount = aui.blueprintAmount;
                }
                else item = ItemManager.CreateByItemID(aui.itemid, aui.amount, aui.skin);

                if (item == null)
                {
                    return null;
                }

                if (aui.blueprintAmount != 0 || aui.blueprintTarget != 0 || aui.dataInt != 0 || aui.subEntity != 0)
                {
                    item.instanceData = aui.shouldPool ? Pool.Get<ProtoBuf.Item.InstanceData>() : new ProtoBuf.Item.InstanceData();
                    item.instanceData.ShouldPool = aui.shouldPool;
                    item.instanceData.blueprintAmount = aui.blueprintAmount;
                    item.instanceData.blueprintTarget = aui.blueprintTarget;
                    item.instanceData.dataInt = aui.dataInt;
                    item.instanceData.subEntity = new(aui.subEntity);
                }

                if (!string.IsNullOrEmpty(aui.name))
                {
                    item.name = aui.name;
                }

                if (!string.IsNullOrEmpty(aui.text))
                {
                    item.text = aui.text;
                }

                if (item.GetHeldEntity() is HeldEntity e)
                {
                    if (item.skin != 0)
                    {
                        e.skinID = item.skin;
                    }

                    if (e is BaseProjectile baseProjectile)
                    {
                        baseProjectile.DelayedModsChanged();
                        baseProjectile.primaryMagazine.contents = aui.ammo;
                        if (!string.IsNullOrEmpty(aui.ammoType))
                        {
                            baseProjectile.primaryMagazine.ammoType = ItemManager.FindItemDefinition(aui.ammoType);
                        }
                    }
                    else if (e is FlameThrower flameThrower)
                    {
                        flameThrower.ammo = aui.ammo;
                    }
                    else if (e is Chainsaw chainsaw)
                    {
                        chainsaw.ammo = aui.ammo;
                    }

                    e.SendNetworkUpdate();
                }

                if (aui.frequency > 0 && item.info.GetComponentInChildren<ItemModRFListener>() is ItemModRFListener rfListener)
                {
                    if (item.instanceData.subEntity.IsValid && BaseNetworkable.serverEntities.Find(item.instanceData.subEntity) is PagerEntity pagerEntity)
                    {
                        pagerEntity.ChangeFrequency(aui.frequency);
                    }
                }

                if (aui.contents != null)
                {
                    foreach (var aum in aui.contents)
                    {
                        Item mod = Create(aum);

                        if (mod != null && !mod.MoveToContainer(item.contents))
                        {
                            mod.Remove();
                        }
                    }
                }

                if (item.hasCondition)
                {
                    item._maxCondition = aui.maxCondition;
                    item._condition = aui.condition;
                }

                item.fuel = aui.fuel;
                item.MarkDirty();

                return item;
            }

            public static void Restore(BasePlayer player, AdminUtilitiesItem aui)
            {
                Item item = Create(aui);

                if (item == null)
                {
                    return;
                }

                ItemContainer newcontainer = aui.container switch
                {
                    "belt" => player.inventory.containerBelt,
                    "wear" => player.inventory.containerWear,
                    "main" or _ => player.inventory.containerMain,
                };

                if (!item.MoveToContainer(newcontainer, aui.position, true))
                {
                    player.GiveItem(item);
                }
            }
        }

        private PlayerInfo LoadPlayerInfo(BasePlayer player)
        {
            if (dataFile == null)
                return null;

            if (playerInfoCache.ContainsKey(player.UserIDString))
            {
                return playerInfoCache[player.UserIDString];
            }
            else
            {
                PlayerInfo user = dataFile.ReadObject<PlayerInfo>($"{player.UserIDString}");

                playerInfoCache[player.UserIDString] = user;

                return user;
            }
        }

        private void SavePlayerInfo(BasePlayer player, PlayerInfo playerInfo)
        {
            if (dataFile == null)
                return;

            dataFile.WriteObject<PlayerInfo>($"{player.UserIDString}", playerInfo);

            if (playerInfoCache.ContainsKey(player.UserIDString))
            {
                playerInfoCache.Remove(player.UserIDString);
            }
        }

        private PlayerInfoItems LoadPlayerInfoItems(BasePlayer player)
        {
            if (dataFileItems == null)
                return null;

            if (playerInfoItemsCache.ContainsKey(player.UserIDString))
            {
                return playerInfoItemsCache[player.UserIDString];
            }
            else
            {
                PlayerInfoItems userItems = dataFileItems.ReadObject<PlayerInfoItems>($"{player.UserIDString}");

                playerInfoItemsCache[player.UserIDString] = userItems;

                return userItems;
            }
        }

        private void SavePlayerInfoItems(BasePlayer player, PlayerInfoItems playerInfoItems)
        {
            if (dataFileItems == null)
                return;

            dataFileItems.WriteObject<PlayerInfoItems>($"{player.UserIDString}", playerInfoItems);

            if (playerInfoItemsCache.ContainsKey(player.UserIDString))
            {
                playerInfoItemsCache.Remove(player.UserIDString);
            }
        }

        ////////////////////////////////////////////////////////////
        // Oxide Hooks
        ////////////////////////////////////////////////////////////

        private void OnNewSave()
        {
            newSave = true;
        }

        private void Init()
        {
            InitConfig();

            dataFile = new DataFileSystem($"{Interface.Oxide.DataDirectory}\\AdminUtilities\\Settings");
            dataFileItems = new DataFileSystem($"{Interface.Oxide.DataDirectory}\\AdminUtilities\\Items");
        }

        private void Loaded()
        {
            permission.RegisterPermission(permTerrain, this);
            permission.RegisterPermission(permInventory, this);
            permission.RegisterPermission(permHHT, this);
            permission.RegisterPermission(permNoClip, this);
            permission.RegisterPermission(permGodMode, this);
        }

        private void OnServerInformationUpdated()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                PlayerInfo user = LoadPlayerInfo(player);

                if (user == null)
                    return;

                timer.Once(0.2f, () => {
                    if (player.IsDeveloper && !(player.IsFlying || player.IsGod()))
                    {
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.IsDeveloper, false);
                    }
                });
            }
        }

        private object OnClientCommand(Connection connection, string command)
        {
            if (command.Contains("/"))
                return null;

            BasePlayer player = BasePlayer.FindByID(connection.userid);

            if (player == null)
                return null;

            PlayerInfo user = LoadPlayerInfo(player);

            if (user == null)
                return null;

            string lowerCommand = command.ToLower();

            if (lowerCommand.Contains("god"))
            {
                if (!HasPermission(player, permGodMode) && !user.GodMode && !player.IsGod())
                    return false;
            }

            return null;
        }

        private void OnServerInitialized()
        {
            if (GetSave())
            {
                if (wipeSettings)
                {
                    string folderPath = $"{Interface.Oxide.DataDirectory}/AdminUtilities/Settings";

                    if (!Directory.Exists(folderPath))
                    {
                        return;
                    }

                    string[] Files = Directory.GetFiles(folderPath);
                    foreach (string file in Files)
                    {
                        File.Delete(file);
                    }
                }

                if (wipeItems)
                {
                    string folderItemsPath = $"{Interface.Oxide.DataDirectory}/AdminUtilities/Items";

                    if (!Directory.Exists(folderItemsPath))
                    {
                        return;
                    }

                    string[] ItemsFiles = Directory.GetFiles(folderItemsPath);
                    foreach (string file in ItemsFiles)
                    {
                        File.Delete(file);
                    }
                }

                newSave = false;
            }
        }

        private void OnEntityTakeDamage(BasePlayer player, HitInfo info)
        {
            if (player == null || info == null)
                return;

            if (player.IsNpc || (player is NPCPlayer))
                return;

            PlayerInfo user = LoadPlayerInfo(player);

            if (user == null)
                return;

            if (user.UnderTerrain)
            {
                info.damageTypes = new Rust.DamageTypeList();
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            PlayerInfo user = LoadPlayerInfo(player);

            if (user == null)
                return;

            if (!HasPermission(player, permNoClip) && user.NoClip)
            {
                user.NoClip = false;
                SavePlayerInfo(player, user);
            }

            if (!HasPermission(player, permGodMode) && user.GodMode)
            {
                user.GodMode = false;
                SavePlayerInfo(player, user);
            }

            if (!persistentNoClip && user.NoClip)
            {
                user.NoClip = false;
                SavePlayerInfo(player, user);
            }

            if (!persistentGodMode && user.GodMode)
            {
                user.GodMode = false;
                SavePlayerInfo(player, user);
            }

            if (player.IsDead())
                return;

            if (HasPermission(player, permTerrain))
            {
                DisconnectTeleport(player);
            }

            if (HasPermission(player, permInventory) && user.SaveInventory)
            {
                SaveInventory(player);
            }
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            PlayerInfo user = LoadPlayerInfo(player);

            if (user == null)
                return;

            if (!HasPermission(player, permTerrain) && user.UnderTerrain)
            {
                NoUnderTerrain(player);
            }

            if (persistentNoClip && HasPermission(player, permNoClip) && user.NoClip)
            {
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsDeveloper, true);

                timer.Once(0.2f, () => {
                    player.SendConsoleCommand("noclip");
                });
            }

            if (persistentGodMode && HasPermission(player, permGodMode) && user.GodMode)
            {
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsDeveloper, true);

                timer.Once(0.2f, () => {
                    player.SendConsoleCommand("setinfo \"global.god\" \"True\"");
                });
            }
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            if (HasPermission(player, permHHT))
            {
                player.health = 100f;
                player.metabolism.hydration.value = player.metabolism.hydration.max;
                player.metabolism.calories.value = player.metabolism.calories.max;
            }
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            if (!player || !player.IsConnected)
                return;

            if (HasPermission(player, permTerrain))
            {
                NoUnderTerrain(player);
            }

            PlayerInfo user = LoadPlayerInfo(player);

            if (user == null)
                return;

            PlayerInfoItems userItems = LoadPlayerInfoItems(player);

            if (userItems == null)
                return;

            if (HasPermission(player, permInventory) && user.SaveInventory && userItems.Items.Count > 0)
            {
                List<Item> items = Pool.Get<List<Item>>();
                int count = player.inventory.GetAllItems(items);
                Pool.FreeUnmanaged(ref items);

                if (count == 2)
                {
                    if (player.inventory.GetAmount(ItemManager.FindItemDefinition("rock").itemid) == 1)
                    {
                        if (player.inventory.GetAmount(ItemManager.FindItemDefinition("torch").itemid) == 1)
                        {
                            player.inventory.Strip();
                        }
                    }
                }

                if (userItems.Items.Any(item => item.amount > 0))
                {
                    foreach (var aui in userItems.Items.ToList())
                    {
                        if (aui.amount > 0)
                        {
                            AdminUtilitiesItem.Restore(player, aui);
                        }
                    }
                }

                userItems.Items.Clear();
                SavePlayerInfoItems(player, userItems);
            }
        }

        private object OnPlayerViolation(BasePlayer player, AntiHackType type)
        {
            if (player.IsSleeping() && (type == AntiHackType.InsideTerrain) && HasPermission(player, permTerrain))
                return true;

            if (player.IsFlying && (type == AntiHackType.FlyHack || type == AntiHackType.InsideTerrain || type == AntiHackType.NoClip) && HasPermission(player, permNoClip))
                return true;

            return null;
        }

        ////////////////////////////////////////////////////////////
        // Commands
        ////////////////////////////////////////////////////////////

        [ChatCommand("disconnectteleport")]
        private void cmdDisconnectTeleport(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, permTerrain))
            {
                Player.Message(player, msg("NoPermission", player.UserIDString));
                return;
            }

            PlayerInfo user = LoadPlayerInfo(player);

            if (user == null)
                return;

            if (args.Length >= 1)
            {
                switch (args[0].ToLower())
                {
                    case "set":
                    {
                        if (args.Length == 4 && float.TryParse(args[1], out float x) && float.TryParse(args[2], out float y) && float.TryParse(args[3], out float z))
                        {
                            var customPos = new Vector3(x, y, z);

                            if (Vector3.Distance(customPos, Vector3.zero) <= TerrainMeta.Size.x / 1.5f && customPos.y > -100f && customPos.y < 4400f)
                            {
                                user.Teleport = customPos.ToString();
                                Player.Message(player, msg("PositionAdded", player.UserIDString, FormatPosition(customPos)));
                            }
                            else
                            {
                                Player.Message(player, msg("OutOfBounds", player.UserIDString));
                            }
                        }
                        else
                        {
                            Player.Message(player, msg("DisconnectTeleportSet", player.UserIDString, FormatPosition(user.Teleport.ToVector3())));
                        }

                        SavePlayerInfo(player, user);
                        return;
                    }
                    case "reset":
                    {
                        user.Teleport = defaultPos.ToString();
                        string message = defaultPos != Vector3.zero ? msg("PositionRemoved2", player.UserIDString, defaultPos) : msg("PositionRemoved1", player.UserIDString);
                        Player.Message(player, message);
                        SavePlayerInfo(player, user);
                        return;
                    }
                }
            }

            string teleportPos = FormatPosition(user.Teleport.ToVector3() == Vector3.zero ? defaultPos : user.Teleport.ToVector3());
            Player.Message(player, msg("DisconnectTeleportSet", player.UserIDString, teleportPos));
            Player.Message(player, msg("DisconnectTeleportReset", player.UserIDString));
        }

        [ChatCommand("saveinventory")]
        private void cmdSaveInventory(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, permInventory))
            {
                Player.Message(player, msg("NoPermission", player.UserIDString));
                return;
            }

            PlayerInfo user = LoadPlayerInfo(player);

            if (user == null)
                return;

            user.SaveInventory = !user.SaveInventory;
            Player.Message(player, msg(user.SaveInventory ? "SavingInventory" : "NotSavingInventory", player.UserIDString));
            SavePlayerInfo(player, user);
        }

        [ChatCommand("noclip")]
        private void cmdNoClip(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, permNoClip))
            {
                Player.Message(player, msg("NoPermission", player.UserIDString));
                return;
            }

            ToggleNoClip(player);
        }

        [ChatCommand("god")]
        private void cmdGodMode(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, permGodMode))
            {
                Player.Message(player, msg("NoPermission", player.UserIDString));
                return;
            }

            ToggleGodMode(player);
        }

        ////////////////////////////////////////////////////////////
        // General Methods
        ////////////////////////////////////////////////////////////

        private bool GetSave()
        {
            if (newSave || BuildingManager.server.buildingDictionary.Count == 0)
            {
                return true;
            }

            return false;
        }

        private void ToggleNoClip(BasePlayer player)
        {
            PlayerInfo user = LoadPlayerInfo(player);

            if (user == null)
                return;

            player.SetPlayerFlag(BasePlayer.PlayerFlags.IsDeveloper, true);
            if (!player.IsFlying)
            {
                timer.Once(0.2f, () => {
                    player.SendConsoleCommand("noclip");
                    Player.Message(player, msg("FlyEnabled", player.UserIDString));
                });
            }
            else
            {
                player.SendConsoleCommand("noclip");
                Player.Message(player, msg("FlyDisabled", player.UserIDString));
            }

            user.NoClip = !player.IsFlying;
            SavePlayerInfo(player, user);
        }

        private void ToggleGodMode(BasePlayer player)
        {
            PlayerInfo user = LoadPlayerInfo(player);

            if (user == null)
                return;

            player.SetPlayerFlag(BasePlayer.PlayerFlags.IsDeveloper, true);
            if (!player.IsGod())
            {
                timer.Once(0.2f, () => {
                    player.SendConsoleCommand("setinfo \"global.god\" \"True\"");
                    Player.Message(player, msg("GodEnabled", player.UserIDString));
                });
            }
            else
            {
                player.SendConsoleCommand("setinfo \"global.god\" \"False\"");
                Player.Message(player, msg("GodDisabled", player.UserIDString));
            }

            user.GodMode = !player.IsGod();
            SavePlayerInfo(player, user);
        }

        private void DisconnectTeleport(BasePlayer player)
        {
            PlayerInfo user = LoadPlayerInfo(player);

            if (user == null)
                return;

            var userTeleport = user.Teleport.ToVector3();
            var position = userTeleport == Vector3.zero ? defaultPos : userTeleport;

            if (position == Vector3.zero)
            {
                position = new Vector3(player.transform.position.x, TerrainMeta.HeightMap.GetHeight(player.transform.position) - 5f, player.transform.position.z);
            }

            player.Teleport(position);

            float terrainHeight = TerrainMeta.HeightMap.GetHeight(player.transform.position);
            bool isUnderTerrain = player.transform.position.y < terrainHeight || player.IsHeadUnderwater();

            if (isUnderTerrain)
            {
                player.metabolism.temperature.min = 20;
                player.metabolism.temperature.max = 20;
                player.metabolism.radiation_poison.max = 0;
                player.metabolism.oxygen.min = 1;
                player.metabolism.wetness.max = 0;
                player.metabolism.calories.min = player.metabolism.calories.value;
                player.metabolism.isDirty = true;
                player.metabolism.SendChangesToClient();
                user.UnderTerrain = true;
                SavePlayerInfo(player, user);
            }
        }

        private void NoUnderTerrain(BasePlayer player)
        {
            PlayerInfo user = LoadPlayerInfo(player);

            if (user == null)
                return;

            float terrainHeight = TerrainMeta.HeightMap.GetHeight(player.transform.position);
            bool isUnderTerrain = player.transform.position.y < terrainHeight || player.IsHeadUnderwater();

            if (isUnderTerrain)
            {
                float newY = terrainHeight + 2f;
                player.Teleport(new Vector3(player.transform.position.x, newY, player.transform.position.z));
                player.SendNetworkUpdateImmediate();
                player.metabolism.temperature.min = -100;
                player.metabolism.temperature.max = 100;
                player.metabolism.radiation_poison.max = 500;
                player.metabolism.oxygen.min = 0;
                player.metabolism.calories.min = 0;
                player.metabolism.wetness.max = 1;
                player.metabolism.SendChangesToClient();
                user.UnderTerrain = false;
                SavePlayerInfo(player, user);
            }
        }

        private string FormatPosition(Vector3 position)
        {
            string x = position.x.ToString("N2");
            string y = position.y.ToString("N2");
            string z = position.z.ToString("N2");

            return $"{x} {y} {z}";
        }

        private void SaveInventory(BasePlayer player)
        {
            PlayerInfoItems userItems = LoadPlayerInfoItems(player);

            if (userItems == null)
                return;

            List<Item> itemList = Pool.Get<List<Item>>();
            int num = player.inventory.GetAllItems(itemList);
            Pool.FreeUnmanaged(ref itemList);

            if (num == 0)
            {
                userItems.Items.Clear();
                SavePlayerInfoItems(player, userItems);
                return;
            }

            var items = new List<AdminUtilitiesItem>();

            AddItemsFromContainer(player.inventory.containerWear, "wear", items);
            AddItemsFromContainer(player.inventory.containerMain, "main", items);
            AddItemsFromContainer(player.inventory.containerBelt, "belt", items);

            if (items.Count == 0)
            {
                return;
            }

            ItemManager.DoRemoves();
            userItems.Items.Clear();
            userItems.Items.AddRange(items);
            SavePlayerInfoItems(player, userItems);
        }

        private void AddItemsFromContainer(ItemContainer container, string containerName, List<AdminUtilitiesItem> items)
        {
            foreach (Item item in container.itemList)
            {
                items.Add(new AdminUtilitiesItem(containerName, item));
                item.Remove();
            }

            container.itemList.Clear();
        }

        private bool HasPermission(BasePlayer player, string permName)
        {
            return player != null && player.IPlayer.HasPermission(permName);
        }

        private string msg(string key, string id = null, params object[] args)
        {
            string message = id == null ? RemoveFormatting(lang.GetMessage(key, this, id)) : lang.GetMessage(key, this, id);

            return args.Length > 0 ? string.Format(message, args) : message;
        }

        private string RemoveFormatting(string source)
        {
            return source.Contains(">") ? Regex.Replace(source, "<.*?>", string.Empty) : source;
        }

        ////////////////////////////////////////////////////////////
        // Configs
        ////////////////////////////////////////////////////////////

        private bool ConfigChanged;
        private Vector3 defaultPos;
        private bool wipeItems;
        private bool wipeSettings;
        private bool persistentNoClip;
        private bool persistentGodMode;

        protected override void LoadDefaultConfig() => PrintWarning("Generating default configuration file...");

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PositionAdded"] = "You will now teleport to <color=orange>{0}</color> on disconnect.",
                ["PositionRemoved1"] = "You will now teleport under ground on disconnect.",
                ["PositionRemoved2"] = "You will now teleport to <color=orange>{0}</color> on disconnect.",
                ["SavingInventory"] = "Your inventory will be saved on disconnect and restored when you wake up.",
                ["NotSavingInventory"] = "Your inventory will no longer be saved.",
                ["DisconnectTeleportSet"] = "/disconnectteleport set <x y z> - sets your log out position. can specify coordinates <color=orange>{0}</color>",
                ["DisconnectTeleportReset"] = "/disconnectteleport reset - resets your log out position to be underground unless a position is configured in the config file",
                ["OutOfBounds"] = "The specified coordinates are not within the allowed boundaries of the map.",
                ["FlyDisabled"] = "You switched NoClip off!",
                ["FlyEnabled"] = "You switched NoClip on!",
                ["GodDisabled"] = "You switched GodMode off!",
                ["GodEnabled"] = "You switched GodMode on!",
                ["NoPermission"] = "You do not have permission to use this command."
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PositionAdded"] = "Te vei teleporta la <color=orange>{0}</color> odat cu deconectarea.",
                ["PositionRemoved1"] = "Te vei teleporta sub pmnt odat cu deconectarea.",
                ["PositionRemoved2"] = "Te vei teleporta la <color=orange>{0}</color> odat cu deconectarea.",
                ["SavingInventory"] = "Inventarul tu va fi salvat la deconectare i recuperat la reconectare.",
                ["NotSavingInventory"] = "Inventarul tu nu va mai fi salvat.",
                ["DisconnectTeleportSet"] = "/disconnectteleport set <x y z> - seteaz poziia ta de deconectare. poi specifica coordonatele <color=orange>{0}</color>",
                ["DisconnectTeleportReset"] = "/disconnectteleport reset - reseteaz poziia ta de deconectare pentru a fi sub pmnt, doar dac o poziie nu este configurat ntr-o fil de configurare",
                ["OutOfBounds"] = "Coordonatele specificate nu se ncadreaz n limitele hrii.",
                ["FlyDisabled"] = "Ai dezactivat NoClip-ul!!",
                ["FlyEnabled"] = "Ai activat NoClip-ul!",
                ["GodDisabled"] = "Ai dezactivat GodMode-ul!",
                ["GodEnabled"] = "Ai activat GodMode-ul!",
                ["NoPermission"] = "Nu ai permisiunea de a folosi aceast comand."
            }, this, "ro");
        }

        private void InitConfig()
        {
            defaultPos = GetConfig("(0, 0, 0)", "Settings", "Default Teleport To Position On Disconnect").ToVector3();
            wipeItems = GetConfig(false, "Settings", "Wipe Saved Inventories On Map Wipe");
            wipeSettings = GetConfig(false, "Settings", "Wipe Players Settings On Map Wipe");
            persistentNoClip = GetConfig(false, "Settings", "Enable Persistent NoClip");
            persistentGodMode = GetConfig(false, "Settings", "Enable Persistent GodMode");

            if (ConfigChanged)
            {
                PrintWarning("Updated configuration file with new/changed values.");
                SaveConfig();
            }
        }

        private T GetConfig<T>(T defaultVal, params string[] path)
        {
            var data = Config.Get(path);
            if (data != null)
            {
                return Config.ConvertValue<T>(data);
            }

            Config.Set(path.Concat(new object[] { defaultVal }).ToArray());
            ConfigChanged = true;
            return defaultVal;
        }

        ////////////////////////////////////////////////////////////
        // Plugin Hooks
        ////////////////////////////////////////////////////////////

        [HookMethod(nameof(API_ToggleNoClip))]
        public void API_ToggleNoClip(BasePlayer player)
        {
            ToggleNoClip(player);
        }

        [HookMethod(nameof(API_ToggleGodMode))]
        public void API_ToggleGodMode(BasePlayer player)
        {
            ToggleGodMode(player);
        }

        [HookMethod(nameof(API_GetDisconnectTeleportPos))]
        public object API_GetDisconnectTeleportPos(string userid)
        {
            BasePlayer player = BasePlayer.FindByID(Convert.ToUInt64(userid));

            if (player == null)
                return null;

            PlayerInfo user = LoadPlayerInfo(player);

            if (user == null)
                return null;

           return user.Teleport;
        }

        [HookMethod(nameof(API_GetSaveInventoryStatus))]
        public bool API_GetSaveInventoryStatus(string userid)
        {
            BasePlayer player = BasePlayer.FindByID(Convert.ToUInt64(userid));

            if (player == null)
                return false;

            PlayerInfo user = LoadPlayerInfo(player);

            if (user == null)
                return false;

            return user.SaveInventory;
        }

        [HookMethod(nameof(API_GetUnderTerrainStatus))]
        public bool API_GetUnderTerrainStatus(string userid)
        {
            BasePlayer player = BasePlayer.FindByID(Convert.ToUInt64(userid));

            if (player == null)
                return false;

            PlayerInfo user = LoadPlayerInfo(player);

            if (user == null)
                return false;

            return user.UnderTerrain;
        }

        [HookMethod(nameof(API_GetNoClipStatus))]
        public bool API_GetNoClipStatus(string userid)
        {
            BasePlayer player = BasePlayer.FindByID(Convert.ToUInt64(userid));

            if (player == null)
                return false;

            PlayerInfo user = LoadPlayerInfo(player);

            if (user == null)
                return false;

            return user.NoClip;
        }

        [HookMethod(nameof(API_GetGodModeStatus))]
        public bool API_GetGodModeStatus(string userid)
        {
            BasePlayer player = BasePlayer.FindByID(Convert.ToUInt64(userid));

            if (player == null)
                return false;

            PlayerInfo user = LoadPlayerInfo(player);

            if (user == null)
                return false;

            return user.GodMode;
        }
    }
}

// --- End of file: AdminUtilities.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/auto-reset-targets ---
// --- Original File Path: A/AutoResetTargets/AutoResetTargets.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Auto Reset Targets", "Default", "1.0.5")]
    [Description("Automatically resets knocked down targets after a set amount of time")]
    public class AutoResetTargets : RustPlugin
    {

        public float activeTime;
        bool Changed = false;
        private const string permissionName = "autoresettargets.use";
        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            ReactiveTarget target = entity as ReactiveTarget;

            var p = entity.OwnerID.ToString();

            if (target != null && target.IsKnockedDown() && permission.UserHasPermission(p, permissionName))
            {
                timer.Once(activeTime, () =>
                {
                    target.ResetTarget();
                });
            }
            
        }


        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        void LoadVariables()
        {

            activeTime = Convert.ToSingle(GetConfig("ART", "Time until reset", 1.0f));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        void Init()
        {
            LoadVariables();
            permission.RegisterPermission(permissionName, this);
        }


    }
}


// --- End of file: AutoResetTargets.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/auth-limiter ---
// --- Original File Path: A/AuthLimiter/AuthLimiter.cs ---

using Network;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Auth Limiter", "supreme", "1.0.2")]
    [Description("Limits the moderators from using ownerid/removeownerid commands")]
    public class AuthLimiter : RustPlugin
    {
        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null || !IsLimited(player))
                return null;

            var command = arg.cmd.FullName;
            return arg.cmd.FullName == "global.ownerid" || arg.cmd.FullName == "global.removeowner" ? false : (object) null;
        }
        private bool IsLimited(BasePlayer player)
        {
            if (player == null || player.net?.connection == null)
                return false;

            if (player.net.connection.authLevel == 1)
                return true;

            return false;
        }
    }
}

// --- End of file: AuthLimiter.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/auto-takeoff ---
// --- Original File Path: A/AutoTakeoff/AutoTakeoff.cs ---

using System.Collections;
using System.Collections.Generic;

using UnityEngine;

using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Auto Takeoff", "0x89A", "1.1.1")]
    [Description("Allows smooth takeoff with helicopters")]
    class AutoTakeoff : RustPlugin
    {
        #region -Fields-

        private const string _canUse = "autotakeoff.use";

        private readonly Dictionary<Minicopter, bool> _isTakingOff = new Dictionary<Minicopter, bool>();

        #endregion

        void Init()
        {
            permission.RegisterPermission(_canUse, this);
        }

        #region -Chat Command-

        [ChatCommand("takeoff")]
        private void TakeOffCommand(BasePlayer player)
        {
            if (player == null)
            {
                return;
            }

            if (!permission.UserHasPermission(player.UserIDString, _canUse))
            {
                player.ChatMessage(GetMessage("NoPermission", player.UserIDString));
                return;
            }

            Minicopter helicopter = player.GetMountedVehicle() as Minicopter;
            if (helicopter == null)
            {
                player.ChatMessage(GetMessage("NotMounted", player.UserIDString));
                return;
            }

            bool isTakingOff;
            if (_isTakingOff.TryGetValue(helicopter, out isTakingOff) && isTakingOff)
            {
                player.ChatMessage(GetMessage("AlreadyTakingOff", player.UserIDString));
                return;
            }

            string vehiclePrefab = helicopter.ShortPrefabName;

            if (!_config.scrapheliCanTakeoff && vehiclePrefab == "scraptransporthelicopter" || !_config.minicopterCanTakeoff && vehiclePrefab == "minicopter.entity")
            {
                player.ChatMessage(GetMessage("NotAllowed", player.UserIDString));
                return;
            }

            DoTakeOff(player, helicopter);
        }

        private void DoTakeOff(BasePlayer player, Minicopter helicopter)
        {
            if (helicopter.IsEngineOn() && helicopter.isMobile)
            {
                //raycast to check if on ground
                Ray ray = new Ray(helicopter.transform.position, -Vector2.up);

                if (Physics.Raycast(ray, 0.5f))
                {
                    if (_config.takeOffMethodType)
                    {
                        helicopter.StartCoroutine(LerpMethod(helicopter));
                        return;
                    }

                    PushMethod(helicopter);
                }
                else
                {
                    player.ChatMessage(GetMessage("NotOnGround", player.UserIDString));
                }

                return;
            }
            
            player.ChatMessage(GetMessage("NotFlying", player.UserIDString));
        }

        #endregion

        #region -Methods-

        private IEnumerator LerpMethod(Minicopter helicopter)
        {
            _isTakingOff[helicopter] = true;
            
            Vector3 helicopterPosition = helicopter.transform.position;
            Vector3 endPos = helicopterPosition + Vector3.up * _config.distanceMoved;

            float distance = Vector3.Distance(helicopterPosition, endPos);
				
            float speed = helicopter.ShortPrefabName == "minicopter.entity" ? _config.minicopterSpeed : _config.scrapHelicopterSpeed;

            float startTime = Time.time;

            while (helicopter.AnyMounted() && helicopter.IsEngineOn())
            {
                float distCovered = (Time.time - startTime) * speed;

                float fractionOfJourney = distCovered / distance;

                helicopter.transform.position = Vector3.Lerp(helicopter.transform.position, endPos, fractionOfJourney);

                if (helicopter.CenterPoint().y + 1 >= endPos.y - 2)
                {
                    _isTakingOff[helicopter] = false;
                    yield break;
                }

                yield return CoroutineEx.waitForFixedUpdate;
            }
        }

        private void PushMethod(Minicopter helicopter)
        {
            Rigidbody rb;
            if (!helicopter.TryGetComponent(out rb))
            {
                return;
            }

            float force = helicopter.ShortPrefabName == "minicopter.entity" ? _config.minicopterPushForce : _config.scrapHelicopterPushForce;
            rb.AddForce(Vector3.up * force, ForceMode.Acceleration);
        }
        
        #endregion
        
        #region -Localization-

        private string GetMessage(string key, string userid) => lang.GetMessage(key, this, userid);
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPermission"] = "You do not have permission to use this command",
                ["NotMounted"] = "You are not in a helicopter",
                ["NotOnGround"] = "You are too far from the ground",
                ["NotFlying"] = "The helicopter is not flying",
                ["AlreadyTakingOff"] = "This helicopter is already taking off",
                ["DefaultConfig"] = "Generating new config"
            }
            , this);
        }

        #endregion

        #region -Configuration-

        private Configuration _config;
        class Configuration
        {
            [JsonProperty(PropertyName = "Take off method type")]
            public bool takeOffMethodType = true;

            [JsonProperty(PropertyName = "Helicopter move distance")]
            public float distanceMoved = 10f;

            [JsonProperty(PropertyName = "Minicopter can auto takeoff")]
            public bool minicopterCanTakeoff = true;

            [JsonProperty(PropertyName = "Minicopter move speed")]
            public float minicopterSpeed = 0.025f;

            [JsonProperty(PropertyName = "Minicopter push force")]
            public float minicopterPushForce = 50;

            [JsonProperty(PropertyName = "Scrap Helicopter can auto takeoff")]
            public bool scrapheliCanTakeoff = true;

            [JsonProperty(PropertyName = "Scrap helicopter move speed")]
            public float scrapHelicopterSpeed = 0.0075f;

            [JsonProperty(PropertyName = "Scrap helicopter push force")]
            public float scrapHelicopterPushForce = 100;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new System.Exception();
                SaveConfig();
            }
            catch
            {
                PrintWarning("Error with config, using default values");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();

        #endregion
    }
}


// --- End of file: AutoTakeoff.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/admin-hammer ---
// --- Original File Path: A/AdminHammer/AdminHammer.cs ---

using System.Collections.Generic;
using Oxide.Core.Configuration;
using UnityEngine;
using Oxide.Core;
using System;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("AdminHammer", "mvrb", "1.13.0")]
    class AdminHammer : RustPlugin
    {
        public static AdminHammer plugin;

        private const string permAllow = "adminhammer.allow";
        private bool logToConsole = true;
        private bool logAdminInfo = true;
        private bool showBoxContents = true;
        private bool showCode = true;
        private float toolDistance = 200f;
        private string toolUsed = "hammer";
        private string commandToRun = "box";
        private string chatCommand = "b";
        private bool showSphere = false;
        private bool performanceMode = false;

        private int layerMask = LayerMask.GetMask("Construction", "Deployed", "Default");

        private readonly DynamicConfigFile dataFile = Interface.Oxide.DataFileSystem.GetFile("AdminHammer");

        private List<ulong> Users = new List<ulong>();

        protected override void LoadDefaultConfig()
        {
            Config["LogToConsole"] = logToConsole = GetConfig("LogToFile", true);
            Config["LogAdminInfo"] = logAdminInfo = GetConfig("LogAdminInfo", true);
            Config["ShowBoxContents"] = showBoxContents = GetConfig("ShowBoxContents", true);
            Config["ShowCode"] = showCode = GetConfig("ShowCode", true);
            Config["ShowSphere"] = showSphere = GetConfig("ShowSphere", false);
            Config["ToolDistance"] = toolDistance = GetConfig("ToolDistance", 200f);
            Config["ToolUsed"] = toolUsed = GetConfig("ToolUsed", "hammer");
            Config["CommandToRun (Leave blank for no command)"] = commandToRun = GetConfig("CommandToRun (Leave blank for no command)", "box");
            Config["ChatCommand"] = chatCommand = GetConfig("ChatCommand", "b");
            Config["PerformanceMode"] = performanceMode = GetConfig("PerformanceMode", false);

            SaveConfig();
        }

        private void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoAuthorizedPlayers"] = "No authorized players.",
                ["AuthorizedPlayers"] = "Authorized players in the {0} owned by {1}:",
                ["NoEntityFound"] = "No entity found. Look at an entity and right-click while holding a {0}.",
                ["NoOwner"] = "No owner found for this entity.",
                ["ChatEntityOwnedBy"] = "This {0} is owned by {1}",
                ["DoorCode"] = "Door Code: <color=yellow>{0}</color>",
                ["ConsoleEntityOwnedBy"] = "This {0} is owned by www.steamcommunity.com/profiles/{1}",
                ["ToolActivated"] = "You have enabled AdminHammer.",
                ["ToolDeactivated"] = "You have disabled AdminHammer.",
                ["AdminUsedTool"] = "{0} [{1}] used AdminHammer on a {2} owned by {3} [{4}] located at {5}",
                ["PerformanceMode"] = "Performance mode is enabled, so you have to use the chat command <color=yellow>/{0}</color> instead of right-clicking"
            }, this);
        }

        private void Init()
        {
            plugin = this;

            Users = dataFile.ReadObject<List<ulong>>();

            LoadDefaultConfig();
            permission.RegisterPermission(permAllow, this);

            cmd.AddChatCommand("ah", this, "CmdAdminHammer");
            cmd.AddChatCommand("adminhammer", this, "CmdAdminHammer");
            cmd.AddChatCommand(chatCommand, this, "CmdCheckEntity");
        }

        private void OnServerInitialized()
        {
            if (performanceMode) return;

            bool fileChanged = false;

            foreach (var player in BasePlayer.activePlayerList)
            {
                if (Users.Contains(player.userID))
                {
                    if (!permission.UserHasPermission(player.UserIDString, permAllow))
                    {
                        Users.Remove(player.userID);
                        fileChanged = true;
                        continue;
                    }

                    if (player.gameObject.GetComponent<AH>() == null)
                    {
                        player.gameObject.AddComponent<AH>();
                    }
                }
            }

            if (fileChanged)
            {
                dataFile.WriteObject(Users);
            }
        }

        private void Unload()
        {
            foreach (var ah in UnityEngine.Object.FindObjectsOfType<AH>().ToList())
            {
                GameObject.Destroy(ah);
            }
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (!Users.Contains(player.userID)) return;

            if (!permission.UserHasPermission(player.UserIDString, permAllow))
            {
                Users.Remove(player.userID);
                dataFile.WriteObject(Users);
                return;
            }

            if (performanceMode) return;

            if (player.gameObject.GetComponent<AH>() == null)
            {
                player.gameObject.AddComponent<AH>();
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            player.gameObject.GetComponent<AH>()?.Destroy();
        }

        private void CmdAdminHammer(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, permAllow)) return;

            if (performanceMode)
            {
                player.ChatMessage(Lang("PerformanceMode", player.UserIDString, chatCommand));
                return;
            }

            if (Users.Contains(player.userID))
            {
                Users.Remove(player.userID);

                if (player.gameObject.GetComponent<AH>() != null)
                    player.gameObject.GetComponent<AH>().Destroy();

                player.ChatMessage(Lang("ToolDeactivated", player.UserIDString));

                Interface.Oxide.CallHook("OnAdminHammerDisabled", player);
            }
            else
            {
                Users.Add(player.userID);

                if (player.gameObject.GetComponent<AH>() == null)
                    player.gameObject.AddComponent<AH>();

                player.ChatMessage(Lang("ToolActivated", player.UserIDString));

                Interface.Oxide.CallHook("OnAdminHammerEnabled", player);
            }

            dataFile.WriteObject(Users);
        }

        private void CmdCheckEntity(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, permAllow)) return;

            CheckEntity(player);
        }

        private void CheckEntity(BasePlayer player)
        {
            RaycastHit hit;
            var raycast = Physics.Raycast(player.eyes.HeadRay(), out hit, toolDistance, layerMask);
            BaseEntity entity = raycast ? hit.GetEntity() : null;

            if (!entity)
            {
                player.ChatMessage(Lang("NoEntityFound", player.UserIDString, toolUsed));
                if (logToConsole) player.ConsoleMessage(Lang("NoEntityFound", player.UserIDString, toolUsed));
                return;
            }

            bool hasSentMsg = false;

            if (entity is Door)
            {
                var door = entity as Door;
                var lockSlot = door.GetSlot(BaseEntity.Slot.Lock);

                if (lockSlot is CodeLock)
                {
                    var codeLock = (CodeLock)lockSlot;
                    string msg = Lang("AuthorizedPlayers", player.UserIDString, door.ShortPrefabName, GetName(entity.OwnerID.ToString())) + "\n";

                    int whitelisted = 0;

                    msg += $"\nWHITELISTED PLAYERS: [<color=yellow>{codeLock.code}</color>] \n";
                    foreach (var user in codeLock.whitelistPlayers)
                    {
                        whitelisted++;
                        msg += $"{whitelisted}. {GetName(user.ToString())}\n";
                    }

                    int guests = 0;
                    msg += "\nGUEST PLAYERS: ";
                    if (!string.IsNullOrEmpty(codeLock.guestCode)) msg += $"[<color=yellow>{codeLock.guestCode}</color>] ";
                    if (codeLock.guestPlayers.Count == 0)
                    {
                        msg += "\n- None";
                    }
                    else
                    {
                        foreach (var user in codeLock.guestPlayers)
                        {
                            if (codeLock.whitelistPlayers.Contains(user)) continue;

                            guests++;
                            msg += $"{guests}. {GetName(user.ToString())}\n";
                        }
                    }

                    player.ChatMessage(whitelisted == 0 ? Lang("NoAuthorizedPlayers", player.UserIDString) : msg);
                    if (logToConsole) player.ConsoleMessage(whitelisted == 0 ? Lang("NoAuthorizedPlayers", player.UserIDString) : msg);
                    //if (showCode) player.ChatMessage(Lang("DoorCode", player.UserIDString, (door.GetSlot(BaseEntity.Slot.Lock) as CodeLock)?.code));
                }
                else if (lockSlot is BaseLock)
                {
                    player.ChatMessage(entity.OwnerID == 0 ? Lang("NoOwner", player.UserIDString, entity.ShortPrefabName) : Lang("ChatEntityOwnedBy", player.UserIDString, entity.ShortPrefabName, GetName(entity.OwnerID.ToString())));
                    if (logToConsole) player.ConsoleMessage(entity.OwnerID == 0 ? Lang("NoOwner", player.UserIDString, entity.ShortPrefabName) : Lang("ChatEntityOwnedBy", player.UserIDString, entity.ShortPrefabName, GetName(entity.OwnerID.ToString())));
                    Puts(entity.OwnerID == 0 ? Lang("NoOwner", player.UserIDString, entity.ShortPrefabName) : Lang("ConsoleEntityOwnedBy", player.UserIDString, entity.ShortPrefabName, entity.OwnerID.ToString()));
                }

                hasSentMsg = true;
            }
            else if (entity is SleepingBag)
            {
                SleepingBag sleepingBag = entity as SleepingBag;

                player.ChatMessage($"This SleepingBag has been assigned to {GetName(sleepingBag.deployerUserID.ToString())} by {GetName(sleepingBag.OwnerID.ToString())}");
                if (logToConsole) player.ConsoleMessage($"This SleepingBag has been assigned to {GetName(sleepingBag.deployerUserID.ToString())} by {GetName(sleepingBag.OwnerID.ToString())}");

                hasSentMsg = true;
            }
            else if (entity is AutoTurret)
            {
                player.ChatMessage(GetAuthorized(entity, player));
                if (logToConsole) player.ConsoleMessage(GetAuthorized(entity, player));

                if (showBoxContents)
                {
                    string msg = $"Items in the AutoTurret owned by {GetName(entity.OwnerID.ToString())}:\n";
                    foreach (var item in (entity as AutoTurret).inventory.itemList)
                    {
                        msg += $"{item.amount}x {item.info.displayName.english}\n";
                    }

                    player.ChatMessage(msg);
                    if (logToConsole) player.ConsoleMessage(msg);
                }

                hasSentMsg = true;
            }
            else if (entity is BuildingPrivlidge)
            {
                player.ChatMessage(GetAuthorized(entity, player));
                if (logToConsole) player.ConsoleMessage(GetAuthorized(entity, player));

                BuildingPrivlidge priv = entity as BuildingPrivlidge;
                if (priv != null)
                {
                    float protectedMinutes = priv.GetProtectedMinutes();

                    TimeSpan t = TimeSpan.FromMinutes(protectedMinutes);

                    string formattedTime = string.Format("{0:D2} days {1:D2} hours {2:D2} minutes {3:D2} seconds",
                                t.Days,
                                t.Hours,
                                t.Minutes,
                                t.Seconds,
                                t.Milliseconds);

                    player.ChatMessage($"The base is protected for {formattedTime}");
                    if (logToConsole) player.ConsoleMessage($"The base is protected for {formattedTime}");
                }

                if (!string.IsNullOrEmpty(commandToRun)) player.Command("chat.say /" + commandToRun);

                hasSentMsg = true;
            }
            else if (entity is StorageContainer)
            {
                if (showBoxContents)
                {
                    var storageContainer = entity as StorageContainer;
                    string msg = $"Items in the {storageContainer.ShortPrefabName} owned by {GetName(storageContainer.OwnerID.ToString())}:\n";
                    foreach (var item in storageContainer.inventory.itemList)
                        msg += $"{item.amount}x {item.info.displayName.english}\n";
                    player.ChatMessage(msg);
                    if (logToConsole) player.ConsoleMessage(msg);
                }

                CodeLock codeLock = (CodeLock)entity.GetSlot(BaseEntity.Slot.Lock);
                if (codeLock != null)
                {
                    string msg = Lang("AuthorizedPlayers", player.UserIDString, entity.ShortPrefabName, GetName(entity.OwnerID.ToString())) + "\n";

                    int authed = 0;

                    string consoleMsg = "";

                    foreach (var user in codeLock.whitelistPlayers)
                    {
                        authed++;
                        msg += $"{authed}. {GetName(user.ToString())} ({user})\n";
                        if (logToConsole) consoleMsg += $"{authed}. {user.ToString()} {GetName(user.ToString())} \n";
                    }

                    player.ChatMessage(authed == 0 ? Lang("NoAuthorizedPlayers", player.UserIDString) : msg);
                    if (logToConsole) player.ConsoleMessage(authed == 0 ? Lang("NoAuthorizedPlayers", player.UserIDString) : msg);
                    player.ChatMessage("CodeLock Code: " + (entity.GetSlot(BaseEntity.Slot.Lock) as CodeLock)?.code.ToString());
                    if (logToConsole) player.ConsoleMessage("CodeLock Code: " + (entity.GetSlot(BaseEntity.Slot.Lock) as CodeLock)?.code.ToString());
                    if (logToConsole) Puts(consoleMsg);
                }

                player.ChatMessage(entity.OwnerID == 0 ? Lang("NoOwner", player.UserIDString, entity.ShortPrefabName) : Lang("ChatEntityOwnedBy", player.UserIDString, entity.ShortPrefabName, GetName(entity.OwnerID.ToString())));
                if (logToConsole) player.ConsoleMessage(entity.OwnerID == 0 ? Lang("NoOwner", player.UserIDString, entity.ShortPrefabName) : Lang("ChatEntityOwnedBy", player.UserIDString, entity.ShortPrefabName, GetName(entity.OwnerID.ToString())));
                Puts(entity.OwnerID == 0 ? Lang("NoOwner", player.UserIDString, entity.ShortPrefabName) : Lang("ConsoleEntityOwnedBy", player.UserIDString, entity.ShortPrefabName, entity.OwnerID.ToString()));

                if (!string.IsNullOrEmpty(commandToRun)) player.Command("chat.say /" + commandToRun);

                hasSentMsg = true;
            }

            if (!hasSentMsg)
			{
				player.ChatMessage(entity.OwnerID == 0 ? Lang("NoOwner", player.UserIDString, entity.ShortPrefabName) : Lang("ChatEntityOwnedBy", player.UserIDString, entity.ShortPrefabName, GetName(entity.OwnerID.ToString())));
				if (logToConsole) player.ConsoleMessage(entity.OwnerID == 0 ? Lang("NoOwner", player.UserIDString, entity.ShortPrefabName) : Lang("ChatEntityOwnedBy", player.UserIDString, entity.ShortPrefabName, GetName(entity.OwnerID.ToString())));
			}

            if (showSphere) player.SendConsoleCommand("ddraw.sphere", 2f, Color.blue, entity.CenterPoint(), 1f);

            if (logToConsole) Puts(entity.OwnerID == 0 ? Lang("NoOwner", player.UserIDString, entity.ShortPrefabName) : Lang("ConsoleEntityOwnedBy", player.UserIDString, entity.ShortPrefabName, entity.OwnerID.ToString()));

            if (logAdminInfo) Puts(Lang("AdminUsedTool", player.UserIDString, player.displayName, player.userID, entity.ShortPrefabName, GetName(entity.OwnerID.ToString()), entity.OwnerID.ToString(), entity.transform.position.ToString()));
        }

        private class AH : MonoBehaviour
        {
            public BasePlayer player;
            private float lastCheck;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                lastCheck = Time.realtimeSinceStartup;
            }

            private void FixedUpdate()
            {
                if (player == null || !player.IsConnected)
                {
                    Destroy();
                    return;
                }

                float currentTime = Time.realtimeSinceStartup;

                if (!player.serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || (player.GetActiveItem() as Item)?.info.shortname != plugin.toolUsed) return;

                if (currentTime - lastCheck >= 0.25f)
                {
                    plugin.CheckEntity(player);
                    lastCheck = currentTime;
                }
            }

            public void Destroy()
            {
                Destroy(this);
            }
        }

        private string GetAuthorized(BaseEntity entity, BasePlayer player)
        {
            string msg = Lang("AuthorizedPlayers", player.UserIDString, entity.ShortPrefabName, GetName(entity.OwnerID.ToString())) + "\n";
            var turret = entity as AutoTurret;
            var priv = entity as BuildingPrivlidge;
            int authed = 0;

            foreach (var user in (turret ? turret.authorizedPlayers : priv.authorizedPlayers))
            {
                authed++;
                msg += $"{authed}. {GetName(user.userid.ToString())}\n";
                Puts($"{authed}. {user.userid} {GetName(user.userid.ToString())}\n");
            }

            return authed == 0 ? Lang("NoAuthorizedPlayers", player.UserIDString) : msg;
        }

        private string GetPlayerColor(ulong id) => BasePlayer.FindByID(id) != null ? "green" : "red";

        private string GetName(string id)
        {
            if (id == "0") return "[SERVERSPAWN]";

            string color = GetPlayerColor(ulong.Parse(id));

            return $"<color={color}> {covalence.Players.FindPlayerById(id)?.Name} </color> ({id})";
        }

        private T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
    }
}

// --- End of file: AdminHammer.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/auto-engine-parts ---
// --- Original File Path: A/AutoEngineParts/AutoEngineParts.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Rust.Modular;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Auto Engine Parts", "WhiteThunder", "1.0.0")]
    [Description("Ensures modular car engines always have engine parts which players cannot remove.")]
    internal class AutoEngineParts : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private Plugin EnginePartsDurability;

        private const string PermissionTier1 = "autoengineparts.tier1";
        private const string PermissionTier2 = "autoengineparts.tier2";
        private const string PermissionTier3 = "autoengineparts.tier3";

        private const float VanillaInternalDamageMultiplier = 0.5f;

        private Configuration _pluginConfig;

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(PermissionTier1, this);
            permission.RegisterPermission(PermissionTier2, this);
            permission.RegisterPermission(PermissionTier3, this);

            Unsubscribe(nameof(OnEntitySpawned));
        }

        private void OnServerInitialized()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
                MaybeUpdateEngineModule(entity as BaseVehicleModule, dropExistingParts: true);

            Subscribe(nameof(OnEntitySpawned));
        }

        private void Unload()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var car = entity as ModularCar;
                if (car == null)
                    continue;

                foreach (var module in car.AttachedModuleEntities)
                {
                    var engineStorage = GetEngineStorage(module);
                    if (engineStorage == null)
                        continue;

                    MaybeUpdateEngineStorage(engineStorage, 0, dropExistingParts: false);
                }
            }
        }

        private object OnVehicleModuleMove(VehicleModuleEngine module)
        {
            var engineStorage = GetEngineStorage(module);
            if (engineStorage == null)
                return null;

            if (!IsLocked(engineStorage))
                return null;

            // Return true to force the module to be moved even though it probably has items.
            // The items will be removed in the OnEntityKill hook.
            return true;
        }

        private void OnEntityKill(VehicleModuleEngine module)
        {
            var engineStorage = GetEngineStorage(module);
            if (engineStorage == null)
                return;

            if (!IsLocked(engineStorage))
                return;

            // Kill the inventory to remove all items.
            engineStorage.inventory.Kill();
        }

        private void OnEntitySpawned(VehicleModuleEngine module)
        {
            // Delaying is necessary since the storage container is created immediately after this hook is called.
            NextTick(() => MaybeUpdateEngineModule(module, dropExistingParts: false));
        }

        private object OnItemLock(Item item)
        {
            var car = item.parent?.entityOwner as ModularCar;
            if (car == null)
                return null;

            var engineStorage = GetEngineStorage(car.GetModuleForItem(item));
            if (engineStorage == null)
                return null;

            if (!IsLocked(engineStorage))
                return null;

            // Return true (standard) to cancel default behavior.
            // This prevents the checkered appearance and allows the item to be dropped.
            return true;
        }

        // This hook is exposed by Engine Parts Durability (EnginePartsDurability).
        private object OnEngineDamageMultiplierChange(EngineStorage engineStorage, float desiredMultiplier)
        {
            // The inventory being locked indicates that this plugin is likely controlling the multiplier.
            if (engineStorage.inventory.IsLocked())
                return false;

            return null;
        }

        // This hook is exposed by plugin: Claim Vehicle Ownership (ClaimVehicle).
        private void OnVehicleOwnershipChanged(ModularCar car)
        {
            var enginePartsTier = GetOwnerEnginePartsTier(car.OwnerID);

            foreach (var module in car.AttachedModuleEntities)
            {
                var engineStorage = GetEngineStorage(module);
                if (engineStorage != null)
                    MaybeUpdateEngineStorage(engineStorage, enginePartsTier, dropExistingParts: true);
            }
        }

        #endregion

        #region Helper Methods

        private static bool UpdateEngineStorageWasBlocked(EngineStorage engineStorage, int tier)
        {
            object hookResult = Interface.CallHook("OnEngineStorageFill", engineStorage, tier);
            return hookResult is bool && (bool)hookResult == false;
        }

        private static ulong GetCarOwnerId(BaseVehicleModule module)
        {
            var car = module.Vehicle as ModularCar;
            return car == null ? 0 : car.OwnerID;
        }

        private static EngineStorage GetEngineStorage(BaseVehicleModule module)
        {
            var engineModule = module as VehicleModuleEngine;
            if (engineModule == null)
                return null;

            return engineModule.GetContainer() as EngineStorage;
        }

        private static bool IsLocked(EngineStorage engineStorage) =>
            engineStorage.inventory.IsLocked();

        private static void RemoveAllEngineParts(EngineStorage engineStorage)
        {
            for (var slot = 0; slot < engineStorage.inventory.capacity; slot++)
            {
                var item = engineStorage.inventory.GetSlot(slot);
                if (item != null)
                {
                    item.RemoveFromContainer();
                    item.Remove();
                }
            }
        }

        private static bool TryAddEngineItem(EngineStorage engineStorage, int slot, int tier)
        {
            ItemModEngineItem output;
            if (!engineStorage.allEngineItems.TryGetItem(tier, engineStorage.slotTypes[slot], out output))
                return false;

            var component = output.GetComponent<ItemDefinition>();
            var item = ItemManager.Create(component);
            if (item == null)
                return false;

            if (!item.MoveToContainer(engineStorage.inventory, slot, allowStack: false))
            {
                item.Remove();
                return false;
            }

            return true;
        }

        private static int Clamp(int x, int min, int max) => Math.Max(min, Math.Min(x, max));

        private void MaybeUpdateEngineModule(BaseVehicleModule module, bool dropExistingParts)
        {
            var engineStorage = GetEngineStorage(module);
            if (engineStorage == null)
                return;

            var enginePartsTier = GetOwnerEnginePartsTier(GetCarOwnerId(module));
            MaybeUpdateEngineStorage(engineStorage, enginePartsTier, dropExistingParts);
        }

        private void MaybeUpdateEngineStorage(EngineStorage engineStorage, int enginePartsTier, bool dropExistingParts)
        {
            if (!UpdateEngineStorageWasBlocked(engineStorage, enginePartsTier))
                UpdateEngineStorage(engineStorage, enginePartsTier, dropExistingParts);
        }

        private void UpdateEngineStorage(EngineStorage engineStorage, int desiredTier, bool dropExistingParts)
        {
            var inventory = engineStorage.inventory;
            var wasLocked = inventory.IsLocked();

            var hasEngineParts = !inventory.IsEmpty();

            // If the storage was already locked, we assume the parts were free so we can safely delete them.
            // This may be less efficient than keeping/repairing the parts if they match the desired tier, but this keeps it simple.
            if (hasEngineParts && wasLocked)
                RemoveAllEngineParts(engineStorage);

            if (desiredTier <= 0)
            {
                if (wasLocked)
                    inventory.SetLocked(false);

                ResetInternalDamageMultiplier(engineStorage);
                return;
            }

            if (hasEngineParts && !wasLocked)
            {
                // The existing engine parts must be removed to add new ones.
                if (dropExistingParts)
                {
                    // Drop existing engine parts because players may have worked hard for them.
                    engineStorage.DropItems();
                }
                else
                    RemoveAllEngineParts(engineStorage);
            }

            // This must be set first because adding items will trigger the OnItemLock hook which needs to see this flag.
            inventory.SetLocked(true);

            var inventoryFilled = true;
            for (var slot = 0; slot < inventory.capacity; slot++)
            {
                if (!TryAddEngineItem(engineStorage, slot, desiredTier))
                    inventoryFilled = false;
            }

            if (!inventoryFilled)
            {
                // Something went wrong when filling the inventory, so unlock it to allow parts to be added.
                inventory.SetLocked(false);
                return;
            }

            // Prevent engine parts from taking damage since the player has no way to repair them while the inventory is locked.
            engineStorage.internalDamageMultiplier = 0;
        }

        private void ResetInternalDamageMultiplier(EngineStorage engineStorage)
        {
            if (EnginePartsDurability != null)
                EnginePartsDurability.Call("API_RefreshMultiplier", engineStorage);
            else
                engineStorage.internalDamageMultiplier = VanillaInternalDamageMultiplier;
        }

        private int GetOwnerEnginePartsTier(ulong ownerId)
        {
            var defaultTier = _pluginConfig.DefaultEnginePartsTier;

            if (ownerId == 0)
                return defaultTier;

            var ownerIdString = ownerId.ToString();

            if (permission.UserHasPermission(ownerIdString, PermissionTier3))
                return 3;
            else if (permission.UserHasPermission(ownerIdString, PermissionTier2))
                return Math.Max(2, defaultTier);
            else if (permission.UserHasPermission(ownerIdString, PermissionTier1))
                return Math.Max(1, defaultTier);
            else
                return defaultTier;
        }

        #endregion

        #region Configuration

        private class Configuration : SerializableConfiguration
        {
            private int _defaultEnginePartsTier = 0;

            [JsonProperty("DefaultEnginePartsTier")]
            public int DefaultEnginePartsTier
            {
                get { return _defaultEnginePartsTier; }
                set { _defaultEnginePartsTier = Clamp(value, 0, 3); }
            }
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #endregion

        #region Configuration Boilerplate

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _pluginConfig = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _pluginConfig = Config.ReadObject<Configuration>();
                if (_pluginConfig == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_pluginConfig))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_pluginConfig, true);
        }

        #endregion
    }
}


// --- End of file: AutoEngineParts.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/a-time-api ---
// --- Original File Path: A/aTimeAPI/aTimeAPI.cs ---


/*Copyright  2022 - 2023 AvG (Email: alias.dev@ya.ru | Discord: AvG #0680 | Alias development team: https://discord.gg/MWeNJV5e7F ) */

using Newtonsoft.Json;
using Oxide.Core;
using System;
using System.Collections;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("aTimeAPI", "AvG ", "1.1.3")]
    [Description("Provides API and Hooks for time.")]
    class aTimeAPI : RustPlugin
    {
        #region [Initialization]
        private static DataFileSystem fileSystem = Interface.Oxide.DataFileSystem;
        private void OnServerInitialized()
        {
            data = fileSystem.GetFile(Name).ReadObject<Data>();
            if (data == null)
            {
                data = new Data();
                fileSystem.GetFile(Name).WriteObject(data);
            }
            CheckTimeCoroutine = ServerMgr.Instance.StartCoroutine(CheckTime());
        }
        private void Unload()
        {
            if (CheckTimeCoroutine != null)
                ServerMgr.Instance.StopCoroutine(CheckTimeCoroutine);
            fileSystem.GetFile(Name).WriteObject(data);
        }
        #endregion
        #region [Data]
        private Data data;
        private class Data
        {
            public bool IsDay = true;
            public int Year = DateTime.Now.Year;
            public int Month = DateTime.Now.Month;
            public int Day = DateTime.Now.Day;
            public int Hour = DateTime.Now.Hour;
        }
        #endregion
        #region [Configuration]
        private Configuration config;
        private class Configuration
        {
            [JsonProperty("Rust day start time (hour)")] public float Day = 7.5f;
            [JsonProperty("Rust night start time (hour)")] public float Night = 20;
        }
        protected override void LoadDefaultConfig() => config = new Configuration();
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<Configuration>();
            SaveConfig();
        }
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion
        private bool IsDayInRustNow() => data.IsDay;
        private Coroutine CheckTimeCoroutine = null;
        private IEnumerator CheckTime()
        {
            while (true)
            {
                Interface.CallHook("OnRealSecond");
                float hour = TOD_Sky.Instance.Cycle.Hour;
                if (data.IsDay)
                {
                    if (hour >= config.Night && hour < config.Day)
                    {
                        data.IsDay = false;
                        Interface.CallHook("OnRustNightStarted");
                    }
                }
                else
                {
                    if (hour >= config.Day && hour < config.Night)
                    {
                        data.IsDay = true;
                        Interface.CallHook("OnRustDayStarted");
                    }
                }
                if (DateTime.Now.Hour != data.Hour)
                {
                    data.Hour = DateTime.Now.Hour;
                    Interface.CallHook("OnNewRealHourStarted", data.Hour);
                    if (DateTime.Now.Day != data.Day)
                    {
                        data.Day = DateTime.Now.Day;
                        Interface.CallHook("OnNewRealDayStarted", data.Day);
                        if (DateTime.Now.Month != data.Month)
                        {
                            data.Month = DateTime.Now.Month;
                            Interface.CallHook("OnNewRealMonthStarted", data.Month);
                            if (DateTime.Now.Year != data.Year)
                            {
                                data.Year = DateTime.Now.Year;
                                Interface.CallHook("OnNewRealYearStarted", data.Year);
                            }
                        }
                    }
                    fileSystem.GetFile(Name).WriteObject(data);
                }
                yield return new WaitForSeconds(1);
            }
        }
    }
}


// --- End of file: aTimeAPI.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/armor-not-forever ---
// --- Original File Path: A/ArmorNotForever/ArmorNotForever.cs ---

using System.Linq;
using UnityEngine;
using Newtonsoft.Json;
using System.Collections.Generic;

#region License
/*
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
#endregion

namespace Oxide.Plugins
{
    [Info("Armor Not Forever", "Flames", "1.0.10")]
    [Description("On hit NPC to not only deal damage to the player, but also reduce the durability of equipped armor")]

    class ArmorNotForever : RustPlugin
    {
        #region Permission

        private const string PermissionUse = "armornotforever.use";
        private const string PermissionDamageTotal = "armornotforever.damagetotal";
        private const string PermissionDamageMultiplier = "armornotforever.damagemultiplier";
        private const string PermissionDamageBypass = "armornotforever.damagebypass";

        #endregion

        #region Configuration
        private ConfigData _configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Global settings")]
            public GlobalSettings globalSettings = new GlobalSettings();

            [JsonProperty(PropertyName = "Multiplier settings")]
            public MultiplierSettings multiplierSettings = new MultiplierSettings();

            public class GlobalSettings
            {
                [JsonProperty(PropertyName = "Debag")]
                public bool Debag;

                [JsonProperty(PropertyName = "Damage from (Suicide). Does not damage armor.")]
                public bool DamageTypeSuicide;

                [JsonProperty(PropertyName = "Damage from (Bleeding). Does not damage armor.")]
                public bool DamageTypeBleeding;

                [JsonProperty(PropertyName = "Damage from (Drowning). Does not damage armor.")]
                public bool DamageTypeDrowning;

                [JsonProperty(PropertyName = "Damage from (Thirst). Does not damage armor.")]
                public bool DamageTypeThirst;

                [JsonProperty(PropertyName = "Damage from (Hunger). Does not damage armor.")]
                public bool DamageTypeHunger;

                [JsonProperty(PropertyName = "Damage from (Cold). Does not damage armor.")]
                public bool DamageTypeCold;

                [JsonProperty(PropertyName = "Damage from (Heat). Does not damage armor.")]
                public bool DamageTypeHeat;

                [JsonProperty(PropertyName = "Damage from (Fall). Does not damage armor.")]
                public bool DamageTypeFall;

                [JsonProperty(PropertyName = "Damage from (Radiation). Does not damage armor.")]
                public bool DamageTypeRadiation;
            }

            public class MultiplierSettings
            {
                [JsonProperty(PropertyName = "Item list Head (item shortname : multiplier)")]
                public Dictionary<string, float> list_Head = new Dictionary<string, float>()
                {
                    ["metal.facemask"] = 1.0f,
                    ["diving.mask"] = 1.0f,
                    ["hat.gas.mask"] = 1.0f,
                    ["heavy.plate.helmet"] = 1.0f,
                    ["bucket.helmet"] = 1.0f,
                    ["wood.armor.helmet"] = 1.0f,
                    ["sunglasses"] = 1.0f,
                    ["twitchsunglasses"] = 1.0f,
                    ["riot.helmet"] = 1.0f,
                    ["coffeecan.helmet"] = 1.0f,
                    ["deer.skull.mask"] = 1.0f,
                };

                [JsonProperty(PropertyName = "Item list Body (item shortname : multiplier)")]
                public Dictionary<string, float> list_Body = new Dictionary<string, float>()
                {
                    ["hazmatsuit"] = 1.0f,
                    ["hazmatsuit.arcticsuit"] = 1.0f,
                    ["hazmatsuit.nomadsuit"] = 1.0f,
                    ["hazmatsuit.spacesuit"] = 1.0f,
                    ["heavy.plate.jacket"] = 1.0f,
                    ["metal.plate.torso"] = 1.0f,
                    ["roadsign.jacket"] = 1.0f,
                    ["bone.armor.suit"] = 1.0f,
                    ["wood.armor.jacket"] = 1.0f,
                    ["attire.hide.poncho"] = 1.0f,
                    ["jumpsuit.suit"] = 1.0f,
                    ["jumpsuit.suit.blue"] = 1.0f,
                    ["cratecostume"] = 1.0f,
                    ["barrelcostume"] = 1.0f,
                    ["gloweyes"] = 1.0f,
                };

                [JsonProperty(PropertyName = "Item list Pants (item shortname : multiplier)")]
                public Dictionary<string, float> list_Pants = new Dictionary<string, float>()
                {
                    ["heavy.plate.pants"] = 1.0f,
                    ["wood.armor.pants"] = 1.0f,
                    ["roadsign.kilt"] = 1.0f,
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _configData = Config.ReadObject<ConfigData>();
                if (_configData == null) LoadDefaultConfig();
            }
            catch
            {
                PrintError("The configuration file is corrupted");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            _configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(_configData);

        #endregion Configuration


        #region Init

        private void Init()
        {
            permission.RegisterPermission(PermissionUse, this);
            permission.RegisterPermission(PermissionDamageTotal, this);
            permission.RegisterPermission(PermissionDamageMultiplier, this);
            permission.RegisterPermission(PermissionDamageBypass, this);
        }

        #endregion

        #region Unload

        void Unload()
        {
            _configData = null;
        }

        #endregion

        #region OnEntityTakeDamage

        void OnEntityTakeDamage(BasePlayer player, HitInfo info)
        {
            if (player == null || !player.userID.IsSteamId() || player.IsNpc || info == null || CheckDamageType(info) || !permission.UserHasPermission(player.UserIDString, PermissionUse) || permission.UserHasPermission(player.UserIDString, PermissionDamageBypass)) return;

            var damageTotal = info.damageTypes.Total();

            foreach (Item item in player.inventory.containerWear.itemList.ToList())
            {
                if (item.conditionNormalized == 0)
                {
                    Message(player, "ArmorBroken");
                    Effect.server.Run("assets/bundled/prefabs/fx/item_break.prefab", player.transform.position);

                    if (24 - player.inventory.containerMain.itemList.Count > 0)
                    {
                        item.MoveToContainer(player.inventory.containerMain);
                    }
                    else
                    {
                        item.Drop(player.transform.position, Vector3.up);
                        Message(player, "InventoryFull");
                    }
                    break;
                }

                foreach (var itemHead in _configData.multiplierSettings.list_Head)
                {
                    if (GetRandom() && item.info.shortname == itemHead.Key)
                    {
                        if (permission.UserHasPermission(player.UserIDString, PermissionDamageTotal) && !permission.UserHasPermission(player.UserIDString, PermissionDamageMultiplier))
                        {
                            item.condition -= damageTotal;
                            if (_configData.globalSettings.Debag) Puts($"Item {itemHead.Key} damageTotal {damageTotal}");
                        }
                        
                        if (permission.UserHasPermission(player.UserIDString, PermissionDamageMultiplier))
                        {
                            item.condition -= itemHead.Value;
                            if (_configData.globalSettings.Debag) Puts($"Item {itemHead.Key} damageMultiplier {itemHead.Value}");
                        }
                    }
                }

                foreach (var itemBody in _configData.multiplierSettings.list_Body)
                {
                    if (GetRandom() && item.info.shortname == itemBody.Key)
                    {
                        if (permission.UserHasPermission(player.UserIDString, PermissionDamageTotal) && !permission.UserHasPermission(player.UserIDString, PermissionDamageMultiplier))
                        {
                            item.condition -= damageTotal;
                            if (_configData.globalSettings.Debag) Puts($"Item {itemBody.Key} damageTotal {damageTotal}");
                        }
                        
                        if (permission.UserHasPermission(player.UserIDString, PermissionDamageMultiplier))
                        {
                            item.condition -= itemBody.Value;
                            if (_configData.globalSettings.Debag) Puts($"Item {itemBody.Key} damageMultiplier {itemBody.Value}");
                        }
                    }
                }

                foreach (var itemPants in _configData.multiplierSettings.list_Pants)
                {
                    if (GetRandom() && item.info.shortname == itemPants.Key)
                    {
                        if (permission.UserHasPermission(player.UserIDString, PermissionDamageTotal) && !permission.UserHasPermission(player.UserIDString, PermissionDamageMultiplier))
                        {
                            item.condition -= damageTotal;
                            if (_configData.globalSettings.Debag) Puts($"Item {itemPants.Key} damageTotal {damageTotal}");
                        }
                        
                        if (permission.UserHasPermission(player.UserIDString, PermissionDamageMultiplier))
                        {
                            item.condition -= itemPants.Value;
                            if (_configData.globalSettings.Debag) Puts($"Item {itemPants.Key} damageMultiplier {itemPants.Value}");
                        }
                    }
                }
            }
        }

        #endregion

        #region CanWearItem

        object CanWearItem(PlayerInventory inventory, Item item, int targetSlot)
        {
            var player = inventory.GetComponent<BasePlayer>();
            if (item.conditionNormalized == 0)
            {
                Message(player, "ItemBroken");
                Effect.server.Run("assets/prefabs/npc/autoturret/effects/targetlost.prefab", player.transform.position);
                return false;
            }
            return null;
        }

        #endregion

        #region Helper Damage

        private bool CheckDamageType(HitInfo info)
        {
            if (_configData.globalSettings.DamageTypeSuicide && info.damageTypes.Has(Rust.DamageType.Suicide)
            || _configData.globalSettings.DamageTypeBleeding && info.damageTypes.Has(Rust.DamageType.Bleeding)
            || _configData.globalSettings.DamageTypeDrowning && info.damageTypes.Has(Rust.DamageType.Drowned)
            || _configData.globalSettings.DamageTypeThirst && info.damageTypes.Has(Rust.DamageType.Thirst)
            || _configData.globalSettings.DamageTypeHunger && info.damageTypes.Has(Rust.DamageType.Hunger)
            || _configData.globalSettings.DamageTypeCold && info.damageTypes.Has(Rust.DamageType.Cold)
            || _configData.globalSettings.DamageTypeHeat && info.damageTypes.Has(Rust.DamageType.Heat)
            || _configData.globalSettings.DamageTypeFall && info.damageTypes.Has(Rust.DamageType.Fall)
            || _configData.globalSettings.DamageTypeRadiation && info.damageTypes.Has(Rust.DamageType.Radiation))
            {
                return true;
            }

            return false;
        }

        private static bool GetRandom()
        {
            return UnityEngine.Random.Range(0f, 1f) < 0.5f;
        }

        #endregion

        #region Language

        private void Message(BasePlayer player, string messageKey, params object[] args)
        {
            if (player == null) return;
            var message = GetMessage(messageKey, player.UserIDString, args);
            player.ChatMessage(message);
        }

        private string GetMessage(string messageKey, string playerID, params object[] args)
        {
            return string.Format(lang.GetMessage(messageKey, this, playerID), args);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "ItemBroken", "<color=#ff0000>THIS ITEM IS BROKEN!</color>" },
                { "ArmorBroken", "<color=#ff0000>Your armor has been broken!</color>" },
                { "InventoryFull", "<color=#ff0000>Your inventory has been full! \nThe item has been dropped from your inventory!</color>" },
            }, this, "en");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "ItemBroken", "<color=#ff0000>  !</color>" },
                { "ArmorBroken", "<color=#ff0000>   !</color>" },
                { "InventoryFull", "<color=#ff0000>   ! \n    !</color>" }
            }, this, "ru");
        }

        #endregion Language
    }
}

// --- End of file: ArmorNotForever.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/anti-npc ---
// --- Original File Path: A/AntiNPC/AntiNPC.cs ---

using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Anti NPC", "birthdates", "1.0.4")]
    [Description("Disables the spawning of NPCs")]
    public class AntiNPC : RustPlugin
    {

        #region Hooks
        private void Init() => LoadConfig();

        private void OnServerInitialized() => Cleanup();

        private void Cleanup()
        {
            foreach (var Entity in BaseNetworkable.serverEntities.ToList().Where(Entity => (Entity as BaseNpc != null || Entity as NPCPlayer != null) && !_config.Whitelist.Contains(Entity.PrefabName)))
            {
                Entity.Kill();
            }
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
            if (!(entity is BaseNpc) && !(entity is NPCPlayer) || _config.Whitelist.Contains(entity.PrefabName))
            {
                return;
            }
            //Next Tick for parenting, e.t.c
            NextTick(() =>
            {
                entity.Kill();
            });
        }
        #endregion

        #region Configuration & Language

        private ConfigFile _config;

        public class ConfigFile
        {
            [JsonProperty("Whitelisted NPCS (Prefab)")]
            public List<string> Whitelist;
            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile()
                {
                    Whitelist = new List<string>
                    {
                        "assets/prefabs/npc/scientist/scientistpeacekeeper.prefab"
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if (_config == null)
            {
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }
        #endregion
    }
}
//Generated with birthdates' Plugin Maker


// --- End of file: AntiNPC.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/admin-decay-hammer ---
// --- Original File Path: A/AdminDecayHammer/AdminDecayHammer.cs ---

using System.Collections.Generic;
using System;

namespace Oxide.Plugins
{
    [Info("Admin Decay Hammer", "Bazz3l", "0.0.5")]
    [Description("Hit a building block to start a faster decay.")]
    class AdminDecayHammer : RustPlugin
    {
        private const string Perm = "admindecayhammer.use";
        private List<ulong> Users = new List<ulong>();

        #region Config
        private PluginConfig configData;

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                DecayVariance = 100f
            };
        }

        private class PluginConfig
        {
            public float DecayVariance;
        }
        #endregion

        #region Lang
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoKeyPress"]      = "To use the decay hammer, please hold shift while hitting a building block.",
                ["NoBuildingBlock"] = "No building block found.",
                ["NoDecayEntity"]   = "No decay entity found.",
                ["NoPermission"]    = "No permission.",
                ["DecayStarted"]    = "Decay will start on next decay tick.",
                ["ToggleEnabled"]   = "Decay hammer is now Enabled.",
                ["ToggleDisabled"]  = "Decay hammer Disabled."
            }, this);
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        #endregion

        #region Oxide
        private void Init()
        {
            permission.RegisterPermission(Perm, this);

            configData = Config.ReadObject<PluginConfig>();
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (player != null && Users.Contains(player.userID))
            {
                Users.Remove(player.userID);
            }
        }

        private void OnHammerHit(BasePlayer player, HitInfo info)
        {
            if (player == null || info == null || !Users.Contains(player.userID) || !permission.UserHasPermission(player.UserIDString, Perm))
            {
                return;
            }

            if (!player.serverInput.IsDown(BUTTON.SPRINT))
            {
                player.ChatMessage(Lang("NoKeyPress", player.UserIDString));
                return;
            }

            BuildingBlock block = info?.HitEntity as BuildingBlock;
            if (block == null)
            {
                player.ChatMessage(Lang("NoBuildingBlock", player.UserIDString));
                return;
            }

            DecayEntity decayEntity = block as DecayEntity;
            if (decayEntity == null)
            {
                player.ChatMessage(Lang("NoDecayEntity", player.UserIDString));
                return;
            }

            BuildingDecay(decayEntity.buildingID);

            player.ChatMessage(Lang("DecayStarted", player.UserIDString));
        }
        #endregion

        #region Core
        private void BuildingDecay(uint buildingID)
        {
            BuildingManager.Building buildManager = BuildingManager.server.GetBuilding(buildingID);
            if (buildManager == null)
            {
                return;
            }

            foreach(DecayEntity decayEnt in buildManager.decayEntities)
            {
                decayEnt.ResetUpkeepTime();
                decayEnt.decayVariance = configData.DecayVariance;
            }
        }
        #endregion

        #region Commands
        [ChatCommand("decayhammer")]
        void DecayHammerCommand(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, Perm))
            {
                player.ChatMessage(Lang("NoPermission", player.UserIDString));
                return;
            }

            if (!Users.Contains(player.userID))
            {
                Users.Add(player.userID);
            }
            else
            {
                Users.Remove(player.userID);
            }

            player.ChatMessage(Users.Contains(player.userID) ? Lang("ToggleEnabled", player.UserIDString) : Lang("ToggleDisabled", player.UserIDString));
        }
        #endregion
    }
}

// --- End of file: AdminDecayHammer.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/auto-plant ---
// --- Original File Path: A/AutoPlant/AutoPlant.cs ---

// #define DEBUG

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;
using Facepunch;
using System.Linq;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Auto Plant", "Egor Blagov / rostov114", "1.2.7")]
    [Description("Automation of your plantations")]
    class AutoPlant : RustPlugin
    {
        #region Variables
        public static AutoPlant _instance;
        private List<ulong> _activeUse = new List<ulong>();
        #endregion

        #region Configuration
        private Configuration _config;
        public class Configuration
        {
            [JsonProperty(PropertyName = "Auto Plant permission")]
            public string autoPlant = "autoplant.use";

            [JsonProperty(PropertyName = "Auto Gather permission")]
            public string autoGather = "autoplant.gather.use";

            [JsonProperty(PropertyName = "Auto Cutting permission")]
            public string autoCutting = "autoplant.cutting.use";

            [JsonProperty(PropertyName = "Auto Remove Dying permission")]
            public string autoDying = "autoplant.removedying.use";

            [JsonProperty(PropertyName = "Auto fertilizer permission")]
            public string autoFertilizer = "autoplant.fertilizer.use";
            
            [JsonProperty(PropertyName = "Auto fertilizer configuration")]
            public FertilizerConfiguration fertilizer = new FertilizerConfiguration();
            
            public class FertilizerConfiguration
            {
                [JsonProperty(PropertyName = "Maximum distance from the PlanterBox")]
                public int maxDistance = 5;

                [JsonProperty(PropertyName = "Default fertilizer amount")]
                public int defaultAmount = 100;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                SaveConfig();
            }
            catch
            {
                PrintError("Error reading config, please check!");

                Unsubscribe(nameof(OnGrowableGather));
                Unsubscribe(nameof(CanTakeCutting));
                Unsubscribe(nameof(OnRemoveDying));
                Unsubscribe(nameof(OnEntityBuilt));
                Unsubscribe(nameof(OnActiveItemChanged));
                Unsubscribe(nameof(OnPlayerInput));
            }
        }

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration();
            SaveConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(_config);
        #endregion

        #region Data
        private Dictionary<ulong, int> _data = new Dictionary<ulong, int>();
        public static class Data
        {
            public static int Get(ulong userID)
            {
                if (_instance._data.ContainsKey(userID))
                {
                    return _instance._data[userID];
                }

                return _instance._config.fertilizer.defaultAmount;
            }

            public static void Set(ulong userID, int amount)
            {
                _instance._data[userID] = amount;
                Data.Save();
            }

            public static void Save()
            {
                Interface.Oxide.DataFileSystem.WriteObject(_instance.Name, _instance._data);
            }

            public static void Load()
            {
                try
                {
                    _instance._data = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, int>>(_instance.Name);
                }
                catch (Exception e)
                {
                    _instance.PrintError(e.Message);

                    _instance.Unsubscribe(nameof(OnActiveItemChanged));
                    _instance.Unsubscribe(nameof(OnPlayerInput));
                }
            }
        }
        #endregion

        #region Language
        private void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                {"notAllowed", "You are not allowed to use this command!"},
                {"changeAmount", "The amount of fertilizer transferred has been changed to {0} pcs."},
                {"currentAmount", "Current amount of fertilizer transferred: {0} pcs."}
            }, this, "en");
            
            lang.RegisterMessages(new Dictionary<string, string>() 
            {
                {"notAllowed", "     !" },
                {"changeAmount", "     {0} ." },
                {"currentAmount", "   : {0} ." }
            }, this, "ru");

            lang.RegisterMessages(new Dictionary<string, string>()
            {
                {"notAllowed", "     !" },
                {"changeAmount", " ,  ,  : {0} ." },
                {"currentAmount", "  ,  : {0} ." }
            }, this, "uk");
        }

        private string _(BasePlayer player, string key, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this, player?.UserIDString), args);
        }
        #endregion

        #region Oxide Hooks
        private void Init()
        {
            permission.RegisterPermission(_config.autoPlant, this);
            permission.RegisterPermission(_config.autoGather, this);
            permission.RegisterPermission(_config.autoCutting, this);
            permission.RegisterPermission(_config.autoDying, this);
            permission.RegisterPermission(_config.autoFertilizer, this);

            checkSubscribeHooks();
        }

        private void Loaded()
        {
            _instance = this;
            Data.Load();
        }

        private object OnGrowableGather(GrowableEntity plant, BasePlayer player)
        {
            if (plant.IsBusy())
                return null;

            List<BaseEntity> growables;
            if (!this.GetGrowables(player, plant, _config.autoGather, out growables))
                return null;

            foreach (BaseEntity growable in growables)
            {
                if (growable != null && growable is GrowableEntity)
                {
                    GrowableEntity _growable = growable as GrowableEntity;
                    if (_growable != null)
                    {
                        _growable.SetFlag(BaseEntity.Flags.Busy, true, false, false);
                        _growable.PickFruit(player);
                        _growable.SetFlag(BaseEntity.Flags.Busy, false, false, false);
                    }
                }
            }

            return true;
        }

        private object CanTakeCutting(BasePlayer player, GrowableEntity plant)
        {
            if (plant.IsBusy())
                return null;

            List<BaseEntity> growables;
            if (!this.GetGrowables(player, plant, _config.autoCutting, out growables))
                return null;

            foreach (BaseEntity growable in growables)
            {
                if (growable != null && growable is GrowableEntity)
                {
                    GrowableEntity _growable = growable as GrowableEntity;
                    if (_growable != null)
                    {
                        _growable.SetFlag(BaseEntity.Flags.Busy, true, false, false);
                        _growable.TakeClones(player);
                        _growable.SetFlag(BaseEntity.Flags.Busy, false, false, false);
                    }
                }
            }

            return true;
        }

        private object OnRemoveDying(GrowableEntity plant, BasePlayer player)
        {
            if (plant.IsBusy())
                return null;

            List<BaseEntity> growables;
            if (!this.GetGrowables(player, plant, _config.autoDying, out growables))
                return null;

            foreach (BaseEntity growable in growables)
            {
                if (growable != null && growable is GrowableEntity)
                {
                    GrowableEntity _growable = growable as GrowableEntity;
                    if (_growable != null)
                    {
                        _growable.SetFlag(BaseEntity.Flags.Busy, true, false, false);
                        _growable.RemoveDying(player);
                        _growable.SetFlag(BaseEntity.Flags.Busy, false, false, false);
                    }
                }
            }

            return true;
        }

        private void OnEntityBuilt(Planner plan, GameObject seed) 
        {
            if (plan.IsBusy())
                return;

            BasePlayer player = plan.GetOwnerPlayer();
            GrowableEntity plant = seed.GetComponent<GrowableEntity>();
            if (player == null || plant == null || !permission.UserHasPermission(player.UserIDString, _config.autoPlant))
                return;

            NextTick(() => 
            {
                Item held = player.GetActiveItem();
                if (held == null || held.amount == 0)
                    return;

                if (player.serverInput.IsDown(BUTTON.SPRINT) && plant.GetParentEntity() is PlanterBox)
                {
                    PlanterBox planterBox = plant.GetParentEntity() as PlanterBox;
                    Construction construction = PrefabAttribute.server.Find<Construction>(plan.GetDeployable().prefabID);
                    List<Construction.Target> targets = Pool.GetList<Construction.Target>();
                    foreach (Socket_Base sock in PrefabAttribute.server.FindAll<Socket_Base>(planterBox.prefabID)) 
                    {
                        if (!sock.female)
                            continue;

                        Vector3 socketPoint = planterBox.transform.TransformPoint(sock.worldPosition);
                        Construction.Target target = new Construction.Target();

                        target.entity = planterBox;
                        target.ray = new Ray(socketPoint + Vector3.up * 1.0f, Vector3.down);
                        target.onTerrain = false;
                        target.position = socketPoint;
                        target.normal = Vector3.up;
                        target.rotation = new Vector3();
                        target.player = player;
                        target.valid = true;
                        target.socket = sock;
                        target.inBuildingPrivilege = true;

                        if (!this.IsFree(construction, target))
                            continue;

                        targets.Add(target);
                    }

                    plan.SetFlag(BaseEntity.Flags.Busy, true, false, false);
                    foreach (Construction.Target target in targets) 
                    {
                        plan.DoBuild(target, construction);
                        if (held.amount == 0)
                            break;
                    }
                    plan.SetFlag(BaseEntity.Flags.Busy, false, false, false);

                    Pool.FreeList(ref targets);
                }
            });
        }

        private void OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem)
        {
            if (player == null)
                return;

            if (newItem != null && newItem.info.shortname == "fertilizer")
            {
                if (permission.UserHasPermission(player.UserIDString, _config.autoFertilizer))
                {
                    _activeUse.Add(player.userID.Get());
                    checkSubscribeHooks();
                }
            }
            else
            {
                if (_activeUse.Contains(player.userID.Get()))
                {
                    _activeUse.Remove(player.userID.Get());
                    checkSubscribeHooks();
                }
            }
        }

        private void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (_activeUse.Contains(player.userID.Get()) && input.WasJustReleased(BUTTON.FIRE_PRIMARY))
            {
                Item activeItem = player.GetActiveItem();
                if (activeItem == null)
                    return;

                if (activeItem.info.shortname != "fertilizer")
                    return;

                PlanterBox planterBox;
                if (IsLookingPlanterBox(player, out planterBox))
                {
                    int amount = Data.Get(player.userID.Get());
                    Item moveItem = (amount >= activeItem.amount) ? activeItem : activeItem.SplitItem(amount);

                    player.Command("note.inv", (object)moveItem.info.itemid, (object)-moveItem.amount);
                    EffectNetwork.Send(new Effect("assets/bundled/prefabs/fx/impacts/physics/phys-impact-meat-soft.prefab", player, 0, new Vector3(), new Vector3()), player.Connection);

                    if (!moveItem.MoveToContainer(planterBox.inventory, -1, true))
                    {
                        moveItem.Drop(player.GetDropPosition(), player.GetDropVelocity(), default(Quaternion));
                    }
                }
            }
        }
#if DEBUG
        private void OnHammerHit(BasePlayer player, HitInfo info) 
        {
            if (player == null || info == null || info?.HitEntity == null) 
                return;

            if (player.IsAdmin && player.serverInput.IsDown(BUTTON.FIRE_SECONDARY) && (info.HitEntity is PlanterBox))
            {
                (info.HitEntity as PlanterBox).DoSplash(ItemManager.FindItemDefinition("water"), 9000);
            }
        }
#endif
        #endregion

        #region Chat Command
        [ChatCommand("fertilizer")]
        private void fertilizer_command(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, _config.autoFertilizer))
            {
                SendReply(player, _(player, "notAllowed"));
                return;
            }

            if (args.Length == 0)
            {
                SendReply(player, _(player, "currentAmount", Data.Get(player.userID.Get())));
                return;
            }

            int amount = _config.fertilizer.defaultAmount;
            try
            {
                amount = Int32.Parse(args[0]);
            }
            catch { }

            Data.Set(player.userID.Get(), amount);
            SendReply(player, _(player, "changeAmount", amount));
        }
        #endregion

        #region Helpers
        public void checkSubscribeHooks()
        {
            if (_activeUse.Count > 0)
            {
                Subscribe(nameof(OnPlayerInput));
            }
            else
            {
                Unsubscribe(nameof(OnPlayerInput));
            }
        }

        public bool IsFree(Construction common, Construction.Target target) 
        {
            List<Socket_Base> list = Facepunch.Pool.GetList<Socket_Base>();
            common.FindMaleSockets(target, list);
            Socket_Base socketBase = list[0];
            Facepunch.Pool.FreeList(ref list);
            Construction.Placement placement = socketBase.DoPlacement(target);
            return !target.entity.IsOccupied(target.socket) && socketBase.CheckSocketMods(ref placement);
        }

        public bool GetGrowables(BasePlayer player, GrowableEntity plant, string perm, out List<BaseEntity> growables)
        {
            growables = null;

            if (player == null || plant == null || !permission.UserHasPermission(player.UserIDString, perm))
                return false;

            if (player.serverInput.IsDown(BUTTON.SPRINT))
            {
                PlanterBox planterBox = plant.GetPlanter();
                if (planterBox == null || planterBox?.children == null || planterBox.children.Count == 0)
                    return false;

                growables = planterBox.children.ToList();
                return true;
            }

            return false;
        }

        private bool IsLookingPlanterBox(BasePlayer player, out PlanterBox planterBox)
        {
            RaycastHit hit;
            planterBox = null;

            if (Physics.Raycast(player.eyes.HeadRay(), out hit, _config.fertilizer.maxDistance, LayerMask.GetMask("Deployed")))
            {
                BaseEntity entity = hit.GetEntity();
                if (entity is PlanterBox)
                {
                    planterBox = entity as PlanterBox;
                }
            }

            return planterBox != null;
        }
        #endregion
    }
}

// --- End of file: AutoPlant.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/airdrop-precision ---
// --- Original File Path: A/AirdropPrecision/AirdropPrecision.cs ---

namespace Oxide.Plugins
{
    [Info("Airdrop Precision", "k1lly0u", "0.2.0")]
    public class AirdropPrecision : RustPlugin
    {
        #region Fields
        private const string CARGOPLANE_PREFAB = "assets/prefabs/npc/cargo plane/cargo_plane.prefab";
        #endregion

        #region Oxide Hooks        
        private void OnExplosiveDropped(BasePlayer player, SupplySignal supplySignal) => OnExplosiveThrown(player, supplySignal);

        private void OnExplosiveThrown(BasePlayer player, SupplySignal supplySignal)
        {
            if (supplySignal == null)
                return;

            supplySignal.CancelInvoke(supplySignal.Explode);
            supplySignal.Invoke(() => Explode(supplySignal), 3f);
        }  
        
        private void Explode(SupplySignal supplySignal)
        {
            CargoPlane cargoPlane = GameManager.server.CreateEntity(CARGOPLANE_PREFAB) as CargoPlane;
            cargoPlane.InitDropPosition(supplySignal.transform.position);
            cargoPlane.Spawn();

            supplySignal.Invoke(supplySignal.FinishUp, 210f);
            supplySignal.SetFlag(BaseEntity.Flags.On, true);
            supplySignal.SendNetworkUpdateImmediate();
        }
        #endregion
    }
}



// --- End of file: AirdropPrecision.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/auto-sign-moderation ---
// --- Original File Path: A/AutoSignModeration/AutoSignModeration.cs ---

// Reference: System.Drawing
using Newtonsoft.Json;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.IO;
using System.Linq;
using UnityEngine;
using UnityEngine.Networking;
using Graphics = System.Drawing.Graphics;
using System.Text;
using Facepunch;
using Oxide.Core.Libraries.Covalence;
using Encoder = System.Drawing.Imaging.Encoder;

namespace Oxide.Plugins
{
    [Info("Auto Sign Moderation", "Whispers88", "1.1.1")]
    [Description("Uses the Omni AI/Open AI to auto moderate image content")]
    public class AutoSignModeration : CovalencePlugin
    {
        private Dictionary<ulong, float> _signCooldown = new Dictionary<ulong, float>();
        private Queue<SignData> _queuedImages = new Queue<SignData>();
        private Dictionary<ImageKey, SignData> _signsQueuedPool = new Dictionary<ImageKey, SignData>();

        private string permWhitelist = "autosignmoderation.whitelist";

        #region Configuration
        private Configuration config;

        public class Configuration
        {
            [JsonProperty("Image Size 25 - 100%")]
            public float imageSizeReduction = 50;

            [JsonProperty("Image Quality 25 - 100%")]
            public float imageQualityReduction = 75;

            [JsonProperty("Sign Update Cooldown (seconds)")]
            public float signCooldown = 5;

            [JsonProperty("Player Moderated Cooldown (seconds)")]
            public float signModerationCooldown = 300;

            [JsonProperty("Hide signs while being checked")]
            public bool hideSign = true;

            [JsonProperty("Use Temp Loading Image")]
            public bool useTempImage = false;

            [JsonProperty("Temp Loading Image URL:")]
            public string tempModerationImageURL = "https://i.postimg.cc/4NNrqT2x/pngegg-2.png";

            [JsonProperty("Logging Mode Only")]
            public bool loggingMode = false;

            [JsonProperty("Send Player Chat Warnings")]
            public bool chatWarnings = false;

            [JsonProperty("Batch Mode - Disables hiding of signs")]
            public BatchSettings batchSettings = new BatchSettings();

            [JsonProperty("Discord Settings")]
            public DiscordSettings discordSettings = new DiscordSettings();

            [JsonProperty("Moderation API (Free) - Limited Options")]
            public ModerationAPI moderationAPI = new ModerationAPI();

            [JsonProperty("Advance Moderation API (Paid)")]
            public GPTModel gptModel = new GPTModel();

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        public class BatchSettings
        {
            [JsonProperty("Check images in batches (Advance Mode Only)")]
            public bool imagePooling = true;

            [JsonProperty("Batch Image Check Rate (Minutes)")]
            public float imagePoolingRate = 15;

            [JsonProperty("Minimum images to batch check")]
            public float minImagesPooled = 3;

            [JsonProperty("Max checks to bypass minimum images 0 = no bypass")]
            public float maxChecksImagesPooled = 4;
        }

        public class DiscordSettings
        {
            [JsonProperty("Log to Discord")]
            public bool discordLogging = false;

            [JsonProperty("Log moderated Images to Discord (WARNING THIS MAY SEND NSFW CONTENT TO YOUR DISCORD)")]
            public bool discordImageLogging = false;

            [JsonProperty("Discord Webhook")]
            public string DiscordWebhook = "https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks";

            [JsonProperty("Discord Username")]
            public string DiscordUsername = "Sign Moderator";

            [JsonProperty("Server Name")]
            public string ServerName = "";

            [JsonProperty("Avatar URL")]
            public string AvatarUrl = "https://i.ibb.co/sQ10728/Loading-Pls-Wait2.png";
        }

        public class ModerationAPI
        {
            [JsonProperty("Enable")]
            public bool enabled = true;

            [JsonProperty("Open AI Token")]
            public string apiToken = "https://openai.com/index/openai-api/";

            [JsonProperty("Cooldown between API Checks (seconds)")]
            public float apiCooldown = 1;

            [JsonProperty("Block images of harassment")]
            public bool harassment = true;

            [JsonProperty("Block images of harassment/threatening")]
            public bool harassmentThreatening = true;

            [JsonProperty("Block images of sexual")]
            public bool sexual = true;

            [JsonProperty("Block images of hate")]
            public bool hate = true;

            [JsonProperty("Block images of hate/threatening")]
            public bool hateThreatening = true;

            [JsonProperty("Block images of illicit")]
            public bool illicit = true;

            [JsonProperty("Block images of illicit/violent")]
            public bool illicitViolent = true;

            [JsonProperty("Block images of self-harm/intent")]
            public bool selfHarmIntent = true;

            [JsonProperty("Block images of self-harm/instructions")]
            public bool selfHarmInstructions = true;

            [JsonProperty("Block images of self-harm")]
            public bool selfHarm = true;

            [JsonProperty("Block images of sexual/minors")]
            public bool sexualMinors = true;

            [JsonProperty("Block images of violence")]
            public bool violence = true;

            [JsonProperty("Block images of violence/graphic")]
            public bool violenceGraphic = true;
        }

        public class GPTModel
        {
            [JsonProperty("Enable GPT Model (WARNING THIS IS PAID PLEASE READ DOCS)")]
            public bool enabled = false;

            [JsonProperty("Open AI Token")]
            public string apiToken = "https://openai.com/index/openai-api/";

            [JsonProperty("Cooldown between API Checks (seconds)")]
            public float apiCooldown = 1;

            [JsonProperty("Model (Don't change this if you dont know what it is)")]
            public string model = "gpt-4o-mini";

            [JsonProperty("Content to moderate")]
            public string prompt = "Pornography, Hate Speech, Child Exploitation, Racist images signs text or symbols, Words like nigger, symbols which resemble swastikas";
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }
        #endregion Configuration

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["WarningMessage"] = "You cannot post explicit content on signs",
                ["CooldownMessage"] = "You need to wait {0} before updating the sign."
            }, this);
        }

        #endregion Localization

        #region Classes
        public class SignData
        {
            public ulong playerId;
            public Signage sign;
            public int textureIndex;
            public uint crc;
            public FileStorage.Type type;
        }

        #region API
        public class Categories
        {
            public bool harassment;
            public bool harassmentthreatening;
            public bool sexual;
            public bool hate;
            public bool hatethreatening;
            public bool illicit;
            public bool illicitviolent;
            public bool selfharmintent;
            public bool selfharminstructions;
            public bool selfharm;
            public bool sexualminors;
            public bool violence;
            public bool violencegraphic;
        }

        public class CategoryScores
        {
            public double harassment;
            public double harassmentthreatening;
            public double sexual;
            public double hate;
            public double hatethreatening;
            public double illicit;
            public double illicitviolent;
            public double selfharmintent;
            public double selfharminstructions;
            public double selfharm;
            public double sexualminors;
            public double violence;
            public double violencegraphic;
        }

        public class Result
        {
            public bool flagged;
            public Categories categories;
            public CategoryScores category_scores;
        }

        public class OmniDataRoot
        {
            public string id;
            public string model;
            public List<Result> results;
        }

        public class Choice
        {
            public int index;
            public Message message;
            public object logprobs;
            public string finish_reason;
        }

        public class CompletionTokensDetails
        {
            public int reasoning_tokens;
            public int audio_tokens;
            public int accepted_prediction_tokens;
            public int rejected_prediction_tokens;
        }

        public class Message
        {
            public string role;
            public string content;
            public object refusal;
        }

        public class PromptTokensDetails
        {
            public int cached_tokens;
            public int audio_tokens;
        }

        public class GPTRoot
        {
            public string id;
            public string @object;
            public int created;
            public string model;
            public List<Choice> choices;
            //public Usage usage;
            //public string service_tier;
            //public string system_fingerprint;
        }

        public class Usage
        {
            public int prompt_tokens;
            public int completion_tokens;
            public int total_tokens;
            public PromptTokensDetails prompt_tokens_details;
            public CompletionTokensDetails completion_tokens_details;
        }

        #endregion API

        #endregion Classes

        #region Hooks
        public class ImageSize
        {
            public int Width { get; }
            public int Height { get; }

            public ImageSize(int width, int height)
            {
                Width = width;
                Height = height;
            }
        }

        public struct ImageKey : IEquatable<ImageKey>
        {
            public ulong NetID;
            public int TextureIndex;

            public bool Equals(ImageKey other)
            {
                return NetID == other.NetID && TextureIndex == other.TextureIndex;
            }

            public override bool Equals(object obj)
            {
                if (obj is ImageKey other)
                {
                    return Equals(other);
                }
                return false;
            }

            public override int GetHashCode()
            {
                return HashCode.Combine(NetID, TextureIndex);
            }
        }

        private ImageCodecInfo _imageCodecInfo = null;
        private EncoderParameters _encoderParams = null;

        private Dictionary<uint, ImageSize> _ImageSizeperAsset = new Dictionary<uint, ImageSize>();
        private void OnServerInitialized()
        {
            if (CheckPooledImagesRun != null) // This is only really needed during testing if static instances persist
            {
                ServerMgr.Instance.StopCoroutine(CheckPooledImagesRun);
                CheckPooledImagesRun = null;
            }
            if (CheckImagesRun != null) // This is only really needed during testing if static instances persist
            {
                ServerMgr.Instance.StopCoroutine(CheckImagesRun);
                CheckImagesRun = null;
            }

            permission.RegisterPermission(permWhitelist, this);

            _stringBuilder = new StringBuilder();

            gptModel = config.gptModel.model;
            prompt = config.gptModel.prompt;

            _ModerationAPIWait = CoroutineEx.waitForSeconds(config.moderationAPI.apiCooldown);
            _GPTModelAPIWait = CoroutineEx.waitForSeconds(config.gptModel.apiCooldown);

            _imageCodecInfo = ImageCodecInfo.GetImageEncoders().FirstOrDefault(x => x.FormatID == ImageFormat.Jpeg.Guid);
            _encoderParams = new EncoderParameters(1);
            _encoderParams.Param[0] = new EncoderParameter(Encoder.Quality, (long)config.imageQualityReduction);

            if (config.imageSizeReduction < 25)
            {
                config.imageSizeReduction = 25;
            }

            if (config.imageQualityReduction < 25)
            {
                config.imageSizeReduction = 25;
            }

            if (config.useTempImage)
            {
                _tempModerationImageURL = config.tempModerationImageURL;
            }
            if (GetLoadingImage != null)
            {
                ServerMgr.Instance.StopCoroutine(GetLoadingImage);
            }

            GetLoadingImage = LoadingImageSetup();
            ServerMgr.Instance.StartCoroutine(GetLoadingImage);

            foreach (var prefab in GameManifest.Current.entities)
            {
                var gamePrefab = GameManager.server.FindPrefab(prefab.ToLower());
                if (gamePrefab == null)
                    continue;

                Signage sign = gamePrefab.GetComponent<Signage>();
                if (sign != null)
                {
                    if (sign.paintableSources?.Length < 1) continue;
                    _ImageSizeperAsset[sign.prefabID] = new ImageSize(sign.paintableSources[0].texWidth, sign.paintableSources[0].texHeight);
                    continue;
                }
                PhotoFrame photoFrame = gamePrefab.GetComponent<PhotoFrame>();
                if (photoFrame != null)
                {
                    _ImageSizeperAsset[photoFrame.prefabID] = new ImageSize(photoFrame.PaintableSource.texWidth, photoFrame.PaintableSource.texHeight);
                    continue;
                }
                NeonSign neonSign = gamePrefab.GetComponent<NeonSign>();
                if (neonSign != null)
                {
                    _ImageSizeperAsset[neonSign.prefabID] = new ImageSize(neonSign.paintableSources[0].texWidth, neonSign.paintableSources[0].texHeight);
                    continue;
                }
                WantedPoster wantedPoster = gamePrefab.GetComponent<WantedPoster>();
                if (wantedPoster != null)
                {
                    _ImageSizeperAsset[wantedPoster.prefabID] = new ImageSize(wantedPoster.TextureSize.x, wantedPoster.TextureSize.y);
                    continue;
                }
                CarvablePumpkin carvablePumpkin = gamePrefab.GetComponent<CarvablePumpkin>();
                if (carvablePumpkin != null)
                {
                    _ImageSizeperAsset[carvablePumpkin.prefabID] = new ImageSize(carvablePumpkin.paintableSources[0].texWidth, carvablePumpkin.paintableSources[0].texHeight);
                    continue;
                }
            }

            if (config.batchSettings.imagePooling)
            {
                if (!config.gptModel.enabled)
                {
                    Puts("You require gpt model to use image pooling. Disabling image pooling");
                    config.batchSettings.imagePooling = false;
                }
                else
                {
                    ServerMgr.Instance.InvokeRepeating(StartPooledImageCheck, 0, config.batchSettings.imagePoolingRate * 60);
                }
            }
        }

        private void Unload()
        {
            if (ServerMgr.Instance.IsInvoking(StartPooledImageCheck))
            {
                ServerMgr.Instance.CancelInvoke(StartPooledImageCheck);
            }
            if (CheckPooledImagesRun != null)
            {
                ServerMgr.Instance.StopCoroutine(CheckPooledImagesRun);
            }
            if (GetLoadingImage != null)
            {
                ServerMgr.Instance.StopCoroutine(GetLoadingImage);
            }
            if (CheckImagesRun != null)
            {
                ServerMgr.Instance.StopCoroutine(CheckImagesRun);
            }

            CheckPooledImagesRun = null;
            GetLoadingImage = null;
            CheckImagesRun = null;

            _signCooldown = null;
            _queuedImages = null;
            _signsQueuedPool = null;
        }

        private void StartPooledImageCheck()
        {
            if (CheckPooledImagesRun != null)
            {
                return;
            }
            CheckPooledImagesRun = CheckPooledImages();
            ServerMgr.Instance.StartCoroutine(CheckPooledImagesRun);
        }

        private StringBuilder _formattedTime = new StringBuilder();
        private object? CanUpdateSign(BasePlayer player, Signage sign)
        {
            if (_signCooldown.TryGetValue(player.userID, out float cooldown) && cooldown > Time.time)
            {
                TimeSpan timeRemaining = TimeSpan.FromSeconds(cooldown - Time.time);
                _formattedTime.Clear();
                if (timeRemaining.Days > 0) _formattedTime.Append(timeRemaining.Days).Append("d ");
                if (timeRemaining.Hours > 0) _formattedTime.Append(timeRemaining.Hours).Append("h");
                if (timeRemaining.Minutes > 0) _formattedTime.Append(timeRemaining.Minutes).Append("m ");
                _formattedTime.Append(timeRemaining.Seconds).Append("s");

                ChatMessage(player.IPlayer, "CooldownMessage", _formattedTime.ToString());
                return false;
            }
            return null;
        }

        void OnSignUpdated(Signage sign, BasePlayer player, int textureIndex)
        {
            if (player == null || sign == null) return;
            if (HasPerm(player.UserIDString, permWhitelist)) return;

            if (config.batchSettings.imagePooling)
            {
                _signsQueuedPool[new ImageKey() { NetID = sign.NetworkID.Value, TextureIndex = textureIndex }] = new SignData { playerId = player.userID, sign = sign, textureIndex = textureIndex, crc = sign.GetContentCRCs[textureIndex], type = sign.FileType };
                return;
            }

            _queuedImages.Enqueue(new SignData { playerId = player.userID, sign = sign, textureIndex = textureIndex, crc = sign.GetContentCRCs[textureIndex], type = sign.FileType });

            if (config.hideSign)
            {
                SetImageToSign(sign, textureIndex, _tempModerationImageCRC);
            }

            _signCooldown[player.userID] = Time.time + config.signCooldown;

            if (CheckImagesRun == null)
            {
                CheckImagesRun = CheckImages();
                ServerMgr.Instance.StartCoroutine(CheckImagesRun);
            }
        }

        #endregion Hooks

        #region Methods
        private void SetImageToSign(Signage sign, int textureIndex, uint crc)
        {
            sign.textureIDs[textureIndex] = crc;
            sign.SendNetworkUpdateImmediate();
        }

        readonly string jsonline1 = "{\"model\": \"omni-moderation-latest\",\"input\": [ { \"type\": \"image_url\",\"image_url\": {\"url\": \"data:image/jpeg;base64,";
        readonly string jsonline2 = "\"}}]}";

        private static StringBuilder _stringBuilder = new StringBuilder();
        private string CreateJson(string base64Input)
        {
            _stringBuilder.Clear();
            _stringBuilder.Append(jsonline1);
            _stringBuilder.Append(base64Input);
            _stringBuilder.Append(jsonline2);
            return _stringBuilder.ToString();
        }

        readonly string jsongptline1 = "{\"model\": \"";
        readonly string jsongptline2 = "\",\"store\": false,\"messages\": [{\"role\": \"user\", \"content\": [{\"type\": \"text\", \"text\": \"Answer with only 'yes' or 'no' if the image contains any of the specified categories:";
        readonly string jsongptline3 = "\"},{\"type\": \"image_url\", \"image_url\": {\"url\": \"data:image/jpeg;base64,";
        readonly string jsongptline4 = "\"}}]}]}";
        private string gptModel = "gpt-4o-mini";
        private string prompt = "Racism, Pornographic material, Hate Speech";
        private string CreateGPTJson(string base64Input)
        {
            _stringBuilder.Clear();
            _stringBuilder.Append(jsongptline1);
            _stringBuilder.Append(gptModel);
            _stringBuilder.Append(jsongptline2);
            _stringBuilder.Append(prompt);
            _stringBuilder.Append(jsongptline3);
            _stringBuilder.Append(base64Input);
            _stringBuilder.Append(jsongptline4);
            return _stringBuilder.ToString();
        }

        private readonly string _moderationAPI = "https://api.openai.com/v1/moderations";
        private readonly string _gptModelAPI = "https://api.openai.com/v1/chat/completions";

        private static WaitForSeconds _ModerationAPIWait = CoroutineEx.waitForSeconds(5);
        private static WaitForSeconds _GPTModelAPIWait = CoroutineEx.waitForSeconds(5);

        private static IEnumerator CheckImagesRun;
        private IEnumerator CheckImages()
        {
            for (int i = 0; i < _queuedImages.Count; i++)
            {
                SignData signData = _queuedImages.Dequeue();
                if (signData.sign == null || signData.sign.GetContentCRCs.Length < 1 || signData.sign.GetContentCRCs[signData.textureIndex] != signData.crc)
                {
                    continue;
                }
                byte[] array = GetImageBytes(signData);
                if (array == null || array.Length == 0)
                {
                    continue;
                }
                string Base64 = Convert.ToBase64String(array);

                if (config.moderationAPI.enabled)
                {
                    yield return CheckModerationAPI(signData, array);
                }

                if (config.gptModel.enabled)
                {
                    yield return CheckGPTModelAPI(signData, array);
                }
                SetImageToSign(signData.sign, signData.textureIndex, signData.crc);
            }
            CheckImagesRun = null;
        }

        private IEnumerator CheckModerationAPI(SignData signData, byte[] array)
        {
            UnityWebRequest www = UnityWebRequest.Post(_moderationAPI, CreateJson(Convert.ToBase64String(array)), "application/json");
            www.SetRequestHeader("Authorization", $"Bearer {config.moderationAPI.apiToken}");
            www.timeout = 20;
            yield return www.SendWebRequest();

            if (IsBadResponse(www))
            {
                yield return _ModerationAPIWait;
                yield break;
            }

            string jsonResponse = www.downloadHandler.text;
            OmniDataRoot omniData = JsonConvert.DeserializeObject<OmniDataRoot>(jsonResponse);
            if (omniData == null || omniData.results == null || omniData.results.Count < 1)
            {
                www.Dispose();
                yield break;
            }

            Result result = omniData.results[0];
            if (result.flagged)
            {
                ReportContent(signData, array);
            }
            www.Dispose();
            yield return false;
        }

        private IEnumerator CheckGPTModelAPI(SignData signData, byte[] array)
        {
            UnityWebRequest www = UnityWebRequest.Post(_gptModelAPI, CreateGPTJson(Convert.ToBase64String(array)), "application/json");
            www.SetRequestHeader("Authorization", $"Bearer {config.gptModel.apiToken}");
            www.timeout = 20;
            yield return www.SendWebRequest();

            if (IsBadResponse(www))
            {
                yield return _GPTModelAPIWait;
                yield break;
            }

            string jsonResponse = www.downloadHandler.text;
            GPTRoot gptData = JsonConvert.DeserializeObject<GPTRoot>(jsonResponse);
            string response = gptData.choices[0]?.message?.content ?? string.Empty;
            if (response.Length > 2)
            {
                response = response.Substring(0, 2);
            }

            if (gptData != null && !string.Equals(response, "no", StringComparison.OrdinalIgnoreCase))
            {
                ReportContent(signData, array);
            }
            www.Dispose();
            yield return false;
        }

        private void ReportContent(SignData signData, byte[] array)
        {
            if (!config.loggingMode)
            {
                signData.sign.ClearContent();
                FileStorage.server.Remove(signData.crc, signData.type, signData.sign.NetworkID);
            }
            _signCooldown[signData.playerId] = Time.time + config.signModerationCooldown;
            SendPlayerWarning(signData.playerId);
            if (config.discordSettings.discordLogging)
            {
                ServerMgr.Instance.StartCoroutine(LogToDiscord(signData, BasePlayer.FindByID(signData.playerId), gptModel, array));
            }
        }
        string badResponse = "Bad Response: ";

        private bool IsBadResponse(UnityWebRequest www)
        {
            if (www.result != UnityWebRequest.Result.Success)
            {
                PrintError(string.Join(badResponse, www.error));
                www.Dispose();
                return true;
            }
            return false;
        }

        #region Image Pooling
        const string jsongptPoolline1 = "{\"model\": \"";
        const string jsongptPoolline2 = "\",\"store\": false,\"messages\": [{\"role\": \"user\", \"content\": [{\"type\": \"text\", \"text\": \"Answer with only 'yes' or 'no' and comma separation per image per image if the images contain any of the specified categories:";
        const string jsongptPoolline3 = "\"},";
        const string jsongptPoolline4 = "{\"type\": \"image_url\", \"image_url\": {\"url\": \"data:image/jpeg;base64,";
        const string jsongptPoolline5 = "\"}},";
        const string jsongptPoolline6 = "]}]}";

        private int _pooledImageChecks = 0;
        private static IEnumerator CheckPooledImagesRun;
        private class PooledSignData
        {
            public byte[] bytes;
            public SignData sign;
        }

        private IEnumerator CheckPooledImages()
        {
            if (_signsQueuedPool.Count < config.batchSettings.minImagesPooled)
            {
                if (config.batchSettings.maxChecksImagesPooled == 0 || _pooledImageChecks < config.batchSettings.maxChecksImagesPooled)
                {
                    if (_signsQueuedPool.Count > 0)
                    {
                        _pooledImageChecks += 1;
                    }

                    CheckPooledImagesRun = null;
                    yield break;
                }

            }
            _pooledImageChecks = 0;

            List<PooledSignData> checkedSigns = Pool.Get<List<PooledSignData>>();

            _stringBuilder.Clear();
            _stringBuilder.Append(jsongptPoolline1);
            _stringBuilder.Append(gptModel);
            _stringBuilder.Append(jsongptPoolline2);
            _stringBuilder.Append(prompt);
            _stringBuilder.Append(jsongptPoolline3);

            foreach (var sign in _signsQueuedPool)
            {
                SignData signData = sign.Value;
                byte[] array = GetImageBytes(signData);
                if (array == null || array.Length == 0)
                {
                    continue;
                }
                string Base64 = Convert.ToBase64String(array);
                _stringBuilder.Append(jsongptPoolline4);
                _stringBuilder.Append(Base64);
                _stringBuilder.Append(jsongptPoolline5);
                checkedSigns.Add(new PooledSignData() { bytes = array, sign = signData });
            }
            _stringBuilder.Remove(_stringBuilder.Length - 1, 1); //remove last comma
            _stringBuilder.Append(jsongptPoolline6);

            _signsQueuedPool.Clear();
            if (checkedSigns.Count < 1)
            {
                Pool.FreeUnmanaged(ref checkedSigns);
                CheckPooledImagesRun = null;
                yield break;
            }
            UnityWebRequest www = UnityWebRequest.Post(_gptModelAPI, _stringBuilder.ToString(), "application/json");
            www.SetRequestHeader("Authorization", $"Bearer {config.gptModel.apiToken}");
            www.timeout = 20;
            yield return www.SendWebRequest();
            
            if (IsBadResponse(www))
            {
                Pool.FreeUnmanaged(ref checkedSigns);
                CheckPooledImagesRun = null;
                yield break;
            }

            string jsonResponse = www.downloadHandler.text;
            GPTRoot gptData = JsonConvert.DeserializeObject<GPTRoot>(jsonResponse);
            string response = gptData.choices[0]?.message?.content?.Replace(" ", string.Empty) ?? string.Empty;

            if (gptData == null || string.IsNullOrEmpty(response))
            {
                www.Dispose();
                Pool.FreeUnmanaged(ref checkedSigns);
                CheckPooledImagesRun = null;
                yield break;
            }
            string[] responses = response.Split(',');

            for (int i = 0; i < responses.Length; i++)
            {
                if (gptData == null || !string.Equals(responses[i], "yes", StringComparison.OrdinalIgnoreCase))
                    continue;

                if (i >= checkedSigns.Count)
                {
                    Puts($"GPT has more responses than images {checkedSigns.Count} response:{string.Join(",", responses)}");
                    break;
                }
                SignData signData = checkedSigns[i].sign;
                ReportContent(signData, checkedSigns[i].bytes);
            }
            www.Dispose();
            Pool.FreeUnmanaged(ref checkedSigns);
            CheckPooledImagesRun = null;
        }
        #endregion Image Pooling

        private void SendPlayerWarning(ulong playerID)
        {
            if (!config.chatWarnings)
                return;

            BasePlayer player = BasePlayer.FindByID(playerID);
            if (player == null)
                return;
            ChatMessage(player.IPlayer, "WarningMessage");
        }

        public byte[] ResizeImage(byte[] bytes, int width, int height)
        {
            if (bytes == null || bytes.Length == 0)
            {
                PrintError("Invalid image byte array.");
                return null;
            }

            if (width <= 0 || height <= 0)
            {
                PrintError("Width and height must be greater than zero.");
                return null;
            }

            MemoryStream originalStream = Pool.Get<MemoryStream>();
            originalStream.Write(bytes, 0, bytes.Length);

            MemoryStream resizedStream = Pool.Get<MemoryStream>();

            using (var originalImage = Image.FromStream(originalStream))
            using (var resizedImage = new Bitmap(width, height))
                try
                {
                    using (var graphics = Graphics.FromImage(resizedImage))
                    {
                        graphics.Clear(System.Drawing.Color.LightGray);
                        graphics.CompositingQuality = CompositingQuality.HighSpeed;
                        graphics.InterpolationMode = InterpolationMode.NearestNeighbor;
                        graphics.SmoothingMode = SmoothingMode.None;
                        graphics.PixelOffsetMode = PixelOffsetMode.HighSpeed;
                        graphics.DrawImage(originalImage, 0, 0, width, height);

                        if (_imageCodecInfo == null || _encoderParams == null)
                        {
                            resizedImage.Save(resizedStream, ImageFormat.Jpeg);
                        }
                        else
                        {
                            resizedImage.Save(resizedStream, _imageCodecInfo, _encoderParams);
                        }
                        return resizedStream.ToArray();
                    }
                }
                catch (Exception ex)
                {
                    PrintError("Error resizing image: " + ex.Message);
                    Pool.FreeUnmanaged(ref originalStream);
                    Pool.FreeUnmanaged(ref resizedStream);
                    return null;
                }
                finally
                {
                    Pool.FreeUnmanaged(ref originalStream);
                    Pool.FreeUnmanaged(ref resizedStream);
                }
        }

        private bool CheckImage(Result omniResult)
        {
            if (omniResult.categories.harassment && config.moderationAPI.harassment)
            {
                return true;
            }
            if (omniResult.categories.harassmentthreatening && config.moderationAPI.harassmentThreatening)
            {
                return true;
            }
            if (omniResult.categories.sexual && config.moderationAPI.sexual)
            {
                return true;
            }
            if (omniResult.categories.hate && config.moderationAPI.hate)
            {
                return true;
            }
            if (omniResult.categories.hatethreatening && config.moderationAPI.hateThreatening)
            {
                return true;
            }
            if (omniResult.categories.illicit && config.moderationAPI.illicit)
            {
                return true;
            }
            if (omniResult.categories.illicitviolent && config.moderationAPI.illicitViolent)
            {
                return true;
            }
            if (omniResult.categories.selfharmintent && config.moderationAPI.selfHarmIntent)
            {
                return true;
            }
            if (omniResult.categories.selfharminstructions && config.moderationAPI.selfHarmInstructions)
            {
                return true;
            }
            if (omniResult.categories.selfharm && config.moderationAPI.selfHarm)
            {
                return true;
            }
            if (omniResult.categories.sexualminors && config.moderationAPI.sexualMinors)
            {
                return true;
            }
            if (omniResult.categories.violence && config.moderationAPI.violence)
            {
                return true;
            }
            if (omniResult.categories.violencegraphic && config.moderationAPI.violenceGraphic)
            {
                return true;
            }
            return false;
        }
        #endregion Methods

        #region Set Up Loading Image

        private uint _tempModerationImageCRC;
        private string _tempModerationImageURL = "https://i.postimg.cc/Zq5qfgtk/10x10-00000000.png";
        private static IEnumerator GetLoadingImage = null;
        private IEnumerator LoadingImageSetup()
        {
            UnityWebRequest www = UnityWebRequest.Get(_tempModerationImageURL);
            www.timeout = 30;
            yield return www.SendWebRequest();

            if (www.result != UnityWebRequest.Result.Success)
            {
                PrintError(www.error + " Cannot get image from:" + _tempModerationImageURL);
                www.Dispose();
                yield break;
            }
            Texture2D texture = new Texture2D(2, 2);
            texture.LoadImage(www.downloadHandler.data);
            if (texture != null)
            {
                byte[] bytes = texture.EncodeToPNG();
                if (bytes.Length > ConVar.Server.maxpacketsize_command)
                {
                    float percentage = Mathf.Sqrt(((float)ConVar.Server.maxpacketsize_command / (float)texture.GetSizeInBytes()));
                    bytes = ResizeImage(bytes, (int)(texture.width * percentage), (int)(texture.height * percentage));
                }
                UnityEngine.Object.DestroyImmediate(texture);
                if (bytes != null)
                {
                    _tempModerationImageCRC = FileStorage.server.Store(bytes, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID);
                }
            }
            www.Dispose();
            GetLoadingImage = null;
        }
        #endregion Set Up Loading Image

        #region Discord Logging
        private IEnumerator LogToDiscord(SignData signData, BasePlayer player, string model, byte[] imageBytes)
        {
            var msg = CreateDiscordMessage(player.displayName, player.UserIDString, signData.sign.ShortPrefabName, signData.sign.transform.position, model, signData.crc);
            List<IMultipartFormSection> formData = new List<IMultipartFormSection>
            {
                new MultipartFormDataSection("payload_json", JsonConvert.SerializeObject(msg))
            };

            if (config.discordSettings.discordImageLogging)
                formData.Add(new MultipartFormFileSection("file1", imageBytes, $"{signData.crc}.png", "image/png"));

            UnityWebRequest wwwpost = UnityWebRequest.Post(config.discordSettings.DiscordWebhook, formData);
            yield return wwwpost.SendWebRequest();
            if (wwwpost.result != UnityWebRequest.Result.Success)
            {
                PrintError("Cannot post log to discord:" + wwwpost.error);
                wwwpost.Dispose();
                yield break;
            }
            wwwpost.Dispose();
        }

        private DiscordMessage CreateDiscordMessage(string playername, string userid, string itemname, Vector3 location, string model, uint crc)
        {
            string steamprofile = "https://steamcommunity.com/profiles/" + userid;
            var fields = new List<DiscordMessage.Fields>()
            {
                new DiscordMessage.Fields("Player: " + playername, $"[{userid}]({steamprofile})", true),
                new DiscordMessage.Fields("Entity", itemname, true),
                new DiscordMessage.Fields("AI Model", model, false),
                new DiscordMessage.Fields("Teleport position", $"```teleportpos {location}```", false)
            };

            var footer = new DiscordMessage.Footer($"Logged @{DateTime.UtcNow:dd/MM/yy HH:mm:ss}");

            DiscordMessage.Image image = new DiscordMessage.Image($"attachment://{crc}.png");

            var embeds = new List<DiscordMessage.Embeds>()
            {
                new DiscordMessage.Embeds("Server - " + (string.IsNullOrEmpty(config.discordSettings.ServerName) ? server.Name : config.discordSettings.ServerName), "A sign has been moderated" , fields, footer, image)
            };
            DiscordMessage msg = new DiscordMessage(config.discordSettings.DiscordUsername, config.discordSettings.AvatarUrl, embeds);
            return msg;
        }

        #region Discord Class
        public class DiscordMessage
        {
            public string username { get; set; }
            public string avatar_url { get; set; }
            public List<Embeds> embeds { get; set; }

            public class Fields
            {
                public string name { get; set; }
                public string value { get; set; }
                public bool inline { get; set; }
                public Fields(string name, string value, bool inline)
                {
                    this.name = name;
                    this.value = value;
                    this.inline = inline;
                }
            }

            public class Footer
            {
                public string text { get; set; }
                public Footer(string text)
                {
                    this.text = text;
                }
            }

            public class Image
            {
                public string url { get; set; }
                public Image(string url)
                {
                    this.url = url;
                }
            }

            public class Embeds
            {
                public string title { get; set; }
                public string description { get; set; }
                public Image image { get; set; }
                public List<Fields> fields { get; set; }
                public Footer footer { get; set; }
                public Embeds(string title, string description, List<Fields> fields, Footer footer, Image image)
                {
                    this.title = title;
                    this.description = description;
                    this.image = image;
                    this.fields = fields;
                    this.footer = footer;
                }
            }

            public DiscordMessage(string username, string avatar_url, List<Embeds> embeds)
            {
                this.username = username;
                this.avatar_url = avatar_url;
                this.embeds = embeds;
            }
        }

        #endregion
        #endregion Discord Logging

        #region Helpers
        private bool HasPerm(string id, string perm) => permission.UserHasPermission(id, perm);
        private string GetLang(string langKey, string playerId = null, params object[] args) => string.Format(lang.GetMessage(langKey, this, playerId), args);
        private void ChatMessage(IPlayer player, string langKey, params object[] args)
        {
            if (player.IsConnected) player.Message(GetLang(langKey, player.Id, args));
        }
        private byte[] GetImageBytes(SignData signData)
        {
            byte[] array = FileStorage.server.Get(signData.crc, signData.type, signData.sign.NetworkID);

            if (array == null)
            {
                //Puts($"Cannot get image from sign crc:{signData.sign.GetContentCRCs[signData.textureIndex]} netID:{signData.sign.NetworkID} entity:{signData.sign.ShortPrefabName}");
                return System.Array.Empty<byte>();
            }

            if (_ImageSizeperAsset.TryGetValue(signData.sign.prefabID, out ImageSize imageSize))
            {
                float sizeReduction = (config.imageSizeReduction) / 100;
                array = ResizeImage(array, (int)(imageSize.Width * sizeReduction), (int)(imageSize.Height * sizeReduction));
                if (array == null)
                {
                    //Puts($"Cannot get image from sign crc:{signData.sign.GetContentCRCs[signData.textureIndex]} netID:{signData.sign.NetworkID} entity:{signData.sign.ShortPrefabName}");
                    return System.Array.Empty<byte>();
                }
            }

            return array;
        }

        #endregion Helpers
    }
}

// --- End of file: AutoSignModeration.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/agriblock ---
// --- Original File Path: A/Agriblock/Agriblock.cs ---

using UnityEngine;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Agriblock", "Death", "1.0.8")]
    [Description("Forces configured plant types to only be planted in planters")]
    class Agriblock : RustPlugin
    {
        #region Hooks
        private void OnEntityBuilt(Planner plan, GameObject seed)
        {
            var player = plan.GetOwnerPlayer();
            var isSeed = seed.GetComponent<GrowableEntity>();

            if (player == null)
            {
                return;
            }

            if (isSeed != null)
            {
                var held = player.GetActiveItem();

                NextTick(() =>
                {
                    if (isSeed.GetParentEntity() == null || !(isSeed.GetParentEntity() is PlanterBox))
                    {
                        if (held == null)
                        {
                            return;
                        }

                        if (!configData.Types.CornEnabled && held.info.shortname.Equals("seed.corn"))
                        {
                            return;
                        }

                        if (!configData.Types.CornCloneEnabled && held.info.shortname.Equals("clone.corn"))
                        {
                            return;
                        }

                        if (!configData.Types.PumpkinEnabled && held.info.shortname.Equals("seed.pumpkin"))
                        {
                            return;
                        }

                        if (!configData.Types.PumpkinCloneEnabled && held.info.shortname.Equals("clone.pumpkin"))
                        {
                            return;
                        }

                        if (!configData.Types.HempEnabled && held.info.shortname.Equals("seed.hemp"))
                        {
                            return;
                        }

                        if (!configData.Types.HempCloneEnabled && held.info.shortname.Equals("clone.hemp"))
                        {
                            return;
                        }

                        SendReply(player, lang.GetMessage("errmsg", this, player.UserIDString).Replace("{seed}", held.info.displayName.english));
                        isSeed.Kill(BaseNetworkable.DestroyMode.None);

                        if (!configData.Options.Refund || held == null)
                        {
                            return;
                        }

                        var refund = ItemManager.CreateByName(held.info.shortname, 1);

                        if (refund != null)
                        {
                            player.inventory.GiveItem(refund);
                        }
                    }
                });
            }
        }
        #endregion

        #region Config
        void Init()
        {
            LoadConfigVariables();
        }

        private ConfigData configData;

        class ConfigData
        {
            public Options Options = new Options();
            public Types Types = new Types();
        }

        class Options
        {
            public bool Refund = true;
        }

        class Types
        {
            public bool CornEnabled = true;
            public bool CornCloneEnabled = true;
            public bool PumpkinEnabled = true;
            public bool PumpkinCloneEnabled = true;
            public bool HempEnabled = true;
            public bool HempCloneEnabled = true;
        }

        private void LoadConfigVariables()
        {
            configData = Config.ReadObject<ConfigData>();
            SaveConfig(configData);
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData();

            SaveConfig(config);
        }

        void SaveConfig(ConfigData config)
        {
            Config.WriteObject(config, true);
        }
        #endregion

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                {"errmsg", "You may not plant {seed} outside of a planter!" }
            }, this, "en");
        }

        private string msg(string key, string id = null)
        {
            return lang.GetMessage(key, this, id);
        }
        #endregion
    }
}

// --- End of file: Agriblock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/absolut-gifts ---
// --- Original File Path: A/AbsolutGifts/AbsolutGifts.cs ---

// Requires: ImageLibrary

using System.Collections.Generic;
using System;
using System.Linq;
using UnityEngine;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using Oxide.Core;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Absolut Gifts", "Absolut", "1.5.2")]
    [Description("Daily gift reward system")]
    class AbsolutGifts : RustPlugin
    {
        [PluginReference]
        Plugin ImageLibrary, ServerRewards, Economics, AbsolutCombat;

        GiftData agdata;
        private DynamicConfigFile AGData;

        bool initialized;
        int GlobalTime = 0;

        string TitleColor = "<color=orange>";
        string MsgColor = "<color=#A9A9A9>";

        int max;

        private Dictionary<int, float[]> GiftPositions = new Dictionary<int, float[]>();
        private Dictionary<string, Timer> timers = new Dictionary<string, Timer>();
        private Dictionary<ulong, GiftCreation> giftprep = new Dictionary<ulong, GiftCreation>();
        private Dictionary<ulong, Vector3> AFK = new Dictionary<ulong, Vector3>();
        private Dictionary<ulong, Info> UIinfo = new Dictionary<ulong, Info>();
        class Info
        {
            public bool open;
            public int page;
            public bool admin;
            public ItemCategory cat = ItemCategory.All;
        }

        #region Server Hooks

        void Loaded()
        {
            AGData = Interface.Oxide.DataFileSystem.GetFile("AbsolutGifts_Data");
            lang.RegisterMessages(messages, this);
        }

        void Unload()
        {
            foreach (var entry in timers)
                entry.Value.Destroy();
            timers.Clear();
            foreach (BasePlayer p in BasePlayer.activePlayerList)
            {
                DestroyPlayer(p);
            }
            if (initialized)
                SaveData();
        }

        void OnServerInitialized()
        {
            initialized = false;
            LoadVariables();
            LoadData();
            LoadImages();
            permission.RegisterPermission(this.Name + ".vip", this);
            permission.RegisterPermission(this.Name + ".admin", this);
            timers.Add("info", timer.Once(900, () => InfoLoop()));
            timers.Add("save", timer.Once(600, () => SaveLoop()));
            SaveData();
            SetGiftPositions();
            timer.Once(5, () =>
            {
                foreach (BasePlayer p in BasePlayer.activePlayerList)
                    OnPlayerConnected(p);
            });
            timers.Add("time", timer.Once(60, () => ChangeGlobalTime()));
        }

        void LoadImages()
        {
            if (!ImageLibrary) return;
            if (timers.ContainsKey("imageloading"))
            {
                timers["imageloading"].Destroy();
                timers.Remove("imageloading");
            }
            if (!isReady())
            { Puts(GetMSG("WaitingImageLibrary")); timers.Add("imageloading", timer.Once(60, () => LoadImages())); return; };
            if (string.IsNullOrEmpty(configData.GiftIconImage))
                AddImage("http://i.imgur.com/zMe9ky5.png", "newgift", (ulong)ResourceId);
            else AddImage(configData.GiftIconImage, "newgift", (ulong)ResourceId);
            CreateLoadOrder();
            LoadAllItemImages();
            if (timers.ContainsKey("imageloading"))
            {
                timers["imageloading"].Destroy();
                timers.Remove("imageloading");
            }
        }

        private void LoadAllItemImages()
        {
            ImageLibrary.Call("LoadImageList", Title, ItemManager.itemList.Select(x => new KeyValuePair<string, ulong>(x.shortname, 0)).ToList());
        }

        private void CreateLoadOrder()
        {
            Dictionary<string, string> newLoadOrder = new Dictionary<string, string>
            {
            {      "sr", "http://oxidemod.org/data/resource_icons/1/1751.jpg?1456924271" },
            {      "eco", "http://oxidemod.org/data/resource_icons/0/717.jpg?1465675504" },
            {      "ac", "http://oxidemod.org/data/resource_icons/2/2103.jpg?1472590458" },
            };
            ImageLibrary.Call("ImportImageList", Title, newLoadOrder, (ulong)ResourceId, true);
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            DestroyPlayer(player);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player != null)
            {
                GetSendMSG(player, "AGInfo");
                InitializePlayer(player);
            }
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            NewGiftIcon(player);
        }

        private void InitializePlayer(BasePlayer player)
        {
            if (!UIinfo.ContainsKey(player.userID))
                UIinfo.Add(player.userID, new Info { page = 0 });
            if (!agdata.Players.ContainsKey(player.userID))
            {
                agdata.Players.Add(player.userID, new playerdata { PlayerTime = 0, ReceivedGifts = new List<int>(), ResetTime = GrabCurrentTime() + (configData.ResetInDays * 86400) });
            }
            else
            {
                //Puts($"CurrentTime: {GrabCurrentTime()}");
                if (GrabCurrentTime() >= agdata.Players[player.userID].ResetTime)
                {
                    //Puts("Time is Greater");
                    agdata.Players[player.userID].ReceivedGifts.Clear();
                    agdata.Players[player.userID].pendingGift.Clear();
                    agdata.Players[player.userID].PlayerTime = 0;
                    agdata.Players[player.userID].ResetTime = GrabCurrentTime() + (configData.ResetInDays * 86400);
                    if (UIinfo[player.userID].open)
                        GiftPanel(player);
                    SaveData();
                }
            }
            double timeremaining = agdata.Players[player.userID].ResetTime - GrabCurrentTime();
            if (timers.ContainsKey(player.UserIDString))
            {
                timers[player.UserIDString].Destroy();
                timers.Remove(player.UserIDString);
            }
            timers.Add(player.UserIDString, timer.Once((float)timeremaining, () => InitializePlayer(player)));
            NewGiftIcon(player);
        }

        private void DestroyPlayer(BasePlayer player)
        {
            if (!agdata.Players.ContainsKey(player.userID))
                agdata.Players.Add(player.userID, new playerdata { PlayerTime = 0, ReceivedGifts = new List<int>() });
            if (timers.ContainsKey(player.UserIDString))
            {
                timers[player.UserIDString].Destroy();
                timers.Remove(player.UserIDString);
            }
            DestroyGiftPanel(player, true);
            CuiHelper.DestroyUi(player, PanelIcon);
            CuiHelper.DestroyUi(player, PanelOnScreen);
        }

        static double GrabCurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;

        #endregion

        #region Player Hooks

        #endregion

        #region Functions
        private string TryForImage(string shortname, ulong skin = 99)
        {
            if (!ImageLibrary) return "https://i.imgur.com/yxESUQJ.png";
            if (shortname.Contains("http") || shortname.Contains("www")) return shortname;
            if (skin == 99) skin = (ulong)ResourceId;
            return GetImage(shortname, skin, true);
        }

        public string GetImage(string shortname, ulong skin = 0, bool returnUrl = false) => (string)ImageLibrary.Call("GetImage", shortname.ToLower(), skin, returnUrl);
        public bool HasImage(string shortname, ulong skin = 0) => (bool)ImageLibrary.Call("HasImage", shortname.ToLower(), skin);
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname.ToLower(), skin);
        public List<ulong> GetImageList(string shortname) => (List<ulong>)ImageLibrary.Call("GetImageList", shortname.ToLower());
        public bool isReady() => (bool)ImageLibrary?.Call("IsReady");

        private void CancelGiftCreation(BasePlayer player)
        {
            DestroyGiftPanel(player, false);
            if (giftprep.ContainsKey(player.userID))
                giftprep.Remove(player.userID);
            GetSendMSG(player, "GiftCreationCanceled");
            UIinfo[player.userID].page = 0;
            Background(player);
        }

        public void DestroyGiftPanel(BasePlayer player, bool background)
        {
            if (UIinfo.ContainsKey(player.userID))
            {
                UIinfo[player.userID].open = false;
                UIinfo[player.userID].page = 0;
            }
            if (background) CuiHelper.DestroyUi(player, PanelStatic);
            CuiHelper.DestroyUi(player, PanelGift);
            CuiHelper.DestroyUi(player, PanelTime);
            for (int i = 0; i < max; i++)
                CuiHelper.DestroyUi(player, "GiftEntry" + i);
        }

        void ChangeGlobalTime()
        {
            if (timers.ContainsKey("time"))
            {
                timers["time"].Destroy();
                timers.Remove("time");
            }
            GlobalTime++;
            timers.Add("time", timer.Once(60, () => ChangeGlobalTime()));       
            CheckPlayers();
        }

        private void CheckPlayers()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
                if (agdata.Players.ContainsKey(player.userID))
                {
                    if (configData.NoAFK)
                        if (CheckAFK(player)) continue;
                    agdata.Players[player.userID].PlayerTime++;
                    int giftIndex = 0;
                    if (permission.UserHasPermission(player.UserIDString, this.Title + ".vip")) giftIndex = agdata.Gifts.Where(k => !agdata.Players[player.userID].ReceivedGifts.Contains(k.Key)).OrderBy(k => k.Key).Select(k => k.Key).FirstOrDefault();
                    else giftIndex = agdata.Gifts.Where(k => !k.Value.vip && !agdata.Players[player.userID].ReceivedGifts.Contains(k.Key)).OrderBy(k => k.Key).Select(k => k.Key).FirstOrDefault();
                    if (giftIndex != 0 && giftIndex <= agdata.Players[player.userID].PlayerTime)
                    {
                        OnScreen(player, "CompletedNewGift", giftIndex.ToString());
                        ProcessGift(player, giftIndex);
                    }
                    if (UIinfo[player.userID].open)
                        PlayerTimeCounter(player);
                }
                else InitializePlayer(player);
        }

        bool CheckAFK(BasePlayer player)
        {
            if (player == null) return false;
            if (!AFK.ContainsKey(player.userID))
            {
                AFK.Add(player.userID, player.transform.position);
                //Puts("Not in Dictionary");
                return false;
            }
            else if (AFK[player.userID] == player.transform.position)
            {
                //Puts("Same Position - AFK");
                return true;
            }
            else if (AFK[player.userID] != player.transform.position)
            {
                AFK[player.userID] = player.transform.position;
                //Puts("New Position - Not AFK");
            }
            return false;
        }

        private void ProcessGift(BasePlayer player, int GiftIndex)
        {
            if (!agdata.Gifts.ContainsKey(GiftIndex)) return;
            var Gift = agdata.Gifts[GiftIndex];
            if (Gift.gifts.Where(k => !k.AC && !k.SR && !k.Eco).Count() == 0)
                foreach (var entry in Gift.gifts)
                {
                    if (entry.SR)
                    {
                        ServerRewards?.Call("AddPoints", player.userID.ToString(), entry.amount);
                        GetSendMSG(player, "NewGiftGiven", entry.amount.ToString(), "ServerRewards Points");
                    }
                    else if (entry.Eco)
                    {
                        Economics.Call("DepositS", player.userID.ToString(), entry.amount);
                        GetSendMSG(player, "NewGiftGiven", entry.amount.ToString(), "Economics");
                    }
                    else if (entry.AC)
                    {
                        AbsolutCombat.Call("AddMoney", player.userID.ToString(), entry.amount, false);
                        GetSendMSG(player, "NewGiftGiven", entry.amount.ToString(), "AbsolutCombat Money");
                    }
                }
            else
            {
                agdata.Players[player.userID].pendingGift.Add(GiftIndex, Gift);
                NewGiftIcon(player);
            }
            agdata.Players[player.userID].ReceivedGifts.Add(GiftIndex);
        }

        private void CreateNumberPadButton(ref CuiElementContainer container, string panelName, int i, int number, string command)
        {
            var pos = CalcNumButtonPos(i);
            UI.CreateButton(ref container, panelName, UIColors["buttonbg"], number.ToString(), 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"{command} {number}");
        }

        private void GetSendMSG(BasePlayer player, string message, string arg1 = "", string arg2 = "", string arg3 = "", string arg4 = "")
        {
            string msg = string.Format(lang.GetMessage(message, this, player.UserIDString), arg1, arg2, arg3, arg4);
            SendReply(player, TitleColor + lang.GetMessage("title", this, player.UserIDString) + "</color>" + MsgColor + msg + "</color>");
        }

        private string GetMSG(string message, BasePlayer player = null, string arg1 = "", string arg2 = "", string arg3 = "", string arg4 = "")
        {
            string p = null;
            if (player != null)
                p = player.UserIDString;
            if (messages.ContainsKey(message))
                return string.Format(lang.GetMessage(message, this, p), arg1, arg2, arg3, arg4);
            else return message;
        }

        bool isAuth(BasePlayer player)
        {
            if (player.net.connection != null)
                if (player.net.connection.authLevel < 2 && !permission.UserHasPermission(player.UserIDString, this.Title + ".admin"))
                    return false;
            return true;
        }

        #endregion

        #region UI Creation

        private string PanelStatic = "PanelStatic";     
        private string PanelGift = "PanelGift";
        private string PanelIcon = "PanelIcon";
        private string PanelOnScreen = "PanelOnScreen";
        private string PanelTime = "PanelTime";

        public class UI
        {
            static public CuiElementContainer CreateOverlayContainer(string panelName, string color, string aMin, string aMax, bool cursor = false)
            {
                var NewElement = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = color},
                        RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                        CursorEnabled = cursor
                    },
                    new CuiElement().Parent = "Overlay",
                    panelName
                }
            };
                return NewElement;
            }
            static public void CreatePanel(ref CuiElementContainer element, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                element.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }
            static public void CreateLabel(ref CuiElementContainer element, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                element.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = 1.0f, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);
            }

            static public void CreateButton(ref CuiElementContainer element, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                element.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 1.0f },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }
            static public void LoadImage(ref CuiElementContainer container, string panel, string img, string aMin, string aMax)
            {
                if (img.StartsWith("http") || img.StartsWith("www"))
                {
                    container.Add(new CuiElement
                    {
                        Parent = panel,
                        Components =
                    {
                        new CuiRawImageComponent {Url = img, Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                    });
                }
                else
                    container.Add(new CuiElement
                    {
                        Parent = panel,
                        Components =
                    {
                        new CuiRawImageComponent {Png = img, Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                    });
            }

            static public void CreateTextOutline(ref CuiElementContainer element, string panel, string colorText, string colorOutline, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                element.Add(new CuiElement
                {
                    Parent = panel,
                    Components =
                    {
                        new CuiTextComponent{Color = colorText, FontSize = size, Align = align, Text = text },
                        new CuiOutlineComponent {Distance = "1 1", Color = colorOutline},
                        new CuiRectTransformComponent {AnchorMax = aMax, AnchorMin = aMin }
                    }
                });
            }
            static public void CreateTextOverlay(ref CuiElementContainer element, string panel, string text, string color, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 1.0f)
            {
                //if (configdata.DisableUI_AG_FadeIn)
                //    fadein = 0;
                element.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = fadein, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);

            }
        }

        private Dictionary<string, string> UIColors = new Dictionary<string, string>
        {
            {"black", "0 0 0 1.0" },
            {"dark", "0.1 0.1 0.1 0.98" },
            {"header", "1 1 1 0.3" },
            {"light", ".564 .564 .564 1.0" },
            {"grey1", "0.6 0.6 0.6 1.0" },
            {"brown", "0.3 0.16 0.0 1.0" },
            {"yellow", "0.9 0.9 0.0 1.0" },
            {"limegreen", "0.42 1.0 0 1.0" },
            {"blue", "0.2 0.6 1.0 1.0" },
            {"red", "1.0 0.1 0.1 1.0" },
            {"white", "1 1 1 1" },
            {"green", "0.28 0.82 0.28 1.0" },
            {"grey", "0.85 0.85 0.85 1.0" },
            {"lightblue", "0.6 0.86 1.0 1.0" },
            {"buttonbg", "0.2 0.2 0.2 0.7" },
            {"buttongreen", "0.133 0.965 0.133 0.9" },
            {"buttonred", "0.964 0.133 0.133 0.9" },
            {"buttongrey", "0.8 0.8 0.8 0.9" },
            {"orange", "1.0 0.64 0.10 1.0" }
        };

        private Dictionary<string, string> TextColors = new Dictionary<string, string>
        {
            {"limegreen", "<color=#6fff00>" }
        };

        #endregion

        #region UI Panels

        void Background(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelStatic);
            if (!UIinfo.ContainsKey(player.userID))
                UIinfo.Add(player.userID, new Info { page = 0 });
            UIinfo[player.userID].open = true;
            var element = UI.CreateOverlayContainer(PanelStatic, "0 0 0 0", "0.2 0.15", "0.8 0.85", true);
            CuiHelper.AddUi(player, element);
            GiftPanel(player);
        }

        void PlayerTimeCounter(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelTime);
            if (!UIinfo.ContainsKey(player.userID))
                UIinfo.Add(player.userID, new Info { page = 0 });
            var element = UI.CreateOverlayContainer(PanelTime, "0 0 0 0", "0.2 0.85", "0.8 0.95");
            UI.CreateTextOutline(ref element, PanelTime, UIColors["white"], UIColors["black"], GetMSG("AccumulatedTime",player, agdata.Players[player.userID].PlayerTime.ToString()), 30, $"0 0", $"1 1", TextAnchor.MiddleCenter);
            CuiHelper.AddUi(player, element);
        }       

        void GiftPanel(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelGift);
            var element = UI.CreateOverlayContainer(PanelGift, "0.1 0.1 0.1 0.8", "0.2 0.15", "0.8 0.85");
            //UI.CreatePanel(ref element, PanelGift, UIColors["dark"], "0. 0", "1 1");
            var i = 0;
            var page = UIinfo[player.userID].page;
            double count = agdata.Gifts.Count();
            //Puts(count.ToString());
            int entriesallowed = max;
            double remainingentries = count - (page * entriesallowed);
            double totalpages = (Math.Floor(count / entriesallowed));
            if (remainingentries > entriesallowed)
            {
                UI.CreateButton(ref element, PanelGift, UIColors["header"], GetMSG("Next", player), 16, "0.76 0.02", "0.86 0.075", $"UI_AG_GiftMenu {page + 1}");
            }
            if (page > 0)
            {
                UI.CreateButton(ref element, PanelGift, UIColors["header"], GetMSG("Back", player), 16, "0.65 0.02", "0.75 0.075", $"UI_AG_GiftMenu {page - 1}");
            }
            if (isAuth(player))
            {
                UI.CreateButton(ref element, PanelGift, UIColors["header"], GetMSG("ToggleAdmin", player), 12, "0.03 0.02", "0.13 0.075", $"UI_AG_ToggleAdmin");
                if (UIinfo[player.userID].admin)
                    UI.CreateButton(ref element, PanelGift, UIColors["orange"], GetMSG("CreateGift", player), 12, "0.16 0.02", "0.26 0.075", $"UI_AG_CreateGifts");
            }
            UI.CreateButton(ref element, PanelGift, UIColors["buttonred"], GetMSG("Close", player), 16, "0.87 0.02", "0.97 0.075", $"UI_AG_DestroyGiftPanel");
            CuiHelper.AddUi(player, element);
            int n = 0;
            int shownentries = page * entriesallowed;
            List<int> completed = new List<int>();
            if (agdata.Players.ContainsKey(player.userID))
                foreach (var entry in agdata.Players[player.userID].ReceivedGifts)
                    completed.Add(entry);
            foreach (var entry in agdata.Gifts.OrderBy(kvp => kvp.Key))
            {
                i++;
                if (i < shownentries + 1) continue;
                if (i <= shownentries + entriesallowed)
                {
                    CreateGiftMenuEntry(player, entry.Key, n);
                    n++;
                }
                if (n >= entriesallowed) break;
            }
            PlayerTimeCounter(player);
        }

        private void CreateGifts(BasePlayer player, int step = 0)
        {
            var i = 0;
            CuiElementContainer element = UI.CreateOverlayContainer(PanelGift, "0.1 0.1 0.1 0.8", "0.3 0.3", "0.7 0.9");
            switch (step)
            {
                case 0:
                    CuiHelper.DestroyUi(player, PanelGift);
                    if (giftprep.ContainsKey(player.userID))
                        giftprep.Remove(player.userID);
                    giftprep.Add(player.userID, new GiftCreation());
                    //UI.CreateLabel(ref element, PanelGift, UIColors["black"], $"{TextColors["limegreen"]} {GetMSG("SelectGiftTimer")}", 20, "0.05 0", ".95 1", TextAnchor.MiddleCenter);
                    NumberPad(player, "UI_AG_SelectTime", "SelectTime");
                    return;
                case 1:
                    CuiHelper.DestroyUi(player, PanelGift);
                    element = UI.CreateOverlayContainer(PanelGift, "0.1 0.1 0.1 0.8", "0.4 0.3", "0.6 0.6");
                    UI.CreateLabel(ref element, PanelGift, UIColors["limegreen"], GetMSG("VIPGift", player, giftprep[player.userID].time.ToString()), 20, "0.05 .4", ".95 .95");
                    UI.CreateButton(ref element, PanelGift, UIColors["buttonbg"], GetMSG("Yes", player), 18, "0.2 0.05", "0.4 0.25", $"UI_AG_VIP true", TextAnchor.MiddleCenter);
                    UI.CreateButton(ref element, PanelGift, UIColors["buttonred"], GetMSG("No", player), 18, "0.6 0.05", "0.8 0.25", $"UI_AG_VIP false");
                    break;
                case 2:
                    CuiHelper.DestroyUi(player, PanelGift);
                    var cat = UIinfo[player.userID].cat;
                    float[] pos;
                    UI.CreatePanel(ref element, PanelGift, "0 0 0 0", $".0001 0.0001", $"0.0002 0.0002");
                    UI.CreateLabel(ref element, PanelGift, UIColors["limegreen"], GetMSG("SelectGift", player, giftprep[player.userID].time.ToString()), 20, "0.05 .95", ".95 1", TextAnchor.MiddleCenter);
                    foreach (var entry in Enum.GetValues(typeof(ItemCategory)).Cast<ItemCategory>().ToList().OrderBy(k=> k == ItemCategory.All).ThenBy(k=>k.ToString().First()))
                    {
                        if (entry == ItemCategory.Search || entry == ItemCategory.Common) continue;
                        pos = FilterButton(i);
                        if(cat == entry)
                            UI.CreateButton(ref element, PanelGift, UIColors["yellow"], entry.ToString(), 10, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_AG_ChangeCat {entry.ToString()}");
                        else UI.CreateButton(ref element, PanelGift, UIColors["black"], entry.ToString(), 10, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_AG_ChangeCat {entry.ToString()}");
                        i++;
                    }
                    var itemList = ItemManager.itemList.Where(k => cat != ItemCategory.All ? k.category == cat : k.category != ItemCategory.All).Select(k => k).ToList();
                    double count = itemList.Count();
                    var page = UIinfo[player.userID].page;
                    double entriesallowed = 30;
                    double remainingentries = count - (page * (entriesallowed));
                    double totalpages = (Math.Floor(count / (entriesallowed))) - 1;
                    {
                        if (remainingentries > entriesallowed)
                        {
                            UI.CreateButton(ref element, PanelGift, UIColors["header"], GetMSG("Next", player), 16, "0.85 0.02", "0.95 0.075", $"UI_AG_CreateGifts {2} {page + 1}");
                        }
                        if (page > 0)
                        {
                            UI.CreateButton(ref element, PanelGift, UIColors["header"], GetMSG("Back", player), 16, "0.74 0.02", "0.84 0.075", $"UI_AG_CreateGifts {2} {page - 1}");
                        }
                    }
                    i = 0;
                    int n = 0;
                    pos = CalcButtonPos(n);
                    double shownentries = page * entriesallowed;
                    if (page == 0 && (cat == ItemCategory.All || cat == ItemCategory.Search || cat == ItemCategory.Common))
                    {
                        if (ServerRewards)
                        {
                            UI.LoadImage(ref element, PanelGift, TryForImage("SR"), $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                            UI.CreateButton(ref element, PanelGift, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_AG_SelectGift SR");
                            n++;
                            i++;
                        }
                        if (Economics)
                        {
                            pos = CalcButtonPos(n);
                            UI.LoadImage(ref element, PanelGift, TryForImage("ECO"), $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                            UI.CreateButton(ref element, PanelGift, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_AG_SelectGift ECO");
                            n++;
                            i++;
                        }
                        if (AbsolutCombat)
                        {
                            pos = CalcButtonPos(n);
                            UI.LoadImage(ref element, PanelGift, TryForImage("AC"), $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                            UI.CreateButton(ref element, PanelGift, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_AG_SelectGift AC");
                            n++;
                            i++;
                        }
                        //if (configData.UseGatherIncrease)
                        //{
                        //    pos = CalcButtonPos(n);
                        //    UI.LoadImage(ref element, PanelGift, TryForImage("GATHER"), $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                        //    UI.CreateButton(ref element, PanelGift, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_AG_SelectGift GATHER");
                        //    n++;
                        //    i++;
                        //}
                    }
                    foreach (var item in itemList.OrderBy(k=>k.displayName.english))
                    {
                        i++;
                        if (i < shownentries + 1) continue;
                        else if (i <= shownentries + entriesallowed)
                        {
                            pos = CalcButtonPos(n);
                            UI.CreatePanel(ref element, PanelGift, UIColors["header"], $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                            UI.LoadImage(ref element, PanelGift, TryForImage(item.shortname, 0), $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                            //UI.CreateLabel(ref element, PanelGift, UIColors["limegreen"], item.shortname, 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", TextAnchor.MiddleCenter);
                            UI.CreateButton(ref element, PanelGift, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_AG_SelectGift {item.itemid}");
                            n++;
                        }
                    }
                    UI.CreateButton(ref element, PanelGift, UIColors["buttonred"], GetMSG("Close", player), 16, "0.03 0.02", "0.13 0.075", $"UI_AG_DestroyGiftPanel");
                    break;
                default:
                    CuiHelper.DestroyUi(player, PanelGift);
                    UI.CreatePanel(ref element, PanelGift, "0 0 0 0", $".0001 0.0001", $"0.0002 0.0002");
                    UI.CreateLabel(ref element, PanelGift, UIColors["limegreen"], GetMSG("NewGiftInfo", player, giftprep[player.userID].time.ToString()), 20, "0.05 .8", ".95 .95");
                    string GiftDetails = "";
                    var alt = "";
                    foreach (var entry in giftprep[player.userID].gifts)
                        if (entry.ID != 0)
                            GiftDetails += $"{GetMSG("GiftDetails", player, GetDisplayNameFromSN(entry.ID), entry.amount.ToString())}\n";
                        else
                        {
                            if (entry.AC) alt = "AbsolutCombat Money";
                            if (entry.Eco) alt = "Economics";
                            if (entry.SR) alt = "ServerRewards Points";
                            GiftDetails += $"{GetMSG("GiftDetails", player, alt, entry.amount.ToString())}\n";
                        }
                    UI.CreateLabel(ref element, PanelGift, UIColors["limegreen"], GiftDetails, 20, "0.1 0.16", "0.9 0.75", TextAnchor.MiddleLeft);
                    UI.CreateButton(ref element, PanelGift, UIColors["buttonbg"], GetMSG("FinalizeGift", player), 18, "0.2 0.05", "0.4 0.15", $"UI_AG_FinalizeGift", TextAnchor.MiddleCenter);
                    if (giftprep[player.userID].gifts.Count() < 9)
                        UI.CreateButton(ref element, PanelGift, UIColors["buttonbg"], GetMSG("AddToGift", player), 18, "0.401 0.05", "0.599 0.15", $"UI_AG_CreateGifts {2} {0}", TextAnchor.MiddleCenter);
                    UI.CreateButton(ref element, PanelGift, UIColors["buttonred"], GetMSG("Cancel", player), 18, "0.6 0.05", "0.8 0.15", $"UI_AG_CancelGiftCreation");
                    break;
            }
            CuiHelper.AddUi(player, element);
        }

        string GetDisplayNameFromSN(int id)
        {
            ItemDefinition def = ItemManager.FindItemDefinition(id);
            if (def != null) return def.displayName.translated;
            else return id.ToString();
        }

        private void CreateGiftMenuEntry(BasePlayer player, int ID, int num)
        {
            var panelName = "GiftEntry" + num;
            CuiHelper.DestroyUi(player, "GiftEntry" + num);
            var pos = GiftPos(num);
            CuiElementContainer container = UI.CreateOverlayContainer(panelName, UIColors["header"], $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
            //UI.CreatePanel(ref container, panelName, UIColors["header"], $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
            if (agdata.Gifts[ID].vip)
            {
                if (configData.HideVIP && !permission.UserHasPermission(player.UserIDString, this.Title + ".vip")) return;
                UI.CreateLabel(ref container, panelName, UIColors["red"], "VIP", 30, $"0 0", $"1 1", TextAnchor.MiddleCenter);
            }
            var i = 0;
            float[] loc;
            foreach (var entry in agdata.Gifts[ID].gifts)
            {
                var item = ItemManager.CreateByItemID(entry.ID);
                {
                    loc = giftentrypos(i);
                    UI.CreatePanel(ref container, panelName, UIColors["buttonbg"], $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}");
                    if (item != null)
                        UI.LoadImage(ref container, panelName, TryForImage(item.info.shortname, entry.Skin), $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}");
                    else if (entry.Eco)
                        UI.LoadImage(ref container, panelName, TryForImage("ECO"), $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}");
                    else if (entry.SR)
                        UI.LoadImage(ref container, panelName, TryForImage("SR"), $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}");
                    else if (entry.AC)
                        UI.LoadImage(ref container, panelName, TryForImage("AC"), $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}");
                    UI.CreateLabel(ref container, panelName, UIColors["limegreen"], entry.amount.ToString(), configData.UITextSize, $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}", TextAnchor.LowerCenter);
                    i++;
                }
            }
            loc = giftentrypos(9);
            if (isAuth(player) && UIinfo[player.userID].admin)
            {
                UI.CreateTextOutline(ref container, panelName, UIColors["white"], UIColors["black"], GetMSG("GiftTitle", player, ID.ToString()), configData.UITextSize, "0 0", "1 1", TextAnchor.UpperCenter);
                UI.CreateButton(ref container, panelName, UIColors["buttonred"], GetMSG("Delete", player), (int)(configData.UITextSize * .8), $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}", $"UI_AG_RemoveGift {ID}");
            }
            else if (agdata.Players[player.userID].ReceivedGifts.Contains(ID))
            {
                UI.CreateTextOutline(ref container, panelName, UIColors["green"], UIColors["black"], GetMSG("GiftTitleCompleted", player, ID.ToString()), configData.UITextSize, "0 0", "1 1", TextAnchor.UpperCenter);
                if (agdata.Players[player.userID].pendingGift.ContainsKey(ID)) UI.CreateButton(ref container, panelName, UIColors["green"], GetMSG("Redeem", player), (int)(configData.UITextSize * .8), $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}", $"UI_AG_RedeemGift {ID}");
            }
            else
            {
                UI.CreateTextOutline(ref container, panelName, UIColors["white"], UIColors["black"], GetMSG("GiftTitle", player, ID.ToString()), configData.UITextSize, "0 0", "1 1", TextAnchor.UpperCenter);
            }
            CuiHelper.AddUi(player, container);
        }

        void NewGiftIcon(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelIcon);
            if (!agdata.Players.ContainsKey(player.userID) || agdata.Players[player.userID].pendingGift.Count() < 1) return;
            var element = UI.CreateOverlayContainer(PanelIcon, "0 0 0 0", $"{configData.minx} {configData.miny}", $"{configData.maxx} {configData.maxy}");
            UI.LoadImage(ref element, PanelIcon, TryForImage("NewGift"), "0 0", "1 1");
            UI.CreateButton(ref element, PanelIcon, "0 0 0 0", "", 12, "0 0", "1 1", "UI_AG_GiftMenu");
            CuiHelper.AddUi(player, element);
        }

        private void NumberPad(BasePlayer player, string cmd, string title)
        {
            CuiHelper.DestroyUi(player, PanelGift);
            var element = UI.CreateOverlayContainer(PanelGift, UIColors["dark"], "0.35 0.3", "0.65 0.7");
            UI.CreatePanel(ref element, PanelGift, UIColors["light"], "0.01 0.02", "0.99 0.98");
            UI.CreateLabel(ref element, PanelGift, UIColors["limegreen"], GetMSG(title, player), 16, "0.1 0.85", "0.9 .98", TextAnchor.UpperCenter);
            var n = 1;
            var i = 0;
            if (title == "SelectTime")
            {
                while (n < 20)
                {
                    CreateNumberPadButton(ref element, PanelGift, i, n, cmd); i++; n++;
                }
                while (n >= 20 && n < 60)
                {
                    CreateNumberPadButton(ref element, PanelGift, i, n, cmd); i++; n += 5;
                }
                while (n >= 60 && n < 240)
                {
                    CreateNumberPadButton(ref element, PanelGift, i, n, cmd); i++; n += 30;
                }
                while (n >= 240 && n <= 1470)
                {
                    CreateNumberPadButton(ref element, PanelGift, i, n, cmd); i++; n += 60;
                }
            }
            else if (title == "SelectAmount")
            {
                while (n < 10)
                {
                    CreateNumberPadButton(ref element, PanelGift, i, n, cmd); i++; n++;
                }
                while (n >= 10 && n < 25)
                {
                    CreateNumberPadButton(ref element, PanelGift, i, n, cmd); i++; n += 5;
                }
                while (n >= 25 && n < 200)
                {
                    CreateNumberPadButton(ref element, PanelGift, i, n, cmd); i++; n += 25;
                }
                while (n >= 200 && n <= 950)
                {
                    CreateNumberPadButton(ref element, PanelGift, i, n, cmd); i++; n += 50;
                }
                while (n >= 1000 && n <= 10000)
                {
                    CreateNumberPadButton(ref element, PanelGift, i, n, cmd); i++; n += 500;
                }
            }
            UI.CreateButton(ref element, PanelGift, UIColors["buttonred"], GetMSG("Quit", player), 10, "0.03 0.02", "0.13 0.075", $"UI_AG_CancelGiftCreation");
            CuiHelper.AddUi(player, element);
        }

        void OnScreen(BasePlayer player, string msg, string arg1 = "", string arg2 = "", string arg3 = "")
        {
            if (timers.ContainsKey("Onscreen_"+player.userID.ToString()))
            {
                timers["Onscreen_" + player.userID.ToString()].Destroy();
                timers.Remove("Onscreen_" + player.userID.ToString());
            }
            CuiHelper.DestroyUi(player, PanelOnScreen);
            var element = UI.CreateOverlayContainer(PanelOnScreen, "0.0 0.0 0.0 0.0", "0.15 0.8", "0.85 .9");
            UI.CreateTextOutline(ref element, PanelOnScreen, UIColors["white"], UIColors["black"], GetMSG(msg, player, arg1, arg2, arg3), 24, "0.0 0.0", "1.0 1.0");
            CuiHelper.AddUi(player, element);
            timers.Add("Onscreen_" + player.userID.ToString(), timer.Once(4, () => CuiHelper.DestroyUi(player, PanelOnScreen)));
        }


        #endregion

        #region UI Calculations

        void SetGiftPositions()
        {
            GiftPositions.Clear();
            int rows = 2;
            int columns = 2;
            if (max > 4)
            {
                if (max <= 6)
                    columns = 3;
                else if (max <= 8)
                    columns = 4;
                else if (max <= 10)
                    columns = 5;
                else if (max <= 12)
                    columns = 6;
            }
            //int rows = configData.GiftsPerPanel > 8 4;
            //if (max % rows > 0)
            //{
            //    if (max % 3 == 0) rows = 3;
            //    else if (max % 2 == 0) rows = 2;
            //    else max++;
            //}
            //Puts($"Number: {number}");
            //Puts($"Max: {max}");
            //int columns = max / rows;
            //Puts($"Columns: {columns} - Rows {rows}");
            //"0.2 0.15", "0.8 0.85"
            Vector2 position = new Vector2(0.205f, .848f);
            Vector2 dimensions = new Vector2();
            dimensions.x = (.6f - (.005f * rows)) / rows;
            dimensions.y = (.6f - (.01f * columns)) / columns;
            position.y = .848f - dimensions.y;
            float gap = (.6f - (dimensions.x * rows)) / (rows+1);
            position.x = .2f + gap;
            //position.x = (float)(1 - ((dimensions.x + .005f) * root));
            int testValue = 0;
            for (int i = 0; i < max; i++)
            {
                float offsetY = 0;
                float offsetX = 0;
                if (i%columns != 0)
                {
                    testValue = i;
                   // Puts($"Index: {i}: TestValue {testValue}");
                    while (testValue - columns > 0)
                    {
                        testValue -= columns;
                      //  Puts($">>Index: {i}: TestValue {testValue}");
                    }
                    offsetY = (-0.01f - dimensions.y) * testValue;
                }
                offsetX = (dimensions.x + gap) * (i < columns ? 0 : (int)Math.Floor((double)i / columns));
                Vector2 offset = new Vector2(offsetX, offsetY);
                Vector2 posMin = position + offset;
                Vector2 posMax = posMin + dimensions;
                GiftPositions.Add(i, new float[] { posMin.x, posMin.y, posMax.x, posMax.y });
            }
            //foreach (var entry in GiftPositions)
            //    Puts($"{entry.Key}: MinX{entry.Value[0]}, MaxX{entry.Value[2]}, MinY{entry.Value[1]}, MaxY{entry.Value[3]}");
        }

        private float[] GiftPos(int number)
        {
            return GiftPositions[number];
        }

        //private float[] GiftPos(int number)
        //{
        //    Vector2 position = new Vector2(0.03f, 0.525f);
        //    Vector2 dimensions = new Vector2(0.46f, 0.425f);
        //    float offsetY = 0;
        //    float offsetX = 0;
        //    if (number >= 0 && number < 2)
        //    {
        //        offsetY = (-0.01f - dimensions.y) * number;
        //    }
        //    if (number > 1 && number < 4)
        //    {
        //        offsetX = dimensions.x + 0.005f;
        //        offsetY = (-0.01f - dimensions.y) * (number - 2);
        //    }
        //    Vector2 offset = new Vector2(offsetX, offsetY);
        //    Vector2 posMin = position + offset;
        //    Vector2 posMax = posMin + dimensions;
        //    return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        //}

        private float[] FilterButton(int number)
        {
            Vector2 position = new Vector2(0.01f, 1.01f);
            Vector2 dimensions = new Vector2(0.1f, 0.04f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 10)
            {
            offsetX = (0.01f + dimensions.x) * number;
            }
            if (number >= 10 && number < 20)
            {
                offsetX = (0.01f + dimensions.x) * (number - 10);
                offsetY = (-0.005f - dimensions.y) * 1;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] BackgroundButton(int number)
        {
            Vector2 position = new Vector2(0.3f, 0.97f);
            Vector2 dimensions = new Vector2(0.035f, 0.03f);
            float offsetY = 0;
            float offsetX = 0;
            offsetX = (0.005f + dimensions.x) * number;
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        
        private float[] giftentrypos(int number)
        {
            Vector2 position = new Vector2(0.005f, 0.42f);
            Vector2 dimensions = new Vector2(0.19f, 0.35f);
            if (max > 4)
            {
                if (max <= 6)
                    dimensions.x = 0.15f;
                else if (max <= 8)
                {
                    dimensions.x = 0.12f;
                    dimensions.y = .38f;
                }
                else if (max <= 10)
                    dimensions.x = 0.1f;
                else if (max <= 12)
                    dimensions.x = 0.08f;
            }
            float gap = (1 - (dimensions.x *5)) / 6;
            position.x = gap;
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 5)
            {
                offsetX = (gap + dimensions.x) * number;
            }
            if (number > 4 && number < 10)
            {
                offsetX = (gap + dimensions.x) * (number - 5);
                offsetY = (-0.03f - dimensions.y) * 1;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }


        private float[] CalcButtonPos(int number)
        {
            Vector2 position = new Vector2(0.02f, 0.78f);
            Vector2 dimensions = new Vector2(0.15f, 0.15f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 6)
            {
                offsetX = (0.01f + dimensions.x) * number;
            }
            if (number > 5 && number < 12)
            {
                offsetX = (0.01f + dimensions.x) * (number - 6);
                offsetY = (-0.025f - dimensions.y) * 1;
            }
            if (number > 11 && number < 18)
            {
                offsetX = (0.01f + dimensions.x) * (number - 12);
                offsetY = (-0.025f - dimensions.y) * 2;
            }
            if (number > 17 && number < 24)
            {
                offsetX = (0.01f + dimensions.x) * (number - 18);
                offsetY = (-0.025f - dimensions.y) * 3;
            }
            if (number > 23 && number < 30)
            {
                offsetX = (0.01f + dimensions.x) * (number - 24);
                offsetY = (-0.025f - dimensions.y) * 4;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] CalcNumButtonPos(int number)
        {
            Vector2 position = new Vector2(0.05f, 0.75f);
            Vector2 dimensions = new Vector2(0.09f, 0.10f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 9)
            {
                offsetX = (0.01f + dimensions.x) * number;
            }
            if (number > 8 && number < 18)
            {
                offsetX = (0.01f + dimensions.x) * (number - 9);
                offsetY = (-0.02f - dimensions.y) * 1;
            }
            if (number > 17 && number < 27)
            {
                offsetX = (0.01f + dimensions.x) * (number - 18);
                offsetY = (-0.02f - dimensions.y) * 2;
            }
            if (number > 26 && number < 36)
            {
                offsetX = (0.01f + dimensions.x) * (number - 27);
                offsetY = (-0.02f - dimensions.y) * 3;
            }
            if (number > 35 && number < 45)
            {
                offsetX = (0.01f + dimensions.x) * (number - 36);
                offsetY = (-0.02f - dimensions.y) * 4;
            }
            if (number > 44 && number < 54)
            {
                offsetX = (0.01f + dimensions.x) * (number - 45);
                offsetY = (-0.02f - dimensions.y) * 5;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        #endregion

        #region UI Commands

        [ChatCommand("gift")]
        private void cmdgift(BasePlayer player, string command, string[] args)
        {
            Background(player);
            return;
        }

        [ChatCommand("max")]
        private void chatmax(BasePlayer player, string command, string[] args)
        {
            //if not absolut doesnt work... for testing only. To prevent people fucking stuff up.
            if (player.userID != 76561197977401750) return;
            max = Convert.ToInt32(args[0]);
            SetGiftPositions();
        }

        [ConsoleCommand("UI_AG_GiftMenu")]
        private void cmdUI_AG_GiftMenu(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            int page;
            if (arg.Args == null || arg.Args.Length == 0 || !int.TryParse(arg.Args[0], out page)) page = 0;
            if (!UIinfo.ContainsKey(player.userID))
                UIinfo.Add(player.userID, new Info { page = 0 });
            UIinfo[player.userID].page = page;
            for (int i = 0; i < max; i++)
                CuiHelper.DestroyUi(player, "GiftEntry" + i);
            GiftPanel(player);
        }     

        [ConsoleCommand("UI_AG_SelectTime")]
        private void cmdUI_AG_SelectTime(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            int time = Convert.ToInt32(arg.Args[0]);
            if (agdata.Gifts.ContainsKey(time))
                GetSendMSG(player, "TimeAlreadyExists", time.ToString());
            giftprep[player.userID].time = time;
            CreateGifts(player, 1);
        }

        [ConsoleCommand("UI_AG_VIP")]
        private void cmdUI_AG_VIP(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var answer = arg.Args[0];
            if (answer == "true")
                giftprep[player.userID].vip = true;
            else giftprep[player.userID].vip = false;
            UIinfo[player.userID].page = 0;
            CreateGifts(player, 2);
        }
   
        [ConsoleCommand("UI_AG_ToggleAdmin")]
        private void cmdUI_AG_ToggleAdmin(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null || !isAuth(player)) return;
            if (UIinfo[player.userID].admin)
                UIinfo[player.userID].admin = false;
            else UIinfo[player.userID].admin = true;
            GiftPanel(player);
        }

        
        [ConsoleCommand("UI_AG_ChangeCat")]
        private void cmdUI_AG_ChangeCat(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null || !isAuth(player)) return;
            ItemCategory cat = (ItemCategory)Enum.Parse(typeof(ItemCategory), arg.Args[0]);
            UIinfo[player.userID].cat = cat;
            UIinfo[player.userID].page = 0;
            CreateGifts(player, 2);
        }


        [ConsoleCommand("UI_AG_CreateGifts")]
        private void cmdUI_AG_CreateGifts(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null || !isAuth(player)) return;
            if (arg.Args == null || arg.Args.Length == 0) { DestroyGiftPanel(player, false); CreateGifts(player); }
            else
            {
                int step;
                if (!int.TryParse(arg.Args[0], out step)) return;
                int page;
                if (arg.Args.Length < 2 || !int.TryParse(arg.Args[1], out page)) page = 0;
                UIinfo[player.userID].page = page;
                CreateGifts(player, step);
            }
        }



        [ConsoleCommand("UI_AG_RedeemGift")]
        private void cmdUI_AG_RedeemGift(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            int ID;
            if (!int.TryParse(arg.Args[0], out ID)) return;
            if (agdata.Players[player.userID].pendingGift.ContainsKey(ID))
            {

                if(agdata.Gifts[ID].gifts.Count() > ((player.inventory.containerBelt.capacity - player.inventory.containerBelt.itemList.Count) + (player.inventory.containerWear.capacity - player.inventory.containerWear.itemList.Count) + (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count)))
                {
                    GetSendMSG(player, "NotEnoughSpace");
                    return;
                }
                foreach (var entry in agdata.Players[player.userID].pendingGift[ID].gifts)
                {
                    if (entry.SR)
                    {
                        ServerRewards?.Call("AddPoints", player.userID.ToString(), entry.amount);
                        GetSendMSG(player, "NewGiftGiven", entry.amount.ToString(), "ServerRewards Points");
                    }
                    else if (entry.Eco)
                    {
                        Economics.Call("DepositS", player.userID.ToString(), entry.amount);
                        GetSendMSG(player, "NewGiftGiven", entry.amount.ToString(), "Economics");
                    }
                    else if (entry.AC)
                    {
                        AbsolutCombat.Call("AddMoney", player.userID.ToString(), entry.amount, false);
                        GetSendMSG(player, "NewGiftGiven", entry.amount.ToString(), "AbsolutCombat Money");
                    }
                    else
                    {
                        Item item = ItemManager.CreateByItemID(entry.ID, entry.amount, entry.Skin);
                        if (item != null)
                        {
                            player.GiveItem(item);
                            GetSendMSG(player, "NewGiftGiven", item.amount.ToString(), item.info.displayName.english);
                        }
                    }
                }
                agdata.Players[player.userID].pendingGift.Remove(ID);
            }
            NewGiftIcon(player);
            GiftPanel(player);
        }

    [ConsoleCommand("UI_AG_RemoveGift")]
        private void cmdUI_AG_RemoveGift(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            int ID;
            if (!int.TryParse(arg.Args[0], out ID)) return;
            if (agdata.Gifts.ContainsKey(ID))
                agdata.Gifts.Remove(ID);
            GetSendMSG(player, "GiftRemoved", ID.ToString());
            GiftPanel(player);
            SaveData();
        }

        [ConsoleCommand("UI_AG_FinalizeGift")]
        private void cmdUI_AG_FinalizeGift(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (agdata.Gifts.ContainsKey(giftprep[player.userID].time))
                agdata.Gifts.Remove(giftprep[player.userID].time);
            agdata.Gifts.Add(giftprep[player.userID].time, new GiftEntry {ID = giftprep[player.userID].time, gifts = giftprep[player.userID].gifts, vip = giftprep[player.userID].vip });
            GetSendMSG(player, "NewGift", giftprep[player.userID].time.ToString());
            SaveData();
            UIinfo[player.userID].page = 0;
            Background(player);
        }



        [ConsoleCommand("UI_AG_DestroyGiftPanel")]
        private void cmdUI_AG_DestroyGiftPanel(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null) return;
            DestroyGiftPanel(player, true);
        }

        [ConsoleCommand("UI_AG_CancelGiftCreation")]
        private void cmdUI_AG_CancelListing(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            CancelGiftCreation(player);
        }


        [ConsoleCommand("UI_AG_SelectGift")]
        private void cmdUI_AG_SelectGift(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            int item;
            if (int.TryParse(arg.Args[0], out item)) giftprep[player.userID].currentgift = new Gift { ID = item };
            else
            {
                if (arg.Args[0] == "SR")
                    giftprep[player.userID].currentgift = new Gift { SR = true };
                else if (arg.Args[0] == "ECO")
                    giftprep[player.userID].currentgift = new Gift { Eco = true };
                else if (arg.Args[0] == "AC")
                    giftprep[player.userID].currentgift = new Gift { AC = true };
            }
            DestroyGiftPanel(player, false);
            NumberPad(player, "UI_AG_SelectAmount", "SelectAmount");
        }

        [ConsoleCommand("UI_AG_SelectAmount")]
        private void cmdUI_AG_SelectPriceAmount(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            int amount = Convert.ToInt32(arg.Args[0]);
            giftprep[player.userID].currentgift.amount = amount;
            giftprep[player.userID].gifts.Add(giftprep[player.userID].currentgift);
            giftprep[player.userID].currentgift = null;
            CreateGifts(player, 99);
        }     
        #endregion

        #region Timers

        private void SaveLoop()
        {
            if (timers.ContainsKey("save"))
            {
                timers["save"].Destroy();
                timers.Remove("save");
            }
            SaveData();
            timers.Add("save", timer.Once(600, () => SaveLoop()));
        }

        private void InfoLoop()
        {
            if (timers.ContainsKey("info"))
            {
                timers["info"].Destroy();
                timers.Remove("info");
            }
            if (configData.InfoInterval == 0) return;
            foreach (BasePlayer p in BasePlayer.activePlayerList)
            {
                GetSendMSG(p, "AGInfo");
            }
            timers.Add("info", timer.Once(configData.InfoInterval * 60, () => InfoLoop()));
        }

        #endregion

        #region Classes
        class GiftData
        {
            public Dictionary<int, GiftEntry> Gifts = new Dictionary<int, GiftEntry>();
            public Dictionary<ulong, playerdata> Players = new Dictionary<ulong, playerdata>();
        }
        class GiftEntry
        {
            public bool vip;
            public List<Gift> gifts = new List<Gift>();
            public int ID;
        }

        class Gift
        {
            public ulong Skin;
            public int amount;
            public int ID;
            public bool SR;
            public bool Eco;
            public bool AC;
        }

        class playerdata
        {
            public int PlayerTime;
            public Dictionary<int, GiftEntry> pendingGift = new Dictionary<int, GiftEntry>();
            public List<int> ReceivedGifts = new List<int>();
            public double ResetTime;
        }

        class GiftCreation
        {
            public int time;
            public bool vip;
            public List<Gift> gifts = new List<Gift>();
            public Gift currentgift;
        }

        #endregion

        #region Data Management

        void SaveData()
        {
            AGData.WriteObject(agdata);
        }

        void LoadData()
        {
            try
            {
                agdata = AGData.ReadObject<GiftData>();
            }
            catch
            {
                Puts("Couldn't load the Absolut Gift Data, creating a new datafile");
                agdata = new GiftData();
            }
            if (agdata.Gifts == null)
                agdata.Gifts = new Dictionary<int, GiftEntry>();
            if (agdata.Players == null)
                agdata.Players = new Dictionary<ulong, playerdata>();
            initialized = true;
        }

        #endregion
        float Default_minx = 0.21f;
        float Default_miny = 0.005f;
        float Default_maxx = 0.34f;
        float Default_maxy = 0.055f;
        #region Config        
        private ConfigData configData;
        class ConfigData
        {
            public int InfoInterval { get; set; }
            public bool NoAFK { get; set; }
            public bool UseGatherIncrease { get; set; }
            public int ResetInDays { get; set; }
            public int GiftsPerPanel { get; set; }
            public bool HideVIP { get; set; }
            public string GiftIconImage { get; set; }
            public int UITextSize { get; set; }
            public float minx { get; set; }
            public float miny { get; set; }
            public float maxx { get; set; }
            public float maxy { get; set; }

        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
            bool changed = false;
            if (configData.maxx == new float() && configData.maxy == new float() && configData.minx == new float() && configData.miny == new float())
            {
                configData.minx = Default_minx;
                configData.miny = Default_miny;
                configData.maxx = Default_maxx;
                configData.maxy = Default_maxy;
                changed = true;
            }
            if (configData.GiftsPerPanel < 4)
            {
                configData.GiftsPerPanel = 4;
                changed = true;
            }
            else if (configData.GiftsPerPanel > 12)
            {
                configData.GiftsPerPanel = 12;
                Puts("You have Gift Per Panel set above 12. 12 is the max; and has been adjusted for you.");
                changed = true;
            }
            if (configData.UITextSize <= 2)
            {
                configData.UITextSize = 12;
                changed = true;
            }
            if(changed) SaveConfig(configData);
            max = configData.GiftsPerPanel;
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                InfoInterval = 15,
                NoAFK = true,
                UseGatherIncrease = true,
                ResetInDays = 1,
                GiftIconImage = "http://i.imgur.com/zMe9ky5.png",
                GiftsPerPanel = 4,
                UITextSize = 12,
                minx = Default_minx,
                miny = Default_miny,
                maxx = Default_maxx,
                maxy = Default_maxy,
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Messages
        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"title", "Absolut Gifts: " },
            {"AGInfo", "This server is running Absolut Gifts. Type /gift to access the Gift Menu!"},
            {"Next", "Next" },
            {"Back", "Back" },
            {"First", "First" },
            {"Last", "Last" },
            {"Close", "Close"},
            {"Quit", "Quit"},
            {"ImgReload", "Images have been wiped and reloaded!" },
            {"ImgRefresh", "Images have been refreshed !" },
            {"NewGiftInfo", "New Gift Information for Playing {0} Minute(s)." },
            {"GiftDetails", "{1} - {0}" },
            {"TimeAlreadyExists", "The select time {0} already exists as a Gift, if you continue the old entry will be removed" },
            {"GiftCreationCanceled", "You have successfully cancelled Gift Creation." },
            {"ToggleAdmin", "Toggle Admin" },
            {"Delete", "Delete" },
            {"GiftTitle", "Gift Requirement: {0} Minute(s)" },
            {"GiftTitleInProgress", "IN PROGRESS: {0} Minute(s)\nYou have {1} Minute(s) Remaining!" },
            {"GiftTitleCompleted", "COMPLETED: {0} Minute(s)" },
            {"NewGift", "You have successfully created a new gift for {0} Minute(s)!" },
            {"GiftRemoved", "You have deleted the gift for {0} Minute(s)!" },
            {"NewGiftGiven", "You have been given {0} {1} for your PlayTime! Thanks for playing on the server today!" },
            {"SelectTime", "Select Minute Requirement for this Gift..." },
            {"SelectAmount", "Select the amount of the chosen item for this Gift." },
            {"CreateGift", "Create a Gift" },
            {"ManageGifts", "Manage Gifts" },
            {"SelectGift", "Select a Gift Item" },
            {"FinalizeGift", "Save Gift" },
            {"AddToGift", "Add More..." },
            {"Cancel", "Cancel" },
            {"NotAuth", "You are not an admin." },
            {"VIPGift", "Make this a VIP only gift?" },
            {"Yes", "Yes" },
            {"No", "No" },
            {"Redeem", "Redeem" },
            {"CompletedNewGift", "You have been given a new gift for the {0} Minute PlayTime Objective!" },
            {"AccumulatedTime", "Accumulated Time: {0}" },
            {"NotEnoughSpace", "You do not have enough room to redeem this gift!" },
            {"WaitingImageLibrary", "Waiting on Image Library to initialize. Trying again in 60 Seconds" },
        };
        #endregion
    }
}

// --- End of file: AbsolutGifts.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/assets-checker ---
// --- Original File Path: A/AssetsChecker/AssetsChecker.cs ---

using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Assets Checker", "SettLe", "1.0.5")]
    [Description("Extracts changes from the games assets and writes them to sorted lists.")]
    public class AssetsChecker : RustPlugin
    {
        private GameManifest.PooledString[] _manifest;
        private bool _inProcess;
        private List<string> _allPrefabs, 
            _allAssets,
            _allImages,
            _allOther,
            _oldPrefabs,
            _oldAssets,
            _oldImages,
            _oldOther,
            _lostPrefabs,
            _lostAssets,
            _lostImages,
            _lostOther,
            _newPrefabs,
            _newAssets,
            _newImages,
            _newOther;

        private void OnServerInitialized()
        {
            _manifest = GameManifest.Current.pooledStrings;
        }
        
        private static void LoadData<T>(ref T data, string file)
        {
            data = Core.Interface.Oxide.DataFileSystem.ReadObject<T>($"AssetsChecker/{file}");
        }
		
        private static void SaveData<T>(T data, string file)
        {
            Core.Interface.Oxide.DataFileSystem.WriteObject($"AssetsChecker/{file}", data);
        }

        private void Unload()
        {
            Clear();
        }

        private void LoadOld()
        {
            LoadData(ref _oldPrefabs, "LastAssembly/Prefabs");
            LoadData(ref _oldAssets, "LastAssembly/Assets");
            LoadData(ref _oldImages, "LastAssembly/Images");
            LoadData(ref _oldOther, "LastAssembly/Other");
        }
        
        private void SaveAll()
        {
            SaveData(_allPrefabs, "LastAssembly/Prefabs");
            SaveData(_allAssets, "LastAssembly/Assets");
            SaveData(_allImages, "LastAssembly/Images");
            SaveData(_allOther, "LastAssembly/Other");
        }
        
        private void SaveLost(string folder)
        {
            SaveData(_lostPrefabs, $"{folder}/Lost/Prefabs");
            SaveData(_lostAssets, $"{folder}/Lost/Assets");
            SaveData(_lostImages, $"{folder}/Lost/Images");
            SaveData(_lostOther, $"{folder}/Lost/Other");
        }
        
        private void SaveNew(string folder)
        {
            SaveData(_newPrefabs, $"{folder}/New/Prefabs");
            SaveData(_newAssets, $"{folder}/New/Assets");
            SaveData(_newImages, $"{folder}/New/Images");
            SaveData(_newOther, $"{folder}/New/Other");
        }
        
        private void Clear()
        {
            _allPrefabs = null;
            _allAssets = null;
            _allImages = null;
            _allOther = null;
            _oldPrefabs = null;
            _oldAssets = null;
            _oldImages = null;
            _oldOther = null;
            _lostPrefabs = null;
            _lostAssets = null;
            _lostImages = null;
            _lostOther = null;
            _newPrefabs = null;
            _newAssets = null;
            _newImages = null;
            _newOther = null;
        }
        
        private void Search()
        {
            _inProcess = true;
            _allPrefabs = new List<string>();
            _allAssets = new List<string>();
            _allImages = new List<string>();
            _allOther = new List<string>();
                
            foreach (GameManifest.PooledString asset in _manifest)
            {
                if (asset.str.EndsWith(".prefab"))
                    _allPrefabs.Add(asset.str);
                else if (asset.str.EndsWith(".asset"))
                    _allAssets.Add(asset.str);
                else if (asset.str.EndsWith(".png"))
                    _allImages.Add(asset.str);
                else
                    _allOther.Add(asset.str);
            }
            
            if (_oldPrefabs.IsNullOrEmpty() || _oldAssets.IsNullOrEmpty() || _oldImages.IsNullOrEmpty() || _oldOther.IsNullOrEmpty())
            {
                PrintWarning("Search for changes is not possible due to absence of lists of old build.\nNew lists have been created for the current build in the AssetsChecker/LastAssembly folder.");
            }
            else
            {
                Puts("The process of searching for changes in the game's assets is started.");
                
                _newPrefabs = new List<string>();
                _newAssets = new List<string>();
                _newImages = new List<string>();
                _newOther = new List<string>();
                
                foreach (var prefab in _allPrefabs)
                {
                    if (!_oldPrefabs.Contains(prefab))
                    {
                        _newPrefabs.Add(prefab);
                    }
                }
                
                foreach (var prefab in _allAssets)
                {
                    if (!_oldAssets.Contains(prefab))
                    {
                        _newAssets.Add(prefab);
                    }
                }
                
                foreach (var prefab in _allImages)
                {
                    if (!_oldImages.Contains(prefab))
                    {
                        _newImages.Add(prefab);
                    }
                }
                
                foreach (var prefab in _allOther)
                {
                    if (!_oldOther.Contains(prefab))
                    {
                        _newOther.Add(prefab);
                    }
                }
                
                _lostPrefabs = new List<string>();
                _lostAssets = new List<string>();
                _lostImages = new List<string>();
                _lostOther = new List<string>();
                
                foreach (var prefab in _oldPrefabs)
                {
                    if (!_allPrefabs.Contains(prefab))
                    {
                        _lostPrefabs.Add(prefab);
                    }
                }
                
                foreach (var prefab in _oldAssets)
                {
                    if (!_allAssets.Contains(prefab))
                    {
                        _lostAssets.Add(prefab);
                    }
                }
                
                foreach (var prefab in _oldImages)
                {
                    if (!_allImages.Contains(prefab))
                    {
                        _lostImages.Add(prefab);
                    }
                }
                
                foreach (var prefab in _oldOther)
                {
                    if (!_allOther.Contains(prefab))
                    {
                        _lostOther.Add(prefab);
                    }
                }
				
                if (_newPrefabs.Count > 0 || _newAssets.Count > 0 || _newImages.Count > 0 || _newOther.Count > 0)
                {
					var now = DateTime.Now;
					var folder = $"{now.Month.ToString()}.{now.Day.ToString()}";
                    SaveNew(folder);
                    Puts($"Found new: {_newPrefabs.Count.ToString()} prefabs, {_newAssets.Count.ToString()} assets, {_newImages.Count.ToString()} images, {_newOther.Count.ToString()} other.\nThe lists is saved to a folder: Oxide/data/AssetsChecker/{folder}/New");
					
					if (_lostPrefabs.Count > 0 || _lostAssets.Count > 0 || _lostImages.Count > 0 || _lostOther.Count > 0)
					{
						SaveLost(folder);
						Puts($"Found removed or renamed: {_lostPrefabs.Count.ToString()} prefabs, {_lostAssets.Count.ToString()} assets, {_lostImages.Count.ToString()} images, {_lostOther.Count.ToString()} other.\nThe lists is saved to a folder: Oxide/data/AssetsChecker/{folder}/Lost");
					}
				}
                else PrintWarning("Changes not found.");
            }
            
            SaveAll();
            Clear();
            _inProcess = false;
        }

        [ConsoleCommand("check_assets")]
        private void CommandCheckAssets(ConsoleSystem.Arg console)
        {
            if (!console.IsServerside)
                return;
            
            if (_inProcess)
            {
                PrintError("The process is already running.");
                return;
            }
            
            LoadOld();
            NextFrame(() => Search());
        }
    }
}

// --- End of file: AssetsChecker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/admin-panel ---
// --- Original File Path: A/AdminPanel/AdminPanel.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

/*======================================================================================================================= 
*
*   
*   20th november 2018
*
*	THANKS TO THE OXIDE/UMOD TEAM for coding quality, ideas, and time spent for the community
*
*   1.3.0   20181120    New maintainer (BuzZ)   added GUI button for set new tp pos (config for color, and bool for on/off)
*   1.4.0   20190609    toggle system FIX
*********************************************
*   Original author :   DaBludger on versions <1.3.0
*   Maintainer(s)   :   BuzZ since 20181116 from v1.3.0
*********************************************   
*
*=======================================================================================================================*/

/*
 * 1.4.7:
 * Added FontSize (8)
 * New configuration format
 * Moved UI position above new map buttons
 * 
 * 1.4.6:
 * Added Player Administration button
 * Added missing localization to language API
 * Added adminpanel.autotoggle.admin permission - toggles panel when added/removed from the admin group
 * Added command `adminpanel settp` - sets the custom teleport
 * Added command `adminpanel settp all` - sets the teleport location for all admins without a custom location
 * Added command `adminpanel removetp` - removes the custom teleport location
 * Removed ToggleMode requirement to use `adminpanel toggle` console command
 * 
 * 1.4.5:
 * UI updates panel when player toggles godmode/vanish/radar
 * Requires AdminRadar 5.0.8+
 * 
 * 1.4.4:
 * Added support for AdminRadar 5.0+
 * 
 * 1.4.3:
 * Fixed `adminpanel toggle`
 * 
 * 1.4.2:
 *  Fixed issue with GUI on server startup @atope
 *  
 * 1.4.1:
 *  Fixed vanish permission
 *  Fixed NullReferenceException in console command: adminpanel
 *  Renamed deprecated hook OnPlayerDie to OnPlayerDeath
 *  Added unsubcribing and subscribing of hooks
 *  Fixed `/adminpanel show` glitching the game when AdminPanelToggleMode is true
 *  Fixed `/adminpanel show` not showing the GUI
 */

// https://umod.org/community/admin-panel/28638-ability-to-create-custom-buttons

namespace Oxide.Plugins
{
    [Info("Admin Panel", "nivex", "1.4.7")]
    [Description("GUI admin panel with command buttons")]
    class AdminPanel : RustPlugin
    {
        [PluginReference]
        private Plugin AdminRadar, Godmode, Vanish, PlayerAdministration;

        private const string permAdminPanel = "adminpanel.allowed";
        private const string permAdminRadar = "adminradar.allowed";
        private const string permGodmode = "godmode.toggle";
        private const string permVanish = "vanish.allow";
        private const string permPlayerAdministration = "playeradministration.access.show";
        private const string permAutoToggle = "adminpanel.autotoggle.admin";

        public Dictionary<BasePlayer, string> playerCUI = new Dictionary<BasePlayer, string>();

        #region Integrations

        public class StoredData
        {
            public Dictionary<string, string> TP = new Dictionary<string, string>();
            public StoredData() { }
        }

        public StoredData data = new StoredData();

        #region Player Administration

        private List<string> _playerAdministration = new List<string>();

        private bool IsPlayerAdministration(string UserID)
        {
            return PlayerAdministration != null && _playerAdministration.Contains(UserID);
        }

        private void TogglePlayerAdministration(BasePlayer player)
        {            
            if (PlayerAdministration == null || !PlayerAdministration.IsLoaded) return;

            if (IsPlayerAdministration(player.UserIDString))
            {
                player.Command("playeradministration.closeui", player, "playeradministration.closeui", new string[0]);
            }
            else
            {
                player.Command("padmin", player, "padmin", new string[0]);
            }
        }

        private void OnPlayerCommand(BasePlayer player, string command, string[] args)
        {
            if (player.IsValid() && permission.UserHasPermission(player.UserIDString, permPlayerAdministration))
            {
                if (command.Equals("padmin", StringComparison.OrdinalIgnoreCase) && !_playerAdministration.Contains(player.UserIDString))
                {
                    _playerAdministration.Add(player.UserIDString);
                    AdminGui(player);
                }
                else if (command.Equals("playeradministration.closeui", StringComparison.OrdinalIgnoreCase) && _playerAdministration.Contains(player.UserIDString))
                {
                    _playerAdministration.Remove(player.UserIDString);
                    AdminGui(player);
                }
            }
        }

        private void OnServerCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();

            if (player.IsValid() && permission.UserHasPermission(player.UserIDString, permPlayerAdministration))
            {
                string command = arg.cmd.FullName.Replace("/", string.Empty);
                
                if (command.Equals("padmin", StringComparison.OrdinalIgnoreCase) && !_playerAdministration.Contains(player.UserIDString))
                {
                    _playerAdministration.Add(player.UserIDString);
                    AdminGui(player);
                }
                else if (command.Equals("playeradministration.closeui", StringComparison.OrdinalIgnoreCase) && _playerAdministration.Contains(player.UserIDString))
                {
                    _playerAdministration.Remove(player.UserIDString);
                    AdminGui(player);
                }
            }
        }

        #endregion Player Administration

        #region Godmode

        private bool IsGod(string UserID)
        {
            return Godmode != null && Convert.ToBoolean(Godmode?.Call("IsGod", UserID));
        }

        private void ToggleGodmode(BasePlayer player)
        {
            if (Godmode == null || !Godmode.IsLoaded) return;

            if (IsGod(player.UserIDString))
                Godmode.Call("DisableGodmode", player.IPlayer);
            else
                Godmode.Call("EnableGodmode", player.IPlayer);

            AdminGui(player);
        }

        private void OnGodmodeToggle(string playerId, bool state)
        {
            var player = RustCore.FindPlayerByIdString(playerId);

            if (player.IsValid() && player.IsConnected && IsAllowed(player, permAdminPanel))
            {
                AdminGui(player);
            }
        }

        #endregion Godmode

        #region Vanish

        private bool IsInvisible(BasePlayer player)
        {
            return Vanish != null && Convert.ToBoolean(Vanish?.Call("IsInvisible", player));
        }

        private void ToggleVanish(BasePlayer player)
        {
            if (Vanish == null || !Vanish.IsLoaded) return;

            if (!IsInvisible(player))
                Vanish.Call("Disappear", player);
            else
                Vanish.Call("Reappear", player);

            AdminGui(player);
        }

        private void OnVanishDisappear(BasePlayer player)
        {
            if (player.IsValid() && player.IsConnected && IsAllowed(player, permAdminPanel))
            {
                AdminGui(player);
            }
        }

        private void OnVanishReappear(BasePlayer player)
        {
            if (player.IsValid() && player.IsConnected && IsAllowed(player, permAdminPanel))
            {
                AdminGui(player);
            }
        }

        #endregion Vanish

        #region Admin Radar

        private bool IsRadar(string id)
        {
            return AdminRadar != null && Convert.ToBoolean(AdminRadar?.Call("IsRadar", id));
        }

        private void ToggleRadar(BasePlayer player)
        {
            if (AdminRadar == null || !AdminRadar.IsLoaded) return;

            if (AdminRadar.Version < new Core.VersionNumber(5, 0, 0)) AdminRadar.Call("cmdESP", player, "radar", new string[0]);
            else if (player.IPlayer != null) AdminRadar.Call("RadarCommand", player.IPlayer, "radar", new string[0]);
            AdminGui(player);
        }

        private void OnRadarActivated(BasePlayer player)
        {
            if (player.IsValid() && player.IsConnected && IsAllowed(player, permAdminPanel))
            {
                AdminGui(player);
            }
        }

        private void OnRadarDeactivated(BasePlayer player)
        {
            if (player.IsValid() && player.IsConnected && IsAllowed(player, permAdminPanel))
            {
                AdminGui(player);
            }
        }

        #endregion Admin Radar

        #endregion Integrations

        private void Init()
        {
            permission.RegisterPermission(permAdminPanel, this);
            permission.RegisterPermission(permAutoToggle, this);
            Unsubscribe(nameof(OnPlayerSleepEnded));
            Unsubscribe(nameof(OnPlayerDeath));
        }

        private void OnUserGroupRemoved(string id, string group)
        {
            if (group != "admin" || !permission.UserHasPermission(id, permAutoToggle))
            {
                return;
            }

            var player = BasePlayer.FindAwakeOrSleeping(id);

            if (player == null || !player.IsConnected)
            {
                return;
            }

            DestroyUI(player);
        }

        private void OnUserGroupAdded(string id, string group)
        {
            if (group != "admin" || !permission.UserHasPermission(id, permAutoToggle))
            {
                return;
            }

            var player = BasePlayer.FindAwakeOrSleeping(id);

            if (player == null || !player.IsConnected || !IsAllowed(player, permAdminPanel))
            {
                return;
            }

            AdminGui(player);
        }

        #region Localization

        private new void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["AdminTP"] = "Teleport",
                ["Godmode"] = "God",
                ["Radar"] = "Radar",
                ["Vanish"] = "Vanish",
                ["NewTP"] = "NewTP",
                ["PA"] = "Player Administration",
                ["Syntax"] = "Invalid syntax: /{0} {1}",
                ["No Custom Location Set"] = "You do not have a custom location set.",
                ["Removed Custom Location"] = "Removed your custom TP coordinates. You will teleport to the admin location instead.",
                ["Set Custom TP Coordinates"] = "Your TP coordinates set to current position {0}",
                ["Set Admin TP Coordinates"] = "Admin zone coordinates set to current position {0}",
                ["Panel Shown"] = "Admin panel refreshed/shown",
                ["Panel Hidden"] = "Admin panel hidden",
                ["Usage"] = "Usage: /{0} show/hide/settp/removetp",
            }, this);

            // Spanish
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["AdminTP"] = "Teleport",
                ["Godmode"] = "Dios",
                ["Radar"] = "Radar",
                ["Vanish"] = "Desaparecer",
                ["NewTP"] = "NewTP",
            }, this, "es");

            // French
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["AdminTP"] = "Teleport",
                ["Godmode"] = "Dieu",
                ["Radar"] = "Radar",
                ["Vanish"] = "Invisible",
                ["NewTP"] = "NewTP",
            }, this, "fr");
        }

        #endregion Localization

        #region Hooks

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            if (IsAllowed(player, permAdminPanel))
            {
                AdminGui(player);
            }
        }

        private void OnPlayerDeath(BasePlayer player)
        {
            DestroyUI(player);
        }

        private void OnPluginLoaded(Plugin plugin)
        {
            if (plugin.Name == "AdminRadar" || plugin.Name == "Godmode" || plugin.Name == "Vanish" || plugin.Name == "PlayerAdministration")
            {
                RefreshAllUI();
            }
        }

        private void OnPluginUnloaded(Plugin plugin)
        {
            if (plugin.Name == "AdminRadar" || plugin.Name == "Godmode" || plugin.Name == "Vanish" || plugin.Name == "PlayerAdministration")
            {
                RefreshAllUI();
            }
        }

        private void OnServerInitialized()
        {
            try
            {
                data = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch
            {

            }

            if (data == null)
            {
                data = new StoredData();
                SaveData();
            }

            Subscribe(nameof(OnPlayerDeath));

            if (!config.ToggleMode)
            {
                Subscribe(nameof(OnPlayerSleepEnded));
                RefreshAllUI();
            }
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, data, true);
        }

        private void RefreshAllUI()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (IsAllowed(player, permAdminPanel))
                {
                    AdminGui(player);
                }
            }
        }

        #endregion Hooks

        #region Command Structure

        [ConsoleCommand("adminpanel")]
        private void ccmdAdminPanel(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null || !IsAllowed(player, permAdminPanel) || !arg.HasArgs()) return;
            
            switch (arg.Args[0].ToLower())
            {
                case "action":
                    {
                        if (arg.Args.Length >= 2)
                        {
                            switch (arg.Args[1].ToLower())
                            {
                                case "vanish":
                                    ToggleVanish(player);
                                    break;
                                case "radar":
                                    ToggleRadar(player);
                                    break;
                                case "god":
                                    ToggleGodmode(player);
                                    break;
                                case "pa":
                                    TogglePlayerAdministration(player);
                                    break;
                                case "admintp":
                                    if (data.TP.ContainsKey(player.UserIDString))
                                    {
                                        var pos = data.TP[player.UserIDString].ToVector3();
                                        player.Teleport(pos);
                                    }
                                    else
                                    {
                                        player.Teleport(config.adminZoneCords);
                                    }
                                    break;
                                case "newtp":
                                    if (config.newtp.enabled)
                                    {
                                        string[] argu = new string[1];
                                        argu[0] = "settp";
                                        ccmdAdminPanel(player, null, argu);
                                    }
                                    break;
                                default:
                                    arg.ReplyWith(_("Syntax", player.UserIDString, "adminpanel", "action vanish/admintp/radar/god/newtp"));
                                    break;
                            }
                        }
                        else
                        {
                            arg.ReplyWith(_("Syntax", player.UserIDString, "adminpanel", "action vanish/admintp/radar/god/newtp"));
                        }

                        break;
                    }
                case "toggle":
                    {
                        if (IsAllowed(player, permAdminPanel))
                        {
                            if (playerCUI.ContainsKey(player))
                            {
                                DestroyUI(player);
                            }
                            else
                            {
                                AdminGui(player);
                            }
                        }
                        break;
                    }
                default:
                    {
                        arg.ReplyWith(_("Syntax", player.UserIDString, "adminpanel", "action/toggle"));
                        break;
                    }
            }
        }

        [ChatCommand("adminpanel")]
        private void ccmdAdminPanel(BasePlayer player, string command, string[] args) // TODO: Make universal command
        {
            if (!IsAllowed(player, permAdminPanel))
            {
                SendReply(player, $"Unknown command: {command}");
                return;
            }

            if (args.Length == 0)
            {
                Message(player, "Usage", command);
                return;
            }

            switch (args[0].ToLower())
            {
                case "hide":
                    DestroyUI(player);
                    Message(player, "Panel Hidden");
                    break;

                case "show":
                    AdminGui(player);                    
                    Message(player, "Panel Shown");
                    break;

                case "settp":
                    Vector3 coord = player.transform.position;
                    if (args.Any(arg => arg.ToLower() == "all"))
                    {
                        config.adminZoneCords = coord;
                        SaveConfig();
                        Message(player, "Set Admin TP Coordinates", coord);
                    }
                    else
                    {
                        data.TP[player.UserIDString] = coord.ToString();
                        SaveData();
                        Message(player, "Set Custom TP Coordinates", coord);
                    }
                    break;

                case "removetp":
                    if (data.TP.Remove(player.UserIDString))
                    {
                        Message(player, "Removed Custom Location");
                        SaveData();
                    }
                    else Message(player, "No Custom Location Set");
                    break;

                default:
                    Message(player, "Syntax", command, args[0]);
                    break;
            }
        }

        #endregion Command Structure

        #region GUI Panel

        private void AdminGui(BasePlayer player)
        {
            NextTick(() =>
            {
                // Destroy existing UI
                DestroyUI(player);

                var BTNColorVanish = config.btnInactColor;
                var BTNColorGod = config.btnInactColor;
                var BTNColorRadar = config.btnInactColor;
                var BTNColorNewTP = config.newtp.color;
                var BTNColorPA = config.btnInactColor;

                if (AdminRadar != null && IsRadar(player.UserIDString)) BTNColorRadar = config.btnActColor;
                if (Godmode != null && IsGod(player.UserIDString)) BTNColorGod = config.btnActColor;
                if (Vanish != null && IsInvisible(player)) BTNColorVanish = config.btnActColor;
                if (_playerAdministration.Contains(player.UserIDString)) BTNColorPA = config.btnActColor;

                var GUIElement = new CuiElementContainer();

                var GUIPanel = GUIElement.Add(new CuiPanel
                {
                    Image =
                    {
                        Color = "1 1 1 0"
                    },
                    RectTransform =
                    {
                        AnchorMin = config.PanelPosMin,
                        AnchorMax = config.PanelPosMax
                    },
                    CursorEnabled = false
                }, "Hud", Name);

                if (AdminRadar != null && permission.UserHasPermission(player.UserIDString, permAdminRadar))
                {
                    GUIElement.Add(new CuiButton
                    {
                        Button =
                        {
                            Command = "adminpanel action radar",
                            Color = BTNColorRadar
                        },
                        Text =
                        {
                            Text = _("Radar", player.UserIDString),
                            FontSize = config.fontSize,
                            Align = TextAnchor.MiddleCenter,
                            Color = "1 1 1 1"
                        },
                        RectTransform =
                        {
                            AnchorMin = "0.062 0.21",
                            AnchorMax = "0.51 0.37"
                        }
                    }, GUIPanel);
                }

                if (PlayerAdministration != null && permission.UserHasPermission(player.UserIDString, permPlayerAdministration))
                {
                    GUIElement.Add(new CuiButton
                    {
                        Button =
                        {
                            Command = "adminpanel action pa",
                            Color = BTNColorPA
                        },
                        Text =
                        {
                            Text = _("PA", player.UserIDString),
                            FontSize = config.fontSize,
                            Align = TextAnchor.MiddleCenter,
                            Color = "1 1 1 1"
                        },
                        RectTransform =
                        {
                            AnchorMin = "0.062 0.39",
                            AnchorMax = "0.51 0.555"
                        }
                    }, GUIPanel);
                }

                GUIElement.Add(new CuiButton
                {
                    Button =
                    {
                        Command = "adminpanel action admintp",
                        Color = "1.28 0 1.28 0.3"
                    },
                    Text =
                    {
                        Text = _("AdminTP", player.UserIDString),
                        FontSize = config.fontSize,
                        Align = TextAnchor.MiddleCenter,
                        Color = "1 1 1 1"
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.52 0.21",
                        AnchorMax = "0.95 0.37"
                    }
                }, GUIPanel);

                if (config.newtp.enabled)
                {
                    GUIElement.Add(new CuiButton
                    {
                        Button =
                        {
                            Command = "adminpanel action newtp",
                            Color = BTNColorNewTP
                        },
                        Text =
                        {
                            Text = _("newTP", player.UserIDString),
                            FontSize = config.fontSize,
                            Align = TextAnchor.MiddleCenter,
                            Color = "1 1 1 1"
                        },
                        RectTransform =
                        {
                            AnchorMin = "0.52 0.39",
                            AnchorMax = "0.95 0.47"
                        }
                    }, GUIPanel);
                }

                if (Godmode != null && permission.UserHasPermission(player.UserIDString, permGodmode))
                {
                    GUIElement.Add(new CuiButton
                    {
                        Button =
                        {
                            Command = "adminpanel action god",
                            Color = BTNColorGod
                        },
                        Text =
                        {
                            Text = _("Godmode", player.UserIDString),
                            FontSize = config.fontSize,
                            Align = TextAnchor.MiddleCenter,
                            Color = "1 1 1 1"
                        },
                        RectTransform =
                        {
                            AnchorMin = "0.52 0.02",
                            AnchorMax = "0.95 0.19"
                        }
                    }, GUIPanel);
                }

                if (Vanish != null && permission.UserHasPermission(player.UserIDString, permVanish))
                {
                    GUIElement.Add(new CuiButton
                    {
                        Button =
                        {
                            Command = "adminpanel action vanish",
                            Color = BTNColorVanish
                        },
                        Text =
                        {
                            Text = _("Vanish", player.UserIDString),
                            FontSize = config.fontSize,
                            Align = TextAnchor.MiddleCenter,
                            Color = "1 1 1 1"
                        },
                        RectTransform =
                        {
                            AnchorMin = "0.062 0.02",
                            AnchorMax = "0.51 0.19"
                        }
                    }, GUIPanel);
                }

                CuiHelper.AddUi(player, GUIElement);
                playerCUI.Add(player, GUIPanel);
            });
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyUI(player);
            }
        }

        private void DestroyUI(BasePlayer player)
        {
            string cuiElement;
            if (playerCUI.TryGetValue(player, out cuiElement))
            {
                CuiHelper.DestroyUi(player, cuiElement);
                playerCUI.Remove(player);
            }
        }

        #endregion GUI Panel

        #region Helpers

        private bool IsAllowed(BasePlayer player, string perm) => player != null && permission.UserHasPermission(player.UserIDString, perm);

        private string _(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private void Message(BasePlayer player, string key, params object[] args) => Player.Message(player, _(key, player.UserIDString, args));

        #endregion Helpers

        #region Configuration

        private Configuration config;

        public class ButtonState
        {
            [JsonProperty(PropertyName = "Button Enabled")]
            public bool enabled { get; set; }

            [JsonProperty(PropertyName = "Button Color")]
            public string color { get; set; }
        }

        public class Configuration
        {
            [JsonProperty(PropertyName = "newtp")]
            public ButtonState newtp { get; set; } = new ButtonState
            {
                enabled = false,
                color = "1.0 0.65 0.85 0.3"
            };

            [JsonProperty(PropertyName = "Admin Zone Coordinates")]
            public Vector3 adminZoneCords { get; set; }

            [JsonProperty(PropertyName = "Button Active Color")]
            public string btnActColor { get; set; } = "0 2.55 0 0.3";

            [JsonProperty(PropertyName = "Button Inactive Color")]
            public string btnInactColor { get; set; } = "2.55 0 0 0.3";

            [JsonProperty(PropertyName = "Font Size")]
            public int fontSize { get; set; } = 8;

            [JsonProperty(PropertyName = "Panel Pos Max")]
            public string PanelPosMax { get; set; } = "0.991 0.87";

            [JsonProperty(PropertyName = "Panel Pos Min")]
            public string PanelPosMin { get; set; } = "0.9 0.7";

            [JsonProperty(PropertyName = "Toggle Mode")]
            public bool ToggleMode { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<Configuration>();
            }
            catch
            {

            }

            if (config == null)
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        protected override void LoadDefaultConfig() => config = new Configuration();

        #endregion
    }
}


// --- End of file: AdminPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/authenticator ---
// --- Original File Path: A/Authenticator/Authenticator.cs ---

using System.Text;
using System.Collections.Generic;
using System.Security.Cryptography;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Authenticator", "Spicy", "2.0.0")]
    [Description("Provides a simple login system.")]

    class Authenticator : CovalencePlugin
    {
        #region Fields

        private SHA512 sha512;
        private HashSet<string> authenticatedUsers;
        private Data data;
        private int kickTimer;

        #endregion

        #region Methods

        private string Syntax(string syntaxKey) => string.Format(_("InvalidSyntax"), _(syntaxKey));

        private string _(string key) => lang.GetMessage(key, this);

        private byte[] Hash(string password) => sha512.ComputeHash(Encoding.UTF8.GetBytes(password));

        private string ByteArrayToString(byte[] array) => Encoding.UTF8.GetString(array);

        private void Check(IPlayer player)
        {
            if (!authenticatedUsers.Contains(player.Id) && player.IsConnected)
                player.Kick(_("AuthenticationFailure"));
        }

        protected override void LoadDefaultConfig() => Config["KickTimer"] = 60;

        #endregion

        #region Classes

        private class Data
        {
            public Dictionary<string, byte[]> Players;
        }

        #endregion

        #region Hooks

        private void OnServerInitialized()
        {
            sha512 = SHA512.Create();
            authenticatedUsers = new HashSet<string>();
            data = Interface.Oxide.DataFileSystem.ReadObject<Data>(Title);

            if (data.Players == null)
                data.Players = new Dictionary<string, byte[]>();

            kickTimer = Config.Get<int>("KickTimer");

            lang.RegisterMessages(new Dictionary<string, string>()
            {
                ["InvalidSyntax"] = "Invalid syntax. Syntax: {0}.",
                ["SyntaxAuth"] = "/auth [register|unregister|login]",
                ["SyntaxRegister"] = "/auth register [password]",
                ["SyntaxUnregister"] = "/auth unregister [password]",
                ["SyntaxLogin"] = "/auth login [password]",
                ["AlreadyRegistered"] = "You're already registered!",
                ["AlreadyUnregistered"] = "You're already unregistered!",
                ["AlreadyLoggedIn"] = "You're already logged in!",
                ["Registered"] = "You've successfully registered!",
                ["Unregistered"] = "You've successfully unregistered!",
                ["LoggedIn"] = "You've successfully logged in!",
                ["NotRegistered"] = "You're not registered!",
                ["IncorrectPassword"] = "The password you've entered is incorrect.\nPlease contact an administrator if you've forgotten it.",
                ["AuthenticationRequired"] = "Hi, please login with '{0}' or you will be kicked in {1} seconds.",
                ["AuthenticationFailure"] = "You didn't login soon enough."
            }, this);
        }

        private void OnUserConnected(IPlayer player)
        {
            if (data.Players.ContainsKey(player.Id))
            {
                player.Reply(string.Format(_("AuthenticationRequired"), _("SyntaxLogin"), kickTimer));
                timer.Once(kickTimer, () => Check(player));
            }
        }

        private void OnUserDisconnected(IPlayer player, string reason) => authenticatedUsers.Remove(player.Id);

        #endregion

        #region Commands

        [Command("auth")]
        private void Auth(IPlayer player, string command, string[] args)
        {
            if (args.Length == 0 || args == null)
            {
                player.Reply(Syntax("SyntaxAuth"));
                return;
            }

            switch (args[0].ToLower())
            {
                case "register":
                    if (args.Length < 2)
                    {
                        player.Reply(Syntax("SyntaxRegister"));
                        break;
                    }

                    if (data.Players.ContainsKey(player.Id))
                    {
                        player.Reply(_("AlreadyRegistered"));
                        break;
                    }

                    data.Players.Add(player.Id, Hash(args[1]));
                    Interface.Oxide.DataFileSystem.WriteObject(Title, data);
                    player.Reply(_("Registered"));
                    break;

                case "unregister":
                    if (args.Length < 2)
                    {
                        player.Reply(Syntax("SyntaxUnregister"));
                        break;
                    }

                    if (!data.Players.ContainsKey(player.Id))
                    {
                        player.Reply(_("AlreadyUnregistered"));
                        break;
                    }

                    if (ByteArrayToString(Hash(args[1])) != ByteArrayToString(data.Players[player.Id]))
                    {
                        player.Reply(_("IncorrectPassword"));
                        break;
                    }

                    data.Players.Remove(player.Id);
                    Interface.Oxide.DataFileSystem.WriteObject(Title, data);
                    player.Reply(_("Unregistered"));
                    break;

                case "login":
                    if (args.Length < 2)
                    {
                        player.Reply(Syntax("SyntaxLogin"));
                        break;
                    }

                    if (authenticatedUsers.Contains(player.Id))
                    {
                        player.Reply(_("AlreadyLoggedIn"));
                        break;
                    }

                    if (!data.Players.ContainsKey(player.Id))
                    {
                        player.Reply(_("NotRegistered"));
                        break;
                    }

                    if (ByteArrayToString(Hash(args[1])) != ByteArrayToString(data.Players[player.Id]))
                    {
                        player.Reply(_("IncorrectPassword"));
                        break;
                    }

                    authenticatedUsers.Add(player.Id);
                    player.Reply(_("LoggedIn"));
                    break;

                default:
                    player.Reply(Syntax("SyntaxAuth"));
                    break;
            }
        }

        #endregion
    }
}

// --- End of file: Authenticator.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/admin-radar ---
// --- Original File Path: A/AdminRadar/AdminRadar.cs ---

//#define DEBUG

using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust.Ai.Gen2;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;
using static Oxide.Plugins.AdminRadarExtensionMethods.ExtensionMethods;

namespace Oxide.Plugins
{
    [Info("Admin Radar", "nivex", "5.4.0")]
    [Description("Radar tool for Admins and Developers.")]
    internal class AdminRadar : RustPlugin
    {
        [PluginReference] Plugin Clans, Backpacks, DiscordMessages;

        [Flags] public enum DrawFlags { None = 0, Arrow = 1 << 1, Box = 1 << 2, Text = 1 << 3, }
        public enum EntityType { Active, Airdrop, Bag, Backpack, Boat, Bradley, Car, CargoPlane, CargoShip, CCTV, CH47, Box, Col, TC, TCArrow, Dead, Drop, Limit, Loot, Heli, Mini, MLRS, Npc, Ore, Horse, RHIB, Sleeper, Stash, Trap, Turret }
        private List<string> _tags = new() { "ore", "cluster", "1", "2", "3", "4", "5", "6", "_", ".", "-", "deployed", "wooden", "large", "pile", "prefab", "collectable", "loot", "small" };
        private List<EntityType> _errorTypes = new();
        private List<Radar> _radars = new();
        private List<BaseEntity> _spawnedEntities = new();
        private Dictionary<NetworkableId, Vector3> _despawnedEntities = new();
        private Dictionary<NetworkableId, BaseEntity> _allEntities = new();
        private Dictionary<string, float> _cooldowns = new();
        private Dictionary<ulong, string> _clans = new();
        private Dictionary<ulong, string> _teamColors = new();
        private Dictionary<string, string> _clanColors = new();
        private Array _allEntityTypes = Enum.GetValues(typeof(EntityType));
        private CoroutineTimer _coroutineTimer = new(1.0f);
        private Stack<Coroutine> _coroutines = new();
        private StoredData data = new();
        private bool _isPopulatingCache;
        private bool isUnloading;
        private Cache cache;

        private class StoredData
        {
            public Dictionary<ulong, UiOffsets> Offsets = new();
            public Dictionary<string, int> EntityTextSize = new();
            public Dictionary<string, int> EntityNameSize = new();
            public Dictionary<string, int> PlayerTextSize = new();
            public Dictionary<string, int> PlayerNameSize = new();
            public List<string> Extended = new();
            public Dictionary<string, List<string>> Filters = new();
            public List<string> Hidden = new();
            public List<string> OnlineBoxes = new();
            public List<string> Visions = new();
            public List<string> Active = new();
            public StoredData() { }
            public void Init()
            {
                Offsets ??= new();
                EntityTextSize ??= new();
                EntityNameSize ??= new();
                PlayerTextSize ??= new();
                PlayerNameSize ??= new();
                Extended ??= new();
                Filters ??= new();
                Hidden ??= new();
                OnlineBoxes ??= new();
                Visions ??= new();
                Active ??= new();
            }
        }

        private class Cache
        {
            public Cache(AdminRadar instance)
            {
                config = instance.config;
                this.instance = instance;
            }

            public Configuration config;
            public AdminRadar instance;
            internal EntityType entityType;
            public Dictionary<NetworkableId, EntityInfo> Airdrops { get; private set; } = new();
            public Dictionary<NetworkableId, EntityInfo> Animals { get; private set; } = new();
            public Dictionary<NetworkableId, EntityInfo> Backpacks { get; private set; } = new();
            public Dictionary<NetworkableId, EntityInfo> Bags { get; private set; } = new();
            public Dictionary<NetworkableId, EntityInfo> Boats { get; private set; } = new();
            public Dictionary<NetworkableId, EntityInfo> BradleyAPCs { get; private set; } = new();
            public Dictionary<NetworkableId, EntityInfo> CargoPlanes { get; private set; } = new();
            public Dictionary<NetworkableId, EntityInfo> CargoShips { get; private set; } = new();
            public Dictionary<NetworkableId, EntityInfo> Cars { get; private set; } = new();
            public Dictionary<NetworkableId, EntityInfo> CCTV { get; private set; } = new();
            public Dictionary<NetworkableId, EntityInfo> CH47 { get; private set; } = new();
            public Dictionary<NetworkableId, EntityInfo> Cupboards { get; private set; } = new();
            public Dictionary<NetworkableId, EntityInfo> Collectibles { get; private set; } = new();
            public Dictionary<NetworkableId, EntityInfo> Containers { get; private set; } = new();
            public Dictionary<NetworkableId, EntityInfo> Corpses { get; private set; } = new();
            public Dictionary<NetworkableId, EntityInfo> Drops { get; private set; } = new();
            public Dictionary<NetworkableId, EntityInfo> Helicopters { get; private set; } = new();
            public Dictionary<NetworkableId, EntityInfo> MiniCopter { get; private set; } = new();
            public Dictionary<NetworkableId, EntityInfo> MLRS { get; private set; } = new();
            public Dictionary<NetworkableId, EntityInfo> NPCPlayers { get; set; } = new();
            public Dictionary<NetworkableId, EntityInfo> Ores { get; private set; } = new();
            public Dictionary<NetworkableId, EntityInfo> RHIB { get; private set; } = new();
            public Dictionary<NetworkableId, EntityInfo> RidableHorse { get; private set; } = new();
            public Dictionary<NetworkableId, EntityInfo> Turrets { get; private set; } = new();
            public Dictionary<NetworkableId, EntityInfo> Traps { get; private set; } = new();

            public bool Add(BaseEntity entity)
            {
                if (entity.IsKilled())
                {
                    return false;
                }
                if (IsDrop(entity))
                {
                    Add_Internal<BaseEntity, EntityInfo>(Drops, entity, EntityType.Drop);
                }
                if (entity is BasePlayer player)
                {
                    Interface.Oxide.NextTick(() =>
                    {
                        if (player.IsKilled())
                        {
                            return;
                        }
                        if (player.userID.IsSteamId())
                        {
                            instance._radars.ForEach(radar => radar.TryCacheOnlinePlayer(player));
                        }
                        else if (config.Core.NPCPlayer && !NPCPlayers.TryGetValue(entity.net.ID, out var ei))
                        {
                            NPCPlayers[entity.net.ID] = ei = new(player, EntityType.Npc, config.Distance.Get);
                            instance.TryCacheByType(EntityType.Npc, ei);
                        }
                    });
                    return false;
                }
                if (config.Core.Dead && entity is PlayerCorpse corpse)
                {
                    Interface.Oxide.NextTick(() =>
                    {
                        if (!corpse.IsKilled() && corpse.playerSteamID.IsSteamId() && !Corpses.TryGetValue(entity.net.ID, out var ei))
                        {
                            Corpses[entity.net.ID] = ei = new(entity, EntityType.Dead, config.Distance.Get);
                            ei.name = corpse.parentEnt?.ToString() ?? corpse.playerSteamID.ToString();
                            instance.TryCacheByType(EntityType.Dead, ei);
                        }
                    });
                    return false;
                }
                if ((config.Additional.Traps || config.GUI.Traps) && IsTrap(entity) && Add_Internal<BaseEntity, EntityInfo>(Traps, entity, EntityType.Trap))
                {
                    return true;
                }
                if (config.Additional.RH && Add_Internal<RidableHorse, EntityInfo>(RidableHorse, entity, EntityType.Horse))
                {
                    return true;
                }
                if (config.Core.Animals && Add_Internal<BaseNpc, EntityInfo>(Animals, entity, EntityType.Npc))
                {
                    return true;
                }
                if (config.Core.Animals && Add_Internal<BaseNPC2, EntityInfo>(Animals, entity, EntityType.Npc))
                {
                    return true;
                }
                if (config.Core.Animals && Add_Internal<SimpleShark, EntityInfo>(Animals, entity, EntityType.Npc))
                {
                    return true;
                }
                if (config.Core.Loot && entity is TrainCarUnloadable tcu && Add_Internal<StorageContainer, EntityInfo>(Containers, tcu.GetStorageContainer(), EntityType.Loot))
                {
                    return true;
                }
                if ((config.Core.Loot || config.Core.Box || config.Core.Stash) && entity is StorageContainer && TryGetContainerType(entity, out entityType) && Add_Internal<StorageContainer, EntityInfo>(Containers, entity, entityType))
                {
                    return true;
                }
                if (config.Core.Col && entity is CollectibleEntity && Add_Internal<CollectibleEntity, EntityInfo>(Collectibles, entity, EntityType.Col))
                {
                    return true;
                }
                if (config.Core.Ore && entity is OreResourceEntity && Add_Internal<OreResourceEntity, EntityInfo>(Ores, entity, EntityType.Ore))
                {
                    return true;
                }
                if ((config.Additional.Cars || config.GUI.Cars) && (Add_Internal<BasicCar, EntityInfo>(Cars, entity, EntityType.Car) || Add_Internal<ModularCar, EntityInfo>(Cars, entity, EntityType.Car) || Add_Internal<Bike, EntityInfo>(Cars, entity, EntityType.Car)))
                {
                    return true;
                }
                if ((config.Additional.CP || config.GUI.CP) && entity.prefabID == 2383782438 && Add_Internal<BaseEntity, EntityInfo>(CargoPlanes, entity, EntityType.CargoPlane))
                {
                    return true;
                }
                if (config.Core.Bags && Add_Internal<SleepingBag, EntityInfo>(Bags, entity, EntityType.Bag))
                {
                    return true;
                }
                if (config.Core.TC && Add_Internal<BuildingPrivlidge, EntityInfo>(Cupboards, entity, EntityType.TC))
                {
                    return true;
                }
                if ((config.Additional.CCTV || config.GUI.CCTV) && Add_Internal<CCTV_RC, EntityInfo>(CCTV, entity, EntityType.CCTV))
                {
                    return true;
                }
                if (config.Core.Airdrop && Add_Internal<SupplyDrop, EntityInfo>(Airdrops, entity, EntityType.Airdrop))
                {
                    return true;
                }
                if (config.Core.Loot && Add_Internal<DroppedItemContainer, EntityInfo>(Backpacks, entity, EntityType.Backpack))
                {
                    return true;
                }
                if (config.Core.Loot && entity is WorldItem wi && wi.item != null && wi.item.IsBackpack() && Add_Internal<WorldItem, EntityInfo>(Backpacks, entity, EntityType.Backpack))
                {
                    return true;
                }
                if ((config.Additional.Heli || config.GUI.Heli) && Add_Internal<PatrolHelicopter, EntityInfo>(Helicopters, entity, EntityType.Heli))
                {
                    return true;
                }
                if ((config.Additional.Bradley || config.GUI.Bradley) && (Add_Internal<BradleyAPC, EntityInfo>(BradleyAPCs, entity, EntityType.Bradley))) // || Add_Internal<TravellingVendor, EntityInfo>(BradleyAPCs, entity, EntityType.Bradley)))
                {
                    return true;
                }
                if ((config.Additional.RHIB || config.GUI.RHIB) && Add_Internal<RHIB, EntityInfo>(RHIB, entity, EntityType.RHIB))
                {
                    return true;
                }
                if ((config.Additional.Boats || config.GUI.Boats) && Add_Internal<BaseBoat, EntityInfo>(Boats, entity, EntityType.Boat))
                {
                    return true;
                }
                if ((config.Additional.MC || config.GUI.MC) && (Add_Internal<Minicopter, EntityInfo>(MiniCopter, entity, EntityType.Mini) || Add_Internal<AttackHelicopter, EntityInfo>(MiniCopter, entity, EntityType.Mini)))
                {
                    return true;
                }
                if ((config.Additional.CH47 || config.GUI.CH47) && Add_Internal<CH47Helicopter, EntityInfo>(CH47, entity, EntityType.CH47))
                {
                    return true;
                }
                if ((config.Additional.CS || config.GUI.CS) && Add_Internal<CargoShip, EntityInfo>(CargoShips, entity, EntityType.CargoShip))
                {
                    return true;
                }
                if (config.Core.Turrets && Add_Internal<AutoTurret, EntityInfo>(Turrets, entity, EntityType.Turret))
                {
                    return true;
                }
                if ((config.Additional.MLRS || config.GUI.MLRS) && Add_Internal<MLRSRocket, EntityInfo>(MLRS, entity, EntityType.MLRS))
                {
                    return true;
                }
                return false;
            }

            private bool TryGetContainerType(BaseEntity entity, out EntityType type)
            {
                if (entity is LockedByEntCrate || IsLoot(entity)) { type = EntityType.Loot; return true; }
                if (entity is StashContainer) { type = EntityType.Stash; return true; }
                if (IsBox(entity)) { type = EntityType.Box; return true; }
                type = (EntityType)0;
                return false;
            }

            public bool Remove(NetworkableId nid, Vector3 entityPos)
            {
                instance._radars.ForEach(radar => radar.RemoveByNetworkId(nid));
                if (Remove_Internal(Airdrops, nid)) return true;
                if (Remove_Internal(Animals, nid)) return true;
                if (Remove_Internal(Backpacks, nid)) return true;
                if (Remove_Internal(Bags, nid)) return true;
                if (Remove_Internal(Boats, nid)) return true;
                if (Remove_Internal(BradleyAPCs, nid)) return true;
                if (Remove_Internal(CargoPlanes, nid)) return true;
                if (Remove_Internal(CargoShips, nid)) return true;
                if (Remove_Internal(Cars, nid)) return true;
                if (Remove_Internal(CCTV, nid)) return true;
                if (Remove_Internal(CH47, nid)) return true;
                if (Remove_Internal(Collectibles, nid)) return true;
                if (Remove_Internal(Containers, nid)) return true;
                if (Remove_Internal(Corpses, nid)) return true;
                if (Remove_Internal(Cupboards, nid)) return true;
                if (Remove_Internal(Helicopters, nid)) return true;
                if (Remove_Internal(MiniCopter, nid)) return true;
                if (Remove_Internal(MLRS, nid)) return true;
                if (Remove_Internal(NPCPlayers, nid)) return true;
                if (Remove_Internal(Ores, nid)) return true;
                if (Remove_Internal(RHIB, nid)) return true;
                if (Remove_Internal(RidableHorse, nid)) return true;
                if (Remove_Internal(Traps, nid)) return true;
                if (Remove_Internal(Turrets, nid)) return true;
                return false;
            }

            private bool Add_Internal<TLookFor, TTargetType>(Dictionary<NetworkableId, EntityInfo> cachedList, BaseEntity entity, EntityType type)
            {
                if (entity is TLookFor && !entity.IsKilled() && !cachedList.TryGetValue(entity.net.ID, out var ei))
                {
                    cachedList[entity.net.ID] = ei = new(entity, type, config.Distance.Get, instance.StripTags);
                    instance.TryCacheByType(type, ei);
                    return true;
                }
                return false;
            }

            private bool Remove_Internal<TType, TKeyType>(Dictionary<TKeyType, TType> cachedList, TKeyType key)
            {
                return cachedList.Remove(key);
            }

#if DEBUG
            public void Print()
            {
                StringBuilder sb = StringBuilderCache.Acquire();

                sb.AppendLine($"{nameof(Airdrops)}: {Airdrops.Count}");
                sb.AppendLine($"{nameof(Animals)}: {Animals.Count}");
                sb.AppendLine($"{nameof(Backpacks)}: {Backpacks.Count}");
                sb.AppendLine($"{nameof(Bags)}: {Bags.Count}");
                sb.AppendLine($"{nameof(Boats)}: {Boats.Count}");
                sb.AppendLine($"{nameof(BradleyAPCs)}: {BradleyAPCs.Count}");
                sb.AppendLine($"{nameof(CargoPlanes)}: {CargoPlanes.Count}");
                sb.AppendLine($"{nameof(CargoShips)}: {CargoShips.Count}");
                sb.AppendLine($"{nameof(Cars)}: {Cars.Count}");
                sb.AppendLine($"{nameof(CCTV)}: {CCTV.Count}");
                sb.AppendLine($"{nameof(CH47)}: {CH47.Count}");
                sb.AppendLine($"{nameof(Collectibles)}: {Collectibles.Count}");
                sb.AppendLine($"{nameof(Containers)}: {Containers.Count}");
                sb.AppendLine($"{nameof(Corpses)}: {Corpses.Count}");
                sb.AppendLine($"{nameof(Cupboards)}: {Cupboards.Count}");
                sb.AppendLine($"{nameof(Helicopters)}: {Helicopters.Count}");
                sb.AppendLine($"{nameof(MiniCopter)}: {MiniCopter.Count}");
                sb.AppendLine($"{nameof(MLRS)}: {MLRS.Count}");
                sb.AppendLine($"{nameof(NPCPlayers)}: {NPCPlayers.Count}");
                sb.AppendLine($"{nameof(Ores)}: {Ores.Count}");
                sb.AppendLine($"{nameof(RHIB)}: {RHIB.Count}");
                sb.AppendLine($"{nameof(RidableHorse)}: {RidableHorse.Count}");
                sb.AppendLine($"{nameof(Traps)}: {Traps.Count}");
                sb.AppendLine($"{nameof(Turrets)}: {Turrets.Count}");

                instance.Puts(StringBuilderCache.GetStringAndRelease(sb));
            }
#endif
            public bool IsDrop(BaseEntity entity)
            {
                if (entity is DroppedItem || entity is Landmine || entity is BearTrap || entity is DroppedItemContainer || entity is RFTimedExplosive)
                {
                    return !config.Settings.DropExceptions.Exists(entity.ShortPrefabName.Contains);
                }
                return false;
            }

            public bool IsTrap(BaseNetworkable entity)
            {
                return entity is BaseTrap || config.Options.AdditionalTraps.Exists(entity.ShortPrefabName.Contains);
            }

            public bool IsLoot(BaseNetworkable entity)
            {
                if (config.Core.Loot)
                {
                    if (entity is WorldItem wi)
                    {
                        return wi.item != null && wi.item.IsBackpack();
                    }
                    return entity is TrainCarUnloadable || entity.ShortPrefabName == "campfire"
                            || entity.ShortPrefabName.Contains("loot", CompareOptions.IgnoreCase)
                            || entity.ShortPrefabName.Contains("crate_", CompareOptions.IgnoreCase)
                            || entity.ShortPrefabName.Contains("trash", CompareOptions.IgnoreCase)
                            || entity.ShortPrefabName.Contains("hackable", CompareOptions.IgnoreCase)
                            || entity.ShortPrefabName.Contains("oil", CompareOptions.IgnoreCase)
                            || entity.ShortPrefabName.Contains("vehicle_parts")
                            || entity.ShortPrefabName.Contains("foodbox");
                }
                return false;
            }

            public bool IsBox(BaseNetworkable entity)
            {
                if (config.Core.Box)
                {
                    return config.Options.AdditionalBoxes.Exists(entity.ShortPrefabName.Contains);
                }
                return false;
            }
        }

        private class CoroutineTimer
        {
            private Stopwatch stopwatch = new();
            private float _maxDurationMs;
            private bool _isRunning;
            //public bool ForceStop { get; set; }
            public double Elapsed => stopwatch.Elapsed.TotalMilliseconds;

            public CoroutineTimer(float maxDurationMs)
            {
                _maxDurationMs = maxDurationMs;
            }

            public void Start()
            {
                stopwatch.Start();
                _isRunning = true;
            }

            public bool ShouldYield()
            {
                _isRunning = stopwatch.Elapsed.TotalMilliseconds < _maxDurationMs;

                if (!_isRunning)
                {
#if DEBUG
                    double milliseconds = Elapsed;
                    if (stopwatch.Elapsed.TotalMilliseconds > 2f * _maxDurationMs)
                    {
                        Interface.Oxide.LogInfo($"[AdminRadar] Time slice took {Elapsed} when it should be around {_maxDurationMs}");
                    }
#endif
                }
                return !_isRunning;
            }

            public void ResetIfYielded()
            {
                if (_isRunning) return;

                stopwatch.Restart();
                _isRunning = true;
            }
        }

        internal static class StringBuilderCache
        {
            [ThreadStatic]
            private static StringBuilder builder;

            public static StringBuilder Acquire(string text = "")
            {
                StringBuilder cached = builder;
                if (cached != null)
                {
                    builder = null;
                    cached.Clear();
                    cached.Append(text);
                    return cached;
                }
                return new(text);
            }

            public static void Clear()
            {
                if (builder != null)
                {
                    builder.Clear();
                    builder = null;
                }
            }

            public static string GetStringAndRelease(StringBuilder sb)
            {
                string result = sb.ToString();
                builder = sb;
                return result;
            }
        }

        public class EntityInfo
        {
            public BuildingPrivlidge priv;
            public BaseEntity entity;
            public EntityType type;
            public Color color;
            public Vector3 _from;
            public Vector3 to;
            public Vector3 offset;
            public string name;
            public object info;
            public float dist;
            public float sqrdist;
            public float size = 0.5f;
            public Transform t;
            public Network.Visibility.Group group => entity?.net?.group;
            public Vector3 from => (t == null ? _from : _from = t.position) + offset;
            public EntityInfo() { }
            public EntityInfo(BaseEntity entity, EntityType type, Func<EntityType, BaseEntity, float> getDistance, Func<string, string> stripTags = null)
            {
                if (stripTags != null)
                {
                    name = stripTags(entity.ShortPrefabName);
                }
                if (getDistance != null)
                {
                    dist = getDistance(type, entity);
                    sqrdist = dist * dist;
                }
                if (type == EntityType.TC)
                {
                    priv = entity as BuildingPrivlidge;
                }
                this.type = type;
                this.entity = entity;
                t = entity.transform;
                _from = t.position;
            }
        }

        private class Radar : FacepunchBehaviour
        {
            private static Func<char, bool> abbr = c => char.IsUpper(c) || char.IsDigit(c);

            public class DataObject : Pool.IPooled
            {
                public EntityInfo ei;
                public Action action;
                public DrawFlags flags;
                public bool disabled;
                public DataObject() { }
                public bool HasFlag(DrawFlags flag)
                {
                    return ((flags & flag) == flag);
                }
                public void SetEnabled(Network.Visibility.Group group, Vector3 to, float max)
                {
                    disabled = ei == null || ei.group != group && (ei.from - to).sqrMagnitude > Mathf.Max(max * max, ei.sqrdist);
                }
                public bool IsOfType(EntityType type)
                {
                    if (type != EntityType.Loot)
                    {
                        return ei.type == type;
                    }
                    return ei.type == EntityType.Loot || ei.type == EntityType.Backpack;
                }
                public void Reset()
                {
                    ei = null;
                    action = null;
                    disabled = false;
                    flags = DrawFlags.None;
                }
                public void EnterPool()
                {
                    Reset();
                }
                public void LeavePool()
                {
                    Reset();
                }
            }

            internal class DistantPlayer : Pool.IPooled
            {
                public Vector3 pos;
                public bool alive;
                public DistantPlayer()
                {
                }
                public void Reset()
                {
                    pos = default;
                    alive = false;
                }
                public void EnterPool()
                {
                    Reset();
                }
                public void LeavePool()
                {
                    Reset();
                }
            }

            internal bool setSource = true, canGetExistingBackpacks = true, isEnabled = true, canBypassOverride, hasPermAllowed, isAdmin, showHT, showAll;
            internal int inactiveSeconds, activatedSeconds, checks;
            internal float currDistance, invokeTime, maxDistance;
            internal string username, userid;
            internal RaycastHit hit;
            internal EntityType currType;
            internal Vector3 position;
            internal BaseEntity source;
            internal BasePlayer player;
            internal AdminRadar instance;
            internal Network.Visibility.Group group;
            internal ItemContainer _backpackItemContainer;
            internal Coroutine _radarCo, _updateCo, _groupCo;
            internal List<ulong> exclude = Pool.Get<List<ulong>>();
            internal List<NetworkableId> removeByNetworkId = Pool.Get<List<NetworkableId>>();
            internal List<EntityType> entityTypes = Pool.Get<List<EntityType>>();
            internal List<DistantPlayer> distant = Pool.Get<List<DistantPlayer>>();
            internal List<EntityType> removeByEntityType = Pool.Get<List<EntityType>>();
            internal Dictionary<NetworkableId, DataObject> data = Pool.Get<Dictionary<NetworkableId, DataObject>>();
            internal Dictionary<EntityType, Action> filters = Pool.Get<Dictionary<EntityType, Action>>();
            internal Dictionary<ulong, ItemContainer> backpacks = Pool.Get<Dictionary<ulong, ItemContainer>>();
            internal Dictionary<ulong, float> Voices = Pool.Get<Dictionary<ulong, float>>();
            internal List<ulong> VoiceExpirations = Pool.Get<List<ulong>>();

            internal Cache Cache => instance.cache;
            internal Configuration config => instance.config;
            internal float delay => invokeTime + 0.05f;

            internal float Distance(Vector3 a)
            {
                float sqrMagnitude = (a - position).sqrMagnitude;

                return Mathf.Ceil(Mathf.Sqrt(sqrMagnitude));
            }

            public Vector3 limitUp;
            public Vector3 halfUp = new(0f, 0.5f);
            public Vector3 twoHalfUp = new(0f, 2.5f);
            public Vector3 twoUp = new(0f, 2f);
            public Vector3 fiveUp = new(0f, 5f);

            private void Awake()
            {
                source = player = GetComponent<BasePlayer>();
                isAdmin = player.IsAdmin;
                userid = player.UserIDString;
                username = player.displayName;
                position = player.transform.position;
                exclude.Add(player.userID);
            }

            private void OnDestroy()
            {
                isEnabled = false;
                Interface.CallHook("OnRadarDeactivated", player, username, userid, position);
                if (config.Settings.Cooldown > 0f)
                {
                    instance._cooldowns[userid] = Time.realtimeSinceStartup + config.Settings.Cooldown;
                }
                if (config.Settings.ShowToggle)
                {
                    instance.Message(player, "Deactivated");
                }
                if (instance._radars.Remove(this) && instance._radars.Count == 0 && !instance.isUnloading)
                {
                    instance.Unsubscribe(nameof(OnPlayerRespawned));
                }
                instance.DestroyUI(player);
                ResetToPool();
                StopAll();
            }

            private void ResetToPool()
            {
                for (int i = distant.Count - 1; i >= 0; i--)
                {
                    var obj = distant[i];
                    if (obj != null)
                    {
                        Pool.Free(ref obj);
                    }
                    distant[i] = null;
                }
                for (int i = data.Count - 1; i >= 0; i--)
                {
                    var obj = data.ElementAt(i);
                    if (obj.Value != null)
                    {
                        var value = obj.Value;
                        value.Reset();
                        Pool.Free(ref value);
                    }
                }
                data.ResetToPool();
                Voices.ResetToPool();
                exclude.ResetToPool();
                distant.ResetToPool();
                filters.ResetToPool();
                backpacks.ResetToPool();
                entityTypes.ResetToPool();
                VoiceExpirations.ResetToPool();
                removeByNetworkId.ResetToPool();
                removeByEntityType.ResetToPool();
            }

            public bool Add(EntityType type)
            {
                if (type == EntityType.Loot && !entityTypes.Contains(EntityType.Backpack))
                {
                    entityTypes.Add(EntityType.Backpack);
                }
                if (!entityTypes.Contains(type))
                {
                    entityTypes.Add(type);
                    return true;
                }
                return false;
            }

            public void Init(AdminRadar instance)
            {
                this.instance = instance;
                this.limitUp = new(0f, config.Limit.Height);
                this.instance._radars.Add(this);
                canBypassOverride = HasPermission(userid, "adminradar.bypass.override");
                hasPermAllowed = HasPermission(userid, "adminradar.allowed");
                InvokeRepeating(Activity, 0f, 1f);
                Interface.CallHook("OnRadarActivated", player, username, userid, position);
                if (instance._radars.Count == 1)
                {
                    instance.Subscribe(nameof(OnPlayerRespawned));
                }
            }

            public void StopAll()
            {
                if (_radarCo != null)
                {
                    StopCoroutine(_radarCo);
                    _radarCo = null;
                }
                if (_updateCo != null)
                {
                    StopCoroutine(_updateCo);
                    _updateCo = null;
                }
                if (_groupCo != null)
                {
                    StopCoroutine(_groupCo);
                    _groupCo = null;
                }
                try { CancelInvoke(Activity); } catch { }
                try { RemoveAdminFlag(); } catch { }
            }

            public bool GetBool(EntityType type)
            {
                return entityTypes.Contains(type);
            }

            private void Activity()
            {
                inactiveSeconds = position == player.transform.position ? inactiveSeconds + 1 : 0;
                position = source.transform.position;
                if (source != player)
                {
                    inactiveSeconds = 0;
                    return;
                }
                if (config.Settings.DeactivateSeconds > 0 && ++activatedSeconds >= config.Settings.DeactivateSeconds)
                {
                    isEnabled = false;
                    Destroy(this);
                }
                if (config.Settings.InactiveSeconds > 0 && inactiveSeconds >= config.Settings.InactiveSeconds)
                {
                    isEnabled = false;
                    Destroy(this);
                }
            }

            private class Idle
            {
                public BasePlayer player;
                public Vector3 lastPosition;
                public float lastMovementTime;
            }

            private Dictionary<ulong, Idle> _idle = new();

            private double GetIdleTime(BasePlayer target)
            {
                Vector3 currPosition = target.transform.position;
                if (!_idle.TryGetValue(target.userID, out var idle))
                {
                    _idle[target.userID] = idle = new();
                    idle.lastPosition = currPosition;
                    idle.lastMovementTime = Time.time;
                    idle.player = target;
                    return 0;
                }
                if (idle.lastPosition != currPosition)
                {
                    idle.lastPosition = currPosition;
                    idle.lastMovementTime = Time.time;
                }
                double time = Math.Round((Time.time - idle.lastMovementTime) / 60.0, config.Settings.IdleRoundDigits);
                return time > 0 ? time : 0;
            }

            private void RemoveIdleTime()
            {
                if (_idle.Count > 0)
                {
                    foreach (var pair in _idle)
                    {
                        if (pair.Value.player == null || !pair.Value.player.IsConnected)
                        {
                            _idle.Remove(pair.Key);
                            break;
                        }
                    }
                }
            }

            private void SetupFilter(EntityType type, Action action)
            {
                if (entityTypes.Contains(type))
                {
                    if (_radarCo != null)
                    {
                        action();
                    }
                    filters[type] = action;
                }
                else if (filters.Remove(type))
                {
                    RemoveByEntityType(type);
                }
            }

            public void SetupFilters(bool barebones)
            {
                if (_updateCo != null)
                {
                    StopCoroutine(_updateCo);
                }
                SetupFilter(EntityType.Active, ShowActive);
                SetupFilter(EntityType.Sleeper, ShowSleepers);
                if (!barebones)
                {
                    SetupFilters();
                }
                if (_radarCo == null)
                {
                    CheckNetworkGroupChange();

                    _radarCo = StartCoroutine(DoRadarRoutine());
                }
                if (_groupCo == null && config.Limit.Enabled)
                {
                    _groupCo = StartCoroutine(DoGroupLimitRoutine());
                }
                DoRemoves();
            }

            private void SetupFilters()
            {
                SetupFilter(EntityType.TC, ShowTC);
                SetupFilter(EntityType.Bag, ShowBags);
                SetupFilter(EntityType.Box, ShowBox);
                SetupFilter(EntityType.Ore, ShowOre);
                SetupFilter(EntityType.Npc, ShowNPC);
                SetupFilter(EntityType.CCTV, ShowCCTV);
                SetupFilter(EntityType.Dead, ShowDead);
                SetupFilter(EntityType.Drop, ShowDrops);
                SetupFilter(EntityType.Heli, ShowHeli);
                SetupFilter(EntityType.Loot, ShowLoot);
                SetupFilter(EntityType.Stash, ShowStash);
                SetupFilter(EntityType.Turret, ShowTurrets);
                SetupFilter(EntityType.Bradley, ShowBradley);
                SetupFilter(EntityType.Col, ShowCollectibles);
                SetupFilter(EntityType.Airdrop, ShowSupplyDrops);
                SetupFilter(EntityType.Car, () => ShowEntity(EntityType.Car, Cache.Cars));
                SetupFilter(EntityType.CH47, () => ShowEntity(EntityType.CH47, Cache.CH47));
                SetupFilter(EntityType.MLRS, () => ShowEntity(EntityType.MLRS, Cache.MLRS));
                SetupFilter(EntityType.RHIB, () => ShowEntity(EntityType.RHIB, Cache.RHIB));
                SetupFilter(EntityType.Boat, () => ShowEntity(EntityType.Boat, Cache.Boats));
                SetupFilter(EntityType.Trap, () => ShowEntity(EntityType.Trap, Cache.Traps));
                SetupFilter(EntityType.Mini, () => ShowEntity(EntityType.Mini, Cache.MiniCopter));
                SetupFilter(EntityType.Horse, () => ShowEntity(EntityType.Horse, Cache.RidableHorse));
                SetupFilter(EntityType.CargoShip, () => ShowEntity(EntityType.CargoShip, Cache.CargoShips));
                SetupFilter(EntityType.CargoPlane, () => ShowEntity(EntityType.CargoPlane, Cache.CargoPlanes));
            }

            private IEnumerator DoGroupLimitRoutine()
            {
                while (isEnabled)
                {
                    ShowGroupLimits();

                    yield return CoroutineEx.waitForSeconds(invokeTime);
                }
            }

            private IEnumerator DoUpdateRoutine()
            {
                SetEnabledDataObjects();

                foreach (var filter in filters)
                {
                    filter.Value();

                    if (checks >= 100)
                    {
                        checks = 0;
                        yield return CoroutineEx.waitForFixedUpdate;
                    }
                }
            }

            private IEnumerator DoRadarRoutine()
            {
                while (isEnabled)
                {
                    if (player == null || !player.IsConnected || instance.isUnloading)
                    {
                        isEnabled = false;
                        Destroy(this);
                        yield break;
                    }

                    if (!SetSource())
                    {
                        yield return CoroutineEx.waitForSeconds(0.1f);
                        continue;
                    }

                    DoRemoves();
                    SetAdminFlag();
                    DirectDrawAll();
                    RemoveAdminFlag();
                    CheckNetworkGroupChange();

                    checks = 0;

                    yield return CoroutineEx.waitForSeconds(invokeTime);
                }
            }

            private void DoRemoves()
            {
                if (data.Count != 0)
                {
                    foreach (var pair in data)
                    {
                        if (pair.Value.ei == null || !pair.Value.ei.entity.IsValid())
                        {
                            removeByNetworkId.Add(pair.Key);
                            pair.Value.disabled = true;
                        }
                    }
                }
                if (removeByEntityType.Count != 0)
                {
                    foreach (var type in removeByEntityType)
                    {
                        RemoveByEntityType(type);
                        entityTypes.Remove(type);
                        filters.Remove(type);
                    }
                    removeByEntityType.Clear();
                }
                if (removeByNetworkId.Count != 0)
                {
                    foreach (var nid in removeByNetworkId)
                    {
                        RemoveByNetworkId(nid);
                    }
                    removeByNetworkId.Clear();
                }
            }

            private void CheckNetworkGroupChange()
            {
                if (group == player.net.group)
                {
                    return;
                }
                group = player.net.group;
                if (_updateCo != null)
                {
                    StopCoroutine(_updateCo);
                }
                if (filters.ContainsKey(EntityType.Npc))
                {
                    RemoveByEntityType(EntityType.Npc);
                    DoRemoves();
                }
                _updateCo = StartCoroutine(DoUpdateRoutine());
            }

            public void SetEnabledDataObjects()
            {
                foreach (var pair in data)
                {
                    pair.Value.SetEnabled(group, position, maxDistance);
                }
            }

            public void RemoveByEntityType(EntityType type)
            {
                foreach (var pair in data)
                {
                    if (pair.Value.IsOfType(type))
                    {
                        removeByNetworkId.Add(pair.Key);
                        pair.Value.disabled = true;
                    }
                }
            }

            public void RemoveByNetworkId(NetworkableId nid)
            {
                if (data.Remove(nid, out var obj))
                {
                    if (obj != null)
                    {
                        Pool.Free(ref obj);
                    }
                }
            }

            public void TryCacheByType(EntityType type, EntityInfo ei)
            {
                try
                {
                    if (!entityTypes.Contains(type) || !ei.entity.IsValid() || ei.entity.net.group != group && Distance(ei._from) > ei.dist)
                    {
                        return;
                    }
                    switch (type)
                    {
                        case EntityType.Airdrop: { CacheAirdrop(ei); break; }
                        case EntityType.Backpack: { CacheBackpack(ei); break; }
                        case EntityType.Bag: { CacheSleepingBag(ei); break; }
                        case EntityType.Box: { CacheContainer(ei); break; }
                        case EntityType.Bradley: { CacheBradley(ei); break; }
                        case EntityType.CCTV: { CacheCCTV(ei); break; }
                        case EntityType.Col: { CacheCol(ei); break; }
                        case EntityType.Dead: { CacheDead(ei); break; }
                        case EntityType.Heli: { CacheHeli(ei); break; }
                        case EntityType.Loot: { CacheLoot(ei); break; }
                        case EntityType.Npc: { CacheNpc(ei); break; }
                        case EntityType.Ore: { CacheOre(ei); break; }
                        case EntityType.Stash: { CacheStash(ei); break; }
                        case EntityType.TC: { CacheTC(ei); break; }
                        case EntityType.Turret: { CacheTurret(ei); break; }
                        default: { CacheEntity(ei, type); break; }
                    }
                }
                catch (Exception ex)
                {
                    currType = type;
                    HandleException(ex);
                }
            }

            private DataObject cobj;
            private DrawFlags cflag;

            private void DirectDrawAll()
            {
                float delay = this.delay;

                foreach (var pair in data)
                {
                    cobj = pair.Value;
                    if (cobj == null || cobj.ei == null || cobj.disabled)
                    {
                        continue;
                    }
                    cflag = DrawFlags.Arrow;
                    if (cobj.HasFlag(DrawFlags.Arrow))
                    {
                        player.SendConsoleCommand("ddraw.arrow", delay, cobj.ei.color, cobj.ei.from, cobj.ei.to, cobj.ei.size);
                    }
                    cflag = DrawFlags.Box;
                    if (cobj.HasFlag(DrawFlags.Box))
                    {
                        player.SendConsoleCommand("ddraw.box", delay, cobj.ei.color, cobj.ei.from, cobj.ei.size);
                    }
                    cflag = DrawFlags.Text;
                    if (cobj.HasFlag(DrawFlags.Text))
                    {
                        try { cobj.action(); } catch (Exception ex) { HandleException(pair.Key, ex); continue; }
                        if (cobj.ei.info == null) { continue; }
                        player.SendConsoleCommand("ddraw.text", delay, cobj.ei.color, cobj.ei.from, cobj.ei.info);
                    }
                }
            }

            private void DrawVisionArrow(BasePlayer target, float dist)
            {
                if (dist <= 150f && instance.data.Visions.Contains(userid) && Physics.Raycast(target.eyes.HeadRay(), out hit, Mathf.Infinity))
                {
                    DrawArrow(Color.red, target.eyes.position + new Vector3(0f, 0.115f, 0f), hit.point, 0.15f, true);
                }
            }

            private void DrawVoiceArrow(BasePlayer target, Vector3 a, float dist)
            {
                if (Voices.Count > 0 && dist <= config.Voice.Distance && Voices.ContainsKey(target.userID))
                {
                    DrawArrow(Color.yellow, a + fiveUp, a + twoHalfUp, 0.5f, true);
                }
            }

            private void DrawArrow(Color color, Vector3 from, Vector3 to, float size, bool @override = false)
            {
                if (config.Methods.Arrow || @override)
                {
                    if (player == null || !player.IsConnected) { return; }
                    player.SendConsoleCommand("ddraw.arrow", delay, color, from, to, size);
                }
            }

            private void DrawPlayerText(Color color, Vector3 position, object prefix, object text, bool @override = false)
            {
                if (config.Methods.Text || @override)
                {
                    if (player == null || !player.IsConnected) { return; }
                    player.SendConsoleCommand("ddraw.text", delay, color, position, Format(prefix, text, false));
                }
            }

            private void DrawBox(Color color, Vector3 position, float size, bool @override = false)
            {
                if (config.Methods.Box || @override)
                {
                    if (player == null || !player.IsConnected) { return; }
                    player.SendConsoleCommand("ddraw.box", delay, color, position, size);
                }
            }

            private void CacheArrow(DataObject obj, Color color, Vector3 offset, Vector3 to, float size, bool @override = false)
            {
                if (config.Methods.Arrow || @override)
                {
                    obj.ei.color = color;
                    obj.ei._from = obj.ei.from;
                    obj.ei.offset = offset;
                    obj.ei.to = to;
                    obj.ei.size = size;
                    obj.flags |= DrawFlags.Arrow;
                }
            }

            private void CacheBox(DataObject obj, Color color, Vector3 offset, float size, bool @override = false)
            {
                if (config.Methods.Box || @override)
                {
                    obj.ei.color = color;
                    obj.ei._from = obj.ei.from;
                    obj.ei.offset = offset;
                    obj.ei.size = size;
                    obj.flags |= DrawFlags.Box;
                }
            }

            private void CacheText(DataObject obj, Color color, Vector3 offset, Action action, bool @override = false)
            {
                if (config.Methods.Text || @override)
                {
                    obj.ei.color = color;
                    obj.ei._from = obj.ei.from;
                    obj.ei.offset = offset;
                    obj.action = action;
                    obj.flags |= DrawFlags.Text;
                }
            }

            private void HandleException(NetworkableId nid, Exception ex)
            {
                if (cobj != null)
                {
                    cobj.disabled = true;
                    currType = cobj.ei.type;
                }
                removeByNetworkId.Add(nid);
                HandleException(ex);
            }

            private void HandleException(Exception ex)
            {
                RemoveAdminFlag();
                removeByEntityType.Add(currType);
                instance._errorTypes.Add(currType);
                instance.Message(player, "Exception");
                instance.Puts("Error @{0} ({1}): {2}", currType, cflag, ex);
                RemoveByEntityType(currType);
            }

            private void SetAdminFlag()
            {
                if (!isAdmin && hasPermAllowed && data.Count > 0 && !player.HasPlayerFlag(BasePlayer.PlayerFlags.IsAdmin))
                {
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                    player.SendNetworkUpdateImmediate();
                }
            }

            private void RemoveAdminFlag()
            {
                if (!isAdmin && hasPermAllowed && player.HasPlayerFlag(BasePlayer.PlayerFlags.IsAdmin))
                {
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                    player.SendNetworkUpdateImmediate();
                }
            }

            private bool API_GetExistingBackpacks(ulong userid)
            {
                if (canGetExistingBackpacks && instance.Backpacks != null)
                {
                    canGetExistingBackpacks = false;
                    instance.timer.Once(60f, () => canGetExistingBackpacks = true);
                    backpacks = instance.Backpacks?.Call("API_GetExistingBackpacks") as Dictionary<ulong, ItemContainer>;
                }

                return backpacks != null && backpacks.TryGetValue(userid, out _backpackItemContainer) && _backpackItemContainer != null && !_backpackItemContainer.IsEmpty();
            }

            public int entityNameSize, entityTextSize, playerNameSize, playerTextSize;

            private string Format(object prefix, object text, bool entity = true)
            {
                if (entity)
                {
                    return $"<size={entityNameSize}>{prefix}</size> <size={entityTextSize}>{text}</size>";
                }
                return $"<size={playerNameSize}>{prefix}</size> <size={playerTextSize}>{text}</size>";
            }

            private string Format(BasePlayer target, bool s)
            {
                if (target.metabolism == null)
                {
                    return $"{Mathf.CeilToInt(target.health)}";
                }
                if (s)
                {
                    return $"{Mathf.CeilToInt(target.health)} {Mathf.CeilToInt(target.metabolism.calories.value)}:{Mathf.CeilToInt(target.metabolism.hydration.value)}";
                }
                return $"{Mathf.CeilToInt(target.health)} <color=#FFA500>{Mathf.CeilToInt(target.metabolism.calories.value)}</color>:<color=#FFADD8E6>{Mathf.CeilToInt(target.metabolism.hydration.value)}</color>";
            }

            private bool HasPermission(string userid, string perm) => instance.permission.UserHasPermission(userid, perm);

            private string GetContents(List<Item> itemList, int num)
            {
                if (num <= 0 || itemList.Count == 0)
                {
                    return $"({itemList.Count})";
                }
                var sb = StringBuilderCache.Acquire();
                foreach (Item item in itemList.Take(num))
                {
                    sb.Append(instance.m(config.Options.Abbr ? string.Concat(item.info.displayName.english.Where(abbr)) : item.info.displayName.english, userid)).Append($": {item.amount}, ");
                }
                sb.Length -= 2;
                return $"({StringBuilderCache.GetStringAndRelease(sb)}) ({itemList.Count})";
            }

            private string GetContents(ItemContainer[] containers, int num)
            {
                if (containers.IsNullOrEmpty())
                {
                    return string.Empty;
                }
                using var itemList = DisposableList<Item>.Get();
                foreach (ItemContainer container in containers)
                {
                    itemList.AddRange(container.itemList);
                }
                string contents = GetContents(itemList, num);
                return contents;
            }

            private bool SetSource()
            {
                if (!setSource)
                {
                    source = player;
                    return true;
                }

                source = player;

                if (player.IsSpectating())
                {
                    var target = player.GetParentEntity() as BasePlayer;

                    if (target != null)
                    {
                        if (target.IsDead() && !target.IsConnected)
                        {
                            player.StopSpectating();
                        }
                        else
                        {
                            source = target;
                        }
                    }
                }

                if (player == source && (player.IsDead() || player.IsSleeping() || player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot)))
                {
                    RemoveAdminFlag();
                    return false;
                }

                return true;
            }

            private float SetDistance(Vector3 a)
            {
                return currDistance = (a - position).magnitude;
            }

            private DataObject SetDataObject(EntityInfo ei)
            {
                if (!data.TryGetValue(ei.entity.net.ID, out var obj))
                {
                    obj = Pool.Get<DataObject>();
                }

                data[ei.entity.net.ID] = obj;
                obj.ei = ei;

                return obj;
            }

            private bool HasDataObject(BaseEntity entity) => data.ContainsKey(entity.net.ID);

            private bool IsValid(EntityInfo ei, float dist)
            {
                if (ei.t == null || !ei.entity.IsValid() || HasDataObject(ei.entity))
                {
                    return false;
                }
                if (ei.type == EntityType.Bradley || ei.type == EntityType.Heli)
                {
                    return SetDistance(ei._from) <= dist || currDistance <= maxDistance;
                }
                return SetDistance(ei._from) <= dist && currDistance <= maxDistance;
            }

            private void ShowActive()
            {
                try
                {
                    currType = EntityType.Active;

                    if (Voices.Count > 0)
                    {
                        CheckVoiceExpirations();
                    }

                    RemoveIdleTime();

                    foreach (var target in BasePlayer.activePlayerList)
                    {
                        TryCacheOnlinePlayer(target);

                        checks++;
                    }
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void CheckVoiceExpirations()
            {
                foreach (var pair in Voices)
                {
                    if (Time.time > pair.Value)
                    {
                        VoiceExpirations.Add(pair.Key);
                    }
                }

                foreach (var key in VoiceExpirations)
                {
                    Voices.Remove(key);
                }

                VoiceExpirations.Clear();
            }

            public void TryCacheOnlinePlayer(BasePlayer target)
            {
                currType = EntityType.Active;

                if (target.IsKilled() || !GetBool(EntityType.Active) || exclude.Contains(target.userID) || !canBypassOverride && HasPermission(target.UserIDString, "adminradar.bypass"))
                {
                    return;
                }

                var nid = target.net.ID;

                if (!data.TryGetValue(nid, out var obj))
                {
                    data[nid] = obj = Pool.Get<DataObject>();
                }

                obj.Reset();
                obj.ei = new(target, EntityType.Active, config.Distance.Get);

                CacheText(obj, Color.green, Vector3.zero, () =>
                {
                    if (target.IsKilled())
                    {
                        return;
                    }

                    if (!target.IsConnected)
                    {
                        TryCacheSleepingPlayer(target);
                        return;
                    }

                    var dist = Distance(obj.ei.from);
                    var color = GetColor(target, obj.ei._from);

                    if (config.Methods.Box && dist > maxDistance)
                    {
                        DrawBox(GetColor(target, obj.ei._from), obj.ei._from + Vector3.up, GetScale(dist));
                    }
                    else if (dist < config.Distance.Players && dist < maxDistance)
                    {
                        DrawArrow(__(config.Hex.Arrows), obj.ei._from + new Vector3(0f, obj.ei._from.y + 10), obj.ei._from, 1);
                        DrawBox(color, obj.ei._from + Vector3.up, target.GetHeight());
                        DrawCupboardArrows(target, EntityType.Active);
                        DrawAppendedText(target, obj.ei._from, twoUp, color);
                        DrawVoiceArrow(target, obj.ei._from, dist);
                        DrawVisionArrow(target, dist);
                    }
                    else if (config.Limit.Enabled && config.Limit.Range > 0f && dist < maxDistance)
                    {
                        var obj2 = Pool.Get<DistantPlayer>();
                        obj2.alive = target.IsAlive();
                        obj2.pos = obj.ei._from;
                        distant.Add(obj2);
                    }
                    else if (config.Options.DrawX && dist < maxDistance)
                    {
                        DrawPlayerText(color, obj.ei._from, "X", string.Empty, true);
                    }
                }, true);
            }

            private void ShowSleepers()
            {
                try
                {
                    currType = EntityType.Sleeper;

                    foreach (var target in BasePlayer.sleepingPlayerList)
                    {
                        TryCacheSleepingPlayer(target);

                        checks++;
                    }
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void TryCacheSleepingPlayer(BasePlayer target)
            {
                if (target.IsKilled() || !GetBool(EntityType.Sleeper) || target.transform.position.y < config.Distance.MinY || !canBypassOverride && HasPermission(target.UserIDString, "adminradar.bypass"))
                {
                    return;
                }

                var nid = target.net.ID;

                if (!data.TryGetValue(nid, out var obj))
                {
                    data[nid] = obj = Pool.Get<DataObject>();
                }

                obj.Reset();
                obj.ei = new(target, EntityType.Sleeper, config.Distance.Get);

                CacheText(obj, Color.cyan, Vector3.zero, () =>
                {
                    if (target.IsKilled())
                    {
                        return;
                    }

                    if (target.IsConnected)
                    {
                        TryCacheOnlinePlayer(target);
                        return;
                    }

                    if (target.transform.position.y < config.Distance.MinY)
                    {
                        removeByNetworkId.Add(nid);
                        return;
                    }

                    var color = __(target.IsAlive() ? config.Hex.Sleeper : config.Hex.SleeperDead);
                    var dist = Distance(obj.ei.from);

                    if (dist < config.Distance.Players)
                    {
                        DrawArrow(__(config.Hex.Arrows), obj.ei._from + new Vector3(0f, obj.ei._from.y + 10), obj.ei._from, 1, false);
                        DrawCupboardArrows(target, EntityType.Sleeper);
                        DrawAppendedText(target, obj.ei._from, halfUp, color);
                    }
                    else if (dist < maxDistance)
                    {
                        DrawPlayerText(Color.cyan, obj.ei._from, "X", string.Empty, config.Options.DrawX);
                        DrawBox(Color.cyan, obj.ei._from + Vector3.up, GetScale(dist));
                    }
                }, true);
            }

            private Color GetColor(BasePlayer target, Vector3 a)
            {
                if (target.health <= 0f)
                {
                    return __(config.Hex.OnlineDead);
                }
                if (canBypassOverride && (target.IsAdmin || target.IsDeveloper))
                {
                    return Color.magenta;
                }
                if (!target.IsOnGround() || target.IsFlying)
                {
                    return __(config.Hex.Flying);
                }
                if (a.y + 1f < TerrainMeta.HeightMap.GetHeight(a))
                {
                    return __(config.Hex.Underground);
                }
                return __(config.Hex.Online);
            }

            private void DrawAppendedText(BasePlayer target, Vector3 a, Vector3 offset, Color color)
            {
                if (target.IsSpectating())
                {
                    offset += Vector3.up;
                }
                var sb = StringBuilderCache.Acquire();
                if (instance.data.Extended.Contains(userid))
                {
                    Item item = target.GetActiveItem();

                    if (item != null)
                    {
                        sb.Append(instance.m(config.Options.Abbr ? string.Concat(item.info.displayName.english.Where(abbr)) : item.info.displayName.english, userid));

                        if (item.contents?.itemList?.Count > 0)
                        {
                            sb.Append(" (");
                            item.contents.itemList.ForEach(con =>
                            {
                                sb.Append(instance.m(config.Options.Abbr ? string.Concat(con.info.displayName.english.Where(abbr)) : con.info.displayName.english, userid)).Append('|');
                            });
                            sb.Length -= 1;
                            sb.Append(')');
                        }
                    }
                }
                if (config.Settings.AveragePingInterval > 0 && target.IsConnected)
                {
                    sb.Append($" {target.IPlayer?.Ping ?? -1}ms");
                }
                if (config.Additional.BackpackPlugin && API_GetExistingBackpacks(target.userID))
                {
                    sb.Append('*');
                }
                if (!string.IsNullOrEmpty(config.Settings.New) && !string.IsNullOrEmpty(config.Settings.NewText))
                {
                    string[] groups = config.Settings.New.Split(',');
                    int index = Array.FindIndex(groups, group => instance.permission.UserHasGroup(target.UserIDString, group.Trim()));
                    if (index != -1)
                    {
                        string[] texts = config.Settings.NewText.Split(",");
                        if (index < texts.Length && !string.IsNullOrWhiteSpace(texts[index]))
                        {
                            sb.Append(texts[index].Trim());
                        }
                    }
                }
                if (instance._clanColors.TryGetValue(instance.GetClanOf(target.userID), out var clan) && !config.Settings.ApplySameColor)
                {
                    clan = $" <color={clan}>C</color>";
                }
                if (instance._teamColors.TryGetValue(target.currentTeam, out var team) && !config.Settings.ApplySameColor)
                {
                    team = $"<color={team}>T</color>";
                }
                if (config.Settings.ShowIdleTime)
                {
                    var time = GetIdleTime(target);
                    if (time >= config.Settings.IdleVisibleMinutes)
                    {
                        sb.Append($"<color={config.Hex.IdleTime}>{time}</color>");
                    }
                }
                string health = showHT && target.metabolism != null ? Format(target, config.Settings.ApplySameColor) : $"{Mathf.CeilToInt(target.health)}";
                if (config.Settings.ApplySameColor && !string.IsNullOrEmpty(clan ?? team))
                {
                    DrawPlayerText(color, a + offset, $"{GetCheats(target)}<color={clan ?? team}>{R(target.displayName)}</color>", $"<color={clan ?? team}>{health} {Distance(a)} {StringBuilderCache.GetStringAndRelease(sb)}</color>");
                }
                else
                {
                    DrawPlayerText(color, a + offset, $"{GetCheats(target)}{R(target.displayName)}", $"<color={config.Hex.Health}>{health}</color> <color={config.Hex.Dist}>{Distance(a)}</color> {StringBuilderCache.GetStringAndRelease(sb)}{clan}{team}");
                }
            }

            private string GetCheats(BasePlayer target)
            {
                var sb = StringBuilderCache.Acquire();
                if (config.Track.Radar && instance.IsRadar(target.UserIDString)) sb.Append(config.Track.RadarText).Append("|");
                if (config.Track.God && target.IsGod()) sb.Append(config.Track.GodText).Append("|");
                if (config.Track.GodPlugin && target.metabolism?.calories?.min == 500) sb.Append(config.Track.GodPluginText).Append("|");
                if (config.Track.Vanish && target.limitNetworking) sb.Append(config.Track.VanishText).Append("|");
                if (config.Track.NoClip && target.IsFlying) sb.Append(config.Track.NoClipText).Append("|");
                if (sb.Length > 0) { sb.Length -= 1; sb.Insert(0, "(").Append(") "); }
                return StringBuilderCache.GetStringAndRelease(sb);
            }

            private void ShowGroupLimits()
            {
                if (distant.Count == 0)
                {
                    return;
                }

                currType = EntityType.Limit;

                var groups = Pool.Get<Dictionary<int, List<DistantPlayer>>>();

                try
                {
                    float sqrMagnitude = config.Limit.Range * config.Limit.Range;
                    int j = 0, k, i;

                    for (; j < distant.Count; j++)
                    {
                        for (k = distant.Count - 1; k >= 0; k--)
                        {
                            if (j != k && (distant[j].pos - distant[k].pos).sqrMagnitude <= sqrMagnitude)
                            {
                                List<DistantPlayer> group = null;

                                foreach (var value in groups.Values)
                                {
                                    if (value.Contains(distant[j]) || value.Contains(distant[k]))
                                    {
                                        group = value;
                                        break;
                                    }
                                }

                                if (group == null)
                                {
                                    groups.Add(groups.Count, group = new());
                                }

                                if (!group.Contains(distant[j]))
                                {
                                    group.Add(distant[j]);
                                }

                                if (!group.Contains(distant[k]))
                                {
                                    group.Add(distant[k]);
                                }
                            }
                        }
                    }

                    j = 0;

                    var dead = __(config.Limit.Dead);
                    var drawAtOffset = config.Limit.Height != 0f;

                    foreach (var group in groups.Values)
                    {
                        var alive = __(instance.GetGroupColor(j));

                        k = 0;

                        for (i = group.Count - 1; i >= 0; i--)
                        {
                            var target = group[i];

                            if (distant.Remove(target))
                            {
                                if (group.Count >= config.Limit.Amount)
                                {
                                    if (k++ == 0 && drawAtOffset)
                                    {
                                        DrawPlayerText(Color.black, target.pos + limitUp, group.Count, string.Empty, true);
                                    }

                                    DrawPlayerText(target.alive ? alive : dead, target.pos, "X", string.Empty, true);
                                }
                                else
                                {
                                    DrawPlayerText(target.alive ? Color.green : dead, target.pos, "X", string.Empty, true);
                                }

                                target.Reset();

                                Pool.Free(ref target);

                                group[i] = null;
                            }
                        }

                        if (k != 0 && ++j > config.Limit.Colors.Count)
                        {
                            j = 0;
                        }
                    }

                    for (j = 0; j < distant.Count; ++j)
                    {
                        DrawPlayerText(distant[j].alive ? Color.green : dead, distant[j].pos, "X", string.Empty, true);
                    }
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
                finally
                {
                    groups.ResetToPool();

                    ClearDistantPlayers();
                }
            }

            private void ClearDistantPlayers()
            {
                for (int i = distant.Count - 1; i >= 0; i--)
                {
                    var obj = distant[i];
                    if (obj != null)
                    {
                        obj.Reset();
                        Pool.Free(ref obj);
                    }
                    distant[i] = null;
                }

                distant.Clear();
            }

            private void DrawCupboardArrows(BasePlayer target, EntityType lastType)
            {
                try
                {
                    if (entityTypes.Contains(EntityType.TCArrow))
                    {
                        currType = EntityType.TCArrow;

                        foreach (var ei in Cache.Cupboards.Values)
                        {
                            if (IsValid(ei, config.Distance.TCArrows) && ei.priv.IsAuthed(target))
                            {
                                DrawArrow(__(config.Hex.TC), target.transform.position + new Vector3(0f, 0.115f, 0f), ei._from, 0.25f, true);
                            }
                        }

                        currType = lastType;
                    }
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowHeli()
            {
                if (Cache.Helicopters.Count > 0)
                {
                    foreach (var heli in Cache.Helicopters.Values)
                    {
                        CacheHeli(heli);
                    }
                }
            }

            private void CacheHeli(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Heli;

                    if (IsValid(ei, 9999f))
                    {
                        var obj = SetDataObject(ei);
                        var color = __(config.Hex.Heli);
                        var name = instance.m("H", userid);
                        var weakspots = (ei.entity as PatrolHelicopter).weakspots;

                        CacheText(obj, color, twoUp, () =>
                        {
                            string heliHealth = ei.entity.Health() > 1000 ? Mathf.CeilToInt(ei.entity.Health()).ToString("#,##0,K", CultureInfo.InvariantCulture) : Mathf.CeilToInt(ei.entity.Health()).ToString();
                            string info = config.Additional.RotorHealth ? $"<color={config.Hex.Health}>{heliHealth}</color> (<color=#FFFF00>{Mathf.CeilToInt(weakspots[0].health)}</color>/<color=#FFFF00>{Mathf.CeilToInt(weakspots[1].health)}</color>)" : $"<color={config.Hex.Health}>{heliHealth}</color>";
                            ei.info = Format(name, $"{info} <color={config.Hex.Dist}>{Distance(ei.from)}</color>");
                        });

                        CacheBox(obj, color, Vector3.up, GetScale(Distance(ei.from)));
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowBradley()
            {
                if (Cache.BradleyAPCs.Count > 0)
                {
                    foreach (var bradley in Cache.BradleyAPCs.Values)
                    {
                        CacheBradley(bradley);
                    }
                }
            }

            private void CacheBradley(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Bradley;

                    if (IsValid(ei, 9999f))
                    {
                        var obj = SetDataObject(ei);
                        var color = __(config.Hex.Bradley);
                        var name = instance.m(ei.entity is BradleyAPC ? "B" : "V", userid);

                        CacheText(obj, color, twoUp, () =>
                        {
                            string health = ei.entity.Health() > 1000 ? Mathf.CeilToInt(ei.entity.Health()).ToString("#,##0,K", CultureInfo.InvariantCulture) : Mathf.CeilToInt(ei.entity.Health()).ToString();
                            ei.info = Format(name, $"<color={config.Hex.Health}>{health}</color> <color={config.Hex.Dist}>{Distance(ei.from)}</color>");
                        });

                        CacheBox(obj, color, Vector3.up, GetScale(currDistance));
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowTC()
            {
                foreach (var tc in Cache.Cupboards)
                {
                    CacheTC(tc.Value);
                }
            }

            private void CacheTC(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.TC;

                    if (IsValid(ei, config.Distance.TC))
                    {
                        var obj = SetDataObject(ei);
                        var color = __(config.Hex.TC);

                        if (config.Methods.Text)
                        {
                            var decayEntities = config.Options.TCBags && ei.priv.buildingID != 0 ? ei.priv.GetBuilding()?.decayEntities : null;
                            var name = instance.m("TC", userid);

                            CacheText(obj, color, halfUp, () =>
                            {
                                var sb = StringBuilderCache.Acquire($"<color={config.Hex.Dist}>{Distance(ei.from)}</color>");

                                if (decayEntities != null)
                                {
                                    sb.Append($" <color={config.Hex.Bag}>{decayEntities.Sum(e => e is SleepingBag ? 1 : 0)}</color>");
                                }

                                if (config.Options.TCAuthed)
                                {
                                    sb.Append($" <color={config.Hex.TC}>{ei.priv.authorizedPlayers.Count}</color>");
                                }

                                sb.Append($" <color={config.Hex.Dist}>{ei.priv.GetProtectedMinutes()}</color>");

                                ei.info = Format(name, StringBuilderCache.GetStringAndRelease(sb));
                            });
                        }

                        CacheBox(obj, color, halfUp, 3f);
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowSupplyDrops()
            {
                foreach (var drop in Cache.Airdrops.Values)
                {
                    CacheAirdrop(drop);
                }
            }

            private void CacheAirdrop(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Airdrop;

                    if (IsValid(ei, config.Distance.Airdrop))
                    {
                        var obj = SetDataObject(ei);
                        var drop = ei.entity as SupplyDrop;
                        var color = __(config.Hex.AD);

                        CacheText(obj, color, halfUp, () =>
                        {
                            string text;
                            if (drop == null || drop.inventory == null || drop.inventory.itemList == null) text = "(N/A) ";
                            else text = config.Options.AirdropContentAmount > 0 ? GetContents(drop.inventory.itemList, config.Options.AirdropContentAmount) : $"({drop.inventory.itemList.Count}) ";
                            ei.info = Format(ei.name, $"<color={config.Hex.Loot}>{text}</color><color={config.Hex.Dist}>{Distance(ei.from)}</color>");
                        });

                        CacheBox(obj, color, halfUp, GetScale(currDistance));
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowContainer(EntityInfo ei, EntityType type)
            {
                checks++;

                if (instance.data.OnlineBoxes.Contains(userid) && ei.entity.OwnerID.IsSteamId() && (ei.entity.PrefabName.Contains("box") || ei.entity.PrefabName.Contains("coffin")))
                {
                    var owner = BasePlayer.FindAwakeOrSleeping(ei.entity.OwnerID.ToString());

                    if (owner == null || !owner.IsConnected)
                    {
                        return;
                    }
                }

                var obj = SetDataObject(ei);
                var amount = config.Options.Get(type);
                var container = ei.entity as IItemContainerEntity;

                if (container == null || container.inventory == null || container.inventory.itemList == null)
                {
                    return;
                }

                var itemList = container.inventory.itemList;
                var color = __(ei.entity is LockedByEntCrate || ei.entity is VendingMachine ? config.Hex.Heli : type == EntityType.Box ? config.Hex.Box : type == EntityType.Loot ? config.Hex.Loot : config.Hex.Stash);

                ei.name = instance.m(instance.StripTags(ei.entity.ShortPrefabName).Replace("coffinstorage", "coffin").Replace("vendingmachine", "VM"), userid);

                CacheText(obj, color, halfUp, () =>
                {
                    ei.info = null;
                    if (itemList == null || !config.Options.DrawEmptyContainers && itemList.Count == 0) return;
                    string text = amount > 0 ? GetContents(itemList, amount) : $"({itemList.Count}) ";
                    ei.info = Format(ei.name, $"{text}<color={config.Hex.Dist}>{Distance(ei._from)}</color>");
                });

                CacheBox(obj, color, halfUp, GetScale(currDistance));
            }

            private void ShowBox()
            {
                foreach (var container in Cache.Containers.Values)
                {
                    CacheContainer(container);
                }
            }

            private void CacheContainer(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Box;

                    if (ei.type == EntityType.Box && IsValid(ei, config.Distance.Get(currType, ei.entity)))
                    {
                        ShowContainer(ei, currType);
                    }
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowStash()
            {
                foreach (var container in Cache.Containers.Values)
                {
                    CacheStash(container);
                }
            }

            private void CacheStash(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Stash;

                    if (ei.type == EntityType.Stash && IsValid(ei, config.Distance.Stash))
                    {
                        ShowContainer(ei, currType);
                    }
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowLoot()
            {
                foreach (var backpack in Cache.Backpacks.Values)
                {
                    CacheBackpack(backpack);
                }

                foreach (var container in Cache.Containers.Values)
                {
                    CacheLoot(container);
                }
            }

            private void CacheBackpack(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Backpack;

                    if (IsValid(ei, config.Distance.Loot))
                    {
                        var obj = SetDataObject(ei);
                        var color = __(config.Hex.Backpack);

                        if (ei.entity is DroppedItemContainer backpack)
                        {
                            CacheText(obj, color, halfUp, () =>
                            {
                                if (ei == null || backpack == null || backpack.inventory == null || backpack.inventory.itemList == null) return;
                                var prefix = string.IsNullOrEmpty(backpack._playerName) ? instance.m("backpack", userid) : backpack._playerName;
                                ei.info = Format(prefix, $"{GetContents(backpack.inventory.itemList, config.Options.BackpackContentAmount)}<color={config.Hex.Dist}>{Distance(ei.from)}</color>");
                            });
                        }
                        else if (ei.entity is DroppedItem wi && wi.item != null && wi.item.IsBackpack())
                        {
                            var user = wi.DroppedBy.IsSteamId() ? instance.covalence.Players.FindPlayerById(wi.DroppedBy.ToString()) : null;
                            var prefix = user == null || string.IsNullOrEmpty(user.Name) ? instance.m("backpack", userid) : user.Name;

                            CacheText(obj, color, halfUp, () =>
                            {
                                if (ei == null || wi == null || wi.item == null || wi.item.contents == null || wi.item.contents.itemList == null) return;
                                ei.info = Format(prefix, $"{GetContents(wi.item.contents.itemList, config.Options.BackpackContentAmount)}<color={config.Hex.Dist}>{Distance(ei.from)}</color>");
                            });
                        }

                        CacheBox(obj, color, halfUp, GetScale(currDistance));
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void CacheLoot(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Loot;

                    if (ei.type == EntityType.Loot && IsValid(ei, config.Distance.Loot))
                    {
                        ShowContainer(ei, currType);
                    }
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowBags()
            {
                foreach (var bag in Cache.Bags.Values)
                {
                    CacheSleepingBag(bag);
                }
            }

            private void CacheSleepingBag(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Bag;

                    if (IsValid(ei, config.Distance.Bag))
                    {
                        var obj = SetDataObject(ei);
                        var color = __(config.Hex.Bag);
                        var name = instance.m("bag", userid);

                        CacheText(obj, color, Vector3.zero, () =>
                        {
                            ei.info = Format(name, $"<color={config.Hex.Dist}>{Distance(ei.from)}</color>");
                        });

                        CacheBox(obj, color, Vector3.zero, 0.5f);
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowTurrets()
            {
                foreach (var turret in Cache.Turrets.Values)
                {
                    CacheTurret(turret);
                }
            }

            private void CacheTurret(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Turret;

                    if (IsValid(ei, config.Distance.Turret))
                    {
                        var obj = SetDataObject(ei);
                        var color = __(config.Hex.AT);
                        var itemList = (ei.entity as AutoTurret)?.inventory?.itemList;
                        var name = instance.m("AT", userid);

                        CacheText(obj, color, halfUp, () =>
                        {
                            ei.info = Format(name, $"({itemList?.Count ?? 0}) <color={config.Hex.Dist}>{Distance(ei.from)}</color>");
                        });

                        CacheBox(obj, color, halfUp, 1f);
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowDead()
            {
                foreach (var ci in Cache.Corpses.Values)
                {
                    CacheDead(ci);
                }
            }

            private void CacheDead(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Dead;

                    if (IsValid(ei, config.Distance.Corpse))
                    {
                        var obj = SetDataObject(ei);
                        var color = __(config.Hex.Corpse);
                        var containers = (ei.entity as PlayerCorpse).containers;

                        CacheText(obj, color, halfUp, () =>
                        {
                            ei.info = Format(ei.name, $"{GetContents(containers, config.Options.CorpseContentAmount)}");
                        });

                        CacheBox(obj, color, Vector3.zero, GetScale(currDistance));
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowDrops()
            {
                foreach (var ci in Cache.Drops.Values)
                {
                    CacheDrop(ci);
                }
            }

            private void CacheDrop(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Drop;

                    if (IsValid(ei, config.Distance.Drops))
                    {
                        var entity = ei.entity;
                        var shortname = entity is DroppedItem drop ? drop?.item?.info.shortname ?? entity.ShortPrefabName : entity.ShortPrefabName;
                        var obj = SetDataObject(ei);
                        var color = Color.red;

                        CacheText(obj, color, halfUp, () =>
                        {
                            ei.info = Format(ei.name, $"{shortname} <color=#FFFF00>{currDistance}</color>");
                        });
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowNPC()
            {
                if (config.Core.NPCPlayer)
                {
                    foreach (var target in Cache.NPCPlayers.Values)
                    {
                        CacheNpc(target);
                    }
                }

                if (config.Core.Animals)
                {
                    foreach (var npc in Cache.Animals.Values)
                    {
                        CacheAnimal(npc);
                    }
                }
            }

            private void CacheAnimal(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Npc;

                    if (IsValid(ei, 9999f))
                    {
                        var obj = SetDataObject(ei);
                        var color = __(config.Hex.Animal);
                        var name = instance.m(ei.entity.ShortPrefabName, userid);
                        var _players = ei.entity.HasBrain ? ei.entity.GetComponent<BaseAIBrain>()?.Senses?.Players : null;

                        CacheText(obj, color, Vector3.up, () =>
                        {
                            ei.info = null;
                            float dist = Distance(ei.from);
                            if (dist < config.Distance.Animal && dist < maxDistance && IsAtView(ei))
                            {
                                if (config.Options.DrawTargetsVictim && _players != null && _players.Count > 0)
                                    DrawVictim(_players.Find(x => x) as BasePlayer, ei._from, new(0f, 1.25f + dist * 0.03f), color);

                                ei.info = Format(name, $"<color={config.Hex.Health}>{Mathf.CeilToInt(ei.entity.Health())}</color> <color={config.Hex.Dist}>{dist}</color>");
                            }
                        });

                        CacheBox(obj, color, Vector3.up, ei.entity.bounds.size.y);
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void CacheNpc(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Npc;

                    if (!(ei.entity is BasePlayer))
                    {
                        CacheAnimal(ei);
                        return;
                    }

                    if (IsValid(ei, 9999f))
                    {
                        var obj = SetDataObject(ei);

                        if (SetDistance(ei.from) < config.Distance.NPC)
                        {
                            var target = ei.entity as BasePlayer;
                            var _players = ei.entity.HasBrain ? ei.entity.GetComponent<BaseAIBrain>()?.Senses?.Players : null;
                            var color = __(target.IsHoldingEntity<BaseMelee>() ? config.Hex.Murderer : target.ShortPrefabName.Contains("peacekeeper") ? config.Hex.Peacekeeper : target.name.Contains("scientist") ? config.Hex.Scientist : target.ShortPrefabName == "murderer" ? config.Hex.Murderer : config.Hex.Animal);
                            var displayName = config.Options.NpcPrefabName ? target.ShortPrefabName : !string.IsNullOrEmpty(target.displayName) && target.displayName != target.UserIDString ? target.displayName : target.ShortPrefabName == "scarecrow" ? instance.m("scarecrow", userid) : target.PrefabName.Contains("scientist") ? instance.m("scientist", userid) : instance.m(target.ShortPrefabName, userid);

                            CacheText(obj, color, twoUp, () =>
                            {
                                ei.info = null;

                                float dist = Distance(ei.from);
                                if (dist > maxDistance || dist > config.Distance.NPC || !IsAtView(ei))
                                {
                                    return;
                                }

                                if (config.Options.DrawTargetsVictim && _players != null && _players.Count > 0)
                                    DrawVictim(_players.Find(x => x) as BasePlayer, ei._from, new(0f, 2f + Distance(ei._from) * 0.03f), color);

                                ei.info = Format(displayName, $"<color={config.Hex.Health}>{Mathf.CeilToInt(target.health)}</color> <color={config.Hex.Dist}>{dist}</color>");
                            });

                            CacheBox(obj, color, Vector3.up, target.GetHeight(target.modelState.ducked));
                            CacheArrow(obj, color, new(0f, ei.from.y + 10), ei.from, 1, false);
                        }
                        else CacheBox(obj, Color.blue, Vector3.up, 5f, true);
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void DrawVictim(BasePlayer victim, Vector3 from, Vector3 offset, Color color)
            {
                if (victim != null)
                {
                    string text = $"<color={(victim.IsSleeping() ? config.Hex.Sleeper : victim.IsAlive() ? "#00ff00" : config.Hex.OnlineDead)}>{victim.displayName}</color>";
                    player.SendConsoleCommand("ddraw.text", delay, color, from + offset, $"<size={config.Settings.PlayerTextSize}>T: {text}</size>");
                }
            }

            private bool IsAtView(EntityInfo ei)
            {
                if (config.Options.NpcWorldView)
                {
                    if (ei.entity is SimpleShark)
                    {
                        return true;
                    }
                    if (position.y > 0f && ei._from.y < -3f)
                    {
                        return false;
                    }
                    if (ei._from.y > 0f && position.y < -3f)
                    {
                        return false;
                    }
                }
                return true;
            }

            private void ShowOre()
            {
                foreach (var ore in Cache.Ores.Values)
                {
                    CacheOre(ore);
                }
            }

            private void CacheOre(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Ore;

                    if (IsValid(ei, config.Distance.Ore))
                    {
                        var obj = SetDataObject(ei);
                        var color = __(config.Hex.Resource);
                        var containedItems = ei.entity.GetComponent<ResourceDispenser>().containedItems;

                        CacheText(obj, color, Vector3.up, () =>
                        {
                            ei.info = Format(ei.name, config.Options.ResourceAmounts ? $"({containedItems.Sum(i => i.amount)}) <color={config.Hex.Dist}>{Distance(ei.from)}</color>" : $"<color={config.Hex.Dist}>{Distance(ei.from)}</color>");
                        });

                        CacheBox(obj, color, Vector3.up, GetScale(currDistance));
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowCCTV()
            {
                foreach (var cctv in Cache.CCTV.Values)
                {
                    CacheCCTV(cctv);
                }
            }

            private void CacheCCTV(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.CCTV;

                    if (IsValid(ei, config.Distance.CCTV))
                    {
                        var obj = SetDataObject(ei);
                        var cctv = ei.entity as CCTV_RC;
                        var name = instance.m("CCTV", userid);

                        CacheText(obj, Color.magenta, new(0f, 0.3f, 0f), () =>
                        {
                            ei.color = ei.entity.HasFlag(BaseEntity.Flags.Reserved5) ? Color.green : cctv.IsPowered() || cctv.IsStatic() ? Color.cyan : Color.red;
                            ei.info = Format(name, $"<color={config.Hex.Dist}>{Distance(ei.from)}</color> {cctv.ViewerCount}");
                        });

                        CacheBox(obj, Color.magenta, Vector3.zero, 0.25f);
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowCollectibles()
            {
                foreach (var col in Cache.Collectibles.Values)
                {
                    CacheCol(col);
                }
            }

            private void CacheCol(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Col;

                    if (IsValid(ei, config.Distance.Col))
                    {
                        var obj = SetDataObject(ei);
                        var color = __(config.Hex.Col);
                        var itemList = ((CollectibleEntity)ei.entity).itemList;

                        CacheText(obj, color, Vector3.up, () =>
                        {
                            ei.info = Format(ei.name, config.Options.ResourceAmounts ? $"({itemList.Sum(i => i.amount)})" : $"<color={config.Hex.Dist}>{Distance(ei.from)}</color>");
                        });

                        CacheBox(obj, color, Vector3.up, ei.size);
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowEntity(EntityType entityType, Dictionary<NetworkableId, EntityInfo> entities)
            {
                if (entities.Count > 0)
                {
                    foreach (var ei in entities.Values)
                    {
                        CacheEntity(ei, entityType);
                    }
                }
            }

            private void CacheEntity(EntityInfo ei, EntityType entityType)
            {
                this.currType = entityType;

                try
                {
                    checks++;

                    if (!ei.t || !ei.entity.IsValid() || HasDataObject(ei.entity))
                    {
                        return;
                    }

                    var offset = Vector3.up;
                    var entityName = $"{entityType}";

                    SetDistance(ei.from);

                    if (entityType == EntityType.Boat)
                    {
                        if (currDistance > config.Distance.Boat || !config.Additional.Boats && !config.GUI.Boats) return;
                    }
                    else if (entityType == EntityType.RHIB)
                    {
                        if (currDistance > config.Distance.Boat || !config.Additional.RHIB && !config.GUI.RHIB) return;
                    }
                    else if (entityType == EntityType.Car)
                    {
                        if (currDistance > config.Distance.Cars || !config.Additional.Cars && !config.GUI.Cars) return;
                    }
                    else if (entityType == EntityType.Mini)
                    {
                        if (currDistance > config.Distance.MC || !config.Additional.MC && !config.GUI.MC) return;
                    }
                    else if (entityType == EntityType.MLRS)
                    {
                        if (currDistance > config.Distance.MLRS || !config.Additional.MLRS && !config.GUI.MLRS) return;
                    }
                    else if (entityType == EntityType.Horse)
                    {
                        if (currDistance > config.Distance.RH || !config.Additional.RH && !config.GUI.Horse) return;
                    }
                    else if (entityType == EntityType.Trap)
                    {
                        if (currDistance > config.Distance.Traps || !config.Additional.Traps && !config.GUI.Traps) return;
                        else if (ei.entity is FlameTurret) offset = new(0f, 1.3f);
                        else if (ei.entity is Landmine) offset = new(0f, 0.25f);
                        else if (ei.entity is BearTrap) offset = halfUp;
                    }
                    else if (entityType == EntityType.CH47)
                    {
                        if (!config.Additional.CH47 && !config.GUI.CH47) return;
                    }

                    entityName = instance.m(ei.entity is ScrapTransportHelicopter ? "STH" : ei.entity is BaseSubmarine ? "SUB" : ei.entity is Tugboat ? "TB" : ei.entity is BaseBoat ? "RB" : string.Concat(entityName.Where(char.IsUpper)), userid);
                    
                    var color = __(ei.entity is ScrapTransportHelicopter ? config.Hex.STH : config.Hex.Get(entityType));
                    var obj = SetDataObject(ei);

                    CacheText(obj, color, offset, () =>
                    {
                        string health = ei.entity.Health() > 1000 ? Mathf.CeilToInt(ei.entity.Health()).ToString("#,##0,K", CultureInfo.InvariantCulture) : Mathf.CeilToInt(ei.entity.Health()).ToString();
                        string info = $"{entityName} <color={config.Hex.Health}>{health}</color>";
                        ei.info = Format(info, $"<color={config.Hex.Dist}>{Distance(ei.from)}</color>");
                    });

                    CacheBox(obj, color, offset, GetScale(currDistance));
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private static float GetScale(float value)
            {
                return value * 0.02f;
            }
        }

        private void StopFillCache()
        {
            //Puts("StopFillCache");

            if (_coroutines.Count > 0)
            {
                while (_coroutines.Count > 0)
                {
                    var co = _coroutines.Pop();
                    if (co == null) continue;
                    ServerMgr.Instance.StopCoroutine(co);
                }
            }
        }

        private IEnumerator FillOnEntitySpawned()
        {
            var instruction = CoroutineEx.waitForSeconds(0.1f);
            while (!isUnloading)
            {
                foreach (var entity in _spawnedEntities)
                {
                    cache.Add(entity);
                }

                _spawnedEntities.Clear();

                yield return instruction;

                foreach (var (id, pos) in _despawnedEntities)
                {
                    cache.Remove(id, pos);
                }

                _despawnedEntities.Clear();

                yield return instruction;
            }
        }

        private IEnumerator FillCache()
        {
            var tick = DateTime.Now;
            int cached = 0, total = 0;

            _coroutineTimer.Start();
            _allEntities = new(total = BaseNetworkable.serverEntities.Count);

            if (_coroutineTimer.ShouldYield())
            {
                yield return CoroutineEx.waitForEndOfFrame;
                _coroutineTimer.ResetIfYielded();
            }

            var checks = 0;
            foreach (BaseNetworkable net in BaseNetworkable.serverEntities)
            {
                if (net is BaseEntity entity)
                {
                    _allEntities.Add(entity.net.ID, entity);
                }

                if (++checks % 10 == 0 && _coroutineTimer.ShouldYield())
                {
                    yield return CoroutineEx.waitForEndOfFrame;
                    _coroutineTimer.ResetIfYielded();
                }
            }

            if (_coroutineTimer.ShouldYield())
            {
                yield return CoroutineEx.waitForEndOfFrame;
                _coroutineTimer.ResetIfYielded();
            }

            yield return CreateCoroutine(RemoveElementsFromList<StabilityEntity>(_coroutineTimer));
            yield return CreateCoroutine(RemoveElementsFromList<TreeEntity>(_coroutineTimer));
            yield return CreateCoroutine(RemoveElementsFromList<HeldEntity>(_coroutineTimer));
            yield return CreateCoroutine(RemoveElementsFromList<BushEntity>(_coroutineTimer));
            yield return CreateCoroutine(RemoveElementsFromList<ProjectileWeaponMod>(_coroutineTimer));

            if (config.Core.Bags)
            {
                yield return CreateCoroutine(AddElementsToCache<SleepingBag>(_coroutineTimer, cache.Bags, EntityType.Bag));
                cached += cache.Bags.Count;
            }

            if (config.Core.TC)
            {
                yield return CreateCoroutine(AddElementsToCache<BuildingPrivlidge>(_coroutineTimer, cache.Cupboards, EntityType.TC));
                cached += cache.Cupboards.Count;
            }

            if (config.Core.NPCPlayer)
            {
                if (config.Additional.RH)
                {
                    yield return CreateCoroutine(AddElementsToCache<RidableHorse>(_coroutineTimer, cache.RidableHorse, EntityType.Horse));
                    cached += cache.RidableHorse.Count;
                }

                yield return CreateCoroutine(AddElementsToCache<BaseNpc>(_coroutineTimer, cache.Animals, EntityType.Npc));
                yield return CreateCoroutine(AddElementsToCache<BaseNPC2>(_coroutineTimer, cache.Animals, EntityType.Npc));
                yield return CreateCoroutine(AddElementsToCache<SimpleShark>(_coroutineTimer, cache.Animals, EntityType.Npc));
                cached += cache.Animals.Count;

                Func<BaseEntity, bool> validNPC = entity =>
                {
                    return entity is BasePlayer player && !entity.IsKilled() && !player.userID.IsSteamId();
                };
                yield return CreateCoroutine(AddElementsToCache<BasePlayer>(_coroutineTimer, cache.NPCPlayers, EntityType.Npc, validNPC));
                cached += cache.NPCPlayers.Count;
            }

            if (config.Additional.CCTV)
            {
                yield return CreateCoroutine(AddElementsToCache<CCTV_RC>(_coroutineTimer, cache.CCTV, EntityType.CCTV));
                cached += cache.CCTV.Count;
            }

            if (config.Core.Airdrop)
            {
                yield return CreateCoroutine(AddElementsToCache<SupplyDrop>(_coroutineTimer, cache.Airdrops, EntityType.Airdrop));
                cached += cache.Airdrops.Count;
            }

            if (config.Core.Loot || config.Core.Box)
            {
                Func<BaseEntity, EntityInfo> getCachedInfo = entity =>
                {
                    var type = cache.IsLoot(entity) ? EntityType.Loot : entity is StashContainer ? EntityType.Stash : EntityType.Box;
                    var unloadable = (entity as TrainCarUnloadable)?.GetStorageContainer();
                    return new(unloadable ?? entity, type, config.Distance.Get, StripTags);
                };

                Func<BaseEntity, bool> condition = entity =>
                {
                    return cache.IsLoot(entity) || cache.IsBox(entity);
                };

                yield return CreateCoroutine(AddElementsToCacheWithInfo<StorageContainer>(_coroutineTimer, cache.Containers, getCachedInfo, condition));
                yield return CreateCoroutine(AddElementsToCache<WorldItem>(_coroutineTimer, cache.Backpacks, EntityType.Backpack, condition));
                cached += cache.Containers.Count;
            }

            if (config.Core.Loot)
            {
                yield return CreateCoroutine(AddElementsToCache<DroppedItemContainer>(_coroutineTimer, cache.Backpacks, EntityType.Backpack));
                cached += cache.Backpacks.Count;
            }

            if (config.Core.Col)
            {
                Func<BaseEntity, EntityInfo> getCachedInfo = entity =>
                {
                    return new(entity, EntityType.Col, config.Distance.Get, StripTags);
                };
                yield return CreateCoroutine(AddElementsToCacheWithInfo<CollectibleEntity>(_coroutineTimer, cache.Collectibles, getCachedInfo));
                cached += cache.Collectibles.Count;
            }

            if (config.Core.Ore)
            {
                Func<BaseEntity, EntityInfo> getCachedInfo = entity =>
                {
                    return new(entity, EntityType.Ore, config.Distance.Get, StripTags);
                };
                yield return CreateCoroutine(AddElementsToCacheWithInfo<OreResourceEntity>(_coroutineTimer, cache.Ores, getCachedInfo));
                cached += cache.Ores.Count;
            }

            if (config.Core.Dead)
            {
                foreach (BaseNetworkable entity in BaseNetworkable.serverEntities)
                {
                    if (entity is PlayerCorpse corpse && !corpse.IsKilled() && corpse.playerSteamID.IsSteamId() && !cache.Corpses.TryGetValue(corpse.net.ID, out var ei))
                    {
                        cache.Corpses[corpse.net.ID] = ei = new(corpse, EntityType.Dead, config.Distance.Get);
                        ei.name = corpse.parentEnt?.ToString() ?? corpse.playerSteamID.ToString();
                    }
                }
                cached += cache.Corpses.Count;
            }

            if (config.Additional.Heli)
            {
                yield return CreateCoroutine(AddElementsToCache<PatrolHelicopter>(_coroutineTimer, cache.Helicopters, EntityType.Heli));
                cached += cache.Helicopters.Count;
            }

            if (config.Additional.Bradley)
            {
                //yield return CreateCoroutine(AddElementsToCache<TravellingVendor>(_coroutineTimer, cache.BradleyAPCs, EntityType.Bradley));
                yield return CreateCoroutine(AddElementsToCache<BradleyAPC>(_coroutineTimer, cache.BradleyAPCs, EntityType.Bradley));
                cached += cache.BradleyAPCs.Count;
            }

            if (config.Additional.RHIB)
            {
                yield return CreateCoroutine(AddElementsToCache<RHIB>(_coroutineTimer, cache.RHIB, EntityType.RHIB));
                yield return CreateCoroutine(AddElementsToCache<BaseSubmarine>(_coroutineTimer, cache.RHIB, EntityType.RHIB));
                cached += cache.RHIB.Count;
            }

            if (config.Additional.Boats)
            {
                yield return CreateCoroutine(AddElementsToCache<BaseBoat>(_coroutineTimer, cache.Boats, EntityType.Boat));
                cached += cache.Boats.Count;
            }

            if (config.Additional.MC)
            {
                yield return CreateCoroutine(AddElementsToCache<Minicopter>(_coroutineTimer, cache.MiniCopter, EntityType.Mini));
                yield return CreateCoroutine(AddElementsToCache<AttackHelicopter>(_coroutineTimer, cache.MiniCopter, EntityType.Mini));
                yield return CreateCoroutine(AddElementsToCache<Drone>(_coroutineTimer, cache.MiniCopter, EntityType.Mini));
                cached += cache.MiniCopter.Count;
            }

            if (config.Additional.CH47)
            {
                yield return CreateCoroutine(AddElementsToCache<CH47Helicopter>(_coroutineTimer, cache.CH47, EntityType.CH47));
                cached += cache.CH47.Count;
            }

            if (config.Additional.CS)
            {
                yield return CreateCoroutine(AddElementsToCache<CargoShip>(_coroutineTimer, cache.CargoShips, EntityType.CargoShip));
                cached += cache.CargoShips.Count;
            }

            if (config.Additional.Cars)
            {
                yield return CreateCoroutine(AddElementsToCache<Bike>(_coroutineTimer, cache.Cars, EntityType.Car));
                yield return CreateCoroutine(AddElementsToCache<BasicCar>(_coroutineTimer, cache.Cars, EntityType.Car));
                yield return CreateCoroutine(AddElementsToCache<ModularCar>(_coroutineTimer, cache.Cars, EntityType.Car));
                cached += cache.Cars.Count;
            }

            if (config.Core.Turrets)
            {
                yield return CreateCoroutine(AddElementsToCache<AutoTurret>(_coroutineTimer, cache.Turrets, EntityType.Turret));
                cached += cache.Turrets.Count;
            }

            if (config.Additional.Traps)
            {
                Func<BaseEntity, bool> condition = entity =>
                {
                    return cache.IsTrap(entity);
                };

                yield return CreateCoroutine(AddElementsToCache<BaseEntity>(_coroutineTimer, cache.Traps, EntityType.Trap, condition));
                cached += cache.Traps.Count;
            }

            if (config.Distance.Drops > 0)
            {
                Func<BaseEntity, bool> condition = entity =>
                {
                    return cache.IsDrop(entity);
                };

                yield return CreateCoroutine(AddElementsToCache<BaseEntity>(_coroutineTimer, cache.Drops, EntityType.Drop, condition));
                cached += cache.Drops.Count;
            }

            if (config.Additional.MLRS)
            {
                yield return CreateCoroutine(AddElementsToCache<MLRSRocket>(_coroutineTimer, cache.MLRS, EntityType.MLRS));
                cached += cache.MLRS.Count;
            }

            if (config.Additional.CP)
            {
                Func<BaseEntity, bool> condition = entity =>
                {
                    return entity.prefabID == 2383782438;
                };
                yield return CreateCoroutine(AddElementsToCache<CargoPlane>(_coroutineTimer, cache.CargoPlanes, EntityType.CargoPlane, condition));
                cached += cache.CargoPlanes.Count;
            }
#if DEBUG
            cache.Print();
#else
            Puts("Cached {0}/{1} entities in {2} seconds!", cached, total, (DateTime.Now - tick).TotalSeconds);
#endif
            _isPopulatingCache = false;
            _allEntities.Clear();
            //Puts("FillCache");
            _coroutines.Pop();
            _coroutines.Push(ServerMgr.Instance.StartCoroutine(FillOnEntitySpawned()));
        }

        private Coroutine CreateCoroutine(IEnumerator operation)
        {
            Coroutine tmp = ServerMgr.Instance.StartCoroutine(operation);

            _coroutines.Push(tmp);
            return tmp;
        }

        private IEnumerator RemoveElementsFromList<TType>(CoroutineTimer timer)
        {
            if (timer.ShouldYield())
            {
                yield return CoroutineEx.waitForEndOfFrame;
                timer.ResetIfYielded();
            }

            if (timer.ShouldYield())
            {
                yield return CoroutineEx.waitForEndOfFrame;
                timer.ResetIfYielded();
            }

#if DEBUG
            Puts($"Start Remove {typeof(TType)}");
#endif
            using var toRemove = DisposableList<NetworkableId>.Get();
            var checks = 0;
            foreach (var (id, entity) in _allEntities)
            {
                if (entity.IsKilled() || entity is TType)
                {
                    toRemove.Add(id);
                }
                if (checks % 10 == 0 && timer.ShouldYield())
                {
                    yield return CoroutineEx.waitForEndOfFrame;
                    timer.ResetIfYielded();
                }
                checks++;
            }

            foreach (var id in toRemove)
            {
                _allEntities.Remove(id);

                if (checks % 10 == 0 && timer.ShouldYield())
                {
                    yield return CoroutineEx.waitForEndOfFrame;
                    timer.ResetIfYielded();
                }
                checks++;
            }

#if DEBUG
            Puts($"End Remove {typeof(TType)}");
#endif
            //Puts("RemoveElementsFromList");
            _coroutines.Pop();
        }

        private IEnumerator AddElementsToCacheWithInfo<TType>(CoroutineTimer timer, Dictionary<NetworkableId, EntityInfo> cachedList, Func<BaseEntity, EntityInfo> getCacheInfoFunc, Func<BaseEntity, bool> condition = null)
        {
            if (timer.ShouldYield())
            {
                yield return CoroutineEx.waitForEndOfFrame;
                timer.ResetIfYielded();
            }

#if DEBUG
            Puts($"Start Caching {typeof(TType)}");
#endif

            using var toRemove = DisposableList<NetworkableId>.Get();
            var checks = 0;
            foreach (var (id, entity) in _allEntities)
            {
                if (entity.IsKilled())
                {
                    toRemove.Add(id);
                }
                else if (entity is TType && !cachedList.TryGetValue(id, out var ei) && (condition == null || condition(entity)))
                {
                    cachedList[id] = ei = getCacheInfoFunc(entity);
                    toRemove.Add(id);
                    TryCacheByType(ei.type, ei);
                }
                if (checks % 10 == 0 && timer.ShouldYield())
                {
                    yield return CoroutineEx.waitForEndOfFrame;
                    timer.ResetIfYielded();
                }
                checks++;
            }

            foreach (var key in toRemove)
            {
                _allEntities.Remove(key);
                if (checks % 10 == 0 && timer.ShouldYield())
                {
                    yield return CoroutineEx.waitForEndOfFrame;
                    timer.ResetIfYielded();
                }
                checks++;
            }

#if DEBUG
            Puts($"End Caching {typeof(TType)}");
#endif
            //Puts("AddElementsToCacheWithInfo");
            _coroutines.Pop();
        }

        private IEnumerator AddElementsToCache<TLookFor>(CoroutineTimer timer, Dictionary<NetworkableId, EntityInfo> cachedList, EntityType type, Func<BaseEntity, bool> condition = null) where TLookFor : BaseEntity
        {
            if (timer.ShouldYield())
            {
                yield return CoroutineEx.waitForEndOfFrame;
                timer.ResetIfYielded();
            }

#if DEBUG
            Puts($"Start Caching {typeof(TLookFor)}");
#endif
            using var toRemove = DisposableList<NetworkableId>.Get();
            var checks = 0;
            foreach (var (id, entity) in _allEntities)
            {
                if (entity.IsKilled())
                {
                    toRemove.Add(id);
                }
                else if (entity is TLookFor && !cachedList.TryGetValue(id, out var ei) && (condition == null || condition(entity)))
                {
                    cachedList[id] = ei = new(entity, type, config.Distance.Get, StripTags);
                    toRemove.Add(id);
                    TryCacheByType(ei.type, ei);
                }
                if (checks % 10 == 0 && timer.ShouldYield())
                {
                    yield return CoroutineEx.waitForEndOfFrame;
                    timer.ResetIfYielded();
                }
                checks++;
            }

            foreach (var key in toRemove)
            {
                _allEntities.Remove(key);
                if (checks % 10 == 0 && timer.ShouldYield())
                {
                    yield return CoroutineEx.waitForEndOfFrame;
                    timer.ResetIfYielded();
                }
                checks++;
            }

#if DEBUG
            Puts($"End Caching {typeof(TLookFor)}");
#endif
            //Puts("AddElementsToCache");
            _coroutines.Pop();
        }

        [ConsoleCommand("espgui")]
        private void ccmdESPGUI(ConsoleSystem.Arg arg)
        {
            if (!arg.HasArgs())
                return;

            var player = arg.Player();

            if (player == null || !HasAccess(player))
                return;

            if (arg.Args.Contains(config.GUI.Arrow) || arg.Args.Contains("move"))
            {
                ccmdMovePosition(player, "espgui", arg.Args);
                return;
            }

            RadarCommandX(player, "espgui", arg.Args);
        }

        private void ccmdMovePosition(BasePlayer player, string command, string[] args)
        {
            var radar = _radars.Find(x => x.player == player);
            if (args.Length == 1)
            {
                ShowRadarUi(player, radar, false);
                ShowMoveUi(player, true);
                return;
            }
            if (!data.Offsets.TryGetValue(player.userID, out UiOffsets offsets))
            {
                return;
            }
            string[] offsetMin = offsets.Min.Split(' ');
            string[] offsetMax = offsets.Max.Split(' ');
            int n = player.serverInput.IsDown(BUTTON.DUCK) ? 1 : player.serverInput.IsDown(BUTTON.SPRINT) ? 50 : 15;
            switch (args[1])
            {
                case "left":
                    offsets.Min = $"{Convert.ToSingle(offsetMin[0]) - n} {offsetMin[1]}";
                    offsets.Max = $"{Convert.ToSingle(offsetMax[0]) - n} {offsetMax[1]}";
                    break;
                case "right":
                    offsets.Min = $"{Convert.ToSingle(offsetMin[0]) + n} {offsetMin[1]}";
                    offsets.Max = $"{Convert.ToSingle(offsetMax[0]) + n} {offsetMax[1]}";
                    break;
                case "up":
                    offsets.Min = $"{offsetMin[0]} {Convert.ToSingle(offsetMin[1]) + n}";
                    offsets.Max = $"{offsetMax[0]} {Convert.ToSingle(offsetMax[1]) + n}";
                    break;
                case "down":
                    offsets.Min = $"{offsetMin[0]} {Convert.ToSingle(offsetMin[1]) - n}";
                    offsets.Max = $"{offsetMax[0]} {Convert.ToSingle(offsetMax[1]) - n}";
                    break;
            }
            offsets.changed = true;
            data.Offsets[player.userID] = offsets;
            ShowRadarUi(player, radar, true);
        }

        private void RadarCommand(IPlayer user, string command, string[] args)
        {
            var player = user.Object as BasePlayer;

            if (player == null)
            {
                user.Message("Not a player!");
                return;
            }

            RadarCommandX(player, command, args);
        }

        private void RadarCommandX(BasePlayer player, string command, string[] args)
        {
            if (args.Contains("list") && permission.UserHasPermission(player.UserIDString, "adminradar.list"))
            {
                Message(player, "ActiveRadars", string.Join(", ", _radars.Select(x => x.username)));
                return;
            }

            //Added command `/radar optout` for a Rust developer to remove all privileges and become a normal player (this removes vanish, radar, admin flag, developer flag and sets auth level to 0)
            //Added command `/ radar optin` for a Rust developer to revert the changes made by opting out (this adds admin flag, developer flag and sets auth level to 3)

            //if (args.Contains("optout") && DeveloperList.Contains(player.userID)) // command: /radar optout
            //{
            //    var vanish = plugins.Find("Vanish") ?? plugins.Find("BetterVanish");
            //    if (vanish != null) vanish.Call("Reappear", player);

            //    DestroyRadar(player);

            //    if (player.IsFlying) player.SendConsoleCommand("noclip");
            //    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
            //    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsDeveloper, false);
            //    player.net.connection.authLevel = 0;
            //    player.SendNetworkUpdateImmediate();
            //    Message(player, "Your developer privileges have been removed.");
            //    return;
            //}

            //if (args.Contains("optin") && DeveloperList.Contains(player.userID)) // command: /radar optin
            //{
            //    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
            //    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsDeveloper, true);
            //    player.net.connection.authLevel = 3;
            //    player.SendNetworkUpdateImmediate();
            //    RadarCommandY(player, command, Array.Empty<string>() );
            //    Message(player, "Your developer privileges have been restored.");
            //    return;
            //}

            if (!HasAccess(player))
            {
                Message(player, player.Connection.authLevel > 0 ? "NotAllowed" : $"Unknown command: {command}");
                return;
            }

            RadarCommandY(player, command, args);
        }

        private void TurnRadarOn(BasePlayer player, string[] args)
        {
            RadarCommandY(player, radarCommand, args);
        }

        private void RadarCommandY(BasePlayer player, string command, string[] args)
        {
            args = args.ToLower(x => x.ToLower() != "true");

            if (!data.Filters.TryGetValue(player.UserIDString, out var filters))
            {
                data.Filters.Add(player.UserIDString, filters = new());
            }

            if (args.Length == 0)
            {
                if (DestroyRadar(player))
                {
                    return;
                }
            }
            else
            {
                switch (args[0])
                {
                    case "move":
                        {
                            var offsets = GetOffsets(player);
                            offsets.Mover = !offsets.Mover;
                            offsets.changed = true;
                            args = Array.FindAll(args, x => x != args[0]);
                        }
                        break;
                    case "reset":
                        {
                            data.Offsets.Remove(player.userID);
                            args = Array.FindAll(args, x => x != args[0]);
                        }
                        break;

                    case "buildings":
                        {
                            if (config.Options.BuildingsDrawTime > 0)
                            {
                                DrawBuildings(player, args.Contains("raid"), args.Contains("twig"));
                            }
                        }
                        return;
                    case "drops":
                        {
                            if (config.Options.DropsDrawTime > 0)
                            {
                                float distance = config.Distance.Drops;
                                if (args.Length == 2 && float.TryParse(args[1], out var result))
                                {
                                    distance = result;
                                }
                                DrawDrops(player, distance);
                            }
                        }
                        return;
                    case "findbyid":
                        {
                            if (config.Options.FindByIDDrawTime > 0)
                            {
                                if (args.Length != 2)
                                {
                                    Player.Message(player, $"{command} findbyid id");
                                    return;
                                }
                                if (!ulong.TryParse(args[1], out ulong userid))
                                {
                                    Player.Message(player, $"Invalid steam id: {userid}");
                                    return;
                                }
                                _coroutines.Push(ServerMgr.Instance.StartCoroutine(FindByIDRoutine(player, userid)));
                            }
                        }
                        return;
                    case "find":
                        if (args.Length > 1 && config.Options.FindDrawTime > 0)
                        {
                            _coroutines.Push(ServerMgr.Instance.StartCoroutine(DrawObjectsRoutine(player, args)));
                        }
                        return;
                    case "online":
                        {
                            if (!data.OnlineBoxes.Remove(player.UserIDString)) data.OnlineBoxes.Add(player.UserIDString);

                            Message(player, data.OnlineBoxes.Contains(player.UserIDString) ? "BoxesOnlineOnly" : "BoxesAll");
                        }
                        return;
                    case "vision":
                        {
                            if (!data.Visions.Remove(player.UserIDString)) data.Visions.Add(player.UserIDString);

                            Message(player, data.Visions.Contains(player.UserIDString) ? "VisionOn" : "VisionOff");
                        }
                        return;
                    case "ext":
                        {
                            if (!data.Extended.Remove(player.UserIDString)) data.Extended.Add(player.UserIDString);

                            Message(player, data.Extended.Contains(player.UserIDString) ? "ExtendedPlayersOn" : "ExtendedPlayersOff");
                        }
                        return;
                    case "help":
                        {
                            Message(player, "Help1", string.Join(", ", GetButtonNames().Keys) + ", HT");
                            Message(player, "Help2", command, "online");
                            Message(player, "Help3", command, "ui");
                            Message(player, "Help7", command, "vision");
                            Message(player, "Help8", command, "ext");
                            Message(player, "Help9", command, config.Distance.Loot);
                            Message(player, "Help5", command);
                            Message(player, "Help6", command);
                            Message(player, "PreviousFilter", command);
                        }
                        return;
                    case "ui":
                        {
                            if (!data.Hidden.Remove(player.UserIDString))
                            {
                                data.Hidden.Add(player.UserIDString);

                                DestroyUI(player);
                            }

                            Message(player, data.Hidden.Contains(player.UserIDString) ? "GUIHidden" : "GUIShown");

                            args = filters.Where(x => x != args[0]);
                        }
                        break;
                    case "f":
                        {
                            args = filters.ToArray();
                        }
                        break;
                    case "size":
                        {
                            TrySetFontSize(player, command, args);
                        }
                        return;
                }
            }

            if (command == "espgui")
            {
                foreach (var filter in args)
                {
                    if (!filters.Remove(filter))
                    {
                        filters.Add(filter);
                    }
                }
                args = filters.ToArray();
            }
            else
            {
                if (config.Settings.Cooldown > 0f && _cooldowns.ContainsKey(player.UserIDString))
                {
                    float cooldown = _cooldowns[player.UserIDString] - Time.realtimeSinceStartup;

                    if (cooldown > 0)
                    {
                        Message(player, "WaitCooldown", cooldown);
                        return;
                    }

                    _cooldowns.Remove(player.UserIDString);
                }

                if (args.Length == 0) data.Filters.Remove(player.UserIDString);
                else data.Filters[player.UserIDString] = args.ToList();
            }

            Radar radar = player.GetComponent<Radar>();

            if (radar == null)
            {
                radar = player.gameObject.AddComponent<Radar>();

                radar.Init(this);
            }

            float invokeTime, maxDistance;

            if (args.Length > 0 && float.TryParse(args[0], NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture, out float outTime))
            {
                invokeTime = outTime < 0.1f ? 0.1f : outTime;
            }
            else invokeTime = config.Settings.DefaultInvokeTime;

            if (args.Length > 1 && float.TryParse(args[1], NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture, out float outDistance))
            {
                maxDistance = outDistance <= 0f ? config.Settings.DefaultMaxDistance : outDistance;
            }
            else maxDistance = config.Settings.DefaultMaxDistance;

            radar.showAll = config.GUI.All && IsArg(args, "all");
            radar.showHT = IsArg(args, "ht");
            radar.entityTypes.Clear();

            if (!data.EntityNameSize.TryGetValue(radar.userid, out radar.entityNameSize)) radar.entityNameSize = config.Settings.EntityNameSize;
            if (!data.EntityTextSize.TryGetValue(radar.userid, out radar.entityTextSize)) radar.entityTextSize = config.Settings.EntityTextSize;
            if (!data.PlayerNameSize.TryGetValue(radar.userid, out radar.playerNameSize)) radar.playerNameSize = config.Settings.PlayerNameSize;
            if (!data.PlayerTextSize.TryGetValue(radar.userid, out radar.playerTextSize)) radar.playerTextSize = config.Settings.PlayerTextSize;

            int limit = config.Settings.GetLimit(player);

            if (limit > 0)
            {
                if (radar.showAll)
                {
                    args = Array.FindAll(args, x => x != "all");

                    radar.showAll = false;
                }

                if (args.Length > limit)
                {
                    args = args.Take(limit);
                }

                data.Filters[player.UserIDString] = args.ToList();
            }

            foreach (EntityType type in _allEntityTypes)
            {
                if (_errorTypes.Contains(type))
                {
                    continue;
                }
                if (radar.showAll || IsArg(args, type.ToString().ToLower()))
                {
                    radar.Add(type);
                }
                else if (config.Additional.Get(type) && !config.GUI.Get(type))
                {
                    radar.Add(type);
                }
            }

            if (config.Limit.Enabled)
            {
                radar.Add(EntityType.Limit);
            }

            if (config.Core.Active)
            {
                radar.Add(EntityType.Active);
            }

            if (config.Settings.UI && !data.Hidden.Contains(player.UserIDString))
            {
                ShowRadarUi(player, radar, false);
            }

            if (!data.Active.Contains(player.UserIDString))
            {
                data.Active.Add(player.UserIDString);
            }

            if (config.Settings.ShowToggle && command != "espgui")
            {
                Message(player, "Activated", invokeTime, maxDistance, command);
            }

            if (radar.maxDistance != maxDistance)
            {
                radar.maxDistance = maxDistance;
                radar.group = null;
            }

            radar.invokeTime = Mathf.Max(0.1f, invokeTime, config.Settings.MinInvokeTime);

            radar.SetupFilters(config.Settings.Barebones);
        }

        private void TrySetFontSize(BasePlayer player, string command, string[] args)
        {
            if (args.Length >= 3)
            {
                for (int i = 1; i < args.Length; i += 2)
                {
                    if (i + 1 < args.Length && int.TryParse(args[i + 1], out var value))
                    {
                        switch (args[i])
                        {
                            case "entityname":
                                data.EntityNameSize[player.UserIDString] = value;
                                break;
                            case "entitytext":
                                data.EntityTextSize[player.UserIDString] = value;
                                break;
                            case "playername":
                                data.PlayerNameSize[player.UserIDString] = value;
                                break;
                            case "playertext":
                                data.PlayerTextSize[player.UserIDString] = value;
                                break;
                        }
                    }
                }
            }
            else
            {
                Message(player, $"eg: /{command} size entityname 14 entitytext 14 playername 16 playertext 16");
            }
            var radar = _radars.Find(x => x.player == player);
            if (radar != null)
            {
                if (data.EntityNameSize.TryGetValue(player.UserIDString, out var entityNameSize)) radar.entityNameSize = entityNameSize;
                if (data.EntityTextSize.TryGetValue(player.UserIDString, out var entityTextSize)) radar.entityTextSize = entityTextSize;
                if (data.PlayerNameSize.TryGetValue(player.UserIDString, out var playerNameSize)) radar.playerNameSize = playerNameSize;
                if (data.PlayerTextSize.TryGetValue(player.UserIDString, out var playerTextSize)) radar.playerTextSize = playerTextSize;
            }
        }

        private void Init()
        {
            isUnloading = false;
            _isPopulatingCache = true;
            cache = new(this);
            Unsubscribe(nameof(OnPlayerRespawned));
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnPlayerVoice));
            Unsubscribe(nameof(OnPlayerSleepEnded));
            Unsubscribe(nameof(OnRadarActivated));
            Unsubscribe(nameof(OnRadarDeactivated));
            permission.RegisterPermission("adminradar.allowed", this);
            permission.RegisterPermission("adminradar.bypass", this);
            permission.RegisterPermission("adminradar.auto", this);
            permission.RegisterPermission("adminradar.bypass.override", this);
            permission.RegisterPermission("adminradar.list", this);
            LoadData();
            RegisterCommands();
        }

        private void Unload()
        {
            isUnloading = true;
            StopFillCache();
            foreach (var radar in _radars.ToList())
            {
                radar.StopAll();
                _radars.Remove(radar);
                UnityEngine.Object.Destroy(radar);
            }
            StringBuilderCache.Clear();
            SaveData();
        }

        private void OnServerInitialized()
        {
            RemoveNonAuthorizedOffsetData();

            if (!config.Methods.Box && !config.Methods.Text && !config.Methods.Arrow)
            {
                Puts("Configuration does not have a chosen drawing method. Setting drawing method to text.");
                config.Methods.Text = true;
            }

            if (config.Voice.Enabled && config.Voice.Distance > 0f)
            {
                Subscribe(nameof(OnPlayerVoice));
            }

            if (config.Settings.Barebones)
            {
                return;
            }

            _coroutines.Push(ServerMgr.Instance.StartCoroutine(FillCache()));

            if (data.Active.Count > 0)
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    if (HasAccess(player) && data.Active.Contains(player.UserIDString))
                    {
                        DelayedInvoke(player);
                    }
                }
            }

            if (permission.GetPermissionUsers("adminradar.auto").Length > 0)
            {
                Subscribe(nameof(OnPlayerSleepEnded));
            }

            if (_sendDiscordMessages)
            {
                Subscribe(nameof(OnRadarActivated));
                Subscribe(nameof(OnRadarDeactivated));
            }

            Subscribe(nameof(OnEntitySpawned));
            SetupClanTeamColors();
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            if (config.Settings.Barebones)
            {
                _radars.ForEach(radar => radar.TryCacheOnlinePlayer(player));
            }
            else
            {
                _spawnedEntities.Add(player);
            }
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            if (HasAccess(player) && permission.UserHasPermission(player.UserIDString, "adminradar.auto"))
            {
                DelayedInvoke(player);
            }
        }

        private void OnPlayerVoice(BasePlayer player, byte[] data)
        {
            if (player == null)
            {
                return;
            }

            foreach (var radar in _radars)
            {
                radar.Voices[player.userID] = Time.time + config.Voice.Interval + Mathf.Max(radar.invokeTime, config.Settings.DefaultInvokeTime);
            }
        }

        private void OnPlayerTrackStarted(BasePlayer player, ulong targetId)
        {
            if (player.userID != targetId)
            {
                _radars.Find(x => x.userid == player.UserIDString)?.exclude?.Add(targetId);
            }
        }

        private void OnPlayerTrackEnded(BasePlayer player, ulong targetId)
        {
            if (player.userID != targetId)
            {
                _radars.Find(x => x.userid == player.UserIDString)?.exclude?.Remove(targetId);
            }
        }

        private void OnRadarActivated(BasePlayer player, string playerName, string playerId, Vector3 lastPosition)
        {
            AdminRadarDiscordMessage(playerName, playerId, true, lastPosition);
        }

        private void OnRadarDeactivated(BasePlayer player, string playerName, string playerId, Vector3 lastPosition)
        {
            AdminRadarDiscordMessage(playerName, playerId, false, lastPosition);
        }

        private void OnEntitySpawned(BaseEntity entity)
        {
            _spawnedEntities.Add(entity);
        }

        private void OnEntityDeath(BaseEntity entity, HitInfo info)
        {
            if (entity.IsValid())
            {
                _despawnedEntities[entity.net.ID] = entity.transform.position;
            }
        }

        private void OnEntityKill(BaseEntity entity)
        {
            if (entity.IsValid())
            {
                _despawnedEntities[entity.net.ID] = entity.transform.position;
            }
        }

        private void OnTeamCreated(BasePlayer player, RelationshipManager.PlayerTeam team)
        {
            string hex = $"#{Core.Random.Range(0x1000000):X6}";
            _teamColors[team.teamID] = hex;
            Interface.CallHook("OnTeamCreatedColor", team.teamID, hex);
        }

        private void OnClanCreate(string tag)
        {
            string hex = $"#{Core.Random.Range(0x1000000):X6}";
            _clanColors[tag] = hex;
            Interface.CallHook("OnClanCreateColor", tag, hex);
        }

        private string GetClanColor(ulong targetId)
        {
            string clan = GetClanOf(targetId);

            if (string.IsNullOrEmpty(clan) || !_clanColors.ContainsKey(clan))
            {
                return null;
            }

            return _clanColors[clan];
        }

        private Dictionary<string, string> GetAllClanColors() => _clanColors;

        private Dictionary<ulong, string> GetAllTeamColors() => _teamColors;

        private string GetTeamColor(ulong id)
        {
            if (id.IsSteamId())
            {
                if (!RelationshipManager.ServerInstance.playerToTeam.TryGetValue(id, out var team))
                {
                    return null;
                }

                id = team.teamID;
            }

            if (!_teamColors.ContainsKey(id))
            {
                return null;
            }

            return _teamColors[id];
        }

        private string GetClanOf(ulong playerId)
        {
            if (!_clans.TryGetValue(playerId, out var clan))
            {
                _clans[playerId] = clan = Clans?.Call("GetClanOf", playerId) as string ?? string.Empty;
                timer.Once(30f, () => _clans.Remove(playerId));
            }

            return clan;
        }

        private void SetupClanTeamColors()
        {
            foreach (var team in RelationshipManager.ServerInstance.teams)
            {
                _teamColors[team.Key] = $"#{Core.Random.Range(0x1000000):X6}";
            }

            Interface.CallHook("OnTeamColorsInitialized", _teamColors);

            var clans = Clans?.Call("GetAllClans");

            if (clans is JArray array)
            {
                foreach (var token in array)
                {
                    _clanColors[token.ToString()] = $"#{Core.Random.Range(0x1000000):X6}";
                }
            }

            Interface.CallHook("OnClanColorsInitialized", _clanColors);
        }

        private bool DestroyRadar(BasePlayer player)
        {
            foreach (var x in _radars)
            {
                if (x.player == player)
                {
                    data.Active.Remove(player.UserIDString);
                    UnityEngine.Object.Destroy(x);
                    _radars.Remove(x);
                    return true;
                }
            }
            return false;
        }

        private bool IsRadar(string id)
        {
            return _radars.Exists(radar => radar.userid == id) ? true : false;
        }

        private void TryCacheByType(EntityType type, EntityInfo ei)
        {
            _radars.ForEach(radar => radar.TryCacheByType(type, ei));
        }

        public void AdminCommand(BasePlayer player, Action action)
        {
            bool isAdmin = player.IsAdmin;
            if (!isAdmin && !player.IsDeveloper && player.IsFlying)
            {
                return;
            }
            if (!isAdmin)
            {
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                player.SendNetworkUpdateImmediate();
            }
            try
            {
                action();
            }
            finally
            {
                if (!isAdmin)
                {
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                    player.SendNetworkUpdateImmediate();
                }
            }
        }

        private static Color __(string value)
        {
            return ColorUtility.TryParseHtmlString(value.StartsWith("#") ? value : $"#{value}", out Color color) ? color : Color.white;
        }

        private string StripTags(string value)
        {
            var sb = StringBuilderCache.Acquire(value);

            foreach (string str in _tags)
            {
                sb.Replace(str, string.Empty);
            }

            return StringBuilderCache.GetStringAndRelease(sb);
        }

        private bool HasAccess(BasePlayer player)
        {
            if (player == null)
                return false;

            if (DeveloperList.Contains(player.userID))
                return true;

            if (config.Settings.Authorized.Count > 0)
                return config.Settings.Authorized.Contains(player.UserIDString);

            if (permission.UserHasPermission(player.UserIDString, "adminradar.allowed"))
                return true;

            if (player.IsConnected && player.net.connection.authLevel >= config.Settings.authLevel)
                return true;

            return false;
        }

        private bool IsArg(string[] args, string val, bool equalTo = true)
        {
            if (equalTo)
            {
                return Array.Exists(args, arg => arg.Equals(val));
            }
            return Array.Exists(args, arg => arg.Contains(val) || val.Contains(arg));
        }

        private void DrawBuildings(BasePlayer player, bool showNonPlayerBases, bool showTwigOnly)
        {
            using var objects = DisposableList<object[]>.Get();
            foreach (var building in BuildingManager.server.buildingDictionary.Values)
            {
                if (!building.HasBuildingBlocks()) continue;
                foreach (var block in building.buildingBlocks)
                {
                    if (block.IsKilled()) continue;
                    if (showNonPlayerBases && block.OwnerID.IsSteamId()) continue;
                    if (!showNonPlayerBases && !block.OwnerID.IsSteamId()) continue;
                    if (showTwigOnly && block.grade != BuildingGrade.Enum.Twigs) continue;
                    var targetName = covalence.Players.FindPlayerById(block.OwnerID.ToString())?.Name;
                    if (string.IsNullOrEmpty(targetName)) targetName = block.OwnerID.IsSteamId() ? block.OwnerID.ToString() : "No owner";
                    objects.Add(new object[2] { block.transform.position, $"<size={config.Settings.PlayerTextSize}>{targetName}</size>" });
                    break;
                }
            }
            if (objects.Count > 0)
            {
                AdminCommand(player, () =>
                {
                    foreach (var obj in objects)
                    {
                        player.SendConsoleCommand("ddraw.text", config.Options.BuildingsDrawTime, Color.red, obj[0], obj[1]);
                    }
                });
            }
            Message(player, "ProcessRequestFinished", objects.Count);
        }

        private IEnumerator FindByIDRoutine(BasePlayer player, ulong userID)
        {
            Message(player, "ProcessRequest");
            int checks = 0;
            using var objects = DisposableList<object[]>.Get();
            foreach (BaseNetworkable net in BaseNetworkable.serverEntities)
            {
                var entity = net as BaseEntity;
                if (entity == null) continue;
                if (entity is BuildingPrivlidge priv && priv.IsAuthed(userID))
                {
                    objects.Add(new object[2] { Color.cyan, entity.transform.position });
                }
                else if (entity?.OwnerID == userID || entity is CodeLock codeLock && codeLock.whitelistPlayers.Contains(userID))
                {
                    objects.Add(new object[2] { Color.red, entity.transform.position });
                }
                else if (entity is SleepingBag bag && bag.deployerUserID == userID)
                {
                    objects.Add(new object[2] { Color.green, entity.transform.position });
                }
                else if (entity is AutoTurret turret && turret.IsAuthed(userID))
                {
                    objects.Add(new object[2] { Color.blue, entity.transform.position });
                }
                if (++checks % 200 == 0)
                {
                    yield return CoroutineEx.waitForSeconds(0.0025f);
                }
            }
            AdminCommand(player, () =>
            {
                foreach (var obj in objects)
                {
                    player.SendConsoleCommand("ddraw.text", config.Options.FindByIDDrawTime, obj[0], obj[1], userID);
                }
            });
            Message(player, "ProcessRequestFinished", objects.Count);
        }

        private const float CHUNK_SIZE = 1000f;

        private List<Collider> FindMapColliders(BasePlayer player)
        {
            List<Collider> colliders = Pool.Get<List<Collider>>();
            using var chunk = DisposableList<Collider>.Get();

            for (float x = 0; x < World.Size; x += CHUNK_SIZE)
            {
                for (float z = 0; z < World.Size; z += CHUNK_SIZE)
                {
                    chunk.Clear();

                    float normX = TerrainMeta.NormalizeX(x);
                    float normZ = TerrainMeta.NormalizeZ(z);
                    float y = TerrainMeta.HeightMap.GetHeight(normX, normZ);

                    Vis.Colliders(new Vector3(x, y, z), CHUNK_SIZE, chunk);

                    colliders.AddRange(chunk);
                }
            }

            return colliders;
        }

        private IEnumerator DrawObjectsRoutine(BasePlayer player, string[] args)
        {
            Message(player, "ProcessRequest");
            int checks = 0;
            using var objects = DisposableList<object[]>.Get();
            bool test = ConVar.Server.hostname.Contains("Test Server");
            string[] split = args[1].Split(':');
            if (split[0] == "asset" && player.Connection.authLevel >= 2)
            {
                var colliders = FindMapColliders(player);
                foreach (var collider in colliders)
                {
                    if (collider.name.Contains(split[1], CompareOptions.OrdinalIgnoreCase))
                    {
                        objects.Add(new object[3] { collider.transform.position, collider.name, Mathf.CeilToInt(Vector3.Distance(collider.transform.position, player.transform.position)) });
                    }
                    if (!test && ++checks % 1000 == 0)
                    {
                        yield return CoroutineEx.waitForSeconds(0.0025f);
                    }
                }
                Pool.FreeUnmanaged(ref colliders);
            }
            else
            {
                foreach (var e in BaseNetworkable.serverEntities)
                {
                    var ent = e as BaseEntity;
                    if (e.ShortPrefabName.Contains(split[0], CompareOptions.OrdinalIgnoreCase) || split[0] == "electrical" && e is IOEntity)
                    {
                        objects.Add(new object[3] { e.transform.position, e.ShortPrefabName + " (" + (ent?.OwnerID ?? 0) + ")", Mathf.CeilToInt(Vector3.Distance(e.transform.position, player.transform.position)) });
                    }
                    if (!test && ++checks % 1000 == 0)
                    {
                        yield return CoroutineEx.waitForSeconds(0.0025f);
                    }
                }
            }
            AdminCommand(player, () =>
            {
                foreach (var obj in objects)
                {
                    player.SendConsoleCommand("ddraw.text", config.Options.FindDrawTime, Color.red, obj[0], $"<size={config.Settings.PlayerTextSize}>{obj[1]} {obj[2]}</size>");
                }
            });
            Message(player, "ProcessRequestFinished", objects.Count);
        }

        private void DrawDrops(BasePlayer player, float maxDistance)
        {
            using var objects = DisposableList<object[]>.Get();
            if (!data.EntityTextSize.TryGetValue(player.UserIDString, out var entityTextSize))
            {
                entityTextSize = config.Settings.EntityTextSize;
            }
            foreach (var ei in cache.Drops.Values)
            {
                if (ei.t == null || !ei.entity.IsValid())
                {
                    continue;
                }
                var currDistance = Mathf.CeilToInt(Vector3.Distance(ei.entity.transform.position, player.transform.position));
                if (currDistance <= maxDistance)
                {
                    var shortname = ei.entity is DroppedItem drop ? drop?.item?.info?.shortname ?? ei.name : ei.name;
                    objects.Add(new object[2] { ei.entity.transform.position, $"<size={entityTextSize}>{shortname} <color=#FFFF00>{currDistance}</color></size>" });
                }
            }
            AdminCommand(player, () =>
            {
                foreach (var obj in objects)
                {
                    if (config.Methods.Text) player.SendConsoleCommand("ddraw.text", config.Options.DropsDrawTime, Color.red, obj[0], obj[1]);
                    if (config.Methods.Box) player.SendConsoleCommand("ddraw.box", config.Options.DropsDrawTime, Color.red, obj[0], 0.25f);
                }
            });
            Message(player, "ProcessRequestFinished", objects.Count);
        }

        private void LoadData()
        {
            try { data = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name); } catch (Exception ex) { Puts(ex.ToString()); }
            data ??= new();
            data.Init();
        }

        private void RemoveNonAuthorizedOffsetData()
        {
            foreach (ulong userid in data.Offsets.Keys.ToList())
            {
                if (permission.UserHasPermission(userid.ToString(), "adminradar.allowed"))
                {
                    continue;
                }
                if (DeveloperList.Contains(userid.ToString()))
                {
                    continue;
                }
                var user = ServerUsers.Get(userid);
                if (user?.group == ServerUsers.UserGroup.Owner)
                {
                    continue;
                }
                if (user?.group == ServerUsers.UserGroup.Moderator)
                {
                    continue;
                }
                data.Offsets.Remove(userid);
            }
        }

        private void SaveOffsetData()
        {
            bool changed = false;
            foreach (var (userid, offset) in data.Offsets.ToList())
            {
                if (offset.Equals(DefaultOffset) && offset.Mover)
                {
                    data.Offsets.Remove(userid);
                }
                if (offset.changed)
                {
                    offset.changed = false;
                    changed = true;
                }
            }
            if (changed && saveTimer == null)
            {
                saveTimer = timer.Once(300f, SaveData);
            }
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, data);
        }

        private void DelayedInvoke(BasePlayer player)
        {
            player.Invoke(() =>
            {
                if (!player.IsDestroyed && !IsRadar(player.UserIDString))
                {
                    RadarCommandX(player, "radar", data.Filters.ContainsKey(player.UserIDString) ? data.Filters[player.UserIDString].ToArray() : Array.Empty<string>());
                }
            }, UnityEngine.Random.Range(0.1f, 1f));
        }

        private Timer saveTimer;

        #region UI

        private List<ulong> isMovingUi = new();
        private List<string> radarUI = new();
        private const string RadarPanelName = "AdminRadar_UI";
        private const double S_X = 49.14;
        private const double S_Y = 22.03;
        private UiOffsets DefaultOffset;

        public void DestroyUI(BasePlayer player)
        {
            if (radarUI.Remove(player.UserIDString))
            {
                CuiHelper.DestroyUi(player, RadarPanelName);
            }
        }

        public static void AddCuiPanel(CuiElementContainer container, bool cursor, string color, string amin, string amax, string omin, string omax, string parent, string name)
        {
            container.Add(new CuiPanel
            {
                CursorEnabled = cursor,
                Image = { Color = color },
                RectTransform = { AnchorMin = amin, AnchorMax = amax, OffsetMin = omin, OffsetMax = omax }
            }, parent, name, name);
        }

        public static void AddCuiButton(CuiElementContainer container, string buttonColor, string command, string text, string textColor, int fontSize, TextAnchor align, string amin, string amax, string omin, string omax, string parent, string name, string font = "robotocondensed-regular.ttf")
        {
            container.Add(new CuiButton
            {
                Button = { Color = buttonColor, Command = command },
                Text = { Text = text, Font = font, FontSize = fontSize, Align = align, Color = textColor },
                RectTransform = { AnchorMin = amin, AnchorMax = amax, OffsetMin = omin, OffsetMax = omax }
            }, parent, name, name);
        }

        private UiOffsets GetOffsets(BasePlayer player)
        {
            if (!data.Offsets.TryGetValue(player.userID, out UiOffsets offsets))
            {
                if (!string.IsNullOrEmpty(config.GUI.Arrow))
                {
                    Message(player, "Radar UI Help", $"{radarCommand} move|reset");
                }

                data.Offsets[player.userID] = offsets = new(DefaultOffset.Min, DefaultOffset.Max);
            }
            return offsets;
        }

        private void ShowRadarUi(BasePlayer player, Radar radar, bool showMoveUi)
        {
            var container = new CuiElementContainer();
            var buttons = GetButtonNames().ToList();
            var offsets = GetOffsets(player);
            var rowLeftToRight = 0;
            var colTopToBottom = 0;

            if (config.GUI.All)
            {
                buttons.Insert(0, new(m("All", player.UserIDString), 0));
            }

            if (offsets.Mover && !string.IsNullOrEmpty(config.GUI.Arrow))
            {
                buttons.Insert(buttons.Count, new(config.GUI.Arrow, 0));
            }

            AddCuiPanel(container, false, "0 0 0 0", "0.5 0", "0.5 0", offsets.Min, offsets.Max, "Overlay", RadarPanelName);

            foreach (var obj in buttons)
            {
                var color = obj.Key == config.GUI.Arrow ? config.GUI.Off : obj.Key == "All" ? (radar.showAll ? config.GUI.On : config.GUI.Off) : (radar.GetBool(obj.Value) ? config.GUI.On : config.GUI.Off);
                var offsetMin = $"{-22.956 + (rowLeftToRight * S_X)} {-9.571 - (colTopToBottom * S_Y)}";
                var offsetMax = $"{22.956 + (rowLeftToRight * S_X)} {9.571 - (colTopToBottom * S_Y)}";
                var text = m(obj.Key, player.UserIDString);
                var command = $"espgui {obj.Key}";

                AddCuiButton(container, color, command, text, "1 1 1 1", 8, TextAnchor.MiddleCenter, "0.5 0.5", "0.5 0.5", offsetMin, offsetMax, RadarPanelName, $"BTN_{rowLeftToRight}_{colTopToBottom}");

                if (++rowLeftToRight >= 5)
                {
                    rowLeftToRight = 0;
                    colTopToBottom++;
                }
            }

            if (!radarUI.Contains(player.UserIDString))
            {
                radarUI.Add(player.UserIDString);
            }

            CuiHelper.AddUi(player, container);

            if (showMoveUi)
            {
                ShowMoveUi(player, false);
            }
        }

        public void ShowMoveUi(BasePlayer player, bool destroyUi)
        {
            string name = $"{RadarPanelName}_MOVE";

            if (destroyUi && isMovingUi.Remove(player.userID))
            {
                CuiHelper.DestroyUi(player, name);
                SaveOffsetData();
                return;
            }
            else if (!isMovingUi.Contains(player.userID))
            {
                isMovingUi.Add(player.userID);
            }

            ulong userid = player.userID;
            CuiElementContainer container = new();

            AddCuiPanel(container, true, "0 0 1 0.6", "0.5 1", "0.5 1", "58.804 -16.298", "137.604 7.102", RadarPanelName, name);
            AddCuiButton(container, "0 0 0.75 0.6", $"espgui move left", "", "1 1 1 1", 10, TextAnchor.MiddleCenter, "0.5 0.5", "0.5 0.5", "-35.484 -7.548", "-17.742 7.548", name, $"{name}_L");
            AddCuiButton(container, "0 0 0.75 0.6", $"espgui move up", "", "1 1 1 1", 10, TextAnchor.MiddleCenter, "0.5 0.5", "0.5 0.5", "-17.743 -7.548", "0 7.548", name, $"{name}_T");
            AddCuiButton(container, "0 0 0.75 0.6", $"espgui move down", "", "1 1 1 1", 10, TextAnchor.MiddleCenter, "0.5 0.5", "0.5 0.5", "-0.001 -7.548", "17.742 7.548", name, $"{name}_B");
            AddCuiButton(container, "0 0 0.75 0.6", $"espgui move right", "", "1 1 1 1", 10, TextAnchor.MiddleCenter, "0.5 0.5", "0.5 0.5", "17.742 -7.548", "35.485 7.548", name, $"{name}_R");

            CuiHelper.AddUi(player, container);
        }

        public SortedDictionary<string, EntityType> GetButtonNames()
        {
            SortedDictionary<string, EntityType> buttons = new();

            foreach (EntityType type in _allEntityTypes)
            {
                if (config.GUI.Get(type))
                {
                    buttons.Add(type.ToString(), type);
                }
            }

            return buttons;
        }

        public class UiOffsets
        {
            [JsonIgnore]
            public bool changed;
            public bool Mover = true;
            public string Min;
            public string Max;
            public UiOffsets() { }
            public UiOffsets(string min, string max)
            {
                Min = min;
                Max = max;
            }
            public bool Equals(UiOffsets other)
            {
                if (other != null && other.Min == Min)
                {
                    return other.Max == Max;
                }
                return false;
            }
        }

        #endregion

        #region Config

        public bool _sendDiscordMessages;

        private void AdminRadarDiscordMessage(string playerName, string playerId, bool state, Vector3 position)
        {
            if (isUnloading || DiscordMessages == null)
            {
                return;
            }

            var text = state ? config.Discord.On : config.Discord.Off;
            var grid = MapHelper.PositionToString(position);
            var message = $"[{DateTime.Now}] {playerName} ({playerId} @ {grid}): {text}";
            var chatEntry = new ConVar.Chat.ChatEntry { Message = message, UserId = playerId, Username = playerName, Time = Facepunch.Math.Epoch.Current };
            var steam = $"[{playerName}](https://steamcommunity.com/profiles/{playerId})";
            var server = $"steam://connect/{ConVar.Server.ip}:{ConVar.Server.port}";

            object fields = new[]
            {
                new { name = config.Discord.Player, value = steam, inline = true },
                new { name = config.Discord.Message, value = text, inline = false },
                new { name = config.Discord.Server, value = server, inline = false },
                new { name = config.Discord.Location, value = grid, inline = false }
            };

            LogToFile("toggles", message, this, false);
            RCon.Broadcast(RCon.LogType.Chat, chatEntry);
            Interface.CallHook("API_SendFancyMessage", config.Discord.Webhook, config.Discord.Title, config.Discord.Color, JsonConvert.SerializeObject(fields), null, this);
        }

        private static List<string> ItemExceptions
        {
            get
            {
                return new() { "bottle", "planner", "rock", "torch", "can.", "arrow." };
            }
        }

        private Configuration config;

        private string GetGroupColor(int index)
        {
            if (config.Limit.ColorsEnabled)
            {
                if (config.Limit.Colors.TryGetValue(index.ToString(), out string color))
                {
                    return color;
                }
            }

            return config.Limit.Basic;
        }

        private static Dictionary<string, string> DefaultColors
        {
            get
            {
                return new()
                {
                    ["0"] = "#FF00FF", // magenta
                    ["1"] = "#008000", // green
                    ["2"] = "#0000FF", // blue
                    ["3"] = "#FFA500", // orange
                    ["4"] = "#FFFF00" // yellow
                };
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new()
            {
                ["NotAllowed"] = "You are not allowed to use this command.",
                ["PreviousFilter"] = "To use your previous filter type <color=#FFA500>/{0} f</color>",
                ["Activated"] = "ESP Activated - {0}s refresh - {1}m distance. Use <color=#FFA500>/{2} help</color> for help.",
                ["Deactivated"] = "ESP Deactivated.",
                ["Exception"] = "ESP Tool: An error occured. Please check the server console.",
                ["GUIShown"] = "GUI will be shown",
                ["GUIHidden"] = "GUI will now be hidden",
                ["InvalidID"] = "{0} is not a valid steam id. Entry removed.",
                ["BoxesAll"] = "Now showing all boxes.",
                ["BoxesOnlineOnly"] = "Now showing online player boxes only.",
                ["Help1"] = "<color=#FFA500>Available Filters</color>: {0}",
                ["Help2"] = "<color=#FFA500>/{0} {1}</color> - Toggles showing online players boxes only when using the <color=#FF0000>box</color> filter.",
                ["Help3"] = "<color=#FFA500>/{0} {1}</color> - Toggles quick toggle UI on/off",
                ["Help5"] = "e.g: <color=#FFA500>/{0} 1 1000 box loot stash</color>",
                ["Help6"] = "e.g: <color=#FFA500>/{0} 0.5 400 all</color>",
                ["VisionOn"] = "You will now see where players are looking.",
                ["VisionOff"] = "You will no longer see where players are looking.",
                ["ExtendedPlayersOn"] = "Extended information for players is now on.",
                ["ExtendedPlayersOff"] = "Extended information for players is now off.",
                ["Help7"] = "<color=#FFA500>/{0} {1}</color> - Toggles showing where players are looking.",
                ["Help8"] = "<color=#FFA500>/{0} {1}</color> - Toggles extended information for players.",
                ["backpack"] = "backpack",
                ["scientist"] = "scientist",
                ["Help9"] = "<color=#FFA500>/{0} drops</color> - Show all dropped items within {1}m.",
                ["NoActiveRadars"] = "No one is using Radar at the moment.",
                ["ActiveRadars"] = "Active radar users: {0}",
                ["All"] = "All",
                ["Bags"] = "Bags",
                ["Box"] = "Box",
                ["Collectibles"] = "Collectibles",
                ["Dead"] = "Dead",
                ["Loot"] = "Loot",
                ["Ore"] = "Ore",
                ["Sleepers"] = "Sleepers",
                ["Stash"] = "Stash",
                ["TC"] = "TC",
                ["Turrets"] = "Turrets",
                ["Bear"] = "Bear",
                ["Boar"] = "Boar",
                ["Chicken"] = "Chicken",
                ["Wolf"] = "Wolf",
                ["Stag"] = "Stag",
                ["Horse"] = "Horse",
                ["My Base"] = "My Base",
                ["scarecrow"] = "scarecrow",
                ["murderer"] = "murderer",
                ["WaitCooldown"] = "You must wait {0} seconds to use this command again.",
                ["missionprovider_stables_a"] = "missions",
                ["missionprovider_stables_b"] = "missions",
                ["missionprovider_outpost_a"] = "missions",
                ["missionprovider_outpost_b"] = "missions",
                ["missionprovider_fishing_a"] = "missions",
                ["missionprovider_fishing_b"] = "missions",
                ["missionprovider_bandit_a"] = "missions",
                ["missionprovider_bandit_b"] = "missions",
                ["simpleshark"] = "shark",
                ["stables_shopkeeper"] = "shopkeeper",
                ["npc_underwaterdweller"] = "dweller",
                ["boat_shopkeeper"] = "shopkeeper",
                ["bandit_shopkeeper"] = "shopkeeper",
                ["outpost_shopkeeper"] = "shopkeeper",
                ["npc_bandit_guard"] = "guard",
                ["bandit_conversationalist"] = "vendor",
                ["npc_tunneldweller"] = "dweller",
                ["ProcessRequest"] = "Processing request; this will take several seconds...",
                ["ProcessRequestFinished"] = "{0} entities were found.",
                ["Radar UI Help"] = "You can toggle the move button/reset the UI using: {0}",
                ["AT"] = "AT",
                ["bag"] = "bag",
                ["LR300AR"] = "LR300",
                ["AR"] = "AK47",
                ["ARICE"] = "AK47",
                ["M92P"] = "M92",
                ["M39P"] = "M39",
                ["STH"] = "STH",
                ["SUB"] = "SUB",
                ["TB"] = "TB",
                ["RB"] = "RB",
                ["MLRS"] = "MLRS",
            }, this, "en");

            lang.RegisterMessages(new()
            {
                ["NotAllowed"] = "No tienes permitido usar este comando.",
                ["PreviousFilter"] = "Para usar tu filtro anterior, escribe <color=#FFA500>/{0} f</color>",
                ["Activated"] = "ESP Activado - Actualizacin cada {0}s - Distancia {1}m. Usa <color=#FFA500>/{2} help</color> para obtener ayuda.",
                ["Deactivated"] = "ESP Desactivado.",
                ["Exception"] = "Herramienta ESP: Se produjo un error. Por favor, revisa la consola del servidor.",
                ["GUIShown"] = "Se mostrar la interfaz grfica",
                ["GUIHidden"] = "La interfaz grfica ahora estar oculta",
                ["InvalidID"] = "{0} no es una ID de Steam vlida. Entrada eliminada.",
                ["BoxesAll"] = "Mostrando todas las cajas ahora.",
                ["BoxesOnlineOnly"] = "Mostrando solo cajas de jugadores en lnea ahora.",
                ["Help1"] = "<color=#FFA500>Filtros disponibles</color>: {0}",
                ["Help2"] = "<color=#FFA500>/{0} {1}</color> - Alterna mostrar solo las cajas de jugadores en lnea cuando se usa el filtro <color=#FF0000>box</color>.",
                ["Help3"] = "<color=#FFA500>/{0} {1}</color> - Activa o desactiva rpidamente la interfaz de alternancia.",
                ["Help5"] = "p. ej.: <color=#FFA500>/{0} 1 1000 box loot stash</color>",
                ["Help6"] = "p. ej.: <color=#FFA500>/{0} 0.5 400 all</color>",
                ["VisionOn"] = "Ahora podrs ver hacia dnde miran los jugadores.",
                ["VisionOff"] = "Ya no podrs ver hacia dnde miran los jugadores.",
                ["ExtendedPlayersOn"] = "La informacin extendida de los jugadores est activada ahora.",
                ["ExtendedPlayersOff"] = "La informacin extendida de los jugadores est desactivada ahora.",
                ["Help7"] = "<color=#FFA500>/{0} {1}</color> - Alterna mostrar hacia dnde miran los jugadores.",
                ["Help8"] = "<color=#FFA500>/{0} {1}</color> - Alterna la informacin extendida de los jugadores.",
                ["backpack"] = "mochila",
                ["scientist"] = "cientfico",
                ["Help9"] = "<color=#FFA500>/{0} drops</color> - Muestra todos los objetos cados dentro de {1}m.",
                ["NoActiveRadars"] = "Nadie est utilizando el Radar en este momento.",
                ["ActiveRadars"] = "Usuarios de radar activos: {0}",
                ["All"] = "Todos",
                ["Bags"] = "Bolsas",
                ["Box"] = "Caja",
                ["Collectibles"] = "Objetos coleccionables",
                ["Dead"] = "Muertos",
                ["Loot"] = "Botn",
                ["Ore"] = "Minerales",
                ["Sleepers"] = "Durmientes",
                ["Stash"] = "Escondite",
                ["TC"] = "TC",
                ["Turrets"] = "Torretas",
                ["Bear"] = "Oso",
                ["Boar"] = "Jabal",
                ["Chicken"] = "Pollo",
                ["Wolf"] = "Lobo",
                ["Stag"] = "Ciervo",
                ["Horse"] = "Caballo",
                ["My Base"] = "Mi Base",
                ["scarecrow"] = "espantapjaros",
                ["murderer"] = "asesino",
                ["WaitCooldown"] = "Debes esperar {0} segundos para usar este comando nuevamente.",
                ["missionprovider_stables_a"] = "misiones",
                ["missionprovider_stables_b"] = "misiones",
                ["missionprovider_outpost_a"] = "misiones",
                ["missionprovider_outpost_b"] = "misiones",
                ["missionprovider_fishing_a"] = "misiones",
                ["missionprovider_fishing_b"] = "misiones",
                ["missionprovider_bandit_a"] = "misiones",
                ["missionprovider_bandit_b"] = "misiones",
                ["simpleshark"] = "tiburn",
                ["stables_shopkeeper"] = "dependiente",
                ["npc_underwaterdweller"] = "morador",
                ["boat_shopkeeper"] = "dependiente",
                ["bandit_shopkeeper"] = "dependiente",
                ["outpost_shopkeeper"] = "dependiente",
                ["npc_bandit_guard"] = "guardia",
                ["bandit_conversationalist"] = "vendedor",
                ["npc_tunneldweller"] = "morador",
                ["ProcessRequest"] = "Procesando la solicitud; esto llevar varios segundos...",
                ["ProcessRequestFinished"] = "Se encontraron {0} entidades.",
                ["Radar UI Help"] = "Puedes alternar el botn de movimiento/restablecer la interfaz usando: {0}",
                ["AT"] = "AT",
                ["bag"] = "bolsa",
                ["LR300AR"] = "LR300",
                ["AR"] = "AK47",
                ["ARICE"] = "AK47",
                ["M92P"] = "M92",
                ["M39P"] = "M39",
                ["STH"] = "STH",
                ["SUB"] = "SUB",
                ["TB"] = "TB",
                ["RB"] = "RB",
                ["MLRS"] = "MLRS",
            }, this, "es-ES");

            lang.RegisterMessages(new()
            {
                ["NotAllowed"] = "Voc no tem permisso para usar este comando.",
                ["PreviousFilter"] = "Para usar seu filtro anterior, digite <color=#FFA500>/{0} f</color>",
                ["Activated"] = "ESP Ativado - Atualizao de {0}s - Distncia de {1}m. Use <color=#FFA500>/{2} help</color> para ajuda.",
                ["Deactivated"] = "ESP Desativado.",
                ["Exception"] = "Ferramenta ESP: Ocorreu um erro. Verifique o console do servidor.",
                ["GUIShown"] = "A GUI ser mostrada",
                ["GUIHidden"] = "A GUI agora ser ocultada",
                ["InvalidID"] = "{0} no  um ID Steam vlido. Entrada removida.",
                ["BoxesAll"] = "Mostrando todas as caixas.",
                ["BoxesOnlineOnly"] = "Mostrando apenas caixas de jogadores online.",
                ["Help1"] = "<color=#FFA500>Filtros Disponveis</color>: {0}",
                ["Help2"] = "<color=#FFA500>/{0} {1}</color> - Alterne para mostrar apenas caixas de jogadores online ao usar o filtro <color=#FF0000>box</color>.",
                ["Help3"] = "<color=#FFA500>/{0} {1}</color> - Alterne a interface de alternncia rpida on/off",
                ["Help5"] = "Exemplo: <color=#FFA500>/{0} 1 1000 box loot stash</color>",
                ["Help6"] = "Exemplo: <color=#FFA500>/{0} 0.5 400 all</color>",
                ["VisionOn"] = "Agora voc ver para onde os jogadores esto olhando.",
                ["VisionOff"] = "Voc no ver mais para onde os jogadores esto olhando.",
                ["ExtendedPlayersOn"] = "Informaes detalhadas dos jogadores ativadas.",
                ["ExtendedPlayersOff"] = "Informaes detalhadas dos jogadores desativadas.",
                ["Help7"] = "<color=#FFA500>/{0} {1}</color> - Alterne para mostrar para onde os jogadores esto olhando.",
                ["Help8"] = "<color=#FFA500>/{0} {1}</color> - Alterne para informaes detalhadas dos jogadores.",
                ["backpack"] = "mochila",
                ["scientist"] = "cientista",
                ["Help9"] = "<color=#FFA500>/{0} drops</color> - Mostra todos os itens cados dentro de {1}m.",
                ["NoActiveRadars"] = "Ningum est usando o radar no momento.",
                ["ActiveRadars"] = "Usurios ativos do radar: {0}",
                ["All"] = "Todos",
                ["Bags"] = "Bolsas",
                ["Box"] = "Caixa",
                ["Collectibles"] = "Colecionveis",
                ["Dead"] = "Mortos",
                ["Loot"] = "Loots",
                ["Ore"] = "Minrio",
                ["Sleepers"] = "Dormindo",
                ["Stash"] = "Stash",
                ["TC"] = "TC",
                ["Turrets"] = "Turrets",
                ["Bear"] = "Urso",
                ["Boar"] = "Javali",
                ["Chicken"] = "Galinha",
                ["Wolf"] = "Lobo",
                ["Stag"] = "Veado",
                ["Horse"] = "Cavalo",
                ["My Base"] = "Minha Base",
                ["scarecrow"] = "espantalho",
                ["murderer"] = "assassino",
                ["WaitCooldown"] = "Voc deve esperar {0} segundos para usar este comando novamente.",
                ["missionprovider_stables_a"] = "misses",
                ["missionprovider_stables_b"] = "misses",
                ["missionprovider_outpost_a"] = "misses",
                ["missionprovider_outpost_b"] = "misses",
                ["missionprovider_fishing_a"] = "misses",
                ["missionprovider_fishing_b"] = "misses",
                ["missionprovider_bandit_a"] = "misses",
                ["missionprovider_bandit_b"] = "misses",
                ["simpleshark"] = "tubaro",
                ["stables_shopkeeper"] = "vendedor",
                ["npc_underwaterdweller"] = "habitante subaqutico",
                ["boat_shopkeeper"] = "vendedor de barco",
                ["bandit_shopkeeper"] = "vendedor",
                ["outpost_shopkeeper"] = "vendedor",
                ["npc_bandit_guard"] = "guarda",
                ["bandit_conversationalist"] = "comerciante",
                ["npc_tunneldweller"] = "habitante do tnel",
                ["ProcessRequest"] = "Processando solicitao; isso levar alguns segundos...",
                ["ProcessRequestFinished"] = "{0} entidades foram encontradas.",
                ["Radar UI Help"] = "Voc pode alternar o boto de movimento/resetar a UI usando: {0}",
                ["AT"] = "AT",
                ["bag"] = "bolsa",
                ["LR300AR"] = "LR300",
                ["AR"] = "AK47",
                ["ARICE"] = "AK47",
                ["M92P"] = "M92",
                ["M39P"] = "M39"
            }, this, "pt-BR");
        }

        public class ConfigurationSettings
        {
            public int GetLimit(BasePlayer player)
            {
                if (player.Connection.authLevel >= 2) return Owner;
                if (player.Connection.authLevel == 1) return Moderator;
                return Allowed;
            }

            [JsonProperty(PropertyName = "Barebones Performance Mode")]
            public bool Barebones;

            [JsonProperty(PropertyName = "Restrict Access To Steam64 IDs", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Authorized = new();

            [JsonProperty(PropertyName = "Restrict Access To Auth Level")]
            public int authLevel = 1;

            [JsonProperty(PropertyName = "Max Active Filters (OWNERID)")]
            public int Owner = 0;

            [JsonProperty(PropertyName = "Max Active Filters (MODERATORID)")]
            public int Moderator = 4;

            [JsonProperty(PropertyName = "Max Active Filters (ADMINRADAR.ALLOWED)")]
            public int Allowed = 2;

            [JsonProperty(PropertyName = "Default Distance")]
            public float DefaultMaxDistance = 500f;

            [JsonProperty(PropertyName = "Default Refresh Time")]
            public float DefaultInvokeTime = 5f;

            [JsonProperty(PropertyName = "Minimum Refresh Time")]
            public float MinInvokeTime = 1.0f;

            [JsonProperty(PropertyName = "Dropped Item Exceptions", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> DropExceptions;

            [JsonProperty(PropertyName = "Deactivate Radar After X Seconds Inactive")]
            public float InactiveSeconds = 300;

            [JsonProperty(PropertyName = "Deactivate Radar After X Seconds Activated")]
            public float DeactivateSeconds;

            [JsonProperty(PropertyName = "User Interface Enabled")]
            public bool UI = true;

            [JsonProperty(PropertyName = "Show Average Ping Every X Seconds [0 = disabled]")]
            public float AveragePingInterval;

            [JsonProperty(PropertyName = "Show Player Idle Time (Minutes)")]
            public bool ShowIdleTime;

            [JsonProperty(PropertyName = "Player Idle Time Visible After X Minutes")]
            public int IdleVisibleMinutes = 1;

            [JsonProperty(PropertyName = "Player Idle Time Round To X Digits")]
            public int IdleRoundDigits;
            
            [JsonProperty(PropertyName = "Re-use Cooldown, Seconds")]
            public float Cooldown;

            [JsonProperty(PropertyName = "Show Radar Activated/Deactivated Messages")]
            public bool ShowToggle = true;

            [JsonProperty(PropertyName = "Player Name Text Size")]
            public int PlayerNameSize = 24;

            [JsonProperty(PropertyName = "Player Information Text Size")]
            public int PlayerTextSize = 24;

            [JsonProperty(PropertyName = "Entity Name Text Size")]
            public int EntityNameSize = 24;

            [JsonProperty(PropertyName = "Entity Information Text Size")]
            public int EntityTextSize = 24;

            [JsonProperty(PropertyName = "Unique Clan/Team Color Applies To Entire Player Text")]
            public bool ApplySameColor;

            [JsonProperty(PropertyName = "Track Group Name")]
            public string New = "";

            [JsonProperty(PropertyName = "Tracked Group Name Text")]
            public string NewText = "<color=#00FF00>*</color>";

            [JsonProperty(PropertyName = "Chat Command")]
            public string Primary = "radar";

            [JsonProperty(PropertyName = "Second Command")]
            public string Secondary = "radar";
        }

        public class ConfigurationOptions
        {
            [JsonProperty(PropertyName = "Additional Boxes", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> AdditionalBoxes = new() { "storage_barrel", "vendingmachine.deployed", "woodbox_deployed", "box.wooden.large", "dropbox.deployed", "coffinstorage", "small_stash_deployed", "mailbox.deployed", "missionstash", "heli_crate" };

            [JsonProperty(PropertyName = "Additional Traps", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> AdditionalTraps = new() { "barricade.metal", "barricade.stone", "barricade.wood", "barricade.woodwire", "spikes.floor", "guntrap", "sam_site_turret_deployed", "flameturret" };

            [JsonProperty(PropertyName = "Draw Distant Players With X")]
            public bool DrawX;

            [JsonProperty(PropertyName = "Draw Empty Containers")]
            public bool DrawEmptyContainers = true;

            [JsonProperty(PropertyName = "Abbreviate Item Names")]
            public bool Abbr = true;

            [JsonProperty(PropertyName = "Show Resource Amounts")]
            public bool ResourceAmounts = true;

            [JsonProperty(PropertyName = "Show X Items From Barrel And Crate")]
            public int LootContentAmount;

            [JsonProperty(PropertyName = "Show X Items From Airdrop")]
            public int AirdropContentAmount;

            [JsonProperty(PropertyName = "Show X Items From Stash")]
            public int StashContentAmount;

            [JsonProperty(PropertyName = "Show X Items From Backpacks")]
            public int BackpackContentAmount = 3;

            [JsonProperty(PropertyName = "Show X Items From Corpses")]
            public int CorpseContentAmount = 3;

            [JsonProperty(PropertyName = "Show NPC At World View")]
            public bool NpcWorldView = true;

            [JsonProperty(PropertyName = "Show NPC Name As Prefab Name")]
            public bool NpcPrefabName;

            [JsonProperty(PropertyName = "Show Authed Count On Cupboards")]
            public bool TCAuthed = true;

            [JsonProperty(PropertyName = "Show Bag Count On Cupboards")]
            public bool TCBags = true;

            [JsonProperty(PropertyName = "Show Npc Player Target")]
            public bool DrawTargetsVictim;

            [JsonProperty(PropertyName = "Radar Buildings Draw Time")]
            public float BuildingsDrawTime = 60f;

            [JsonProperty(PropertyName = "Radar Drops Draw Time")]
            public float DropsDrawTime = 60f;

            [JsonProperty(PropertyName = "Radar Find Draw Time")]
            public float FindDrawTime = 60f;

            [JsonProperty(PropertyName = "Radar FindByID Draw Time")]
            public float FindByIDDrawTime = 60f;

            public int Get(EntityType type)
            {
                switch (type)
                {
                    case EntityType.Backpack: return BackpackContentAmount;
                    case EntityType.Dead: return CorpseContentAmount;
                    case EntityType.Airdrop: return AirdropContentAmount;
                    case EntityType.Stash: return StashContentAmount;
                    case EntityType.Ore: return ResourceAmounts ? 1 : 0;
                    case EntityType.Col: return ResourceAmounts ? 1 : 0;
                    case EntityType.Loot: return LootContentAmount;
                    default: return 0;
                }
            }
        }

        public class ConfigurationDrawMethods
        {
            [JsonProperty(PropertyName = "Draw Arrows On Players")]
            public bool Arrow;

            [JsonProperty(PropertyName = "Draw Boxes")]
            public bool Box;

            [JsonProperty(PropertyName = "Draw Text")]
            public bool Text = true;
        }

        public class ConfigurationLimits
        {
            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled;

            [JsonProperty(PropertyName = "Limit")]
            public int Amount = 4;

            [JsonProperty(PropertyName = "Range")]
            public float Range = 50f;

            [JsonProperty(PropertyName = "Height Offset [0.0 = disabled]")]
            public float Height = 40f;

            [JsonProperty(PropertyName = "Use Group Colors Configuration")]
            public bool ColorsEnabled = true;

            [JsonProperty(PropertyName = "Dead Color")]
            public string Dead = "#ff0000";

            [JsonProperty(PropertyName = "Group Color Basic")]
            public string Basic = "#ffff00";

            [JsonProperty(PropertyName = "Group Limit Colors", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, string> Colors = DefaultColors;
        }

        public class ConfigurationDrawDistances
        {
            [JsonProperty(PropertyName = "Sleepers Min Y")]
            public float MinY = -150f;

            [JsonProperty(PropertyName = "Player Corpses")]
            public float Corpse = 200;

            [JsonProperty(PropertyName = "Players")]
            public float Players = 500;

            [JsonProperty(PropertyName = "Airdrop Crates")]
            public float Airdrop = 400f;

            [JsonProperty(PropertyName = "Animals")]
            public float Animal = 200;

            [JsonProperty(PropertyName = "Boats")]
            public float Boat = 150f;

            [JsonProperty(PropertyName = "Boxes")]
            public float Box = 100;

            [JsonProperty(PropertyName = "Cars")]
            public float Cars = 500f;

            [JsonProperty(PropertyName = "CCTV")]
            public float CCTV = 500;

            [JsonProperty(PropertyName = "Collectibles")]
            public float Col = 100;

            [JsonProperty(PropertyName = "Loot Containers")]
            public float Loot = 150;

            [JsonProperty(PropertyName = "MiniCopter")]
            public float MC = 200f;

            [JsonProperty(PropertyName = "MLRS")]
            public float MLRS = 5000f;

            [JsonProperty(PropertyName = "NPC Players")]
            public float NPC = 300;

            [JsonProperty(PropertyName = "Resources (Ore)")]
            public float Ore = 200;

            [JsonProperty(PropertyName = "Ridable Horses")]
            public float RH = 250;

            [JsonProperty(PropertyName = "Sleeping Bags")]
            public float Bag = 250;

            [JsonProperty(PropertyName = "Stashes")]
            public float Stash = 250;

            [JsonProperty(PropertyName = "Tool Cupboards")]
            public float TC = 150;

            [JsonProperty(PropertyName = "Tool Cupboard Arrows")]
            public float TCArrows = 250;

            [JsonProperty(PropertyName = "Traps")]
            public float Traps = 100;

            [JsonProperty(PropertyName = "Turrets")]
            public float Turret = 100;

            [JsonProperty(PropertyName = "Vending Machines")]
            public float VendingMachine = 250;

            [JsonProperty(PropertyName = "Radar Drops Command")]
            public float Drops = 500;

            public float Get(EntityType type, BaseEntity entity)
            {
                switch (type)
                {
                    case EntityType.Active: return Players;
                    case EntityType.Sleeper: return Players;
                    case EntityType.Dead: return Corpse;
                    case EntityType.Airdrop: return Airdrop;
                    case EntityType.Backpack: return Loot;
                    case EntityType.Boat: return Boat;
                    case EntityType.Bag: return Bag;
                    case EntityType.Car: return Cars;
                    case EntityType.CCTV: return CCTV;
                    case EntityType.Col: return Col;
                    case EntityType.Drop: return Drops;
                    case EntityType.Loot: return Loot;
                    case EntityType.Mini: return MC;
                    case EntityType.MLRS: return MLRS;
                    case EntityType.Ore: return Ore;
                    case EntityType.Horse: return RH;
                    case EntityType.RHIB: return Boat;
                    case EntityType.Stash: return Stash;
                    case EntityType.TC: return TC;
                    case EntityType.TCArrow: return TCArrows;
                    case EntityType.Trap: return Traps;
                    case EntityType.Turret: return Turret;
                    case EntityType.Bradley:
                    case EntityType.CargoPlane:
                    case EntityType.CargoShip:
                    case EntityType.CH47:
                    case EntityType.Limit:
                    default:
                        {
                            if (entity is VendingMachine) return VendingMachine;
                            if (type == EntityType.Box) return Box;
                            if (entity is BaseNpc) return Animal;
                            if (entity is BaseNPC2) return Animal;
                            if (type == EntityType.Npc) return NPC;
                            return 9999f;
                        }
                }
            }
        }

        public class ConfigurationCoreTracking
        {
            [JsonProperty(PropertyName = "Players")]
            public bool Active = true;

            [JsonProperty(PropertyName = "Sleepers")]
            public bool Sleepers = true;

            [JsonProperty(PropertyName = "Animals")]
            public bool Animals = true;

            [JsonProperty(PropertyName = "Bags")]
            public bool Bags = true;

            [JsonProperty(PropertyName = "Box")]
            public bool Box = true;

            [JsonProperty(PropertyName = "Collectibles")]
            public bool Col = true;

            [JsonProperty(PropertyName = "Dead")]
            public bool Dead = true;

            [JsonProperty(PropertyName = "Loot")]
            public bool Loot = true;

            [JsonProperty(PropertyName = "NPC")]
            public bool NPCPlayer = true;

            [JsonProperty(PropertyName = "Ore")]
            public bool Ore = true;

            [JsonProperty(PropertyName = "Stash")]
            public bool Stash = true;

            [JsonProperty(PropertyName = "SupplyDrops")]
            public bool Airdrop = true;

            [JsonProperty(PropertyName = "TC")]
            public bool TC = true;

            [JsonProperty(PropertyName = "Turrets")]
            public bool Turrets = true;
        }

        public class ConfigurationAdditionalTracking
        {
            [JsonProperty(PropertyName = "Backpacks Plugin")]
            public bool BackpackPlugin { get; set; }

            [JsonProperty(PropertyName = "Boats")]
            public bool Boats;

            [JsonProperty(PropertyName = "Bradley APC")]
            public bool Bradley = true;

            [JsonProperty(PropertyName = "Cars")]
            public bool Cars;

            [JsonProperty(PropertyName = "CargoPlanes")]
            public bool CP;

            [JsonProperty(PropertyName = "CargoShips")]
            public bool CS;

            [JsonProperty(PropertyName = "CCTV")]
            public bool CCTV;

            [JsonProperty(PropertyName = "CH47")]
            public bool CH47;

            [JsonProperty(PropertyName = "Helicopters")]
            public bool Heli = true;

            [JsonProperty(PropertyName = "Helicopter Rotor Health")]
            public bool RotorHealth;

            [JsonProperty(PropertyName = "MiniCopter")]
            public bool MC;

            [JsonProperty(PropertyName = "MLRS")]
            public bool MLRS = true;

            [JsonProperty(PropertyName = "Ridable Horses")]
            public bool RH;

            [JsonProperty(PropertyName = "RHIB")]
            public bool RHIB;

            [JsonProperty(PropertyName = "Traps")]
            public bool Traps;

            public bool Get(EntityType type)
            {
                switch (type)
                {
                    case EntityType.Boat: return Boats;
                    case EntityType.Bradley: return Bradley;
                    case EntityType.CargoPlane: return CP;
                    case EntityType.CargoShip: return CS;
                    case EntityType.Car: return Cars;
                    case EntityType.CCTV: return CCTV;
                    case EntityType.CH47: return CH47;
                    case EntityType.Heli: return Heli;
                    case EntityType.Horse: return RH;
                    case EntityType.Mini: return MC;
                    case EntityType.MLRS: return MLRS;
                    case EntityType.RHIB: return RHIB;
                    case EntityType.Trap: return Traps;
                    default: return false;
                }
            }
        }

        public class ConfigurationHex
        {
            [JsonProperty(PropertyName = "Player Arrows")]
            public string Arrows = "#000000";

            [JsonProperty(PropertyName = "Distance")]
            public string Dist = "#ffa500";

            [JsonProperty(PropertyName = "Helicopters")]
            public string Heli = "#ff00ff";

            [JsonProperty(PropertyName = "Bradley")]
            public string Bradley = "#ff00ff";

            [JsonProperty(PropertyName = "MiniCopter")]
            public string MC = "#ff00ff";

            [JsonProperty(PropertyName = "MiniCopter (ScrapTransportHelicopter)")]
            public string STH = "#ff00ff";

            [JsonProperty(PropertyName = "Online Player")]
            public string Online = "#ffffff";

            [JsonProperty(PropertyName = "Online Player (Underground)")]
            public string Underground = "#ffffff";

            [JsonProperty(PropertyName = "Online Player (Flying)")]
            public string Flying = "#ffffff";

            [JsonProperty(PropertyName = "Online Dead Player")]
            public string OnlineDead = "#ff0000";

            [JsonProperty(PropertyName = "Dead Player")]
            public string Dead = "#ff0000";

            [JsonProperty(PropertyName = "Sleeping Player")]
            public string Sleeper = "#00ffff";

            [JsonProperty(PropertyName = "Sleeping Dead Player")]
            public string SleeperDead = "#ff0000";

            [JsonProperty(PropertyName = "Health")]
            public string Health = "#ff0000";

            [JsonProperty(PropertyName = "Idle Time")]
            public string IdleTime = "#00ffff";

            [JsonProperty(PropertyName = "Backpacks")]
            public string Backpack = "#c0c0c0";

            [JsonProperty(PropertyName = "Scientists")]
            public string Scientist = "#ffff00";

            [JsonProperty(PropertyName = "Scientist Peacekeeper")]
            public string Peacekeeper = "#ffff00";

            [JsonProperty(PropertyName = "Murderers")]
            public string Murderer = "#000000";

            [JsonProperty(PropertyName = "Animals")]
            public string Animal = "#0000ff";

            [JsonProperty(PropertyName = "Resources")]
            public string Resource = "#ffff00";

            [JsonProperty(PropertyName = "Collectibles")]
            public string Col = "#ffff00";

            [JsonProperty(PropertyName = "Tool Cupboards")]
            public string TC = "#000000";

            [JsonProperty(PropertyName = "Sleeping Bags")]
            public string Bag = "#ff00ff";

            [JsonProperty(PropertyName = "Airdrops")]
            public string AD = "#ff00ff";

            [JsonProperty(PropertyName = "AutoTurrets")]
            public string AT = "#ffff00";

            [JsonProperty(PropertyName = "Corpses")]
            public string Corpse = "#ffff00";

            [JsonProperty(PropertyName = "Box")]
            public string Box = "#ff00ff";

            [JsonProperty(PropertyName = "Loot")]
            public string Loot = "#ffff00";

            [JsonProperty(PropertyName = "Stash")]
            public string Stash = "#ffffff";

            [JsonProperty(PropertyName = "Boat")]
            public string Boat = "#ff00ff";

            [JsonProperty(PropertyName = "CargoPlane")]
            public string CP = "#ff00ff";

            [JsonProperty(PropertyName = "CargoShip")]
            public string CS = "#ff00ff";

            [JsonProperty(PropertyName = "Car")]
            public string Cars = "#ff00ff";

            [JsonProperty(PropertyName = "CCTV")]
            public string CCTV = "#ff00ff";

            [JsonProperty(PropertyName = "CH47")]
            public string CH47 = "#ff00ff";

            [JsonProperty(PropertyName = "RidableHorse")]
            public string RH = "#ff00ff";

            [JsonProperty(PropertyName = "MLRS")]
            public string MLRS = "#ff00ff";

            [JsonProperty(PropertyName = "NPC")]
            public string NPC = "#ff00ff";

            [JsonProperty(PropertyName = "RHIB")]
            public string RHIB = "#ff00ff";

            [JsonProperty(PropertyName = "Traps")]
            public string Traps = "#ff00ff";

            public string Get(EntityType type)
            {
                switch (type)
                {
                    case EntityType.Active: return Online;
                    case EntityType.Airdrop: return Box;
                    case EntityType.Backpack: return Backpack;
                    case EntityType.Bag: return Bag;
                    case EntityType.Boat: return Boat;
                    case EntityType.Box: return Box;
                    case EntityType.Bradley: return Bradley;
                    case EntityType.CargoPlane: return CP;
                    case EntityType.CargoShip: return CS;
                    case EntityType.Car: return Cars;
                    case EntityType.CCTV: return CCTV;
                    case EntityType.CH47: return CH47;
                    case EntityType.Col: return Col;
                    case EntityType.Dead: return Dead;
                    case EntityType.Heli: return Heli;
                    case EntityType.Horse: return RH;
                    case EntityType.Loot: return Loot;
                    case EntityType.Mini: return MC;
                    case EntityType.MLRS: return MLRS;
                    case EntityType.Npc: return NPC;
                    case EntityType.Ore: return Resource;
                    case EntityType.RHIB: return RHIB;
                    case EntityType.Sleeper: return Sleeper;
                    case EntityType.Stash: return Stash;
                    case EntityType.TC: return TC;
                    case EntityType.Turret: return AT;
                    case EntityType.Trap: return Traps;
                    default: return "#ff00ff";
                }
            }
        }

        public class ConfigurationGUI
        {
            [JsonProperty(PropertyName = "Move Arrow Text")]
            public string Arrow = "";

            [JsonProperty(PropertyName = "Offset Min")]
            public string OffsetMin = "185.044 91.429";

            [JsonProperty(PropertyName = "Offset Max")]
            public string OffsetMax = "230.956 110.571";

            [JsonProperty(PropertyName = "Color On")]
            public string On = "0.69 0.49 0.29 0.5";

            [JsonProperty(PropertyName = "Color Off")]
            public string Off = "0.29 0.49 0.69 0.5";

            [JsonProperty(PropertyName = "Show Button - All")]
            public bool All = true;

            [JsonProperty(PropertyName = "Show Button - Airdrops")]
            public bool Airdrop = true;

            [JsonProperty(PropertyName = "Show Button - Bags")]
            public bool Bags = true;

            [JsonProperty(PropertyName = "Show Button - Boats")]
            public bool Boats;

            [JsonProperty(PropertyName = "Show Button - Bradley")]
            public bool Bradley;

            [JsonProperty(PropertyName = "Show Button - Box")]
            public bool Box = true;

            [JsonProperty(PropertyName = "Show Button - Cars")]
            public bool Cars;

            [JsonProperty(PropertyName = "Show Button - CCTV")]
            public bool CCTV = true;

            [JsonProperty(PropertyName = "Show Button - CargoPlanes")]
            public bool CP;

            [JsonProperty(PropertyName = "Show Button - CargoShips")]
            public bool CS;

            [JsonProperty(PropertyName = "Show Button - CH47")]
            public bool CH47;

            [JsonProperty(PropertyName = "Show Button - Collectibles")]
            public bool Col = true;

            [JsonProperty(PropertyName = "Show Button - Dead")]
            public bool Dead = true;

            [JsonProperty(PropertyName = "Show Button - Heli")]
            public bool Heli;

            [JsonProperty(PropertyName = "Show Button - Loot")]
            public bool Loot = true;

            [JsonProperty(PropertyName = "Show Button - MiniCopter")]
            public bool MC;

            [JsonProperty(PropertyName = "Show Button - MLRS")]
            public bool MLRS = true;

            [JsonProperty(PropertyName = "Show Button - NPC")]
            public bool NPC = true;

            [JsonProperty(PropertyName = "Show Button - Ore")]
            public bool Ore = true;

            [JsonProperty(PropertyName = "Show Button - Ridable Horses")]
            public bool Horse;

            [JsonProperty(PropertyName = "Show Button - RigidHullInflatableBoats")]
            public bool RHIB;

            [JsonProperty(PropertyName = "Show Button - Sleepers")]
            public bool Sleepers = true;

            [JsonProperty(PropertyName = "Show Button - Stash")]
            public bool Stash = true;

            [JsonProperty(PropertyName = "Show Button - TC")]
            public bool TC = true;

            [JsonProperty(PropertyName = "Show Button - TC Arrow")]
            public bool TCArrow = true;

            [JsonProperty(PropertyName = "Show Button - TC Turrets")]
            public bool Turrets = true;

            [JsonProperty(PropertyName = "Show Button - Traps")]
            public bool Traps = true;

            public bool Get(EntityType type)
            {
                switch (type)
                {
                    case EntityType.Airdrop: return Airdrop;
                    case EntityType.Bag: return Bags;
                    case EntityType.Boat: return Boats;
                    case EntityType.Box: return Box;
                    case EntityType.Bradley: return Bradley;
                    case EntityType.CargoPlane: return CP;
                    case EntityType.CargoShip: return CS;
                    case EntityType.Car: return Cars;
                    case EntityType.CCTV: return CCTV;
                    case EntityType.CH47: return CH47;
                    case EntityType.Col: return Col;
                    case EntityType.Dead: return Dead;
                    case EntityType.Heli: return Heli;
                    case EntityType.Horse: return Horse;
                    case EntityType.Loot: return Loot;
                    case EntityType.Mini: return MC;
                    case EntityType.MLRS: return MLRS;
                    case EntityType.Npc: return NPC;
                    case EntityType.Ore: return Ore;
                    case EntityType.RHIB: return RHIB;
                    case EntityType.Sleeper: return Sleepers;
                    case EntityType.Stash: return Stash;
                    case EntityType.TC: return TC;
                    case EntityType.TCArrow: return TCArrow;
                    case EntityType.Turret: return Turrets;
                    case EntityType.Trap: return Traps;
                    default: return false;
                }
            }
        }

        public class ConfigurationVoiceDetection
        {
            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled = true;

            [JsonProperty(PropertyName = "Timeout After X Seconds")]
            public int Interval = 3;

            [JsonProperty(PropertyName = "Detection Radius")]
            public float Distance = 30f;
        }

        public class ConfigurationDiscord
        {
            [JsonProperty(PropertyName = "Message - Embed Color (DECIMAL)")]
            public int Color = 3329330;

            [JsonProperty(PropertyName = "Message - Webhook URL")]
            public string Webhook = "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";

            [JsonProperty(PropertyName = "Embed_MessageServer")]
            public string Server = "Server";

            [JsonProperty(PropertyName = "Embed_MessageLocation")]
            public string Location = "Location";

            [JsonProperty(PropertyName = "Embed_MessageTitle")]
            public string Title = "Player Message";

            [JsonProperty(PropertyName = "Embed_MessagePlayer")]
            public string Player = "Player";

            [JsonProperty(PropertyName = "Embed_MessageMessage")]
            public string Message = "Message";

            [JsonProperty(PropertyName = "Off")]
            public string Off = "Radar turned off.";

            [JsonProperty(PropertyName = "On")]
            public string On = "Radar turned on.";
        }

        public class ConfigurationTrack
        {
            [JsonProperty(PropertyName = "Radar")]
            public bool Radar;

            [JsonProperty(PropertyName = "Radar Text")]
            public string RadarText = "<color=#00FF00>R</color>";

            [JsonProperty(PropertyName = "Console Godmode")]
            public bool God;

            [JsonProperty(PropertyName = "Console Godmode Text")]
            public string GodText = "<color=#89CFF0>G</color>";

            [JsonProperty(PropertyName = "Plugin Godmode")]
            public bool GodPlugin;

            [JsonProperty(PropertyName = "Plugin Godmode Text")]
            public string GodPluginText = "<color=#0000CD>G</color>";

            [JsonProperty(PropertyName = "Vanish")]
            public bool Vanish = true;

            [JsonProperty(PropertyName = "Vanish Text")]
            public string VanishText = "<color=#FF00FF>V</color>";

            [JsonProperty(PropertyName = "NOCLIP")]
            public bool NoClip;

            [JsonProperty(PropertyName = "NOCLIP Text")]
            public string NoClipText = "<color=#FFFF00>F</color>";
        }

        public class Configuration
        {
            [JsonProperty(PropertyName = "Core Tracking")]
            public ConfigurationCoreTracking Core { get; set; } = new();

            [JsonProperty(PropertyName = "Additional Tracking")]
            public ConfigurationAdditionalTracking Additional { get; set; } = new();

            [JsonProperty(PropertyName = "Color-Hex Codes")]
            public ConfigurationHex Hex { get; set; } = new();

            [JsonProperty(PropertyName = "DiscordMessages")]
            public ConfigurationDiscord Discord { get; set; } = new();

            [JsonProperty(PropertyName = "Drawing Distances")]
            public ConfigurationDrawDistances Distance { get; set; } = new();

            [JsonProperty(PropertyName = "Drawing Methods")]
            public ConfigurationDrawMethods Methods { get; set; } = new();

            [JsonProperty(PropertyName = "Group Limit")]
            public ConfigurationLimits Limit { get; set; } = new();

            [JsonProperty(PropertyName = "GUI")]
            public ConfigurationGUI GUI { get; set; } = new();

            [JsonProperty(PropertyName = "Options")]
            public ConfigurationOptions Options { get; set; } = new();

            [JsonProperty(PropertyName = "Settings")]
            public ConfigurationSettings Settings { get; set; } = new();

            [JsonProperty(PropertyName = "Track Admin Status")]
            public ConfigurationTrack Track { get; set; } = new();

            [JsonProperty(PropertyName = "Voice Detection")]
            public ConfigurationVoiceDetection Voice { get; set; } = new();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            canSaveConfig = false;

            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
                if (config.Settings.DropExceptions == null) config.Settings.DropExceptions = ItemExceptions;
                canSaveConfig = true;
                SaveConfig();
            }
            catch (Exception ex)
            {
                Puts(ex.ToString());
                LoadDefaultConfig();
            }

            if (config.GUI.Boats) config.Additional.Boats = true;
            if (config.GUI.Bradley) config.Additional.Bradley = true;
            if (config.GUI.Cars) config.Additional.Cars = true;
            if (config.GUI.CCTV) config.Additional.CCTV = true;
            if (config.GUI.CP) config.Additional.CP = true;
            if (config.GUI.CS) config.Additional.CS = true;
            if (config.GUI.CH47) config.Additional.CH47 = true;
            if (config.GUI.Heli) config.Additional.Heli = true;
            if (config.GUI.MC) config.Additional.MC = true;
            if (config.GUI.MLRS) config.Additional.MLRS = true;
            if (config.GUI.Horse) config.Additional.RH = true;
            if (config.GUI.RHIB) config.Additional.RHIB = true;
            if (config.Voice.Interval < 3) config.Voice.Interval = 3;

            DefaultOffset = new(config.GUI.OffsetMin, config.GUI.OffsetMax);

            _sendDiscordMessages = !string.IsNullOrEmpty(config.Discord.Webhook) && config.Discord.Webhook != "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";
        }

        private void RegisterCommands()
        {
            if (!string.IsNullOrEmpty(config.Settings.Primary))
            {
                radarCommand = config.Settings.Primary;
                AddCovalenceCommand(config.Settings.Primary, nameof(RadarCommand));
            }
            if (!string.IsNullOrEmpty(config.Settings.Secondary) && config.Settings.Primary != config.Settings.Secondary)
            {
                if (string.IsNullOrEmpty(radarCommand))
                {
                    radarCommand = config.Settings.Secondary;
                }
                AddCovalenceCommand(config.Settings.Secondary, nameof(RadarCommand));
            }
        }

        private string radarCommand;
        private bool canSaveConfig = true;

        protected override void SaveConfig()
        {
            if (canSaveConfig)
            {
                Config.WriteObject(config);
            }
        }

        protected override void LoadDefaultConfig() => config = new();

        private string m(string key, string id, params object[] args)
        {
            return args.Length > 0 ? string.Format(lang.GetMessage(key, this, id), args) : lang.GetMessage(key, this, id);
        }

        private static string R(string source)
        {
            return source.Contains(">") ? Regex.Replace(source, "<.*?>", string.Empty) : source;
        }

        private void Message(BasePlayer target, string key, params object[] args)
        {
            if (target.IsValid())
            {
                Player.Message(target, m(key, target.UserIDString, args), 0uL);
            }
        }

        #endregion
    }
}

namespace Oxide.Plugins.AdminRadarExtensionMethods
{
    public static class ExtensionMethods
    {
        public class DisposableList<T> : List<T>, IDisposable, Pool.IPooled
        {
            public void EnterPool() => this.Clear();
            public void LeavePool() => this.Clear();
            public void Dispose() { DisposableList<T> obj = this; obj.Clear(); Pool.Free(ref obj); }
            public static DisposableList<T> Get() => Pool.Get<DisposableList<T>>();
        }
        public static T ElementAt<T>(this IEnumerable<T> a, int b) { using (var c = a.GetEnumerator()) { while (c.MoveNext()) { if (b == 0) { return c.Current; } b--; } } return default(T); }
        public static List<T> ToList<T>(this IEnumerable<T> a, Func<T, bool> b = null) { var c = new List<T>(); using (var d = a.GetEnumerator()) { while (d.MoveNext()) { if (b == null || b(d.Current)) { c.Add(d.Current); } } } return c; }
        public static string[] ToLower(this IEnumerable<string> a, Func<string, bool> b = null) { var c = new List<string>(); using (var d = a.GetEnumerator()) { while (d.MoveNext()) { if (b == null || b(d.Current)) { c.Add(d.Current.ToLower()); } } } return c.ToArray(); }
        public static T[] Take<T>(this IList<T> a, int b) { var c = new List<T>(); for (int i = 0; i < a.Count; i++) { if (c.Count == b) { break; } c.Add(a[i]); } return c.ToArray(); }
        public static IEnumerable<V> Select<T, V>(this IEnumerable<T> a, Func<T, V> b) { var c = new List<V>(); using (var d = a.GetEnumerator()) { while (d.MoveNext()) { c.Add(b(d.Current)); } } return c; }
        public static T[] Where<T>(this IEnumerable<T> a, Func<T, bool> b) { var c = new List<T>(); using (var d = a.GetEnumerator()) { while (d.MoveNext()) { if (b(d.Current)) { c.Add(d.Current); } } } return c.ToArray(); }
        public static float Sum<T>(this IEnumerable<T> a, Func<T, float> b) { float c = 0; if (a == null) return c; foreach (T d in a) { if (d == null) continue; c = checked(c + b(d)); } return c; }
        public static int Sum<T>(this IEnumerable<T> a, Func<T, int> b) { int c = 0; if (a == null) return c; foreach (T d in a) { if (d == null) continue; c = checked(c + b(d)); } return c; }
        public static bool IsKilled(this BaseNetworkable a) => a == null || a.net == null || a.IsDestroyed || !a.isSpawned;
        public static void ResetToPool<K, V>(this Dictionary<K, V> obj) { if (obj == null) return; obj.Clear(); Pool.FreeUnmanaged(ref obj); }
        public static void ResetToPool<T>(this HashSet<T> obj) { if (obj == null) return; obj.Clear(); Pool.FreeUnmanaged(ref obj); }
        public static void ResetToPool<T>(this List<T> obj) { if (obj == null) return; obj.Clear(); Pool.FreeUnmanaged(ref obj); }
    }
}

// --- End of file: AdminRadar.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/angry-bounds ---
// --- Original File Path: A/AngryBounds/AngryBounds.cs ---

using System;
using System.Text;
using System.Collections.Generic;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("AngryBounds", "Tori1157", "1.2.0")]
    [Description("Prevents players from building outside of map bounds.")]

    public class AngryBounds : RustPlugin
    {
        #region Fields

        private bool Changed;

        private decimal boundChange;

        #endregion

        #region Loading

        private void Init() => LoadVariables();

        private void LoadVariables()
        {
            boundChange = Convert.ToDecimal(GetConfig("Options", "Boundary Adjust Size", 0));

            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Out Of Bounds"] = "<color=red>You're out of bounds, can't build here!</color>",
            }, this);
        }

        #endregion

        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            var player = plan.GetOwnerPlayer();
            var entity = go.ToBaseEntity();

            if (player == null || entity == null)
                return;

            var block = entity.GetComponent<BuildingBlock>();

            if (player != null && CheckPlayerPosition(player))
            {

                NextTick(() =>
                {
                    entity.Kill();
                    player.ChatMessage(lang.GetMessage("Out Of Bounds", this, player.UserIDString));
                });

                if (block != null)
                {
                    foreach (var refundItem in block.BuildCost()) // Credit to Ryan for this code.
                        player.GiveItem(ItemManager.CreateByItemID(refundItem.itemDef.itemid, (int)refundItem.amount));
                }
                else
                {
                    string item = ClearName(entity.ShortPrefabName);

                    if (item == null)
                        return;

                    int itemId = (int)entity.prefabID;

                    ItemDefinition definition = ItemManager.itemList.Find((ItemDefinition x) => x.shortname == item);

                    if (definition == null)
                    {
                        ItemDefinition IdDefinition = ItemManager.FindItemDefinition(itemId);

                        if (IdDefinition != null)
                        {
                            player.GiveItem(ItemManager.CreateByItemID(itemId, 1));
                            return;
                        }

                        return;
                    }

                    player.GiveItem(ItemManager.CreateByPartialName(item, 1));
                }
            }
        }

        private bool CheckPlayerPosition(BasePlayer player)
        {
            var worldHalf = World.Size / 2;
            var worldAdded = (Math.Sign(boundChange) == -1 ? worldHalf - Decimal.Negate(boundChange) : worldHalf + boundChange);

            var playerX = Convert.ToDecimal(player.transform.position.x);
            var playerZ = Convert.ToDecimal(player.transform.position.z);

            var positionX = (Math.Sign(playerX) == -1 ? Decimal.Negate(playerX) : playerX);
            var positionZ = (Math.Sign(playerZ) == -1 ? Decimal.Negate(playerZ) : playerZ);

            if (Math.Sign(boundChange) == 0)
                return positionX > worldHalf || positionZ > worldHalf;
            else
                return positionX > worldAdded || positionZ > worldAdded;
        }

        #region Helpers

        string ClearName(string item)
        {
            var replace = new[] { ".deployed", "_deployed", "_leather", "_small", "_large" };
            var output = new StringBuilder(item);

            foreach (var r in replace)
                output.Replace(r, string.Empty);

            return output.ToString();
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;

            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }

            object value;

            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        #endregion
    }
}

// --- End of file: AngryBounds.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/admin-no-loot ---
// --- Original File Path: A/AdminNoLoot/AdminNoLoot.cs ---

using Newtonsoft.Json;
using Oxide.Core.Configuration;
using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Admin No Loot", "Dana", "0.1.3")]
    [Description("Protects admins' corpses and bodies from being looted.")]
    public class AdminNoLoot : RustPlugin
    {
        private PluginConfig _pluginConfig;
        public const string PermissionBypass = "adminnoloot.bypass";

        #region Hooks

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }
        protected override void LoadConfig()
        {
            var configPath = $"{Manager.ConfigPath}/{Name}.json";
            var newConfig = new DynamicConfigFile(configPath);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }

            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = newConfig.ReadObject<PluginConfig>();
            if (_pluginConfig.Config == null)
            {
                _pluginConfig.Config = new AdminNoLootConfig
                {
                    ShowWarning = true
                };
            }
            newConfig.WriteObject(_pluginConfig);
            PrintWarning("Config Loaded");
        }

        private void OnServerInitialized()
        {
            permission.RegisterPermission(PermissionBypass, this);
        }
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { MessageManager.NoCorpseLootPermission, "You can't loot Admin corpse!" },
                { MessageManager.NoBagLootPermission, "You can't loot Admin bag!" },
                { MessageManager.NoBodyLootPermission, "You can't loot Admin body!" },
            }, this);
        }
        object CanLootPlayer(BasePlayer target, BasePlayer looter)
        {
            if (target.IsAdmin && target.userID != looter.userID && !permission.UserHasPermission(looter.UserIDString, PermissionBypass))
            {
                if (_pluginConfig.Config.ShowWarning)
                    looter.ChatMessage(lang.GetMessage(MessageManager.NoBodyLootPermission, this, looter.UserIDString));

                return false;
            }
            return null;
        }
        object CanLootEntity(BasePlayer player, DroppedItemContainer container)
        {
            var target = BasePlayer.FindAwakeOrSleeping(container.playerSteamID.ToString());
            if (target == null)
                return null;

            if (target.IsAdmin && target.userID != player.userID && !permission.UserHasPermission(player.UserIDString, PermissionBypass))
            {
                if (_pluginConfig.Config.ShowWarning)
                    player.ChatMessage(lang.GetMessage(MessageManager.NoBagLootPermission, this, player.UserIDString));

                return false;
            }
            return null;
        }
        object CanLootEntity(BasePlayer player, LootableCorpse corpse)
        {
            var target = BasePlayer.FindAwakeOrSleeping(corpse.playerSteamID.ToString());
            if (target == null)
                return null;

            if (target.IsAdmin && target.userID != player.userID && !permission.UserHasPermission(player.UserIDString, PermissionBypass))
            {
                if (_pluginConfig.Config.ShowWarning)
                    player.ChatMessage(lang.GetMessage(MessageManager.NoCorpseLootPermission, this, player.UserIDString));

                return false;
            }
            return null;
        }
        #endregion Hooks

        #region Classes

        public class MessageManager
        {
            public const string NoCorpseLootPermission = "NoCorpseLootPermission";
            public const string NoBagLootPermission = "NoBagLootPermission";
            public const string NoBodyLootPermission = "NoBodyLootPermission";
        }

        private class PluginConfig
        {
            public AdminNoLootConfig Config { get; set; }
        }
        private class AdminNoLootConfig
        {
            [JsonProperty(PropertyName = "Warning - Enabled")]
            public bool ShowWarning { get; set; }
        }
        #endregion Classes
    }
}

// --- End of file: AdminNoLoot.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/anti-chat-flood ---
// --- Original File Path: A/AntiChatFlood/AntiChatFlood.cs ---

using System.Collections.Generic;
using System;
using UnityEngine;
using Oxide.Core.Plugins;
using System.Reflection;
using Oxide.Core;
using System.Data;
using Rust;

namespace Oxide.Plugins
{
    [Info("AntiChatFlood", "DylanSMR", "1.0.2", ResourceId = 1759)]
    [Description("Data test stuff.")]

    class AntiChatFlood : RustPlugin
    {
        [PluginReference]
        Plugin BetterChat;              
        
        private bool Changed;
        
        //////////
        //Config//
        //////////
 
        static bool WarningEnabled = true;
        static int WaitTillMsg = 5;
        static int MaxWarnings = 3;
        static bool AdminBypass = true;
        public int AuthToBypass = 1;
        
        static bool DisableBetterChat = false; 
 
        void OnServerInitialized()
        {
            LoadVariables();
        } 
 
        void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }
 
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        
        private void LoadConfigVariables()
        {
            CheckCfg("Time until a player can chat again.", ref WaitTillMsg);
            CheckCfg("If the warning system is enabled", ref WarningEnabled);
            CheckCfg("How many warnings until a player is kicked.", ref MaxWarnings);
            CheckCfg("If the plugin disables betterchat when this loads", ref DisableBetterChat);
        }
        
        void Loaded() 
        {    
			lang.RegisterMessages(new Dictionary<string,string>{
				["ACF_WAIT"] = "<color='#DD0000'>You are typing to fast - Please wait {0} seconds.</color>",
                ["ACF_WARNING"] = "<color='#DD0000'>You now have a current total of {0} warnings.</color>",
                ["ACF_ADDED"] = "{0} was added to the data file.",
                ["ACF_REMOVED"] = "{0} was removed from the (temp)data file.",
                ["ACF_KICKING"] = "Kicking {0} for reaching the warning limit of {1}.",
                ["ACF_REASON"] = "You were kicked as you reached the max limit of warnings.",
                ["ACF_HELP"] = "<color='#DD0000'>Help Commands: </cwarning> to check your warnings></color>",
                ["ACF_ADMINHELP"] = "<color='DD0000'>Admin Help Commands: </awipe (target)> to wipe a players warnings | </awipeall> to wipe all player warnings.</color>",
                ["ACF_WIPEDALL"] = "<color='#DD0000'>All players warning wiped to 0, each database file was erased.</color>",
                ["ACF_WIPEDAT"] = "{0} wiped {1}'s warnings!!!",
                ["ACF_WIPEDP"] = "<color='#DD0000'>You have wiped {0}'s warnings</color>",
                ["ACF_WIPEDY"] = "<color='DD0000'>{0} has wiped your warnings</color>",
                ["ACF_WARNINGS"] = "<color='DD0000'>You have a current total of {0} warnings and need {1} more warning to be kicked</color>",
                
			}, this);
            
            if(BetterChat != null)
            {
                if(!DisableBetterChat)
                {
                    rust.RunServerCommand("oxide.unload AntiChatFlood");
                    PrintWarning("PLUGIN UNLOADED DUE TO BETTERCHAT INSTALLED!!!");  
                }
                else
                {
                    rust.RunServerCommand("oxide.unload BetterChat");
                    PrintWarning("BETTERCHAT UNLOADED!!!");
                }
            }             		
        }         

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }
        private void CheckCfgFloat(string Key, ref float var)
        {

            if (Config[Key] != null)
                var = Convert.ToSingle(Config[Key]);
            else
                Config[Key] = var;
        }        
        
        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
        
        ///////////////////////////////
        //TEMP DATA-DO NOT EDIT BELOW//
        ///////////////////////////////
        

        List<ulong> playerWait = new List<ulong>();        
        private Dictionary<ulong, PlayerWarnings> pWarn = new Dictionary<ulong, PlayerWarnings>(); 

        class PlayerWarnings 
        {
            public string Name;
            public float CurrentWarnings;
        }
                 
        ////////////////////
        //Plugin Functions//
        ////////////////////
        
        void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                pWarn.Remove(player.userID);
            }
        }
        
        void Init()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                pWarn.Add(player.userID, new PlayerWarnings()); 
            }
        }
        
        private string GetMessage(string name, string sid = null) {
			return lang.GetMessage(name, this, sid);
		}
        
        void OnPlayerInit(BasePlayer player)
        {
            SetVars(player);
        }
        
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            pWarn.Remove(player.userID);
            PrintWarning(String.Format(lang.GetMessage("ACF_REMOVED", this), player.displayName));
        }
        
        void SetVars(BasePlayer player) // Now lets add some data to the dictionary
        {
            if (!pWarn.ContainsKey(player.userID)) 
                pWarn.Add(player.userID, new PlayerWarnings()); 
            pWarn[player.userID].Name = player.displayName;
            pWarn[player.userID].CurrentWarnings = 0;
            
            PrintWarning(String.Format(lang.GetMessage("ACF_ADDED", this), player.displayName));
        }
        
        void KickPlayer(BasePlayer player)
        {  
            BasePlayer target = player;
            Network.Net.sv.Kick(target.net.connection, String.Format(lang.GetMessage("ACF_REASON", this)));      
        }
        
        private object FindPlayer(string arg)
        {
            var foundPlayers = new List<BasePlayer>();
            ulong steamid;
            ulong.TryParse(arg, out steamid);
            string lowerarg = arg.ToLower();

            foreach (var p in BasePlayer.activePlayerList)
            {
                if (steamid != 0L)
                    if (p.userID == steamid)
                    {
                        foundPlayers.Clear();
                        foundPlayers.Add(p);
                        return foundPlayers;
                    }
                string lowername = p.displayName.ToLower();
                if (lowername.Contains(lowerarg))
                {
                    foundPlayers.Add(p);
                }
            }
            if (foundPlayers.Count == 0) return lang.GetMessage("noPlayers", this);
            if (foundPlayers.Count > 1) return lang.GetMessage("multiPlayers", this);

            return foundPlayers[0];
        }
        
        void WipeAllStats()
        {
            foreach(BasePlayer player in BasePlayer.activePlayerList)
            {
                pWarn[player.userID].CurrentWarnings = 0;
                SetVars(player);
                PrintWarning(String.Format(lang.GetMessage("ACF_WIPEDALL", this)));
                SendReply(player, String.Format(lang.GetMessage("ACF_WIPEDALL", this)));
            }  
        }
        /////////////////
        //Chat Handlers//
        /////////////////
       
        object OnPlayerChat(ConsoleSystem.Arg arg)
        {
            
            var player = arg.Connection.player as BasePlayer;            
            if(player.net.connection.authLevel >= AuthToBypass && AdminBypass == true)
            {
                return null;
            }
            if(BetterChat != null)
            {
                return BetterChat;    
            }            
            if(playerWait.Contains(player.userID))
            {
                SendReply(player, String.Format(lang.GetMessage("ACF_WAIT", this), WaitTillMsg));
                if (WarningEnabled = true)
                {
                    if (pWarn.ContainsKey(player.userID))  
                    {
                        if (pWarn[player.userID].CurrentWarnings <= MaxWarnings)
                        {
                            pWarn[player.userID].CurrentWarnings++;
                            SendReply(player, String.Format(lang.GetMessage("ACF_WARNING", this), pWarn[player.userID].CurrentWarnings));
                        }
                        else
                        {
                            pWarn[player.userID].CurrentWarnings = 0;
                            PrintWarning(String.Format(lang.GetMessage("ACF_KICKING", this), player.displayName, MaxWarnings));  
                            timer.Once(2, () =>
                            {
                                KickPlayer(player);
                            });
                        }
                    }
                    else
                    {
                        SetVars(player);
                        timer.Once(2, () =>
                        {
                            if (pWarn[player.userID].CurrentWarnings <= MaxWarnings)
                            {
                                pWarn[player.userID].CurrentWarnings++;
                                SendReply(player, String.Format(lang.GetMessage("ACF_WARNING", this), pWarn[player.userID].CurrentWarnings));
                            }      
                            else
                            {
                                KickPlayer(player);
                            }
                        });
                    }
                }
            }
            else
            {
                playerWait.Add(player.userID);  
                timer.Once(WaitTillMsg, () => playerWait.Remove(player.userID));
                return null;
            }
            return true;
        }
        
        
        /////////////////
        //Chat Commands//
        /////////////////
        
        [ChatCommand("chelp")]
        void help(BasePlayer player)
        {
            if (player.net.connection.authLevel > 1)
            {
                SendReply(player, String.Format(lang.GetMessage("ACF_ADMINHELP", this)));
            }
            else
            {
                SendReply(player, String.Format(lang.GetMessage("ACF_HELP", this)));
            }
        }
        
        [ChatCommand("cwipeall")]
        void AWipeAll(BasePlayer player)
        {
            if (player.net.connection.authLevel > 1)
            {
                WipeAllStats();
            }                      
        }
        
        [ChatCommand("cwipe")]
        void playerwipe(BasePlayer player, string command, string[] args)     
        {
            if (args.Length == 1)
            {
                if(player.net.connection.authLevel > 1)
                {
                    object addPlayer = FindPlayer(args[0]);             
                    BasePlayer target = (BasePlayer)addPlayer;         
                    pWarn[target.userID].CurrentWarnings = 0;
                
                    PrintWarning(String.Format(lang.GetMessage("ACF_WIPEDAT", this), player.displayName, target));
                    SendReply(player, String.Format(lang.GetMessage("ACF_WIPEDP", this), target.displayName));
                    SendReply(target, String.Format(lang.GetMessage("ACF_WIPEDY", this), player.displayName));
                
                    SetVars(target);
                }
            }
            else
            {
                if (player.net.connection.authLevel > 1)
                {
                    SendReply(player, String.Format(lang.GetMessage("ACF_ADMINHELP", this)));
                }
                else
                {
                    SendReply(player, String.Format(lang.GetMessage("ACF_HELP", this)));
                }
            }
        }    
        
        [ChatCommand("cwarning")]  
        void CheckWarnings(BasePlayer player)
        {
            if (pWarn.ContainsKey(player.userID)) 
            {
                var TillKick = MaxWarnings + 1 - pWarn[player.userID].CurrentWarnings;
                SendReply(player, String.Format(lang.GetMessage("ACF_WARNINGS", this), pWarn[player.userID].CurrentWarnings, TillKick ));
            }
            else
            {
                SetVars(player);
            }
        }
    }
}

// --- End of file: AntiChatFlood.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/auto-pickup ---
// --- Original File Path: A/AutoPickup/AutoPickup.cs ---

//#define DEBUG

using System;
using System.Collections.Generic;
using ConVar;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Auto Pickup", "Arainrr", "1.2.16")]
    [Description("Automatically pickup hemp, pumpkin, ore, pickupable items, corpse, etc.")]
    public class AutoPickup : RustPlugin
    {
        #region Fields

        [PluginReference] private readonly Plugin Friends, Clans;

        private static AutoPickup instance;
        private static PickupType enabledPickupTypes;
        private static object False;
        private const string PERMISSION_USE = "autopickup.use";

        [Flags]
        //[JsonConverter(typeof(StringEnumConverter))]
        private enum PickupType
        {
            None = 0,
            PlantEntity = 1,
            CollectibleEntity = 1 << 1,
            MurdererCorpse = 1 << 2,
            ScientistCorpse = 1 << 3,
            PlayerCorpse = 1 << 4,
            ItemDropBackpack = 1 << 5,
            ItemDrop = 1 << 6,
            WorldItem = 1 << 7,
            LootContainer = 1 << 8,
            CollectableGifts = 1 << 9,
        }

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            LoadData();
            False = false;
            instance = this;
            enabledPickupTypes = PickupType.None;
            Unsubscribe(nameof(CanLootEntity));
            Unsubscribe(nameof(OnPlayerAttack));
            Unsubscribe(nameof(OnEntitySpawned));
            permission.RegisterPermission(PERMISSION_USE, this);
            cmd.AddChatCommand(configData.chatS.command, this, nameof(CmdAutoPickup));
        }

        private void OnServerInitialized()
        {
            UpdateConfig();
            foreach (var entry in configData.autoPickupS)
            {
                if (entry.Value.enabled)
                {
                    enabledPickupTypes |= entry.Key;
                }
            }
            if (enabledPickupTypes.HasFlag(PickupType.LootContainer))
            {
                bool enabledBarrel = false, enabledLoot = false;
                foreach (var entry in configData.lootContainerS)
                {
                    if (!entry.Value) continue;
                    if (IsBarrel(entry.Key))
                    {
                        enabledBarrel = true;
                    }
                    else
                    {
                        enabledLoot = true;
                    }
                }

                if (enabledBarrel)
                {
                    Subscribe(nameof(OnPlayerAttack));
                }
                if (enabledLoot)
                {
                    Subscribe(nameof(CanLootEntity));
                }
            }
            Subscribe(nameof(OnEntitySpawned));
            foreach (var baseNetworkable in BaseNetworkable.serverEntities)
            {
                CheckEntity(baseNetworkable);
            }
        }

        private void OnServerSave() => timer.Once(UnityEngine.Random.Range(0f, 60f), SaveData);

        private void Unload()
        {
            if (AutoPickupHelper.autoPickupHelpers != null)
            {
                foreach (var autoPickupEntity in AutoPickupHelper.autoPickupHelpers.ToArray())
                {
                    UnityEngine.Object.Destroy(autoPickupEntity);
                }
                AutoPickupHelper.autoPickupHelpers = null;
            }

            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyUI(player);
            }
            SaveData();
            configData = null;
            False = instance = null;
        }

        private void OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            if (attacker == null || !attacker.userID.IsSteamId()) return;
            var barrel = info?.HitEntity as LootContainer;
            if (barrel == null || barrel.net == null) return;
            if (!IsBarrel(barrel.ShortPrefabName)) return;
            var radius = configData.autoPickupS[PickupType.LootContainer].radius;
            if (radius > 0f && Vector3.Distance(attacker.transform.position, barrel.transform.position) > radius)
            {
                return;
            }
            if (permission.UserHasPermission(attacker.UserIDString, PERMISSION_USE))
            {
                if (TryPickupLootContainer(barrel, attacker, info))
                {
                }
            }
        }

        private object CanLootEntity(BasePlayer player, LootContainer lootContainer)
        {
            if (player == null || lootContainer == null) return null;
            if (permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
            {
                if (TryPickupLootContainer(lootContainer, player))
                {
                    return False;
                }
            }
            return null;
        }

        private void OnEntitySpawned(BaseNetworkable baseNetworkable) => CheckEntity(baseNetworkable, true);

        #endregion Oxide Hooks

        #region Methods

        private bool TryPickupLootContainer(LootContainer lootContainer, BasePlayer player, HitInfo info = null)
        {
            bool enabled;
            if (configData.lootContainerS.TryGetValue(lootContainer.ShortPrefabName, out enabled) && !enabled)
            {
                return false;
            }
            if (configData.globalS.preventPickupLoot && lootContainer.OwnerID.IsSteamId() && !AreFriends(lootContainer.OwnerID, player.userID))
            {
                return false;
            }
            var autoPickData = GetAutoPickupData(player.userID, true);
            if (autoPickData.enabled && !autoPickData.blockPickupTypes.HasFlag(PickupType.LootContainer))
            {
                if (CanAutoPickup(player, lootContainer) && PickupLootContainer(player, lootContainer, info))
                {
                    return true;
                }
            }
            return false;
        }

        private void UpdateConfig()
        {
            foreach (PickupType pickupType in Enum.GetValues(typeof(PickupType)))
            {
                if (pickupType == PickupType.None) continue;
                if (!configData.autoPickupS.ContainsKey(pickupType))
                {
                    configData.autoPickupS.Add(pickupType, new ConfigData.PickupTypeS { enabled = true, radius = 0.5f });
                }
            }
            foreach (var itemDefinition in ItemManager.GetItemDefinitions())
            {
                if (!configData.worldItemS.itemCategoryS.ContainsKey(itemDefinition.category))
                {
                    configData.worldItemS.itemCategoryS.Add(itemDefinition.category, true);
                }
            }
            foreach (var prefab in GameManifest.Current.entities)
            {
                var entity = GameManager.server.FindPrefab(prefab.ToLower())?.GetComponent<BaseEntity>();
                if (entity == null || string.IsNullOrEmpty(entity.ShortPrefabName)) continue;
                var lootContainer = entity as LootContainer;
                if (lootContainer != null)
                {
                    if (!configData.lootContainerS.ContainsKey(lootContainer.ShortPrefabName))
                    {
                        configData.lootContainerS.Add(lootContainer.ShortPrefabName, !lootContainer.ShortPrefabName.Contains("stocking"));
                    }
                    continue;
                }
                var collectibleEntity = entity as CollectibleEntity;
                if (collectibleEntity != null)
                {
                    if (!configData.collectibleEntityS.ContainsKey(collectibleEntity.ShortPrefabName))
                    {
                        configData.collectibleEntityS.Add(collectibleEntity.ShortPrefabName, true);
                    }
                    continue;
                }
                var plantEntity = entity as GrowableEntity;
                if (plantEntity != null)
                {
                    if (!configData.plantEntityS.ContainsKey(plantEntity.ShortPrefabName))
                    {
                        configData.plantEntityS.Add(plantEntity.ShortPrefabName, true);
                    }
                    continue;
                }
            }
            SaveConfig();
        }

        #region AreFriends

        private bool AreFriends(ulong playerID, ulong friendID)
        {
            if (playerID == friendID) return true;
            if (configData.globalS.useTeams && SameTeam(playerID, friendID)) return true;
            if (configData.globalS.useFriends && HasFriend(playerID, friendID)) return true;
            if (configData.globalS.useClans && SameClan(playerID, friendID)) return true;
            return false;
        }

        private static bool SameTeam(ulong playerID, ulong friendID)
        {
            if (!RelationshipManager.TeamsEnabled()) return false;
            var playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(playerID);
            if (playerTeam == null) return false;
            var friendTeam = RelationshipManager.ServerInstance.FindPlayersTeam(friendID);
            if (friendTeam == null) return false;
            return playerTeam == friendTeam;
        }

        private bool HasFriend(ulong playerID, ulong friendID)
        {
            if (Friends == null) return false;
            return (bool)Friends.Call("HasFriend", playerID, friendID);
        }

        private bool SameClan(ulong playerID, ulong friendID)
        {
            if (Clans == null) return false;
            //Clans
            var isMember = Clans.Call("IsClanMember", playerID.ToString(), friendID.ToString());
            if (isMember != null) return (bool)isMember;
            //Rust:IO Clans
            var playerClan = Clans.Call("GetClanOf", playerID);
            if (playerClan == null) return false;
            var friendClan = Clans.Call("GetClanOf", friendID);
            if (friendClan == null) return false;
            return (string)playerClan == (string)friendClan;
        }

        #endregion AreFriends

        #region Data

        private StoredData.AutoPickData defaultData;

        private StoredData.AutoPickData DefaultData => defaultData ?? (defaultData = CreateDefaultData());

        private StoredData.AutoPickData GetAutoPickupData(ulong playerID, bool readOnly = false)
        {
            StoredData.AutoPickData autoPickData;
            if (!storedData.playerAutoPickupData.TryGetValue(playerID, out autoPickData))
            {
                if (readOnly)
                {
                    return DefaultData;
                }

                autoPickData = CreateDefaultData();
                storedData.playerAutoPickupData.Add(playerID, autoPickData);
            }

            return autoPickData;
        }

        private StoredData.AutoPickData CreateDefaultData()
        {
            return new StoredData.AutoPickData
            {
                enabled = configData.globalS.defaultEnabled
            };
        }

        #endregion Data

        #endregion Methods

        #region Helpers

        private static void CheckEntity(BaseNetworkable baseNetworkable, bool justCreated = false)
        {
            if (baseNetworkable == null) return;
            var pickupType = GetPickupTypeFromEntity(baseNetworkable);
            if (pickupType == PickupType.None) return;
            if (!enabledPickupTypes.HasFlag(pickupType))
            {
                return;
            }
            var autoPickupEntity = baseNetworkable.GetComponent<AutoPickupHelper>();
            if (autoPickupEntity != null)
            {
                UnityEngine.Object.Destroy(autoPickupEntity);
            }

            switch (pickupType)
            {
                case PickupType.CollectibleEntity:
                    {
                        bool enabled;
                        if (configData.collectibleEntityS.TryGetValue(baseNetworkable.ShortPrefabName, out enabled) && !enabled)
                        {
                            return;
                        }
                        break;
                    }

                case PickupType.PlantEntity:
                    {
                        bool enabled;
                        if (configData.plantEntityS.TryGetValue(baseNetworkable.ShortPrefabName, out enabled) && !enabled)
                        {
                            return;
                        }
                        if (configData.globalS.preventPlanterBox && baseNetworkable.GetParentEntity() is PlanterBox)
                        {
                            return;
                        }
                        break;
                    }

                case PickupType.MurdererCorpse:
                case PickupType.ScientistCorpse:
                case PickupType.PlayerCorpse:
                case PickupType.ItemDrop:
                case PickupType.ItemDropBackpack:
                    break;

                case PickupType.WorldItem:
                    {
                        var worldItem = baseNetworkable as WorldItem;
                        if (worldItem != null)
                        {
                            var item = worldItem.GetItem();
                            if (item != null)
                            {
                                if (configData.worldItemS.itemBlockList.Contains(item.info.shortname)) return;
                                bool enabled;
                                if (configData.worldItemS.itemCategoryS.TryGetValue(item.info.category, out enabled) && !enabled)
                                {
                                    return;
                                }
                            }
                        }
                        if (justCreated)
                        {
                            var collisionDetection = baseNetworkable.GetComponent<WorldItemCollisionDetection>();
                            if (collisionDetection != null)
                            {
                                UnityEngine.Object.Destroy(collisionDetection);
                            }
                            baseNetworkable.gameObject.AddComponent<WorldItemCollisionDetection>();
                            return;
                        }
                        break;
                    }
            }
            CreateAutoPickupHelper(baseNetworkable.transform, pickupType);
        }

        private static PickupType GetPickupTypeFromEntity(BaseNetworkable baseNetworkable)
        {
            switch (baseNetworkable.ShortPrefabName)
            {
                case "murderer_corpse": return PickupType.MurdererCorpse;
                case "scientist_corpse": return PickupType.ScientistCorpse;
                case "player_corpse": return PickupType.PlayerCorpse;
                case "item_drop": return PickupType.ItemDrop;
                case "item_drop_backpack": return PickupType.ItemDropBackpack;
                default:
                    if (baseNetworkable is GrowableEntity)
                    {
                        return PickupType.PlantEntity;
                    }
                    if (baseNetworkable is CollectibleEntity)
                    {
                        return PickupType.CollectibleEntity;
                    }
                    if (baseNetworkable is WorldItem)
                    {
                        return PickupType.WorldItem;
                    }
                    if (baseNetworkable is CollectableEasterEgg)
                    {
                        return PickupType.CollectableGifts;
                    }
                    return PickupType.None;
            }
        }

        private static void CreateAutoPickupHelper(Transform transform, PickupType pickupType)
        {
            var newObject = new GameObject("AutoPickHelper");
            newObject.transform.SetParent(transform);
            newObject.transform.position = transform.position;
            newObject.AddComponent<AutoPickupHelper>().Init(pickupType);
        }

        private static bool PickupLootContainer(BasePlayer player, LootContainer lootContainer, HitInfo info = null)
        {
            var itemContainer = lootContainer?.inventory;
            if (itemContainer != null)
            {
                for (int i = itemContainer.itemList.Count - 1; i >= 0; i--)
                {
                    player.GiveItem(itemContainer.itemList[i], BaseEntity.GiveItemReason.PickedUp);
                }
                if (itemContainer.itemList == null || itemContainer.itemList.Count <= 0)
                {
                    if (info != null)
                    {
                        lootContainer.Invoke(() => lootContainer.Die(info), 0.2f);
                    }
                    else
                    {
                        lootContainer.Invoke(() => lootContainer.Kill(BaseNetworkable.DestroyMode.Gib), 0.2f);
                    }
                }
                return true;
            }
            return false;
        }

        private static bool InventoryExistItem(BasePlayer player, Item item)
        {
            return player.inventory.containerMain.FindItemByItemID(item.info.itemid) != null
                   || player.inventory.containerBelt.FindItemByItemID(item.info.itemid) != null;
        }

        private static bool InventoryIsFull(BasePlayer player, Item item)
        {
            if (player.inventory.containerMain.IsFull() && player.inventory.containerBelt.IsFull())
            {
                var item1 = player.inventory.containerMain.FindItemByItemID(item.info.itemid);
                var item2 = player.inventory.containerBelt.FindItemByItemID(item.info.itemid);
                return (item1 == null || !item.CanStack(item1)) && (item2 == null || !item.CanStack(item2));
            }
            return false;
        }

        private static bool PickupDroppedItemContainer(BasePlayer player, DroppedItemContainer droppedItemContainer)
        {
            var itemContainer = droppedItemContainer?.inventory;
            if (itemContainer != null)
            {
                for (int i = itemContainer.itemList.Count - 1; i >= 0; i--)
                {
                    player.GiveItem(itemContainer.itemList[i], BaseEntity.GiveItemReason.PickedUp);
                }
                if (itemContainer.itemList == null || itemContainer.itemList.Count <= 0)
                {
                    droppedItemContainer.Kill(BaseNetworkable.DestroyMode.Gib);
                }
                return true;
            }
            return false;
        }

        private static bool PickupPlayerCorpse(BasePlayer player, PlayerCorpse playerCorpse)
        {
            var itemContainers = playerCorpse?.containers;
            if (itemContainers != null)
            {
                for (int i = itemContainers.Length - 1; i >= 0; i--)
                {
                    var itemContainer = itemContainers[i];
                    if (itemContainer != null)
                    {
                        for (int j = itemContainer.itemList.Count - 1; j >= 0; j--)
                        {
                            player.GiveItem(itemContainer.itemList[j], BaseEntity.GiveItemReason.PickedUp);
                        }
                    }
                }
                return true;
            }
            return false;
        }

        private static bool CanAutoPickup(BasePlayer player, BaseEntity entity)
        {
            return entity != null && player.CanInteract() && Interface.CallHook("OnAutoPickupEntity", player, entity) == null;
        }

        private static bool IsBarrel(string shortPrefabName) => shortPrefabName.Contains("barrel") || shortPrefabName.Contains("roadsign");

        #endregion Helpers

        #region Components

        private class WorldItemCollisionDetection : MonoBehaviour
        {
            private bool collided;

            private void OnCollisionEnter(Collision collision)
            {
                if (collided || collision?.gameObject == null) return;
                collided = true;
                Invoke(nameof(AddAutoPickupComponent), configData.worldItemS.pickupDelay);
            }

            private void AddAutoPickupComponent()
            {
                CreateAutoPickupHelper(transform, PickupType.WorldItem);
                DestroyImmediate(this);
            }
        }

        private class AutoPickupHelper : FacepunchBehaviour
        {
            private const int LAYER_PLAYER = (int)Rust.Layer.Player_Server;
            public static List<AutoPickupHelper> autoPickupHelpers;

            private BaseEntity entity;
            private PickupType pickupType;
            private SphereCollider sphereCollider;

            private void Awake()
            {
                if (autoPickupHelpers == null)
                {
                    autoPickupHelpers = new List<AutoPickupHelper>();
                }
                autoPickupHelpers.Add(this);
                entity = GetComponentInParent<BaseEntity>();
            }

            public void Init(PickupType pickupType)
            {
                if (gameObject == null || entity == null)
                {
                    Destroy(this);
                    return;
                }
                this.pickupType = pickupType;
                transform.position = entity.CenterPoint();
                CreateCollider();
            }

            private void CreateCollider()
            {
                sphereCollider = gameObject.AddComponent<SphereCollider>();
                sphereCollider.gameObject.layer = (int)Rust.Layer.Reserved1;
                sphereCollider.radius = configData.autoPickupS[pickupType].radius;
                sphereCollider.isTrigger = true;
#if DEBUG
                InvokeRepeating(Tick, 0f, 1f);
#endif
            }

#if DEBUG

            private void Tick()
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    if (player.IsAdmin && Vector3.Distance(transform.position, player.transform.position) < 50f)
                    {
                        player.SendConsoleCommand("ddraw.sphere", 1, Color.cyan, sphereCollider.transform.position, sphereCollider.radius);
                    }
                }
            }

#endif

            private void OnTriggerEnter(Collider collider)
            {
                if (collider == null || collider.gameObject == null) return;
                if (collider.gameObject.layer != LAYER_PLAYER) return;
                var player = collider.ToBaseEntity() as BasePlayer;
                if (player == null || !player.userID.IsSteamId()) return;
                if (instance.permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
                {
                    var autoPickData = instance.GetAutoPickupData(player.userID, true);
                    if (autoPickData.enabled && !autoPickData.blockPickupTypes.HasFlag(pickupType))
                    {
                        switch (pickupType)
                        {
                            case PickupType.PlantEntity:
                                var plantEntity = entity as GrowableEntity;
                                if (configData.globalS.preventPickupPlant && plantEntity.OwnerID.IsSteamId() && !instance.AreFriends(plantEntity.OwnerID, player.userID)) return;
                                if (CanAutoPickup(player, plantEntity))
                                {
                                    if (autoPickData.autoClone)
                                    {
                                        plantEntity.TakeClones(player);
                                    }
                                    else
                                    {
                                        plantEntity.PickFruit(player);
                                    }
                                    plantEntity.RemoveDying(player);
                                }
                                return;

                            case PickupType.CollectibleEntity:
                                var collectibleEntity = entity as CollectibleEntity;
                                if (CanAutoPickup(player, collectibleEntity))
                                {
                                    collectibleEntity.DoPickup(player);
                                    Destroy(this);
                                }
                                return;

                            case PickupType.ItemDrop:
                            case PickupType.ItemDropBackpack:
                                var droppedItemContainer = entity as DroppedItemContainer;
                                if (configData.globalS.preventPickupBackpack && droppedItemContainer.playerSteamID.IsSteamId() && !instance.AreFriends(droppedItemContainer.playerSteamID, player.userID)) return;
                                if (CanAutoPickup(player, droppedItemContainer))
                                {
                                    if (PickupDroppedItemContainer(player, droppedItemContainer))
                                    {
                                        Destroy(this);
                                    }
                                }
                                return;

                            case PickupType.MurdererCorpse:
                            case PickupType.ScientistCorpse:
                            case PickupType.PlayerCorpse:
                                var playerCorpse = entity as PlayerCorpse;
                                if (!playerCorpse.CanLoot()) return;
                                if (configData.globalS.preventPickupCorpse && playerCorpse.playerSteamID.IsSteamId() && !instance.AreFriends(playerCorpse.playerSteamID, player.userID)) return;
                                if (CanAutoPickup(player, playerCorpse))
                                {
                                    if (PickupPlayerCorpse(player, playerCorpse))
                                    {
                                        Destroy(this);
                                    }
                                }
                                return;

                            case PickupType.WorldItem:
                                var worldItem = entity as WorldItem;
                                if (CanAutoPickup(player, worldItem))
                                {
                                    var item = worldItem.GetItem();
                                    if (item != null)
                                    {
                                        if (configData.worldItemS.onlyPickupExistItem && !InventoryExistItem(player, item)) return;
                                        if (configData.worldItemS.checkInventoryFull && InventoryIsFull(player, item)) return;
                                        var rpcMessage = default(BaseEntity.RPCMessage);
                                        rpcMessage.player = player;
                                        worldItem.Pickup(rpcMessage);
                                        Destroy(this);
                                    }
                                }
                                return;

                            case PickupType.CollectableGifts:
                                var gifts = entity as CollectableEasterEgg;
                                if (CanAutoPickup(player, gifts))
                                {
                                    if (configData.collectableGiftsS.requiresBasket && !(player.GetHeldEntity() is EasterBasket)) return;
                                    if (EggHuntEvent.serverEvent != null)
                                    {
                                        if (!EggHuntEvent.serverEvent.IsEventActive())
                                        {
                                            return;
                                        }
                                        EggHuntEvent.serverEvent.OnEggCollected(player, gifts);
                                        player.GiveItem(ItemManager.Create(gifts.itemToGive));
                                    }
                                    Effect.server.Run(gifts.pickupEffect.resourcePath, base.transform.position + Vector3.up * 0.3f, Vector3.up);
                                    gifts.Kill();
                                    Destroy(this);
                                }
                                return;

                            default:
                                return;
                        }
                    }
                }
            }

            private void OnDestroy()
            {
                Destroy(gameObject);
                autoPickupHelpers?.Remove(this);
            }
        }

        #endregion Components

        #region UI

        private const string UINAME_MAIN = "AutoPickupUI_Main";
        private const string UINAME_MENU = "AutoPickupUI_Menu";

        private static void CreateMainUI(BasePlayer player)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-180 -180", OffsetMax = "180 230" },
                CursorEnabled = true
            }, "Hud", UINAME_MAIN);
            container.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0.6" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
            }, UINAME_MAIN);
            var titlePanel = container.Add(new CuiPanel
            {
                Image = { Color = "0.31 0.88 0.71 1" },
                RectTransform = { AnchorMin = "0 0.912", AnchorMax = "0.998 1" },
            }, UINAME_MAIN);
            container.Add(new CuiElement
            {
                Parent = titlePanel,
                Components =
                {
                    new CuiTextComponent { Text = instance.Lang("Title", player.UserIDString), FontSize = 20, Align = TextAnchor.MiddleCenter, Color ="1 0 0 1" },
                    new CuiOutlineComponent { Distance = "0.5 0.5", Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.2 0",  AnchorMax = "0.8 1" }
                }
            });
            container.Add(new CuiButton
            {
                Button = { Color = "0.95 0.1 0.1 0.95", Close = UINAME_MAIN },
                Text = { Text = "X", Align = TextAnchor.MiddleCenter, Color = "0 0 0 1", FontSize = 22 },
                RectTransform = { AnchorMin = "0.885 0", AnchorMax = "1 0.99" }
            }, titlePanel);
            CuiHelper.DestroyUi(player, UINAME_MAIN);
            CuiHelper.AddUi(player, container);
            var autoPickData = instance.GetAutoPickupData(player.userID);
            UpdateMenuUI(player, autoPickData);
        }

        private static void UpdateMenuUI(BasePlayer player, StoredData.AutoPickData autoPickData)
        {
            if (player == null) return;
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                Image = { Color = "0.1 0.1 0.1 0.4" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.898" },
            }, UINAME_MAIN, UINAME_MENU);
            int i = 0;
            const float spacingY = 0.01f;
            const float entrySize = (1f - 11f * spacingY) / 12f;

            var enabledMsg = instance.Lang("Enabled", player.UserIDString);
            var disabledMsg = instance.Lang("Disabled", player.UserIDString);

            var anchors = GetEntryAnchors(i++, entrySize, spacingY);
            CreateEntryUI(ref container, $"AutoPickupUI Toggle",
                instance.Lang("Status", player.UserIDString),
                autoPickData.enabled ? enabledMsg : disabledMsg,
                $"0 {anchors[0]}", $"0.995 {anchors[1]}");
            foreach (PickupType pickupType in Enum.GetValues(typeof(PickupType)))
            {
                if (pickupType == PickupType.None || !enabledPickupTypes.HasFlag(pickupType)) continue;
                anchors = GetEntryAnchors(i++, entrySize, spacingY);
                CreateEntryUI(ref container, $"AutoPickupUI {pickupType}",
                    instance.Lang(pickupType.ToString(), player.UserIDString),
                    !autoPickData.blockPickupTypes.HasFlag(pickupType) ? enabledMsg : disabledMsg,
                    $"0 {anchors[0]}", $"0.995 {anchors[1]}");

                if (pickupType == PickupType.PlantEntity && !autoPickData.blockPickupTypes.HasFlag(pickupType))
                {
                    anchors = GetEntryAnchors(i++, entrySize, spacingY);
                    CreateEntryUI(ref container, $"AutoPickupUI Clone",
                        instance.Lang("AutoClonePlants", player.UserIDString),
                        autoPickData.autoClone ? enabledMsg : disabledMsg,
                        $"0 {anchors[0]}", $"0.995 {anchors[1]}");
                }
            }

            CuiHelper.DestroyUi(player, UINAME_MENU);
            CuiHelper.AddUi(player, container);
        }

        private static void CreateEntryUI(ref CuiElementContainer container, string command, string leftText, string rightText, string anchorMin, string anchorMax)
        {
            var panelName = container.Add(new CuiPanel
            {
                Image = { Color = "0.1 0.1 0.1 0.6" },
                RectTransform = { AnchorMin = anchorMin, AnchorMax = anchorMax },
            }, UINAME_MENU);
            container.Add(new CuiLabel
            {
                Text = { Color = "0 1 1 1", FontSize = 14, Align = TextAnchor.MiddleLeft, Text = leftText },
                RectTransform = { AnchorMin = "0.06 0", AnchorMax = "0.795 1" }
            }, panelName);
            container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0.7", Command = command },
                Text = { Text = rightText, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", FontSize = 14 },
                RectTransform = { AnchorMin = "0.7 0.2", AnchorMax = "0.985 0.8" },
            }, panelName);
        }

        private static float[] GetEntryAnchors(int i, float entrySize, float spacingY)
        {
            //return new[] { 1f - (i + 1) * spacing, 1f - i * spacing };
            return new[] { 1f - (i + 1) * entrySize - i * spacingY, 1f - i * (entrySize + spacingY) };
        }

        private static void DestroyUI(BasePlayer player) => CuiHelper.DestroyUi(player, UINAME_MAIN);

        #endregion UI

        #region Commands

        [ConsoleCommand("AutoPickupUI")]
        private void CCmdAutoPickupUI(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE)) return;
            var autoPickData = GetAutoPickupData(player.userID);
            switch (arg.Args[0].ToLower())
            {
                case "toggle":
                    autoPickData.enabled = !autoPickData.enabled;
                    break;

                case "clone":
                    autoPickData.autoClone = !autoPickData.autoClone;
                    break;

                default:
                    PickupType pickupType;
                    if (Enum.TryParse(arg.Args[0], true, out pickupType))
                    {
                        if (autoPickData.blockPickupTypes.HasFlag(pickupType))
                        {
                            autoPickData.blockPickupTypes &= ~pickupType;
                        }
                        else
                        {
                            autoPickData.blockPickupTypes |= pickupType;
                        }
                    }

                    break;
            }
            UpdateMenuUI(player, autoPickData);
        }

        private void CmdAutoPickup(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
            {
                Print(player, Lang("NotAllowed", player.UserIDString));
                return;
            }
            CreateMainUI(player);
        }

        #endregion Commands

        #region ConfigurationFile

        private static ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Settings")]
            public Settings globalS = new Settings();

            [JsonProperty(PropertyName = "Chat Settings")]
            public ChatS chatS = new ChatS();

            [JsonProperty(PropertyName = "Auto Pickup Settings")]
            public Dictionary<PickupType, PickupTypeS> autoPickupS = new Dictionary<PickupType, PickupTypeS>();

            [JsonProperty(PropertyName = "World Item Pickup Settings")]
            public WorldItemPickupS worldItemS = new WorldItemPickupS();

            [JsonProperty(PropertyName = "Collectable Gifts Pickup Settings")]
            public CollectableGiftsPickupS collectableGiftsS = new CollectableGiftsPickupS();

            [JsonProperty(PropertyName = "Loot Container Pickup Settings")]
            public Dictionary<string, bool> lootContainerS = new Dictionary<string, bool>();

            [JsonProperty(PropertyName = "Collectible Entity Pickup Settings")]
            public Dictionary<string, bool> collectibleEntityS = new Dictionary<string, bool>();

            [JsonProperty(PropertyName = "Plant Entity Pickup Settings")]
            public Dictionary<string, bool> plantEntityS = new Dictionary<string, bool>();

            public class Settings
            {
                [JsonProperty(PropertyName = "Clear Data On Map Wipe")]
                public bool clearDataOnWipe = false;

                [JsonProperty(PropertyName = "Use Teams")]
                public bool useTeams = false;

                [JsonProperty(PropertyName = "Use Clans")]
                public bool useClans = true;

                [JsonProperty(PropertyName = "Use Friends")]
                public bool useFriends = true;

                [JsonProperty(PropertyName = "Auto pickup is enabled by default")]
                public bool defaultEnabled = true;

                [JsonProperty(PropertyName = "Prevent pickup other player's backpack")]
                public bool preventPickupBackpack;

                [JsonProperty(PropertyName = "Prevent pickup other player's corpse")]
                public bool preventPickupCorpse;

                [JsonProperty(PropertyName = "Prevent pickup other player's plant entity")]
                public bool preventPickupPlant;

                [JsonProperty(PropertyName = "Prevent pickup other player's loot container")]
                public bool preventPickupLoot = true;

                [JsonProperty(PropertyName = "Prevent pickup of plant entities in the planter box")]
                public bool preventPlanterBox = false;
            }

            public class ChatS
            {
                [JsonProperty(PropertyName = "Chat Command")]
                public string command = "ap";

                [JsonProperty(PropertyName = "Chat Prefix")]
                public string prefix = "<color=#00FFFF>[AutoPickup]</color>: ";

                [JsonProperty(PropertyName = "Chat SteamID Icon")]
                public ulong steamIDIcon = 0;
            }

            public class PickupTypeS
            {
                [JsonProperty(PropertyName = "Enabled")]
                public bool enabled = true;

                [JsonProperty(PropertyName = "Check Radius")]
                public float radius = 0.5f;
            }

            public class WorldItemPickupS
            {
                [JsonProperty(PropertyName = "Auto Pickup Delay")]
                public float pickupDelay = 0.5f;

                [JsonProperty(PropertyName = "Check that player's inventory is full")]
                public bool checkInventoryFull = true;

                [JsonProperty(PropertyName = "Only pickup items that exist in player's inventory")]
                public bool onlyPickupExistItem;

                [JsonProperty(PropertyName = "Item Block List (Item shortname)")]
                public HashSet<string> itemBlockList = new HashSet<string>();

                [JsonProperty(PropertyName = "Allow Pickup Item Category")]
                public Dictionary<ItemCategory, bool> itemCategoryS = new Dictionary<ItemCategory, bool>();
            }

            public class CollectableGiftsPickupS
            {
                [JsonProperty(PropertyName = "Requires player to hold a basket")]
                public bool requiresBasket = true;
            }

            [JsonProperty(PropertyName = "Version")]
            public VersionNumber version;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    LoadDefaultConfig();
                }
                else
                {
                    UpdateConfigValues();
                }
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
            configData.version = Version;
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        private void UpdateConfigValues()
        {
            if (configData.version < Version)
            {
                if (configData.version <= default(VersionNumber))
                {
                    string prefix, prefixColor;
                    if (GetConfigValue(out prefix, "Chat Settings", "Chat Prefix") && GetConfigValue(out prefixColor, "Chat Settings", "Chat Prefix Color"))
                    {
                        configData.chatS.prefix = $"<color={prefixColor}>{prefix}</color>: ";
                    }
                }

                if (configData.version <= new VersionNumber(1, 2, 13))
                {
                    configData.autoPickupS[PickupType.LootContainer].radius = 0f;
                }
                configData.version = Version;
            }
        }

        private bool GetConfigValue<T>(out T value, params string[] path)
        {
            var configValue = Config.Get(path);
            if (configValue == null)
            {
                value = default(T);
                return false;
            }
            value = Config.ConvertValue<T>(configValue);
            return true;
        }

        #endregion ConfigurationFile

        #region DataFile

        private StoredData storedData;

        private class StoredData
        {
            public readonly Dictionary<ulong, AutoPickData> playerAutoPickupData = new Dictionary<ulong, AutoPickData>();

            public class AutoPickData
            {
                public bool enabled;
                public bool autoClone;
                public PickupType blockPickupTypes;
            }
        }

        private void LoadData()
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch
            {
                storedData = null;
            }
            if (storedData == null)
            {
                ClearData();
            }
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);

        private void ClearData()
        {
            storedData = new StoredData();
            SaveData();
        }

        private void OnNewSave(string filename)
        {
            if (configData.globalS.clearDataOnWipe)
            {
                ClearData();
            }
        }

        #endregion DataFile

        #region LanguageFile

        private void Print(BasePlayer player, string message)
        {
            Player.Message(player, message, configData.chatS.prefix, configData.chatS.steamIDIcon);
        }

        private string Lang(string key, string id = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, id), args);
            }
            catch (Exception)
            {
                PrintError($"Error in the language formatting of '{key}'. (userid: {id}. lang: {lang.GetLanguage(id)}. args: {string.Join(" ,", args)})");
                throw;
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "You do not have permission to use this command",
                ["Enabled"] = "<color=#8ee700>Enabled</color>",
                ["Disabled"] = "<color=#ce422b>Disabled</color>",
                ["Title"] = "Auto Pickup UI",
                ["Status"] = "Auto Pickup Status",
                ["PlantEntity"] = "Auto Pickup Plant Entity",
                ["CollectibleEntity"] = "Auto Pickup Collectible Entity",
                ["MurdererCorpse"] = "Auto Pickup Murderer Corpse",
                ["ScientistCorpse"] = "Auto Pickup Scientist Corpse",
                ["PlayerCorpse"] = "Auto Pickup Player Corpse",
                ["ItemDropBackpack"] = "Auto Pickup Item Drop Backpack",
                ["ItemDrop"] = "Auto Pickup Item Drop",
                ["WorldItem"] = "Auto Pickup World Item",
                ["LootContainer"] = "Auto Pickup Loot Container",
                ["CollectableGifts"] = "Auto Pickup Collectable Gifts",
                ["AutoClonePlants"] = "Auto Clone Plants",
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "",
                ["Enabled"] = "<color=#8ee700></color>",
                ["Disabled"] = "<color=#ce422b></color>",
                ["Title"] = "",
                ["Status"] = "",
                ["PlantEntity"] = "",
                ["CollectibleEntity"] = "",
                ["MurdererCorpse"] = "",
                ["ScientistCorpse"] = "",
                ["PlayerCorpse"] = "",
                ["ItemDropBackpack"] = "",
                ["ItemDrop"] = "",
                ["WorldItem"] = "",
                ["LootContainer"] = "",
                ["CollectableGifts"] = "",
                ["AutoClonePlants"] = "",
            }, this, "zh-CN");
        }

        #endregion LanguageFile
    }
}

// --- End of file: AutoPickup.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/anti-helibombing ---
// --- Original File Path: A/AntiHelibombing/AntiHelibombing.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Rust;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Anti Helibombing", "ZEODE", "1.1.11")]
    [Description("Prevent malicious collision damage to players helicopters within safe zones.")]
    public class AntiHelibombing: CovalencePlugin
    {
        private static System.Random random = new System.Random();
        private const string permAdmin = "antihelibombing.admin";
        private const string permBlacklist = "antihelibombing.blacklist";
        private const string permKickProtect = "antihelibombing.kickprotect";

        private Dictionary<string, Cooldown> CooldownDelay = new Dictionary<string, Cooldown>();
        private Dictionary<ulong, SpawnProtection> SpawnDelay = new Dictionary<ulong, SpawnProtection>();

        private class Cooldown
        {
            public Timer CooldownTimer;
        }

        private class SpawnProtection
        {
            public Timer SpawnTimer;
        }

        #region Config

        private ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Options")]
            public Options options;

            public class Options
            {
                [JsonProperty(PropertyName = "Block ALL heli damage in Safe Zones (overrides spawn protection)")]
                public bool blockAllDamage;
                [JsonProperty(PropertyName = "Use collision cooldown timer (prevent damage outside Safe Zone due to collision inside)")]
                public bool useCooldown;
                [JsonProperty(PropertyName = "Collision cooldown time (seconds)")]
                public int cooldownTime;
                [JsonProperty(PropertyName = "Use heli spawn protection cooldown timer")]
                public bool useSpawnProtection;
                [JsonProperty(PropertyName = "Spawn protection cooldown time (seconds)")]
                public int spawnCooldownTime;
                [JsonProperty(PropertyName = "Kick players who break the Safe Zone collision threshold")]
                public bool useKick;
                [JsonProperty(PropertyName = "Safe Zone collision threshold (example: 30)")]
                public int collisionLimit;
                [JsonProperty(PropertyName = "Block crush damage to players from Scrap Heli in safe zones")]
                public bool noCrush;
                [JsonProperty(PropertyName = "Clear player collision data on wipe")]
                public bool clearDataOnWipe;
                [JsonProperty(PropertyName = "Use chat prefix")]
                public bool useChatPrefix;
                [JsonProperty(PropertyName = "Chat prefix")]
                public string chatPrefix;
            }
            public VersionNumber Version { get; set; }
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                options = new ConfigData.Options
                {
                    blockAllDamage = false,
                    useCooldown = true,
                    cooldownTime = 20,
                    useSpawnProtection = true,
                    spawnCooldownTime = 45,
                    useKick = false,
                    collisionLimit = 30,
                    noCrush = true,
                    clearDataOnWipe = true,
                    useChatPrefix = true,
                    chatPrefix = "[Anti Helibombing]: "
                },
                Version = Version
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
                else
                {
                    UpdateConfigValues();
                }
            }
            catch (Exception ex)
            {
                if (ex is JsonSerializationException || ex is NullReferenceException || ex is JsonReaderException)
                {
                    Puts($"Exception Type: {ex.GetType()}");
                    LoadDefaultConfig();
                    return;
                }
                throw;
            }
        }

        protected override void LoadDefaultConfig()
        {
            Puts($"Configuration file missing or corrupt, creating default config file.");
            config = GetDefaultConfig();
            SaveConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        private void UpdateConfigValues()
        {
            ConfigData defaultConfig = GetDefaultConfig();
            if (config.Version < Version)
            {
                Puts("Config update detected! Updating config file...");
                if (config.Version < new VersionNumber(1, 1, 0))
                {
                    config.options.useCooldown = defaultConfig.options.useCooldown;
                    config.options.cooldownTime = defaultConfig.options.cooldownTime;
                    config.options.clearDataOnWipe = defaultConfig.options.clearDataOnWipe;
                    config.options.useChatPrefix = defaultConfig.options.useChatPrefix;
                    config.options.chatPrefix = defaultConfig.options.chatPrefix;
                }
                if (config.Version < new VersionNumber(1, 1, 1))
                {
                    config.options.blockAllDamage = defaultConfig.options.blockAllDamage;
                    config.options.useSpawnProtection = defaultConfig.options.useSpawnProtection;
                    config.options.spawnCooldownTime = defaultConfig.options.spawnCooldownTime;
                }
                if (config.Version < new VersionNumber(1, 1, 5))
                {
                    config.options.useKick = defaultConfig.options.useKick;
                    config.options.collisionLimit = defaultConfig.options.collisionLimit;
                }
                if (config.Version < new VersionNumber(1, 1, 8))
                {
                    config.options.noCrush = defaultConfig.options.noCrush;
                }
                Puts("Config update completed!");
            }
            config.Version = Version;
            SaveConfig();
        }

        #endregion

        #region Stored Data

        private StoredData storedData;

        private class StoredData
        {
            public Dictionary<string, HeliBombData> CollisionData = new Dictionary<string, HeliBombData>();
        }

        private class HeliBombData
        {
            public string PlayerName;
            public int Collisions;
            public bool OnCooldown;
        }

        #endregion

        #region Language

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Permission"] = "You do not have permission to do that!",
                ["Usage"] = "Usage:\n - /ahb <Steam64Id> (Remove the / prefix for console)",
                ["PlayerNotFound"] = "No data for player with ID: {0}.",
                ["PlayerData"] = "Player Information:\nName: {0} ({1})\nSafe Zone Collisions: {2}\nBlacklisted: {3}\nKick Protected: {4}",
                ["ClearCmdUsage"] = "Usage:\n - /ahb.clear (clear ALL player data)\n - /ahb.clear <Steam64Id> (clear data for player)\nRemove the / prefix for console.",
                ["DataCleared"] = "ALL collision data cleared.",
                ["UserCleared"] = "Collision data cleared for: {0} ({1}).",
                ["Kicked"] = "You have been kicked for Helibombing!"
            }, this);
        }

        public string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        public void Message(IPlayer player, string key, params object[] args)
        {
            if (player == null) return;
            var message = Lang(key, player.Id, args);
            if (config.options.useChatPrefix)
            {
                player.Reply(config.options.chatPrefix + message);
            }
            else
            {
                player.Reply(message);
            }
        }

        #endregion

        #region Oxide Hooks

        private void Init()
        {
            if (!config.options.clearDataOnWipe) Unsubscribe(nameof(OnNewSave));
            permission.RegisterPermission(permAdmin, this);
            permission.RegisterPermission(permBlacklist , this);
            permission.RegisterPermission(permKickProtect , this);
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
                if (storedData == null)
                {
                    Puts("Data file is blank. Creating default data file...");
                    storedData = new StoredData();
                    SaveData();
                }
            }
            catch (Exception ex)
            {
                if (ex is JsonSerializationException || ex is NullReferenceException || ex is JsonReaderException)
                {
                    Puts("Data file invalid. Creating default data file...");
                    storedData = new StoredData();
                    SaveData();
                    return;
                }
                throw;
            }
        }

        private void OnNewSave()
        {
            Puts("Server wipe detected, ALL player data cleared.");
            storedData = new StoredData();
            SaveData();
        }

        private void Unload()
        {
            SaveData();
        }

        private void OnServerSave()
        {
            int delay  = random.Next(5, 10);
            timer.Once(delay, () =>
            {
                SaveData();
            });
        }

        private object OnEntitySpawned(Minicopter heli)
        {
            timer.Once(0.2f, () =>
            {
                if (heli == null || heli.IsDestroyed) return;
                if (heli.InSafeZone())
                {
                    SpawnProtection sp;
                    if (!SpawnDelay.TryGetValue(heli.net.ID.Value, out sp))
                    {
                        SpawnDelay[heli.net.ID.Value] = sp = new SpawnProtection
                        {
                            SpawnTimer = timer.Once(config.options.spawnCooldownTime , () =>
                            {
                                if (heli == null || heli.IsDestroyed) return;
                                SpawnDelay.Remove(heli.net.ID.Value);
                            }),
                        };
                    }
                }
            });
            return null;
        }

        private object OnEntityTakeDamage(BasePlayer player, HitInfo info)
        {
            if (info == null) return null;

            if (config.options.noCrush && player.InSafeZone())
            {
                var damageType = info.damageTypes.GetMajorityDamageType();
                if (damageType == DamageType.Fall && IsHeliCrushed(player))
                {
                    return true;
                }
            }
            return null;
        }


        private object OnEntityTakeDamage(Minicopter heli, HitInfo info)
        {
            if (info == null) return null;

            var pilot = heli.GetPlayerDamageInitiator() as BasePlayer;
            if (pilot != null && pilot.IPlayer.HasPermission(permBlacklist))
            {
                // Blacklisted players will always get damage in safe zones
                // with this permission because they're very naughty boys ;)
                return null;
            }

            var damageType = info.damageTypes.GetMajorityDamageType();
            if (config.options.blockAllDamage && heli.InSafeZone())
            {
                if (damageType == DamageType.Decay)
                {
                    return null;
                }
                else if (pilot != null)
                {
                    AddPlayerData(pilot, config.options.useCooldown);
                }
                return true;
            }
            else if (config.options.useSpawnProtection && heli.InSafeZone())
            {
                if (damageType == DamageType.Decay)
                {
                    return null;
                }

                if (pilot != null)
                {
                    AddPlayerData(pilot, config.options.useCooldown);
                }
                if (HasSpawnDelay(heli.net.ID.Value))
                {
                    return true;
                }
            }
            else
            {
                if (pilot != null && config.options.useCooldown)
                {
                    if (damageType == DamageType.Decay)
                    {
                        return null;
                    }
                    else if (HasCollisionDelay(pilot.UserIDString))
                    {
                        return true;
                    }
                }
            }
            return null;
        }

        #endregion

        #region Helpers

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
        }

        private void AddPlayerData(BasePlayer player, bool cooldown)
        {
            string steamId = player.UserIDString;
            if(!storedData.CollisionData.ContainsKey(steamId))
            {
                storedData.CollisionData.Add(steamId, new HeliBombData());
                storedData.CollisionData[steamId].PlayerName = player.displayName;
                storedData.CollisionData[steamId].Collisions = 1;
                storedData.CollisionData[steamId].OnCooldown = cooldown;
            }
            else
            {
                var cols = storedData.CollisionData[steamId].Collisions;
                storedData.CollisionData[steamId].PlayerName = player.displayName;
                storedData.CollisionData[steamId].Collisions = cols + 1;
                storedData.CollisionData[steamId].OnCooldown = cooldown;
            }
            if (config.options.useCooldown)
            {
                Cooldown cd;
                if (!CooldownDelay.TryGetValue(steamId, out cd))
                {
                    CooldownDelay[steamId] = cd = new Cooldown
                    {
                        CooldownTimer = timer.Once(config.options.cooldownTime, () =>
                        {
                            RemoveCooldown(steamId);
                        }),
                    };
                }
                else
                {
                    cd.CooldownTimer.Reset();
                }
            }
            if (config.options.useKick) ProcessKick(player.IPlayer);
        }

        private void RemoveCooldown(string steamId)
        {
            if (storedData.CollisionData.ContainsKey(steamId))
            {
                CooldownDelay.Remove(steamId);
                storedData.CollisionData[steamId].OnCooldown = false;
            }
        }

        private bool HasCollisionDelay(string steamId)
        {
            if(storedData.CollisionData.ContainsKey(steamId))
            {
                return storedData.CollisionData[steamId].OnCooldown;
            }
            return false;
        }

        private bool HasSpawnDelay(ulong heliId)
        {
            SpawnProtection sp;
            if (SpawnDelay.TryGetValue(heliId, out sp))
            {
                return true;
            }
            return false;
        }

        private bool IsHeliCrushed(BasePlayer player)
        {
            RaycastHit hit;
            var heightOffset = new Vector3(0, 5.0f, 0);
            if (Physics.Raycast(player.transform.position + heightOffset, Vector3.down, out hit, 10.0f, -5, QueryTriggerInteraction.UseGlobal))
            {
                if (hit.GetEntity() is ScrapTransportHelicopter)
                {
                    return true;
                }
            }
            return false;
        }

        public void ProcessKick(IPlayer player)
        {
            if (player.HasPermission(permKickProtect))
            {
                return;
            }
            if(storedData.CollisionData.ContainsKey(player.Id))
            {
                if (storedData.CollisionData[player.Id].Collisions >= config.options.collisionLimit)
                {
                    if (player.IsConnected)
                    {
                        player.Kick(Lang("Kicked"));
                        Puts($"{player} was kicked for HeliBombing after {storedData.CollisionData[player.Id].Collisions} safe zone collisions.");
                        storedData.CollisionData[player.Id].Collisions = 0;
                    }
                }
            }
        }

        #endregion

        #region Commands

        [Command("ahb", "antihelibombing")]
        private void CmdViewPlayerLog(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin))
            {
                Message(player, "Permission");
                return;
            }
            if (args?.Length < 1 || args?.Length > 1)
            {
                Message(player, "Usage");
                return;
            }

            ulong formatCheck;
            if (UInt64.TryParse(args[0], out formatCheck))
            {
                if (!storedData.CollisionData.ContainsKey(args[0]))
                {
                    Message(player, "PlayerNotFound", args[0]);
                    return;
                }
                else
                {
                    string name = storedData.CollisionData[args[0]].PlayerName;
                    string cols = Convert.ToString(storedData.CollisionData[args[0]].Collisions);
                    bool blacklist = player.HasPermission(permBlacklist);
                    bool kickprotect = player.HasPermission(permKickProtect);
                    Message(player, "PlayerData", name, args[0], cols, blacklist, kickprotect);
                    return;
                }
            }
            else
            {
                Message(player, "Usage");
                return;
            }
        }

        [Command("ahb.clear", "antihelibombing.clear")]
        private void CmdClearPlayerLog(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin))
            {
                Message(player, "Permission");
                return;
            }
            if (args?.Length > 1)
            {
                Message(player, "ClearCmdUsage");
                return;
            }
            else if (args?.Length < 1)
            {
                storedData.CollisionData.Clear();
                SaveData();
                Message(player, "DataCleared");
                return;
            }
            else if (args?.Length == 1)
            {
                ulong formatCheck;
                if (UInt64.TryParse(args[0], out formatCheck))
                {
                    if (!storedData.CollisionData.ContainsKey(args[0]))
                    {
                        Message(player, "PlayerNotFound", args[0]);
                        return;
                    }
                    else
                    {
                        string name = storedData.CollisionData[args[0]].PlayerName;
                        storedData.CollisionData.Remove(args[0]);
                        SaveData();
                        Message(player, "UserCleared", name, args[0]);
                        return;
                    }
                }
                else
                {
                    Message(player, "ClearCmdUsage");
                    return;
                }
            }
        }

        #endregion
    }
}

// --- End of file: AntiHelibombing.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/advanced-arrows ---
// --- Original File Path: A/AdvancedArrows/AdvancedArrows.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Advanced Arrows", "Ryan", "2.1.3")]
    [Description("Allows players with permission to use custom arrow types")]
    class AdvancedArrows : RustPlugin
    {
        #region Declaration

        private readonly Dictionary<ulong, ActiveArrow> ActiveArrows = new Dictionary<ulong, ActiveArrow>();

        private ConfigFile configFile;

        private readonly System.Random rnd = new System.Random();

        private enum ArrowType
        {
            Wind,
            Fire,
            Explosive,
            Knockdown,
            Narco,
            Poison,
            None
        }

        #endregion

        #region Config

        private class ConfigFile
        {
            public Dictionary<ArrowType, Arrow> Arrows;
            public ExplosionSettings ExplosionSettings;

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    Arrows = new Dictionary<ArrowType, Arrow>()
                    {
                        { ArrowType.Wind, new Arrow() },
                        { ArrowType.Fire, new Arrow() },
                        { ArrowType.Explosive, new Arrow() },
                        { ArrowType.Knockdown, new Arrow() },
                        { ArrowType.Narco, new Arrow() },
                        { ArrowType.Poison, new Arrow() },
                    },
                    ExplosionSettings = new ExplosionSettings()
                };
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Generating default configuration file...");
            configFile = ConfigFile.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configFile = Config.ReadObject<ConfigFile>();
        }

        protected override void SaveConfig() => Config.WriteObject(configFile);

        #endregion

        #region Lang

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Cmd_Types"] = "<color=orange>ARROW TYPES</color> \n{0}",
                ["Cmd_Switched"] = "You've switched your arrow type to '<color=orange>{0}</color>', you have <color=orange>{1}</color> uses until it's automatically deactivated.",
                ["Cmd_Disabled"] = "You've sucessfully <color=orange>disabled</color> your active arrow",
                ["Cmd_NoPerm"] = "You don't have permission to use arrow '<color=orange>{0}</color>'",
                ["Cmd_Price"] = "(<color=orange>{0}</color>x {1})",
                ["Cmd_Active"] = "<color=orange>Active Arrow</color>: {0}",

                ["Arrow_Disabled"] = "Your arrow has been automatically disabled",

                ["Error_NotSelected"] = "Your bow isn't drawn, you must select am arrow using '<color=orange>/arrow</color>'.",
                ["Error_InvalidEnt"] = "Your arrow didn't hit anything",
                ["Error_NotPlayer"] = "You can't hit an entity with arrow type '<color=orange>{0}</color>'.",

                ["Hit_Wind"] = "You hit <color=orange>{0}</color> with a <color=orange>Wind</color> arrow!",
                ["Hit_Fire"] = "You used a <color=orange>Fire</color> arrow! (<color=orange>{0}</color> HP remaining)",
                ["Hit_Explosive"] = "You used a <color=orange>Explosive</color> arrow! (<color=orange>{0}</color> HP remaining)",
                ["Hit_Knockdown"] = "You knocked <color=orange>{0}</color> out, choose his fate!",
                ["Hit_Narco"] = "You've sent <color=orange>{0}</color> to sleep, act quick before they wake up again!",
                ["Hit_Poison"] = "You've sucessfully poisoned <color=orange>{0}</color> (<color=orange>{1}</color> HP remaining)",

                ["Damaged_Poison"] = "You've been poisoned by an poisoned arrow, there's no cure!",

                ["Resources_Needed"] = "You need <color=orange>{0}</color>x <color=orange>{1}</color> to use that arrow",
                ["Resources_Spent"] = "The arrow you just used costed <color=orange>{0}</color>x <color=orange>{1}</color>"
            }, this);
        }

        #endregion

        #region Classes

        private class ExplosionSettings
        {
            public float ExplosiveDamage;
            public float ExplosionRadius;

            public ExplosionSettings()
            {
                ExplosiveDamage = 50f;
                ExplosionRadius = 10f;
            }
        }

        private class Price
        {
            public bool Enabled;
            public string ItemShortname;
            public int ItemAmount;

            public Price()
            {
                Enabled = true;
                ItemShortname = "metal.refined";
                ItemAmount = 30;
            }
        }

        private class Arrow
        {
            public Price ArrowPrice;
            public string Permission;
            public int Uses;

            public Arrow()
            {
                ArrowPrice = new Price();
                Permission = "able";
                Uses = 1;
            }
        }

        private class ActiveArrow
        {
            public int Uses;
            public ArrowType ArrowType;

            public ActiveArrow()
            {
            }

            public ActiveArrow(ArrowType type)
            {
                Uses = 0;
                ArrowType = type;
            }
        }

        #endregion

        #region Methods

        private bool IsPlayerArrow(ArrowType type)
        {
            switch (type)
            {
                case ArrowType.Explosive:
                    return false;
                case ArrowType.Fire:
                    return false;
                default:
                    return true;
            }
        }

        private bool CanUseArrow(BasePlayer player, ArrowType type, BaseCombatEntity combatEntity, out Item outItem)
        {
            if (IsPlayerArrow(type) && combatEntity.ToPlayer() == null)
            {
                PrintToChat(player, Lang("Error_NotPlayer", player.UserIDString, type));
                outItem = null;
                return false;
            }
            var typeConfig = configFile.Arrows[type];
            if (!typeConfig.ArrowPrice.Enabled)
            {
                outItem = null;
                return true;
            }
            if (player.inventory.FindItemByItemID(typeConfig.ArrowPrice.ItemShortname) == null)
            {
                PrintToChat(player, Lang("Resources_Needed", player.UserIDString, typeConfig.ArrowPrice.ItemAmount,
                    ItemManager.CreateByPartialName(typeConfig.ArrowPrice.ItemShortname).info.displayName.english) ?? "<color=red>ITEM NOT FOUND</color>");
                ActiveArrows.Remove(player.userID);
                outItem = null;
                return false;
            }
            var item = player.inventory.FindItemByItemID(typeConfig.ArrowPrice.ItemShortname);
            var amount = player.inventory.GetAmount(item.info.itemid);
            if (amount >= typeConfig.ArrowPrice.ItemAmount)
            {
                outItem = ItemManager.CreateByName(typeConfig.ArrowPrice.ItemShortname, typeConfig.ArrowPrice.ItemAmount) ?? ItemManager.CreateByName("metal.refined", 30);
                return true;
            }
            outItem = null;
            var neededAmount = typeConfig.ArrowPrice.ItemAmount - amount;
            PrintToChat(player, Lang("Resources_Needed", player.UserIDString, neededAmount, item.info.displayName.english));
            return false;
        }

        private void TakeItems(BasePlayer player, Item item)
        {
            player.inventory.Take(player.inventory.FindItemsByItemID(item.info.itemid), item.info.itemid, item.amount);
            PrintToChat(player, Lang("Resources_Spent", player.UserIDString, item.amount, item.info.displayName.english));
        }

        private void FireArrow(Vector3 targetPos)
        {
            var entity = GameManager.server.CreateEntity("assets/bundled/prefabs/fireball.prefab", targetPos);
            Effect.server.Run("assets/prefabs/weapons/satchelcharge/effects/satchel-charge-explosion.prefab", targetPos);
            entity.Spawn();
        }

        private void ExplosiveArrow(Vector3 targetPos, BaseCombatEntity combatEnt)
        {
            Effect.server.Run("assets/prefabs/npc/patrol helicopter/effects/rocket_explosion.prefab", targetPos);
            var vicinityEnts = new List<BaseCombatEntity>();
            var damage = configFile.ExplosionSettings.ExplosiveDamage;
            Vis.Entities(targetPos, configFile.ExplosionSettings.ExplosionRadius, vicinityEnts);
            foreach (var vicinityEnt in vicinityEnts)
            {
                var scaledDamage = damage - Vector3.Distance(targetPos, vicinityEnt.transform.position) * 2;
                vicinityEnt.Hurt(scaledDamage, DamageType.Explosion);
            }
        }

        private bool CanActivateArrow(BasePlayer player, ArrowType type)
        {
            var typeConfig = configFile.Arrows[type];
            if (!permission.UserHasPermission(player.UserIDString, Name + "." + typeConfig.Permission))
            {
                PrintToChat(player, Lang("Cmd_NoPerm", player.UserIDString, type));
                return false;
            }
            return true;
        }

        private void DealWithArrow(BasePlayer player, ActiveArrow arrow)
        {
            if (!CanActivateArrow(player, arrow.ArrowType))
                return;
            if (!ActiveArrows.ContainsKey(player.userID))
                ActiveArrows.Add(player.userID, arrow);
            else
                ActiveArrows[player.userID] = arrow;
            PrintToChat(player, Lang("Cmd_Switched", player.UserIDString, arrow.ArrowType, configFile.Arrows[arrow.ArrowType].Uses));
        }

        private void DealWithRemoval(BasePlayer player)
        {
            ActiveArrows[player.userID].Uses++;
            if (ActiveArrows[player.userID].Uses >= configFile.Arrows[ActiveArrows[player.userID].ArrowType].Uses)
            {
                PrintToChat(player, Lang("Arrow_Disabled", player.UserIDString));
                ActiveArrows.Remove(player.userID);
            }
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private string GetHelpMsg(BasePlayer player)
        {
            var msgList = new List<string>();
            var msg = "";
            foreach (var type in Enum.GetValues(typeof(ArrowType)).Cast<ArrowType>())
            {
                if(type.Equals(ArrowType.None)) continue;
                var configType = configFile.Arrows[type];
                msgList.Add(type + " " + (configType.ArrowPrice.Enabled ? Lang("Cmd_Price", player.UserIDString, configType.ArrowPrice.ItemAmount,
                    ItemManager.CreateByPartialName(configType.ArrowPrice.ItemShortname).info.displayName.english ?? "<color=red>ITEM NOT FOUND</color>") : ""));
            }
            msg = "\t" + string.Join("\n\t", msgList.ToArray());
            if (ActiveArrows.ContainsKey(player.userID))
                msg += "\n" + Lang("Cmd_Active", player.UserIDString, ActiveArrows[player.userID].ArrowType);
            return msg;
        }

        #endregion

        #region Hooks

        private void Init()
        {
            foreach (var arrow in configFile.Arrows)
            {
                if (!permission.PermissionExists(Name + "." + arrow.Value.Permission, this))
                    permission.RegisterPermission(Name + "." + arrow.Value.Permission, this);
            }
        }

        private void OnPlayerAttack(BasePlayer attacker, HitInfo hitInfo)
        {
            if (hitInfo == null || attacker == null || hitInfo.WeaponPrefab == null || hitInfo.Weapon == null)
                return;

            if (hitInfo.WeaponPrefab.ToString().Contains("hunting") || hitInfo.Weapon.name.Contains("bow") && attacker.IsAdmin)
            {
                var hitEntity = hitInfo.HitEntity as BaseCombatEntity;

                if (hitEntity != null)
                {
                    ActiveArrow arrow;
                    if (ActiveArrows.TryGetValue(attacker.userID, out arrow))
                    {
                        Item foundItem;
                        switch (arrow.ArrowType)
                        {
                            case ArrowType.Wind:
                            {
                                if (!CanUseArrow(attacker, arrow.ArrowType, hitEntity, out foundItem))
                                    return;
                                TakeItems(attacker, foundItem);
                                var windPlayer = hitEntity.ToPlayer();
                                windPlayer.MovePosition(windPlayer.transform.position + new Vector3(1, rnd.Next(5, 11), 1));
                                timer.Repeat(0.1f, 30, () => windPlayer.violationLevel = 0);
                                PrintToChat(attacker, Lang("Hit_Wind", attacker.UserIDString, windPlayer.name));
                                DealWithRemoval(attacker);
                                return;
                            }

                            case ArrowType.Fire:
                            {
                                if (!CanUseArrow(attacker, arrow.ArrowType, hitEntity, out foundItem))
                                    return;
                                TakeItems(attacker, foundItem);
                                NextTick(() =>
                                {
                                    FireArrow(hitInfo.HitPositionWorld);
                                    PrintToChat(attacker, Lang("Hit_Fire", attacker.UserIDString, Math.Round(hitEntity.Health(), 1)));
                                });
                                DealWithRemoval(attacker);
                                return;
                            }

                            case ArrowType.Explosive:
                            {
                                if (!CanUseArrow(attacker, arrow.ArrowType, hitEntity, out foundItem))
                                    return;
                                TakeItems(attacker, foundItem);
                                NextTick(() =>
                                {
                                    ExplosiveArrow(hitInfo.HitPositionWorld, hitEntity);
                                    PrintToChat(attacker, Lang("Hit_Explosive", attacker.UserIDString, Math.Round(hitEntity.Health(), 1)));
                                });
                                DealWithRemoval(attacker);
                                return;
                            }

                            case ArrowType.Knockdown:
                            {
                                if (!CanUseArrow(attacker, arrow.ArrowType, hitEntity, out foundItem))
                                    return;
                                TakeItems(attacker, foundItem);
                                var knockdownPlayer = hitEntity.ToPlayer();
                                NextTick(() => PrintToChat(attacker, Lang("Hit_Knockdown", attacker.UserIDString, knockdownPlayer.name, Math.Round(knockdownPlayer.health, 1))));
                                knockdownPlayer.BecomeWounded();
                                DealWithRemoval(attacker);
                                return;
                            }

                            case ArrowType.Narco:
                            {
                                if (!CanUseArrow(attacker, arrow.ArrowType, hitEntity, out foundItem))
                                    return;
                                TakeItems(attacker, foundItem);
                                var narcoPlayer = hitEntity.ToPlayer();
                                NextTick(() => PrintToChat(attacker, Lang("Hit_Narco", attacker.UserIDString, narcoPlayer.name, Math.Round(narcoPlayer.health, 1))));
                                narcoPlayer.StartSleeping();
                                DealWithRemoval(attacker);
                                return;
                            }

                            case ArrowType.Poison:
                            {
                                if (!CanUseArrow(attacker, arrow.ArrowType, hitEntity, out foundItem))
                                    return;
                                TakeItems(attacker, foundItem);
                                var poisonPlayer = hitEntity.ToPlayer();
                                NextTick(() => PrintToChat(attacker, Lang("Hit_Poison", attacker.UserIDString, poisonPlayer.name, Math.Round(poisonPlayer.Health(), 1))));
                                PrintToChat(poisonPlayer, Lang("Damaged_Poison", poisonPlayer.UserIDString));
                                poisonPlayer.metabolism.poison.value = 30;
                                DealWithRemoval(attacker);
                                return;
                            }
                        }
                    }
                    else
                    {
                        if (ActiveArrows.ContainsKey(attacker.userID))
                            ActiveArrows.Remove(attacker.userID);
                    }
                }
            }
        }

        [ChatCommand("arrow")]
        private void ArrowCommand(BasePlayer player, string command, string[] args)
        {
            if (args.Length >= 1)
            {
                switch (args[0].ToLower())
                {
                    case "wind":
                        DealWithArrow(player, new ActiveArrow(ArrowType.Wind));
                        return;

                    case "fire":
                        DealWithArrow(player, new ActiveArrow(ArrowType.Fire));
                        return;

                    case "explosive":
                        DealWithArrow(player, new ActiveArrow(ArrowType.Explosive));
                        return;

                    case "knockdown":
                        DealWithArrow(player, new ActiveArrow(ArrowType.Knockdown));
                        return;

                    case "narco":
                        DealWithArrow(player, new ActiveArrow(ArrowType.Narco));
                        return;

                    case "poison":
                        DealWithArrow(player, new ActiveArrow(ArrowType.Poison));
                        return;

                    case "none":
                        if (!ActiveArrows.ContainsKey(player.userID))
                            goto default;
                        ActiveArrows[player.userID] = new ActiveArrow(ArrowType.None);
                        PrintToChat(player, Lang("Cmd_Disabled", player.UserIDString, ArrowType.None));
                        return;

                    default:
                        PrintToChat(player, Lang("Cmd_Types", player.UserIDString, GetHelpMsg(player)));
                        return;
                }
            }
            PrintToChat(player, Lang("Cmd_Types", player.UserIDString, GetHelpMsg(player)));
        }

        #endregion
    }
}

// --- End of file: AdvancedArrows.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/admin-toggle ---
// --- Original File Path: A/AdminToggle/AdminToggle.cs ---

using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Admin Toggle", "Talha", "1.0.6")]
    [Description("Toggle your admin status")]
    public class AdminToggle : RustPlugin
    {
        private const string perm = "admintoggle.use";
        
        private void Init() { permission.RegisterPermission(perm, this); }
        
        private void Message(BasePlayer player, string key)
        {
            var message = string.Format(lang.GetMessage(key, this, player.UserIDString));
            player.ChatMessage(message);
        }
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ToPlayer"] = "You switched to player mode!",
                ["ToAdmin"] = "You switched to admin mode!"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ToPlayer"] = "Oyuncu moduna gei yaptn!",
                ["ToAdmin"] = "Admin moduna gei yaptn!"
            }, this, "tr");
        }

        [ChatCommand("admin")]
        private void Toggle(BasePlayer player)
        {
            if (!player.IPlayer.HasPermission(perm)) return;
            if (player.IsAdmin)
            {
                if (player.IsFlying) { player.SendConsoleCommand("noclip");}
                player.Connection.authLevel = 0;
                ServerUsers.Set(player.userID, ServerUsers.UserGroup.None, player.displayName, "");
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                permission.RemoveUserGroup(player.userID.ToString(), "admin");
                ServerUsers.Save();
                Message(player, "ToPlayer");
            }
            else
            {
                player.Connection.authLevel = 1;
                ServerUsers.Set(player.userID, ServerUsers.UserGroup.Owner, player.displayName, "");
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                permission.AddUserGroup(player.userID.ToString(), "admin");
                ServerUsers.Save();
                Message(player, "ToAdmin");
            }
        }
    }
}

// --- End of file: AdminToggle.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/anti-offline-raid ---
// --- Original File Path: A/AntiOfflineRaid/AntiOfflineRaid.cs ---

#define DEBUG
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using UnityEngine;

//AntiOfflineRaid created with PluginMerge v(1.0.6.0) by MJSU @ https://github.com/dassjosh/Plugin.Merge
namespace Oxide.Plugins
{
    [Info("Anti Offline Raid", "Calytic/Shady14u", "1.0.2")]
    [Description("Prevents/reduces offline raiding")]
    public partial class AntiOfflineRaid : RustPlugin
    {
        #region 1.AntiOfflineRaid.Config.cs
        private static Configuration _config;
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) LoadDefaultConfig();
                if (_config != null)
                {
                    _config.DamageScaleKeys = _config.DamageScale.Keys.Select(int.Parse).ToList();
                    _config.DamageScaleKeys.Sort();
                }
                
                SaveConfig();
            }
            catch (Exception e)
            {
                Debug.LogException(e);
                PrintWarning("Creating new config file.");
                LoadDefaultConfig();
            }
        }
        
        protected override void LoadDefaultConfig() => _config = Configuration.DefaultConfig();
        protected override void SaveConfig() => Config.WriteObject(_config);
        
        public class Configuration
        {
            [JsonProperty(PropertyName = "AbsoluteTimeScale")]
            public Dictionary<string, object> AbsoluteTimeScale = new();
            
            [JsonProperty(PropertyName = "DamageScale")]
            public Dictionary<string, object> DamageScale = new();
            
            public List<string> Activities { get; set; }
            
            public int AfkMinutes { get; set; }
            
            public bool ClanFirstOffline { get; set; }
            
            public bool ClanShare { get; set; }
            
            public int CooldownMinutes { get; set; }
            
            public float InterimDamage { get; set; }
            
            public int MinMembers { get; set; }
            
            public int MinutesSinceLastAttackToProtect { get; set; }
            
            public bool PlaySound { get; set; }
            
            public List<string> Prefabs { get; set; }
            
            public bool ProtectBaseWhenAway { get; set; }
            
            public int ServerTimeOffset { get; set; }
            
            public bool ShowMessage { get; set; }
            
            public string SoundFile { get; set; }
            public List<int> DamageScaleKeys { get; set; }
            
            
            public static Configuration DefaultConfig()
            {
                return new Configuration
                {
                    DamageScale = new Dictionary<string, object>
                    {{"1", 0.2}, {"3", 0.35f}, {"6", 0.5f}, {"12", 0.8f}, {"48", 1}},
                    AbsoluteTimeScale = new Dictionary<string, object> {{"03", 0.1}},
                    AfkMinutes = 5,
                    CooldownMinutes = 10,
                    InterimDamage = 0,
                    MinMembers = 1,
                    ClanShare = false,
                    ClanFirstOffline = false,
                    ShowMessage = true,
                    PlaySound = false,
                    Prefabs = new List<string>
                    {
                        "door.hinged", "door.double.hinged", "window.bars", "floor.ladder.hatch",
                        "floor.frame", "wall.frame", "shutter", "wall.external", "gates.external", "box", "locker"
                    },
                    Activities = GetDefaultActivities(),
                    ServerTimeOffset = 0,
                    SoundFile = "assets/prefabs/weapon mods/silencers/effects/silencer_attach.fx.prefab",
                    ProtectBaseWhenAway = false,
                    MinutesSinceLastAttackToProtect = 10,
                    DamageScaleKeys = new List<int>{1,3,6,12,48}
                };
            }
        }
        
        private static List<string> GetDefaultActivities()
        {
            return new List<string> { "input", "loot", "respawn", "chat", "wakeup" };
        }
        #endregion

        #region 2.AntiOfflineRaid.Localization.cs
        private static class PluginMessages
        {
            public const string ProtectionMessage = "Protection Message";
            public const string DeniedPermission = "Denied: Permission";
            
            
        }
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [PluginMessages.ProtectionMessage] = "This building is protected: {amount}%",
                [PluginMessages.DeniedPermission] = "You lack permission to do that"
            }, this);
            
        }
        
        private string GetMsg(string key, object userId = null)
        {
            return lang.GetMessage(key, this, userId?.ToString());
        }
        
        void SendMessage(HitInfo hitInfo, int amt = 100)
        {
            if (hitInfo.Initiator is BasePlayer player)
            ShowMessage(player, amt);
        }
        #endregion

        #region 3.AntiOfflineRaid.Permissions.cs
        private static class PluginPermissions
        {
            public const string Protect = "antiofflineraid.protect";
            public const string Check = "antiofflineraid.check";
            
            
        }
        private void LoadPermissions()
        {
            permission.RegisterPermission(PluginPermissions.Protect, this);
            permission.RegisterPermission(PluginPermissions.Check, this);
        }
        
        bool HasPerm(BasePlayer p, string pe)
        {
            return permission.UserHasPermission(p.userID.ToString(), pe);
        }
        
        bool HasPerm(string userid, string pe)
        {
            return permission.UserHasPermission(userid, pe);
        }
        #endregion

        #region 4.AntiOfflineRaid.Data.cs
        private StoredData _storedData;
        
        public class StoredData
        {
            public Dictionary<ulong, LastOnline> LastOnlines { get; set; } = new Dictionary<ulong, LastOnline>();
            public Dictionary<string, List<string>> MembersCache { get; set; } = new Dictionary<string, List<string>>();
        }
        
        #region BoilerPlate
        private void LoadData()
        {
            try
            {
                _storedData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("AntiOfflineRaid");
            }
            catch (Exception e)
            {
                Puts(e.Message);
                Puts(e.StackTrace);
                _storedData = new StoredData();
            }
        }
        
        private void SaveData()
        {
            Interface.GetMod().DataFileSystem.WriteObject("AntiOfflineRaid", _storedData);
        }
        
        #endregion
        #endregion

        #region 5.AntiOfflineRaid.Hooks.cs
        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (hitInfo == null || entity == null)
            return null;
            
            if (hitInfo.damageTypes.Has(DamageType.Decay))
            {
                return null;
            }
            
            return IsBlocked(entity)
            ? OnStructureAttack(entity, hitInfo)
            : null;
        }
        
        void OnLootItem(BasePlayer player, Item item) => UpdateLastOnline(player.userID);
        
        void OnLootPlayer(BasePlayer player, BasePlayer target) => UpdateLastOnline(player.userID);
        
        void OnPlayerChat(ConsoleSystem.Arg args) => UpdateLastOnline(args.Player().userID);
        
        void OnPlayerConnected(BasePlayer player) => UpdateLastOnline(player.userID);
        
        void OnPlayerDisconnected(BasePlayer player) => UpdateLastOnline(player.userID);
        
        void OnPlayerRespawn(BasePlayer player) => UpdateLastOnline(player.userID);
        
        void OnPlayerSleepEnded(BasePlayer player) => UpdateLastOnline(player.userID);
        
        void OnServerInitialized()
        {
            LoadPermissions();
            LoadData();
            
            if (_config.ClanShare)
            {
                if (!plugins.Exists("Clans"))
                {
                    _config.ClanShare = false;
                    PrintWarning("Clans not found! clanShare disabled. Cannot use clanShare without a clans plugin.");
                }
            }
            
            if (!_config.Activities.Any())
            {
                PrintWarning("At least one activity trigger must be configured for this plugin to operate.");
                ToggleHooks(new List<string>());
            }
            else
            {
                ToggleHooks(_config.Activities);
                UpdateLastOnlineAll(false);
                _lastOnlineTimer = timer.Repeat(TickRate * 60, 0, () => UpdateLastOnlineAll());
            }
        }
        
        private void OnServerSave()
        {
            SaveData();
        }
        
        void OnClanCreate(string tag)
        {
            CacheClan(tag);
        }
        
        void OnClanUpdate(string tag)
        {
            CacheClan(tag);
        }
        
        void OnClanDestroy(string tag)
        {
            if (_storedData.MembersCache.ContainsKey(tag))
            {
                _storedData.MembersCache.Remove(tag);
            }
        }
        
        protected void ToggleHook(List<string> wakeupTriggers, string trigger, string hook)
        {
            if (wakeupTriggers.Contains(trigger))
            {
                Subscribe(hook);
            }
            else
            {
                Unsubscribe(hook);
            }
        }
        
        protected void ToggleHooks(List<string> wakeupTriggers)
        {
            var defaultWakeupTriggers = GetDefaultActivities();
            
            foreach (var trigger in defaultWakeupTriggers)
            {
                switch (trigger)
                {
                    case "input":
                    ToggleHook(wakeupTriggers, trigger, "OnPlayerInput");
                    break;
                    case "loot":
                    ToggleHook(wakeupTriggers, trigger, "OnLootPlayer");
                    ToggleHook(wakeupTriggers, trigger, "OnLootItem");
                    break;
                    case "respawn":
                    ToggleHook(wakeupTriggers, trigger, "OnPlayerRespawn");
                    break;
                    case "chat":
                    ToggleHook(wakeupTriggers, trigger, "OnPlayerChat");
                    break;
                    case "wakeup":
                    ToggleHook(wakeupTriggers, trigger, "OnPlayerSleepEnded");
                    break;
                }
            }
        }
        
        private void Unload()
        {
            UpdateLastOnlineAll();
            SaveData();
        }
        #endregion

        #region 6.AntiOfflineRaid.Commands.cs
        [ConsoleCommand("ao")]
        void CheckOfflineStatus(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null) return;
            if (arg.Connection.player is not BasePlayer player) return;
            
            if (!HasPerm(player, PluginPermissions.Check) && arg.Connection.authLevel < 1)
            {
                SendReply(arg, GetMsg("Denied: Permission", arg.Connection.userid));
                return;
            }
            SendReply(arg, SendStatus(arg.Args[0]));
            
        }
        
        [ChatCommand("ao")]
        void CheckOfflineStatus(BasePlayer player, string command, string[] args)
        {
            if (!HasPerm(player, PluginPermissions.Check) && player.net.connection.authLevel < 1)
            {
                SendReply(player, GetMsg("Denied: Permission", player.UserIDString));
                return;
            }
            
            SendReply(player, SendStatus(args[0]));
        }
        
        [ChatCommand("ao.fill.onlineTimes")]
        void CmdFillOnlines(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin)
            return;
            
            foreach (var basePlayer in covalence.Players.All)
            {
                UpdateLastOnline(Convert.ToUInt64(basePlayer.Id));
            }
            
        }
        
        void SendHelpText(BasePlayer player)
        {
            var stringBuilder = new StringBuilder("AntiOfflineRaid by <color=#ce422b>Shady14u</color>\n");
            
            if (_config.CooldownMinutes > 0)
            {
                stringBuilder.Append($"  <color=\"#ffd479\">First {_config.CooldownMinutes} minutes</color>: 100%\n");
                stringBuilder.Append($"  <color=\"#ffd479\">Between {_config.CooldownMinutes} minutes and 1 hour</color>: {_config.InterimDamage * 100}%\n");
            }
            else
            {
                stringBuilder.Append($"  <color=\"#ffd479\">First hour</color>: {_config.InterimDamage * 100}%\n");
            }
            
            foreach (var key in _config.DamageScaleKeys)
            {
                var scale = Math.Round(Convert.ToDouble(_config.DamageScale[key.ToString()]) * 100, 0);
                var hours = Math.Round(Convert.ToDouble(key), 1);
                if (hours >= 24)
                {
                    var days = Math.Round(hours / 24, 1);
                    stringBuilder.Append($"  <color=\"#ffd479\">After {days} days(s)</color>: {scale}%\n");
                }
                else
                {
                    stringBuilder.Append($"  <color=\"#ffd479\">After {hours} hour(s)</color>: {scale}%\n");
                }
            }
            
            player.ChatMessage(stringBuilder.ToString());
        }
        #endregion

        #region 7.AntiOfflineRaid.Classes.cs
        public class LastOnline
        {
            [JsonIgnore] public float AfkMinutes = 0;
            
            public long LastOnlineLong;
            
            [JsonIgnore] public Vector3 LastPosition;
            
            public ulong UserId;
            
            [JsonConstructor]
            public LastOnline(ulong userid, long lastOnlineLong)
            {
                UserId = userid;
                LastOnlineLong = lastOnlineLong;
            }
            
            public LastOnline(ulong userId, DateTime lastOnline)
            {
                UserId = userId;
                LastOnlineTime = lastOnline;
            }
            
            [JsonIgnore] public BasePlayer AarPlayer => BasePlayer.FindByID(UserId);
            
            [JsonIgnore] public double Days => (DateTime.Now - LastOnlineTime).TotalDays;
            
            [JsonIgnore] public double Hours => (DateTime.Now - LastOnlineTime).TotalHours;
            
            [JsonIgnore]
            public DateTime LastOnlineTime
            {
                get => DateTime.FromBinary(LastOnlineLong);
                
                set => LastOnlineLong = value.ToBinary();
            }
            
            [JsonIgnore] public double Minutes => (DateTime.Now - LastOnlineTime).TotalMinutes;
            
            public bool HasMoved(Vector3 position)
            {
                if (LastPosition.Equals(position)) return true;
                LastPosition = new Vector3(position.x, position.y, position.z);
                return false;
            }
            
            public bool IsAfk()
            {
                return AfkMinutes >= _config.AfkMinutes;
            }
            
            public bool IsConnected()
            {
                var player = AarPlayer;
                return player != null && player.IsConnected;
            }
            
            public bool IsOffline()
            {
                return !IsConnected() && Minutes >= _config.CooldownMinutes;
            }
        }
        
        class ScaleCacheItem
        {
            public DateTime Expires;
            public float Scale;
            
            public ScaleCacheItem(DateTime expires, float scale)
            {
                Expires = expires;
                Scale = scale;
            }
        }
        #endregion

        #region 0.AntiOfflineRaid.cs
        [PluginReference] Plugin Clans;
        private const string JsonMessage =
        @"[{""name"":""AntiOfflineRaidMsg"",""parent"":""Overlay"",""components"":[{""type"":""UnityEngine.UI.Image"",""color"":""0 0 0 0.78""},{""type"":""RectTransform"",""anchormax"":""0.64 0.88"",""anchormin"":""0.38 0.79""}]},{""name"":""MessageLabel{1}"",""parent"":""AntiOfflineRaidMsg"",""components"":[{""type"":""UnityEngine.UI.Text"",""align"":""MiddleCenter"",""fontSize"":""19"",""text"":""{protection_message}""},{""type"":""RectTransform"",""anchormax"":""1 1"",""anchormin"":""0 0""}]}]";
        
        private const float TickRate = 5f;
        private readonly Dictionary<ulong, ScaleCacheItem> _cachedScales = new();
        private Timer _lastOnlineTimer;
        
        public List<string> CacheClan(string tag)
        {
            if (string.IsNullOrEmpty(tag)) return null;
            
            var clan = Clans.Call<JObject>("GetClan", tag);
            var members = new List<string>();
            
            if (clan?["members"] == null) return members;
            
            members.AddRange(clan["members"].Select(m => (string) m));
            
            _storedData.MembersCache[tag] = members;
            return members;
        }
        
        float CacheDamageScale(ulong targetId, float scale, ScaleCacheItem kvp = null)
        {
            if (kvp == null)
            {
                kvp = new ScaleCacheItem(DateTime.Now.AddMinutes(1), scale);
                _cachedScales.Add(targetId, kvp);
            }
            else
            {
                kvp.Expires = DateTime.Now.AddMinutes(1);
                kvp.Scale = scale;
            }
            
            return scale;
        }
        
        protected IPlayer FindPlayerByPartialName(string nameOrIdOrIp)
        {
            return string.IsNullOrEmpty(nameOrIdOrIp) ? null : covalence.Players.FindPlayer(nameOrIdOrIp);
        }
        
        public List<string> GetClanMembers(string tag)
        {
            return _storedData.MembersCache.TryGetValue(tag, out var memberList) ? memberList : CacheClan(tag);
        }
        
        public int GetClanMembersOnline(ulong targetId)
        {
            var player = covalence.Players.FindPlayerById(targetId.ToString());
            if (player == null) return 0;
            
            if (Clans == null)
            {
                PrintWarning("Clans plugin not installed");
                _config.ClanShare = false;
                return player.IsConnected ? 1 : 0;
            }
            
            var tag = Clans.Call<string>("GetClanOf", targetId);
            if (tag == null)
            {
                return player.IsConnected ? 1 : 0;
            }
            
            var members = GetClanMembers(tag);
            var mCount = 0;
            foreach (var memberId in members)
            {
                if (string.IsNullOrEmpty(memberId)) continue;
                var mid = Convert.ToUInt64(memberId);
                if (mid == targetId) continue;
                if (!IsOffline(mid)) mCount++;
            }
            
            return mCount;
        }
        
        public ulong GetClanOffline(string tag)
        {
            var clanMembers = GetClanMembers(tag);
            if (clanMembers == null || clanMembers.Count == 0) return 0;
            
            var members = new Dictionary<string, double>();
            foreach (var memberId in clanMembers)
            {
                var mid = Convert.ToUInt64(memberId);
                if (_storedData.LastOnlines.TryGetValue(mid, out var lastOnlineMember))
                {
                    members.Add(memberId, lastOnlineMember.Minutes);
                }
            }
            
            return _config.ClanFirstOffline
            ?
            // loop through all offline members, sorted by who is most offline
            members.OrderByDescending(p => p.Value).Select(kvp => Convert.ToUInt64(kvp.Key)).FirstOrDefault()
            :
            // loop through all offline members, sorted by who is least offline
            members.OrderBy(p => p.Value).Select(kvp => Convert.ToUInt64(kvp.Key)).FirstOrDefault();
        }
        
        private DateTime GetPlayersLastOnline(ulong memberId)
        {
            if (_storedData.LastOnlines.TryGetValue(memberId, out var playerLastOnline))
            {
                return playerLastOnline.IsConnected() ? DateTime.Now.AddMinutes(1) : playerLastOnline.LastOnlineTime;
            }
            
            return DateTime.Now.AddHours(-1);
        }
        
        void HideMessage(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "AntiOfflineRaidMsg");
        }
        
        private bool IsAuthorizedOnline(BaseEntity entity)
        {
            var privilege = entity.GetBuildingPrivilege();
            if (privilege == null) return true;
            if (!privilege.authorizedPlayers.Any()) return true;
            foreach (var privilegePlayer in privilege.authorizedPlayers)
            {
                if (!IsOffline(privilegePlayer.userid))
                {
                    return true;
                }
            }
            return false;
        }
        
        public bool IsBlocked(BaseCombatEntity entity)
        {
            if (entity is BuildingBlock) return true;
            var prefabName = entity?.ShortPrefabName;
            return !string.IsNullOrEmpty(prefabName) && _config.Prefabs.Any(x => prefabName.Contains(x));
        }
        
        private bool IsClanInRange(ulong targetId)
        {
            var tag = Clans?.Call<string>("GetClanOf", targetId);
            if (tag == null)
            {
                return IsPlayerInRange(targetId);
            }
            
            var members = GetClanMembers(tag);
            
            foreach (var memberId in members)
            {
                if (string.IsNullOrEmpty(memberId))
                continue;
                var mid = Convert.ToUInt64(memberId);
                if (IsPlayerInRange(mid)) return true;
            }
            
            return false;
        }
        
        public bool IsClanOffline(ulong targetId)
        {
            return GetClanMembersOnline(targetId) < _config.MinMembers;
        }
        
        public bool IsOffline(ulong playerId)
        {
            if (_storedData.LastOnlines.TryGetValue(playerId, out var lastOnlinePlayer))
            {
                return lastOnlinePlayer.IsOffline();
            }
            
            var player = covalence.Players.FindPlayerById(playerId.ToString());
            return player is not {IsConnected: true};
        }
        
        private static bool IsPlayerInRange(ulong targetId)
        {
            var player = BasePlayer.FindByID(targetId);
            return player != null && player.IsBuildingAuthed();
        }
        
        public object MitigateDamage(HitInfo hitInfo, float scale)
        {
            if (scale < 0 ) return null;
            
            var isFire = hitInfo.damageTypes.GetMajorityDamageType() == DamageType.Heat;
            
            if (scale == 0)
            {
                if (_config.ShowMessage && ((isFire && hitInfo.WeaponPrefab != null) || !isFire))
                SendMessage(hitInfo);
                
                if (_config.PlaySound && hitInfo.Initiator is BasePlayer && !isFire)
                Effect.server.Run(_config.SoundFile, hitInfo.Initiator.transform.position);
                return true;
            }
            
            hitInfo.damageTypes.ScaleAll(scale);
            if (!(scale < 1)) return null;
            
            if (_config.ShowMessage && ((isFire && hitInfo.WeaponPrefab != null) || (!isFire)))
            SendMessage(hitInfo, 100 - Convert.ToInt32(scale * 100));
            
            if (_config.PlaySound && hitInfo.Initiator is BasePlayer && !isFire)
            Effect.server.Run(_config.SoundFile, hitInfo.Initiator.transform.position);
            
            return null;
        }
        
        object OnStructureAttack(BaseEntity entity, HitInfo hitInfo)
        {
            var targetId = entity.OwnerID;
            if (!targetId.IsSteamId() || !HasPerm(targetId.ToString(), PluginPermissions.Protect) ||
            !_storedData.LastOnlines.TryGetValue(targetId, out var lastOnline)) return null;
            
            var buildBlock = entity as BuildingBlock;
            if (buildBlock != null && buildBlock.grade == BuildingGrade.Enum.Twigs) return null;
            
            var clanLastOnline = lastOnline.IsConnected()
            ? lastOnline
            : _storedData.LastOnlines[RecentActiveClanMember(targetId)];
            
            if ((DateTime.Now - clanLastOnline.LastOnlineTime).Minutes <= _config.MinutesSinceLastAttackToProtect)
            {
                UpdateLastOnline(targetId);
            }
            
            var scale = ScaleDamageCached(clanLastOnline);
            
            if (!IsAuthorizedOnline(entity)) return MitigateDamage(hitInfo, scale);
            
            if (_config.ProtectBaseWhenAway)
            {
                return IsClanInRange(targetId) ? null : MitigateDamage(hitInfo, 0);
            }
            
            return null;
        }
        
        private ulong RecentActiveClanMember(ulong targetId)
        {
            var tag = Clans?.Call<string>("GetClanOf", targetId);
            if (tag == null)
            {
                return targetId;
            }
            
            var members = GetClanMembers(tag);
            var lastActive = targetId;
            var memberOnline = GetPlayersLastOnline(targetId);
            foreach (var memberId in members.Where(x => !string.IsNullOrEmpty(x)))
            {
                var memberLast = GetPlayersLastOnline(ulong.Parse(memberId));
                if (memberLast <= memberOnline) continue;
                memberOnline = memberLast;
                lastActive = ulong.Parse(memberId);
            }
            
            return lastActive;
        }
        
        public float ScaleDamage(LastOnline lastOnline)
        {
            if (lastOnline == null || !lastOnline.IsOffline())
            {
                return -1;
            }
            
            // if absolute scale is configured, override relative scaling
            if (_config.AbsoluteTimeScale.Count > 0)
            {
                var hour = DateTime.Now.ToString("HH", DateTimeFormatInfo.InvariantInfo);
                if (_config.AbsoluteTimeScale.TryGetValue(hour, out var scaleObj))
                {
                    return Convert.ToSingle(scaleObj);
                }
            }
            
            float scale = -1;
            if (lastOnline.Minutes >= 60)
            {
                var scaleKey = _config.DamageScaleKeys.FirstOrDefault(x => x <= lastOnline.Hours);
                if (_config.DamageScale.TryGetValue(scaleKey.ToString(), out var scaleValue))
                {
                    scale = Convert.ToSingle(scaleValue);
                }
            }
            else
            {
                scale = _config.InterimDamage;
            }
            
            return scale;
        }
        
        float ScaleDamageCached(LastOnline lastOnline)
        {
            if (_cachedScales.TryGetValue(lastOnline.UserId, out var kvp) && DateTime.Now < kvp.Expires)
            {
                return kvp.Scale;
            }
            
            return CacheDamageScale(lastOnline.UserId, ScaleDamage(lastOnline), kvp);
        }
        
        string SendStatus(string playerSearch)
        {
            if (string.IsNullOrEmpty(playerSearch)) return "Invalid Syntax. ao <PlayerName>";
            
            var target = FindPlayerByPartialName(playerSearch);
            if (target == null || !_storedData.LastOnlines.TryGetValue(Convert.ToUInt64(target.Id), out var lo)) return "No player found.";
            
            var stringBuilder = new StringBuilder();
            if (IsOffline(Convert.ToUInt64(target.Id)))
            {
                stringBuilder.AppendLine(
                "<color=#F31D07><size=15>AntiOfflineRaid Status</size></color>: " + target.Name);
                stringBuilder.AppendLine(target.IsConnected
                ? $"<color=#56C5D5>Player Status</color>: <color=#E49C63>AFK</color>: {lo.LastOnlineTime.AddHours(_config.ServerTimeOffset)} EST"
                : $"<color=#56C5D5>Player Status</color>: <color=#F31D07>Offline</color>: {lo.LastOnlineTime.AddHours(_config.ServerTimeOffset)} EST");
            }
            else
            {
                stringBuilder.AppendLine(
                $"<color=#3CF348><size=15>AntiOfflineRaid Status</size></color>: {target.Name}");
                stringBuilder.AppendLine("<color=#56C5D5>Player Status</color>: <color=#3CF348>Online</color>");
            }
            
            stringBuilder.AppendLine($"<color=#56C5D5>AFK</color>: {lo.AfkMinutes} minutes");
            if (_config.ClanShare)
            {
                stringBuilder.AppendLine(
                $"<color=#56C5D5>Clan Status</color>: {(IsClanOffline(Convert.ToUInt64(target.Id)) ? "<color=#F31D07>Offline</color>" : "<color=#3CF348>Online</color>")} ({GetClanMembersOnline(Convert.ToUInt64(target.Id))})");
                var tag = Clans.Call<string>("GetClanOf", target.Id);
                if (!string.IsNullOrEmpty(tag))
                {
                    var msg = _config.ClanFirstOffline ? "First Offline" : "Last Offline";
                    if (_storedData.LastOnlines.TryGetValue(GetClanOffline(tag), out var lastOfflinePlayer))
                    {
                        var p = covalence.Players.FindPlayerById(lastOfflinePlayer.UserId.ToString());
                        stringBuilder.AppendLine(
                        $"<color=#56C5D5>Clan {msg}</color>: {p.Name} - {lastOfflinePlayer.LastOnlineTime.AddHours(_config.ServerTimeOffset)} EST");
                    }
                }
            }
            
            var scale = ScaleDamage(lo);
            if (scale > -1)
            {
                stringBuilder.AppendLine($"<color=#56C5D5>Scale</color>: {scale*100}%");
            }
            
            return stringBuilder.ToString();
        }
        
        void ShowMessage(BasePlayer player, int amount = 100)
        {
            HideMessage(player);
            var sb = new StringBuilder();
            sb.Clear();
            sb.Append(JsonMessage);
            sb.Replace("{1}", Core.Random.Range(1, 99999).ToString());
            sb.Replace("{protection_message}", GetMsg("Protection Message", player.UserIDString));
            sb.Replace("{amount}", amount.ToString());
            
            CuiHelper.AddUi(player, sb.ToString());
            
            timer.In(3f, () => HideMessage(player));
        }
        
        void UpdateLastOnline(ulong playerId, bool hasMoved = true)
        {
            if (!_storedData.LastOnlines.TryGetValue(playerId, out var lastOnlinePlayer))
            {
                _storedData.LastOnlines.Add(playerId, new LastOnline(playerId, DateTime.Now));
            }
            else
            {
                lastOnlinePlayer.LastOnlineTime = DateTime.Now;
                if (hasMoved)
                lastOnlinePlayer.AfkMinutes = 0;
            }
        }
        
        void UpdateLastOnlineAll(bool afkCheck = true)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (!player.IsConnected)
                continue;
                
                var hasMoved = true;
                
                if (afkCheck)
                {
                    if (_storedData.LastOnlines.TryGetValue(player.userID, out var lastOnlinePlayer))
                    {
                        if (!lastOnlinePlayer.HasMoved(player.transform.position))
                        {
                            hasMoved = false;
                            lastOnlinePlayer.AfkMinutes += TickRate;
                        }
                        
                        if (lastOnlinePlayer.IsAfk())
                        {
                            continue;
                        }
                    }
                }
                
                UpdateLastOnline(player.userID, hasMoved);
            }
        }
        #endregion

    }

}


// --- End of file: AntiOfflineRaid.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/arena-wall-generator ---
// --- Original File Path: A/ArenaWallGenerator/ArenaWallGenerator.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text.RegularExpressions;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Rust;
using UnityEngine;

/*
Added permission arenawallgenerator.allowed
Added ice walls as an option
Added square arena as an option
Added triangle arena as an option
- Patch by magus2621
*/

namespace Oxide.Plugins
{
    [Info("ArenaWallGenerator", "nivex", "1.0.6")]
    [Description("An easy to use arena wall generator.")]
    class ArenaWallGenerator : RustPlugin
    {
        private string hewwPrefab;
        private string heswPrefab;
        private string heiwPrefab;
        private const string permName = "arenawallgenerator.allowed";
        private const int wallMask = Layers.Mask.Terrain | Layers.Mask.World | Layers.Mask.Default | Layers.Mask.Construction | Layers.Mask.Deployed;
        private StoredData storedData = new StoredData();
        private List<BaseCombatEntity> _walls = new List<BaseCombatEntity>();
        private bool newSave;

        public enum Shape
        {
            Circle,
            Square,
            Triangle
        }

        public class StoredData
        {
            public int Seed = 0;
            public readonly Dictionary<string, float> Arenas = new Dictionary<string, float>();
            public StoredData() { }
        }

        private void OnNewSave(string filename) => newSave = true;

        private void OnServerSave()
        {
            SaveData();
        }

        private void Unload()
        {
            SaveData();
        }

        private void Init()
        {
            Unsubscribe(nameof(OnEntityDeath));
            Unsubscribe(nameof(OnEntityKill));
            Unsubscribe(nameof(OnEntityTakeDamage));
            permission.RegisterPermission(permName, this);
        }

        private void OnServerInitialized(bool isStartup)
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch { }

            if (storedData?.Arenas == null)
                storedData = new StoredData();

            if (newSave || BuildingManager.server.buildingDictionary.Count == 0)
            {
                if (respawnOnWipe && storedData.Seed == ConVar.Server.seed)
                {
                    foreach (var entry in storedData.Arenas)
                    {
                        API_CreateZoneWalls(entry.Key.ToVector3(), entry.Value);
                    }
                }

                storedData.Seed = ConVar.Server.seed;
                newSave = false;
                SaveData();
            }

            if (noDecay)
            {
                Subscribe(nameof(OnEntityTakeDamage));
            }
            
            if (respawnWalls)
            {
                Subscribe(nameof(OnEntityDeath));
                Subscribe(nameof(OnEntityKill));
            }

            Subscribe(nameof(OnEntitySpawned));
            hewwPrefab = StringPool.Get(1745077396);
            heswPrefab = StringPool.Get(1585379529);
            heiwPrefab = StringPool.Get(921229511);
            _walls.AddRange(BaseNetworkable.serverEntities.Where(e => e is SimpleBuildingBlock || e.prefabID == 921229511).OfType<BaseCombatEntity>());
        }

        private object OnEntityKill(IceFence fence)
        {
            if (fence.prefabID == 921229511 && fence.OwnerID != 0 && !fence.OwnerID.IsSteamId() && ArenaTerritory(fence.transform.position))
            {
                return false;
            }

            return null;
        }

        private object OnEntityKill(SimpleBuildingBlock block) => block.OwnerID != 0 && !block.OwnerID.IsSteamId() && ArenaTerritory(block.transform.position) ? false : (object)null;

        private void OnEntityDeath(IceFence fence, HitInfo hitInfo) => OnEntityDeathHandler(fence);

        private void OnEntityDeath(SimpleBuildingBlock e, HitInfo hitInfo) => OnEntityDeathHandler(e);

        private void OnEntityDeathHandler(BaseCombatEntity e)
        {
            if (e.OwnerID != 0 && !e.OwnerID.IsSteamId())
            {
                _walls.Remove(e);

                RecreateZoneWall(e.PrefabName, e.transform.position, e.transform.rotation, e.OwnerID);
            }
        }

        private void OnEntitySpawned(IceFence fence)
        {
            if (fence.prefabID == 921229511)
            {
                _walls.Add(fence);
            }
        }

        private void OnEntitySpawned(SimpleBuildingBlock e) => _walls.Add(e);

        private void OnEntityTakeDamage(IceFence fence, HitInfo hitInfo)
        {
            if (fence.prefabID == 921229511)
            {
                OnEntityTakeDamageHandler(fence, hitInfo);
            }
        }

        private void OnEntityTakeDamage(SimpleBuildingBlock ssb, HitInfo hitInfo) => OnEntityTakeDamageHandler(ssb, hitInfo);

        private void OnEntityTakeDamageHandler(BaseCombatEntity e, HitInfo hitInfo)
        {
            if (e == null || hitInfo == null || !hitInfo.damageTypes.Has(DamageType.Decay) || !ArenaTerritory(e.transform.position))
            {
                return;
            }

            hitInfo.damageTypes = new DamageTypeList();
        }

        public void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);

        public void RecreateZoneWall(string prefab, Vector3 pos, Quaternion rot, ulong ownerId)
        {
            if (!ArenaTerritory(pos))
            {
                return;
            }

            var e = GameManager.server.CreateEntity(prefab, pos, rot, false);

            if (e == null)
            {
                return;
            }

            e.OwnerID = ownerId;
            e.Spawn();
            e.gameObject.SetActive(true);

            if (!noDecay)
            {
                return;
            }

            DecayEntity decayEntity;
            if (e.TryGetComponent(out decayEntity))
            {
                decayEntity.decay = null;
            }
        }

        [HookMethod("ArenaTerritory")]
        public bool ArenaTerritory(Vector3 position)
        {
            foreach (var zone in storedData.Arenas)
            {
                if (Vector3Ex.Distance2D(position, zone.Key.ToVector3()) <= zone.Value + 5f)
                {
                    return true;
                }
            }

            return false;
        }

        public ulong GetHashId(string uid)
        {
            return Convert.ToUInt64(Math.Abs(uid.GetHashCode()));
        }

        public bool RemoveCustomZoneWalls(Vector3 center)
        {
            var list = new List<Vector3>();

            foreach (var zone in storedData.Arenas)
            {
                if (Vector3Ex.Distance2D(center, zone.Key.ToVector3()) <= zone.Value)
                {
                    list.Add(zone.Key.ToVector3());
                }
            }

            if (list.Count > 0)
            {
                list.Sort((x, y) => Vector3.Distance(y, x).CompareTo(Vector3.Distance(x, y)));

                string key = list.First().ToString();

                if (RemoveZoneWalls(GetHashId(key)) > 0)
                {
                    storedData.Arenas.Remove(key);
                    return true;
                }
            }

            return false;
        }

        public int RemoveZoneWalls(ulong hashId)
        {
            int removed = 0;

            if (respawnWalls)
            {
                Unsubscribe(nameof(OnEntityKill));
            }

            foreach (var e in _walls.ToList())
            {
                if (e.OwnerID == hashId)
                {
                    _walls.Remove(e);
                    e.Kill();
                    removed++;
                }
            }

            if (respawnWalls)
            {
                Subscribe(nameof(OnEntityKill));
            }

            return removed;
        }

        public List<Vector3> GetCircumferencePositions(Vector3 center, float radius, float next, float y)
        {
            var positions = new List<Vector3>();
            float degree = 0f;

            while (degree < 360f)
            {
                float angle = Mathf.Deg2Rad * degree;
                float x = center.x + radius * Mathf.Cos(angle);
                float z = center.z + radius * Mathf.Sin(angle);

                if (y == 0f)
                {
                    y = TerrainMeta.HeightMap.GetHeight(TerrainMeta.NormalizeX(x), TerrainMeta.NormalizeZ(z));
                }

                positions.Add(new Vector3(x, y, z));

                degree += next;
            }

            return positions;
        }

        public List<Vector3> GetSquarePerimeterPositions(Vector3 center, float radius, float y, float rotation)
        {
            var positions = new List<Vector3>();
            var area = Mathf.PI * Mathf.Pow(radius, 2f);
            var length = Mathf.Sqrt(area);
            var corners = GetSquareCorners(center, radius, y, rotation);
            var gap = 
                radius <= 10f ? 1f : 
                radius <= 15f ? 0.5f : 
                radius <= 20f ? 0.2175f : 
                radius <= 35f ? 1f : 
                radius <= 40f ? 0.25f :
                radius <= 60f ? 0.5f :
                0f;

            positions.AddRange(AddSides(gap, length, y, corners[0], corners[1]));
            positions.AddRange(AddSides(gap, length, y, corners[1], corners[2]));
            positions.AddRange(AddSides(gap, length, y, corners[2], corners[3]));
            positions.AddRange(AddSides(gap, length, y, corners[3], corners[0]));

            return positions;
        }

        public List<Vector3> GetTrianglePerimeterPositions(Vector3 center, float radius, float y, float rotation)
        {
            var positions = new List<Vector3>();
            float area = Mathf.PI * Mathf.Pow(radius, 2f);
            float length = Mathf.Sqrt(area / (Mathf.Sqrt(3f) / 4f));
            var corners = GetTriangleCorners(center, radius, y, rotation);
            float gap = 0.5f;

            positions.AddRange(AddSides(gap, length, y, corners[0], corners[1]));
            positions.AddRange(AddSides(gap, length, y, corners[1], corners[2]));
            positions.AddRange(AddSides(gap, length, y, corners[2], corners[0]));

            return positions;
        }

        private static List<Vector3> AddSides(float gap, float length, float y, Vector3 corner1, Vector3 corner2)
        {
            var positions = new List<Vector3>();
            for (float i = gap; i <= length - gap; i += 5)
            {
                var x = (1 - i / length) * corner1.x + i / length * corner2.x;
                var z = (1 - i / length) * corner1.z + i / length * corner2.z;

                if (y == 0f)
                {
                    y = TerrainMeta.HeightMap.GetHeight(TerrainMeta.NormalizeX(x), TerrainMeta.NormalizeZ(z));
                }

                positions.Add(new Vector3(x, y, z));
            }

            return positions;
        }

        private static List<float> AddDirections(int n, Vector3 center, Vector3 reference)
        {
            var directions = new List<float>(); // Vector3Ex.Direction
            var x = reference.x - center.x;
            var z = reference.z - center.z;
            float angle = Mathf.Atan2(x, z) * Mathf.Rad2Deg;
            for (int i = 1; i <= n; i++)
            {
                directions.Add(angle);
            }

            return directions;
        }

        public List<Vector3> GetSquareCorners(Vector3 center, float radius, float y, float rotation)
        {
            var corners = new List<Vector3>();
            float area = Mathf.PI * Mathf.Pow(radius, 2f);
            float length = Mathf.Sqrt(area);
            var j = Mathf.Sin(Mathf.Deg2Rad * -rotation) - Mathf.Cos(Mathf.Deg2Rad * -rotation);
            var k = Mathf.Sin(Mathf.Deg2Rad * -rotation) + Mathf.Cos(Mathf.Deg2Rad * -rotation);

            var corner1 = new Vector3(center.x - length / 2 * j, 0f, center.z + length / 2 * k);
            var corner2 = new Vector3(center.x + length / 2 * k, 0f, center.z + length / 2 * j);
            var corner3 = new Vector3(center.x + length / 2 * j, 0f, center.z - length / 2 * k);
            var corner4 = new Vector3(center.x - length / 2 * k, 0f, center.z - length / 2 * j);

            corner1.y = y == 0f ? TerrainMeta.HeightMap.GetHeight(corner1) : y;
            corner2.y = y == 0f ? TerrainMeta.HeightMap.GetHeight(corner2) : y;
            corner3.y = y == 0f ? TerrainMeta.HeightMap.GetHeight(corner3) : y;
            corner4.y = y == 0f ? TerrainMeta.HeightMap.GetHeight(corner4) : y;

            corners.Add(corner1);
            corners.Add(corner2);
            corners.Add(corner3);
            corners.Add(corner4);

            return corners;
        }

        public List<Vector3> GetSquareSideCenters(Vector3 center, float radius, float y, float rotation)
        {
            var centers = new List<Vector3>();
            var corners = GetSquareCorners(center, radius, y, rotation);
            var center1 = new Vector3((corners[0].x + corners[1].x) / 2, 0f, (corners[0].z + corners[1].z) / 2);
            var center2 = new Vector3((corners[1].x + corners[2].x) / 2, 0f, (corners[1].z + corners[2].z) / 2);
            var center3 = new Vector3((corners[2].x + corners[3].x) / 2, 0f, (corners[2].z + corners[3].z) / 2);
            var center4 = new Vector3((corners[3].x + corners[0].x) / 2, 0f, (corners[3].z + corners[0].z) / 2);

            center1.y = y == 0f ? TerrainMeta.HeightMap.GetHeight(center1) : y;
            center2.y = y == 0f ? TerrainMeta.HeightMap.GetHeight(center2) : y;
            center3.y = y == 0f ? TerrainMeta.HeightMap.GetHeight(center3) : y;
            center4.y = y == 0f ? TerrainMeta.HeightMap.GetHeight(center4) : y;

            centers.Add(center1);
            centers.Add(center2);
            centers.Add(center3);
            centers.Add(center4);

            return centers;
        }

        public List<Vector3> GetTriangleCorners(Vector3 center, float radius, float y, float rotation)
        {
            var corners = new List<Vector3>();
            float area = Mathf.PI * Mathf.Pow(radius, 2f);
            float length = Mathf.Sqrt(area / (Mathf.Sqrt(3f) / 4f));
            float circleRadius = Mathf.Sqrt(3f) / 3f * length;
            int start = (int)Mathf.Round(rotation);
            var circle = new List<Vector3>();

            for (float degree = 0f; degree < 360f; degree++)
            {
                float angle = Mathf.Deg2Rad * degree;
                float x = center.x + circleRadius * Mathf.Cos(angle);
                float z = center.z + circleRadius * Mathf.Sin(angle);

                if (y == 0f)
                {
                    y = TerrainMeta.HeightMap.GetHeight(TerrainMeta.NormalizeX(x), TerrainMeta.NormalizeZ(z));
                }

                circle.Add(new Vector3(x, y, z));
            }

            var corner1 = circle[start % circle.Count];
            var corner2 = circle[(start + 120) % circle.Count];
            var corner3 = circle[(start + 240) % circle.Count];

            corner1.y = y == 0f ? TerrainMeta.HeightMap.GetHeight(corner1) : y;
            corner2.y = y == 0f ? TerrainMeta.HeightMap.GetHeight(corner2) : y;
            corner3.y = y == 0f ? TerrainMeta.HeightMap.GetHeight(corner3) : y;

            corners.Add(corner1);
            corners.Add(corner2);
            corners.Add(corner3);

            return corners;
        }

        public List<Vector3> GetTriangleSideCenters(Vector3 center, float radius, float y, float rotation)
        {
            var centers = new List<Vector3>();
            var corners = GetTriangleCorners(center, radius, y, rotation);
            var center1 = new Vector3((corners[0].x + corners[1].x) / 2, 0f, (corners[0].z + corners[1].z) / 2);
            var center2 = new Vector3((corners[1].x + corners[2].x) / 2, 0f, (corners[1].z + corners[2].z) / 2);
            var center3 = new Vector3((corners[2].x + corners[0].x) / 2, 0f, (corners[2].z + corners[0].z) / 2);

            center1.y = y == 0f ? TerrainMeta.HeightMap.GetHeight(center1) : y;
            center2.y = y == 0f ? TerrainMeta.HeightMap.GetHeight(center2) : y;
            center3.y = y == 0f ? TerrainMeta.HeightMap.GetHeight(center3) : y;

            centers.Add(center1);
            centers.Add(center2);
            centers.Add(center3);

            return centers;
        }

        public bool CreateZoneWalls(Vector3 center, float radius, string prefab, IPlayer p, Shape shape)
        {
            int spawned = 0;
            float minHeight = 200f;
            float maxHeight = -200f;
            var tick = DateTime.Now;
            ulong hashId = GetHashId(center.ToString());
            int raycasts = Mathf.CeilToInt(360 / radius * 0.1375f);
            var player = p.Object as BasePlayer;
            var rotation = player.eyes.rotation.eulerAngles.y;
            var directions = new List<float>();

            if (shape == Shape.Square)
            {
                var positions = GetSquarePerimeterPositions(center, radius, 0f, rotation);
                var elements = positions.Count / 4;
                var centers = GetSquareSideCenters(center, radius, 0f, rotation);

                foreach (var position in GetSquarePerimeterPositions(center, radius, 0f, rotation))
                {
                    RaycastHit hit;
                    if (Physics.Raycast(new Vector3(position.x, position.y + 200f, position.z), Vector3.down, out hit, Mathf.Infinity, wallMask))
                    {
                        maxHeight = Mathf.Max(hit.point.y, maxHeight);
                        minHeight = Mathf.Min(hit.point.y, minHeight);
                        center.y = minHeight;
                    }
                }

                foreach (var sideCenter in centers)
                {
                    directions.AddRange(AddDirections(elements, center, sideCenter));
                }
            }
            else if (shape == Shape.Triangle)
            {
                var positions = GetTrianglePerimeterPositions(center, radius, 0f, rotation);
                var elements = positions.Count / 3;
                var centers = GetTriangleSideCenters(center, radius, 0f, rotation);

                foreach (var position in GetTrianglePerimeterPositions(center, radius, 0f, rotation))
                {
                    RaycastHit hit;
                    if (Physics.Raycast(new Vector3(position.x, position.y + 200f, position.z), Vector3.down, out hit, Mathf.Infinity, wallMask))
                    {
                        maxHeight = Mathf.Max(hit.point.y, maxHeight);
                        minHeight = Mathf.Min(hit.point.y, minHeight);
                        center.y = minHeight;
                    }
                }

                foreach (var sideCenter in centers)
                {
                    directions.AddRange(AddDirections(elements, center, sideCenter));
                }
            }
            else
            {
                foreach (var position in GetCircumferencePositions(center, radius, raycasts, 0f))
                {
                    RaycastHit hit;
                    if (Physics.Raycast(new Vector3(position.x, position.y + 200f, position.z), Vector3.down, out hit, Mathf.Infinity, wallMask))
                    {
                        maxHeight = Mathf.Max(hit.point.y, maxHeight);
                        minHeight = Mathf.Min(hit.point.y, minHeight);
                        center.y = minHeight;
                    }
                }
            }

            float gap = prefab == heswPrefab ? 0.3f : 0.5f;
            int stacks = Mathf.CeilToInt((maxHeight - minHeight) / 6f) + extraWallStacks;
            float next = 360 / radius - gap;

            for (int i = 0; i < stacks; i++)
            {
                if (shape == Shape.Square)
                {
                    foreach (var position in GetSquarePerimeterPositions(center, radius, center.y, rotation).Select((Value, Index) => new { Value, Index }))
                    {
                        float groundHeight = TerrainMeta.HeightMap.GetHeight(new Vector3(position.Value.x, position.Value.y + 6f, position.Value.z));

                        if (groundHeight > position.Value.y + 10f)
                        {
                            continue;
                        }

                        if (useLeastAmount && position.Value.y - groundHeight > 6f + extraWallStacks * 6f)
                        {
                            continue;
                        }

                        var entity = GameManager.server.CreateEntity(prefab, position.Value, default(Quaternion), false);

                        if (entity == null)
                        {
                            return false;
                        }

                        entity.OwnerID = hashId;
                        var lookDirection = new Vector3(Mathf.Sin(Mathf.Deg2Rad * directions[position.Index]), 0f, Mathf.Cos(Mathf.Deg2Rad * directions[position.Index]));
                        entity.transform.rotation = Quaternion.LookRotation(lookDirection, Vector3.up);
                        entity.Spawn();
                        entity.gameObject.SetActive(true);
                        spawned++;

                        if (stacks == i - 1)
                        {
                            RaycastHit hit;
                            if (Physics.Raycast(new Vector3(position.Value.x, position.Value.y + 6f, position.Value.z), Vector3.down, out hit, 12f, Layers.Mask.World | Layers.Mask.Terrain))
                            {
                                if (hit.collider.name.Contains("rock_") || hit.collider.name.Contains("formation_", CompareOptions.OrdinalIgnoreCase))
                                {
                                    stacks++;
                                }
                            }
                        }
                    }
                }
                else if (shape == Shape.Triangle)
                {
                    foreach (var position in GetTrianglePerimeterPositions(center, radius, center.y, rotation).Select((Value, Index) => new { Value, Index }))
                    {
                        float groundHeight = TerrainMeta.HeightMap.GetHeight(new Vector3(position.Value.x, position.Value.y + 6f, position.Value.z));

                        if (groundHeight > position.Value.y + 9f)
                        {
                            continue;
                        }

                        if (useLeastAmount && position.Value.y - groundHeight > 6f + extraWallStacks * 6f)
                        {
                            continue;
                        }

                        var entity = GameManager.server.CreateEntity(prefab, position.Value, default(Quaternion), false);

                        if (entity == null)
                        {
                            return false;
                        }

                        entity.OwnerID = hashId;
                        var lookDirection = new Vector3(Mathf.Sin(Mathf.Deg2Rad * directions[position.Index]), 0f, Mathf.Cos(Mathf.Deg2Rad * directions[position.Index]));
                        entity.transform.rotation = Quaternion.LookRotation(lookDirection, Vector3.up);
                        entity.Spawn();
                        entity.gameObject.SetActive(true);
                        spawned++;

                        if (stacks == i - 1)
                        {
                            RaycastHit hit;
                            if (Physics.Raycast(new Vector3(position.Value.x, position.Value.y + 6f, position.Value.z), Vector3.down, out hit, 12f, Layers.Mask.World | Layers.Mask.Terrain))
                            {
                                if (hit.collider.name.Contains("rock_") || hit.collider.name.Contains("formation_", CompareOptions.OrdinalIgnoreCase))
                                {
                                    stacks++;
                                }
                            }
                        }
                    }
                }
                else
                {
                    foreach (var position in GetCircumferencePositions(center, radius, next, center.y))
                    {
                        float groundHeight = TerrainMeta.HeightMap.GetHeight(new Vector3(position.x, position.y + 6f, position.z));

                        if (groundHeight > position.y + 9f)
                        {
                            continue;
                        }

                        if (useLeastAmount && position.y - groundHeight > 6f + extraWallStacks * 6f)
                        {
                            continue;
                        }

                        var entity = GameManager.server.CreateEntity(prefab, position, default(Quaternion), false);

                        if (entity == null)
                        {
                            return false;
                        }

                        entity.OwnerID = hashId;
                        entity.transform.LookAt(center, Vector3.up);
                        entity.Spawn();
                        entity.gameObject.SetActive(true);
                        spawned++;

                        if (stacks == i - 1)
                        {
                            RaycastHit hit;
                            if (Physics.Raycast(new Vector3(position.x, position.y + 6f, position.z), Vector3.down, out hit, 12f, Layers.Mask.World | Layers.Mask.Terrain))
                            {
                                if (hit.collider.name.Contains("rock_") || hit.collider.name.Contains("formation_", CompareOptions.OrdinalIgnoreCase))
                                {
                                    stacks++;
                                }
                            }
                        }
                    }
                }

                center.y += 6f;
            }

            string strPos = $"{center.x:N2} {center.y:N2} {center.z:N2}";

            if (p == null)
            {
                Puts(msg("GeneratedWalls", null, spawned, stacks, strPos, (DateTime.Now - tick).TotalSeconds));
            }
            else p.Reply(msg("GeneratedWalls", p.Id, spawned, stacks, strPos, (DateTime.Now - tick).TotalSeconds));

            return true;
        }

        private bool API_CreateZoneWalls(Vector3 center, float radius, int shape = 0)
        {
            if (CreateZoneWalls(center, radius, useWoodenWalls ? hewwPrefab : useIceWalls ? heiwPrefab : heswPrefab, null, shape == 0 ? Shape.Circle : Shape.Square))
            {
                storedData.Arenas[center.ToString()] = radius;
                return true;
            }

            return false;
        }

        private bool API_RemoveZoneWalls(Vector3 center)
        {
            return RemoveCustomZoneWalls(center);
        }

        private bool HasPermission(IPlayer player)
        {
            if (player.IsServer) return false;
            if (player.IsAdmin) return true;
            return player.HasPermission(permName);
        }
        private void CommandWalls(IPlayer p, string command, string[] args)
        {
            if (!HasPermission(p))
            {
                return;
            }

            var player = p.Object as BasePlayer;

            if (args.Length >= 1)
            {
                float radius;
                if (float.TryParse(args[0], out radius) && radius > 2f)
                {
                    if (radius > maxCustomWallRadius)
                    {
                        radius = maxCustomWallRadius;
                    }

                    RaycastHit hit;
                    if (Physics.Raycast(player.eyes.HeadRay(), out hit, Mathf.Infinity, wallMask))
                    {
                        string prefab;
                        Shape shape;

                        if (args.Any(arg => arg.Contains("stone", CompareOptions.OrdinalIgnoreCase)))
                            prefab = heswPrefab;
                        else if (args.Any(arg => arg.Contains("wood", CompareOptions.OrdinalIgnoreCase)))
                            prefab = hewwPrefab;
                        else if (args.Any(arg => arg.Contains("ice", CompareOptions.OrdinalIgnoreCase)))
                            prefab = heiwPrefab;
                        else prefab = useWoodenWalls ? hewwPrefab : useIceWalls ? heiwPrefab : heswPrefab;

                        if (args.Any(arg => arg.Contains("circle", CompareOptions.OrdinalIgnoreCase)))
                            shape = Shape.Circle;
                        else if (args.Any(arg => arg.Contains("square", CompareOptions.OrdinalIgnoreCase)))
                            shape = Shape.Square;
                        else if (args.Any(arg => arg.Contains("triangle", CompareOptions.OrdinalIgnoreCase)))
                            shape = Shape.Triangle;
                        else shape = useShape.Equals("square") ? Shape.Square : useShape.Equals("triangle") ? Shape.Triangle : Shape.Circle;

                        storedData.Arenas[hit.point.ToString()] = radius;
                        CreateZoneWalls(hit.point, radius, prefab, p, shape);
                    }
                    else p.Reply(msg("FailedRaycast", p.Id));
                }
                else p.Reply(msg("InvalidNumber", p.Id, args[0]));
            }
            else
            {
                if (!RemoveCustomZoneWalls(player.transform.position))
                {
                    p.Reply(msg("WallsSyntax", player.UserIDString, chatCommandName));
                }

                foreach (var entry in storedData.Arenas)
                {
                    player.SendConsoleCommand("ddraw.text", 30f, Color.yellow, entry.Key.ToVector3(), entry.Value);
                }
            }
        }

        #region Config

        private bool Changed;
        private int extraWallStacks;
        private bool useLeastAmount;
        private float maxCustomWallRadius;
        private bool useWoodenWalls;
        private bool useIceWalls;
        private string useShape;
        private string chatCommandName;
        private bool respawnWalls;
        private bool respawnOnWipe;
        private bool noDecay;

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["GeneratedWalls"] = "Generated {0} arena walls {1} high at {2} in {3}ms",
                ["FailedRaycast"] = "Look towards the ground, and try again.",
                ["InvalidNumber"] = "Invalid number: {0}",
                ["WallsSyntax"] = "Use <color=orange>/{0} [radius] <circle|square|triangle> <wood|ice|stone></color>, or stand inside of an existing arena and use <color=orange>/{0}</color> to remove it.",
            }, this);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            extraWallStacks = Convert.ToInt32(GetConfig("Settings", "Extra High External Wall Stacks", 2));
            useLeastAmount = Convert.ToBoolean(GetConfig("Settings", "Create Least Amount Of Walls", false));
            maxCustomWallRadius = Convert.ToSingle(GetConfig("Settings", "Maximum Arena Radius", 300f));
            useWoodenWalls = Convert.ToBoolean(GetConfig("Settings", "Use Wooden Walls", false));
            useIceWalls = Convert.ToBoolean(GetConfig("Settings", "Use Ice Walls", false));
            useShape = Convert.ToString(GetConfig("Settings", "Use Shape", "circle"));
            chatCommandName = Convert.ToString(GetConfig("Settings", "Chat Command", "awg"));
            respawnWalls = Convert.ToBoolean(GetConfig("Settings", "Respawn Zone Walls On Death", false));
            respawnOnWipe = Convert.ToBoolean(GetConfig("Settings", "Respawn Arenas On Wipe If Same Seed", false));
            noDecay = Convert.ToBoolean(GetConfig("Settings", "Block Decay Damage", true));

            AddCovalenceCommand(chatCommandName, nameof(CommandWalls));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            Config.Clear();
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        public string msg(string key, string id = null, params object[] args)
        {
            string message = id == null ? RemoveFormatting(lang.GetMessage(key, this, id)) : lang.GetMessage(key, this, id);

            return args.Length > 0 ? string.Format(message, args) : message;
        }

        public string RemoveFormatting(string source)
        {
            return source.Contains(">") ? Regex.Replace(source, "<.*?>", string.Empty) : source;
        }

        #endregion
    }
}

// --- End of file: ArenaWallGenerator.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/anti-explosive-upgrade ---
// --- Original File Path: A/AntiExplosiveUpgrade/AntiExplosiveUpgrade.cs ---

using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Anti Explosive Upgrade", "birthdates", "1.0.0")]
    [Description("Deny upgrading a building block when an explosive is stuck to it")]
    public class AntiExplosiveUpgrade : RustPlugin
    {

        #region Hook

        private object OnStructureUpgrade(Component entity, BasePlayer player, BuildingGrade.Enum grade)
        {
            if (entity.GetComponentInChildren<TimedExplosive>() == null) return null;
            player.ChatMessage(lang.GetMessage("CannotUpgrade", this, player.UserIDString));
            return false;
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"CannotUpgrade", "You cannot upgrade this as an explosive is stuck to it!"}
            }, this);
        }

        #endregion
    }
}

// --- End of file: AntiExplosiveUpgrade.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/anti-noob-raid ---
// --- Original File Path: A/AntiNoobRaid/AntiNoobRaid.cs ---

using Oxide.Core;
using System;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using Rust;
using UnityEngine;
using Newtonsoft.Json;
using System.Linq;

/*========================================================*
*                                                         *
*   ***************************************************   *
*   *Original author :   Slydelix on versions <1.8.5  *   *
*   *Maintainer(s)   :   RustySpoon342 from v1.8.6    *   *
*   ***************************************************   *
*                                                         *
*    Patch Submissions : Nivex on versions 1.8.9, 1.9.0   *
*                                                         *
*=========================================================*/

namespace Oxide.Plugins
{
    [Info("AntiNoobRaid", "MasterSplinter", "2.1.1", ResourceId = 2697)]
    class AntiNoobRaid : RustPlugin
    {
        [PluginReference] private Plugin PlaytimeTracker, WipeProtection, Clans, StartProtection;

        //Pre-release Version Number
        private bool beta = false;
        private string betaversion = "0.0.6";

        private List<BasePlayer> cooldown = new List<BasePlayer>();
        private List<BasePlayer> MessageCooldown = new List<BasePlayer>();
        private List<ulong> LeaderLower = new List<ulong>();
        private List<BuildingBlock> _blocks = new List<BuildingBlock>();
        private Timer CheckingPT;
        private Timer CheckingC;

        //private Dictionary<ulong, Timer> RaidTimerDictionary = new Dictionary<ulong, Timer>();
        private Dictionary<string, string> raidtools = new Dictionary<string, string>
        {
            {"ammo.rocket.fire", "rocket_fire" },
            {"ammo.rocket.hv", "rocket_hv" },
            {"ammo.rocket.basic", "rocket_basic" },
            {"ammo.rocket.smoke", "rocket_smoke" },
            {"explosive.timed", "explosive.timed.deployed" },
            {"surveycharge", "survey_charge.deployed" },
            {"explosive.satchel", "explosive.satchel.deployed" },
            {"grenade.beancan", "grenade.beancan.deployed" },
            {"grenade.f1", "grenade.f1.deployed" },
            {"ammo.grenadelauncher.he", "40mm_grenade_he" },
            {"ammo.rifle", "riflebullet" },
            {"ammo.rifle.explosive", "riflebullet_explosive" },
            {"ammo.rifle.incendiary", "riflebullet_fire" },
            {"ammo.pistol", "pistolbullet" },
            {"ammo.pistol.fire", "pistolbullet_fire" },
            {"ammo.shotgun", "shotgunbullet" },
            {"ammo.shotgun.fire", "shotgunbullet_fire" },
            {"ammo.shotgun.slug", "shotgunslug" },
            {"ammo.rocket.mlrs", "rocket_mlrs" },
            {"arrow.wooden", "arrow_wooden" },
            {"arrow.hv", "arrow_hv" },
            {"arrow.fire", "arrow_fire" },
            {"arrow.bone", "arrow_bone" }
        };
        private Dictionary<string, string> RaidToolsCheck = new Dictionary<string, string>
        {
            {"ammo.rocket.fire", "rocket_fire" },
            {"ammo.rocket.hv", "rocket_hv" },
            {"ammo.rocket.basic", "rocket_basic" },
            {"ammo.rocket.smoke", "rocket_smoke" },
            {"explosive.timed", "explosive.timed.deployed" },
            {"surveycharge", "survey_charge.deployed" },
            {"explosive.satchel", "explosive.satchel.deployed" },
            {"grenade.beancan", "grenade.beancan.deployed" },
            {"grenade.f1", "grenade.f1.deployed" },
            {"ammo.grenadelauncher.he", "40mm_grenade_he" },
            {"ammo.grenadelauncher.buckshot", "shotgunbullet" },
            {"ammo.rifle", "riflebullet" },
            {"ammo.rifle.hv", "riflebullet" },
            {"ammo.pistol", "pistolbullet" },
            {"ammo.pistol.hv", "pistolbullet" },
            {"ammo.shotgun", "shotgunbullet" },
            {"ammo.shotgun.slug", "shotgunslug" },
            {"ammo.handmade.shell", "handmade_shell.projectile" },
            {"ammo.rocket.mlrs", "rocket_mlrs" },
            {"ammo.nailgun.nails", "nailgun.entity" },
            {"flamethrower", "flamethrower.entity" },
            {"arrow.wooden", "arrow_wooden" },
            {"arrow.hv", "arrow_hv" },
            {"arrow.bone", "arrow_bone" },
            {"spear.stone","spear_stone.entity" },
            {"speargun.spear","speargun_spear" },
            {"spear.wooden", "spear_wooden.entity" },
            {"knife.bone", "knife_bone.entity" },
            {"bone.club", "bone_club.entity" },
            {"knife.butcher", "butcherknife.entity" },
            {"machete", "machete.weapon" },
            {"knife.combat", "knife.combat.entity" },
            {"longsword", "longsword.entity" },
            {"mace", "mace.entity" },
            {"paddle", "paddle.entity" },
            {"pitchfork", "pitchfork.entity" },
            {"salvaged.cleaver", "salvaged_cleaver.entity" },
            {"salvaged.sword", "salvaged_sword.entity" },
            {"hatchet", "hatchet.entity" },
            {"pickaxe", "pickaxe.entity" },
            {"axe.salvaged", "axe_salvaged.entity" },
            {"hammer.salvaged", "hammer_salvaged.entity" },
            {"icepick.salvaged", "icepick_salvaged.entity" },
            {"stonehatchet", "stonehatchet.entity" },
            {"stone.pickaxe", "stone_pickaxe.entity" },
            {"rock", "rock.entity" },
            {"skull", "skull.entity" },
            {"jackhammer", "jackhammer.entity" }
        };
        private Dictionary<string, string> NotSupportedRaidTools = new Dictionary<string, string>
        {
            {"ammo.rifle.explosive", "riflebullet_explosive" },
            {"ammo.rifle.incendiary", "riflebullet_fire" },
            {"ammo.pistol.fire", "pistolbullet_fire" },
            {"ammo.shotgun.fire", "shotgunbullet_fire" },
            {"flamethrower", "flamethrower.entity" },
            {"snowball", "snowballgunbullet" },
            {"arrow.fire", "arrow_fire" }
        };


        private int layers = LayerMask.GetMask("Construction", "Deployed");
        private readonly string AdminPerm = "antinoobraid.admin";
        private readonly string NoobPerm = "antinoobraid.noob";

        #region Config

        private class ConfigFile
        {
            [JsonProperty(PropertyName = "Main Settings")]
            public MainSettings Main = new MainSettings();
            [JsonProperty(PropertyName = "Other Settings")]
            public OtherSettings Other = new OtherSettings();
            [JsonProperty(PropertyName = "Team & Clan Settings")]
            public RelationshipSettings Relationship = new RelationshipSettings();
            [JsonProperty(PropertyName = "Refund Settings")]
            public RefundSettings Refund = new RefundSettings();
            [JsonProperty(PropertyName = "Manage Messages")]
            public ManageMessages Messages = new ManageMessages();
            [JsonProperty(PropertyName = "Entity Settings")]
            public EntitySettings Entity = new EntitySettings();
            [JsonProperty(PropertyName = "Weapon Settings")]
            public WeaponSettings RaidTools = new WeaponSettings();
            [JsonProperty(PropertyName = "Advance Settings")]
            public AdvanceSettings Advance = new AdvanceSettings();

            public static readonly ConfigFile DefaultConfigFile = new ConfigFile();

        }

        public class MainSettings
        {
            [JsonProperty("Time (seconds) after which noob will lose protection (in-game time)")]
            public int ProtectionTime = 43200;
            [JsonProperty("Days of inactivity after which player will be raidable")]
            public double InactivityRemove = 3;
            [JsonProperty("Remove noob status of a raider on raid attempt")]
            public bool UnNoobNew = true;
            [JsonProperty("Remove noob status of a raider who is manually marked as a noob on raid attempt")]
            public bool UnNoobManual = true;
        }

        public class OtherSettings
        {
            [JsonProperty("Allow Patrol Helicopter to damage noob structures (This will allow players to raid noobs with Patrol Helicopter)")]
            public bool PatrolHeliDamage = true;
            [JsonProperty("Ignore twig when calculating base ownership (prevents exploiting)")]
            public bool IgnoreTwig = true;
            [JsonProperty("Check full ownership of the base instead of only one block")]
            public bool CheckFullOwnership = true;
            [JsonProperty("Kill fireballs when someone tries to raid protected player with fire (prevents lag)")]
            public bool KillFire = true;
            [JsonProperty("Clear Player Data on Map-Wipe")]
            public bool MapWipe = false;
        }

        public class RelationshipSettings
        {
            [JsonProperty("Enable 'Clan' Support (Allow clan members to destroy each others entities & Remove protection from clan members when a member tries to raid)")]
            public bool CheckClan = true;
            [JsonProperty("Enable 'Team' Support (Allow team members to destroy each others entities & Remove protection from team members when a member tries to raid)")]
            public bool CheckTeam = true;
            [JsonProperty("Enable 'Team' playtime sync (Sync's all player's within a team to the highest playtime)")]
            public bool SyncTeamPlaytime = true;
        }

        public class RefundSettings
        {
            [JsonProperty("Refund explosives")]
            public bool RefundItem = true;
            [JsonProperty("Refunds before player starts losing explosives")]
            public int RefundTimes = 4;
        }

        public class ManageMessages
        {
            [JsonProperty("Notify player on first connection with protection time")]
            public bool MessageOnFirstConnection = true;
            [JsonProperty("Use game tips to send most messages to players")]
            public bool UseGT = false;
            [JsonProperty("Show message for not being able to raid")]
            public bool ShowMessage = true;
            [JsonProperty("Show time until raidable")]
            public bool ShowTime = false;
            [JsonProperty("Show time until raidable only to owners")]
            public bool ShowOwnerTime = true;
            [JsonProperty("Show message on first Twig placement that Twig is not protected")]
            public bool ShowMessageTwig = true;
        }

        public class EntitySettings
        {
            [JsonProperty("List of entities that can be destroyed even if owner is noob")]
            public Dictionary<string, string> AllowedEntities = AllowedEntitiesDictionary;
            [JsonProperty("List of entities that can be destroyed without losing noob protection")]
            public Dictionary<string, string> AllowedEntitiesNoob = AllowedEntitiesNoobDictionary;

            public static Dictionary<string, string> AllowedEntitiesDictionary = new Dictionary<string, string>
            {
                {"ShortPrefabName", "Common Name"}, {"beartrap", "Snap Trap"}, {"landmine", "Landmine"},
            };
            public static Dictionary<string, string> AllowedEntitiesNoobDictionary = new Dictionary<string, string>
            {
                {"ShortPrefabName", "Common Name"}, {"campfire", "Camp Fire"},
            };
        }

        public class WeaponSettings
        {
            [JsonProperty("List of Weapons/Tools that won't trigger player to lose noob protection")]
            public Dictionary<string, string> AllowedRaidTools = AllowedRaidToolsDictionary;

            public static Dictionary<string, string> AllowedRaidToolsDictionary = new Dictionary<string, string>
            {
                {"ShortPrefabName", "Common Name"}, {"rocket_smoke", "Smoke Rocket WIP!!!!"},
            };
        }

        public class AdvanceSettings
        {
            [JsonProperty("User data refresh interval (seconds)")]
            public int Frequency = 30;
            [JsonProperty("Save interval (seconds)")]
            public int SaveFrequency = 60;
            [JsonProperty("Save data on Server Save")]
            public bool OnServerSave = true;
            [JsonProperty("Show structure has no owner in console")]
            public bool ShowNoOwnerBase = false;
            [JsonProperty("Enable Logs (Logs can be found in /oxide/logs/antinoobraid)")]
            public bool EnableLogging = true;
        }

        private ConfigFile config;

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            PrintWarning("Creating new config file");
            NextTick(() => Config.WriteObject(config));
            SaveConfig();
        }

        #endregion

        #region Lang

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                {"NoPlayerFound", "Couldn't find '{0}'"},
                {"NotNumber",  "{0} is not a number" },

                {"antinoobcmd_syntax", "Wrong syntax! /antinoob <addnoob|removenoob|wipe>" },
                {"antinoobcmd_addnoob_syntax", "Wrong syntax! /antinoob addnoob <name/steamid>" },
                {"antinoobcmd_alreadynoob", "{0} is already marked as a noob" },
                {"antinoobcmd_marked", "Marked {0} as a noob" },
                {"antinoobcmd_removenoob_syntax", "Wrong syntax! /antinoob removenoob <name/steamid>" },
                {"antinoobcmd_removednoob", "{0} does not have a noob status anymore" },
                {"antinoobcmd_missingnoob", "{0} is not a noob" },
                {"antinoobcmd_wipe_syntax", "Missing argument! <all|playerdata|attempts>" },
                {"dataFileWiped", "Data file successfully wiped"},
                {"dataFileWiped_attempts", "Data file successfully wiped (raid attempts)"},
                {"dataFileWiped_playerdata", "Data file successfully wiped (player data)"},

                {"struct_noowner","Structure at {0} has no owner! OwnerID = {1} buildingID = {2}" },
                {"clan_lostnoob" , "Clan '{0}' lost their noob status because they tried to raid" },
                {"lost_teamsprotection" , "You lost your team noob protection for damaging a structure" },
                {"lost_clansprotection" , "You lost your clan noob protection for damaging a structure" },
                {"new_user_lostprotection" , "You lost your noob protection for damaging a structure" },
                {"console_lostnoobstatus", "{0} hasn't connected for {1} days so he lost his noob status (can be raided)"},
                {"console_notenough", "{0} doesn't have enough hours in game to be marked as a non-noob"},

                {"firstconnectionmessage", "You are a new player so your buildings are protected for first {0} hours of your time on server"},

                {"pt_notInstalled", "Playtime Tracker is not installed, will check again in 15 seconds!"},
                {"pt_detected", "Playtime Tracker detected"},
                {"C_notInstalled", "Clans is not installed, will check again in 15 seconds!"},
                {"C_detected", "Clans detected"},

                {"userinfo_nofound", "Failed to get playtime info for {0}! trying again in 300 seconds!"},
                {"userinfo_nofound_2nd_attempt", "Failed to get playtime info for {0}! Has been marked as non-noob!"},
                {"userinfo_found", "Successfully got playtime info for {0}!"},

                {"twig_can_attack", "This structure is Twig & is not raid protected. Please upgrade to Wood or higer for protection!"},
                {"can_attack", "This structure is not raid protected"},
                {"NotLooking", "You are not looking at a building/deployable"},

                {"refunditem_help", "Wrong Syntax! /refunditem add <you have to hold the item you want to add>\n/refunditem remove <you have to hold the item you want to remove>\n/refunditem list\n/refunditem clear\n/refunditem all <sets all raid tools as refundable>"},
                {"refunditem_needholditem", "You need to hold the item you want to add/remove from refund list"},
                {"refunditem_notexplosive", "This item is not an explosive"},
                {"refunditem_added", "Added '{0}' to list of items to refund"},
                {"refunditem_alreadyonlist", "This item is already on the list"},
                {"refunditem_notonlist", "This item is not on the list"},
                {"refunditem_removed", "Removed '{0}' from the list of items to refund"},
                {"refunditem_addedall", "Added all raid tools to refund list"},
                {"refunditem_cleared", "Cleared list of items to refund"},
                {"refunditem_empty", "There are no item set up yet"},
                {"refunditem_list", "List of items which will get refunded: \n{0}"},

                {"refund_free", "Your '{0}' was refunded."},
                {"refund_last", "Your '{0}' was refunded but will not be next time."},
                {"refund_1time", "Your '{0}' was refunded. After 1 more attempt it wont be refunded."},
                {"refund_nTimes", "Your '{0}' was refunded. After {1} more attempts it wont be refunded"},

                {"cannot_attack_no_time", "This entity cannot be destroyed because it was built by a new player"},
                {"cannot_attack_time", "This entity cannot be destroyed because it was built by a new player ({0})"},
                {"looking_item", "The entity name is {0}"},
                {"notlooking_item", "You need to look at a deployed item to get the name!"},
                {"holding_item", "The items name is {0}"},
                {"notholding_item", "You need to hold a Raiding Tool to get the name!"},
                {"Not_Supported", "This Raiding Tool is not supported for \"Weapon Settings\"!"},
                {"Increase_Refresh", "Increase \"User data refresh interval\" in the Config and reload! Can't be less or equal than 10 seconds." },

                {"secs", " seconds"},
                {"mins", " minutes"},
                {"min", " minute"},
                {"hours", " hours"},
                {"hour", " hour"},
                {"day", " day"},
                {"days", " days"}
            }, this);
        }

        #endregion

        #region DataFile/Classes

        private class BuildingInfo
        {
            public static HashSet<BuildingInfo> buildCache = new HashSet<BuildingInfo>();

            public BuildingInfo() { }

            public uint buildingID;

            public ulong OwnerID;

            public DateTime lastUpdate;

            public static BuildingInfo GetByBuildingID(uint bID)
            {
                foreach (var entry in buildCache)
                    if (entry.buildingID == bID) return entry;

                return null;
            }

            public double GetCacheAge()
            {
                if (lastUpdate == null) return -1;
                return DateTime.UtcNow.Subtract(lastUpdate).TotalSeconds;
            }
        }

        private class ClanInfo
        {
            public static HashSet<ClanInfo> clanCache = new HashSet<ClanInfo>();

            public ClanInfo() { }

            public static ClanInfo FindClanByName(string clanName)
            {
                foreach (var clan in ClanInfo.clanCache)
                    if (clan.clanName == clanName) return clan;

                return null;
            }

            public static ClanInfo GetClanOf(ulong playerID)
            {
                foreach (var clan in ClanInfo.clanCache)
                    if (clan.members.Contains(playerID)) return clan;

                return null;
            }

            public string clanName { get; set; }

            public List<ulong> members = new List<ulong>();
        }

        private class StoredData
        {
            public Dictionary<ulong, double> players = new Dictionary<ulong, double>();
            public Dictionary<ulong, int> AttackAttempts = new Dictionary<ulong, int>();
            public List<ulong> playersWithNoData = new List<ulong>();
            public List<ulong> FirstMessaged = new List<ulong>();
            public List<ulong> InTeam = new List<ulong>();
            public List<ulong> ShowTwigsNotProtected = new List<ulong>();
            public Dictionary<ulong, string> lastConnection = new Dictionary<ulong, string>();
            public List<ulong> IgnoredPlayers = new List<ulong>();

            public StoredData()
            {
            }
        }

        private class StoredDataItemList
        {
            public Dictionary<string, string> ItemList = new Dictionary<string, string>();

            public StoredDataItemList()
            {
            }
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject($"{this.Name}\\{this.Name}_Data", storedData);
        private void SaveDataItemList() => Interface.Oxide.DataFileSystem.WriteObject($"{this.Name}\\{this.Name}_RefundItemList", storedDataItemList);


        StoredData storedData;
        StoredDataItemList storedDataItemList;

        #endregion

        #region Setup/Saving
        private void Init()
        {
            permission.RegisterPermission(AdminPerm, this);
            permission.RegisterPermission(NoobPerm, this);

            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>($"{this.Name}\\{this.Name}_Data");
            storedDataItemList = Interface.Oxide.DataFileSystem.ReadObject<StoredDataItemList>($"{this.Name}\\{this.Name}_RefundItemList");
            config = Config.ReadObject<ConfigFile>();
            Unsubscribe(nameof(OnEntityDeath));
            Unsubscribe(nameof(OnEntityKill));
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnEntityTakeDamage));
            //if (config